[
  {
    "id": "docs-ton-org--",
    "title": "Welcome toTON Blockchaindocumentation",
    "url": "https://docs.ton.org/",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationWelcome to TON Blockchain documentationWelcome toTON BlockchaindocumentationMeet the AI-native, beautiful and comprehensive documentation covering foundations, tools, languages, and APIs.Learn TON in Y minutesOr choose a path →Choose your pathEmbark on a journey tailored to your role, experience, and intent.FreshmanLearn the fundamentals of TON Blockchain. Perfectly suited for newcomers who explore the web3 world through TON.How to read this documentation?Start hereWhat is blockchain?What is a smart contract on TON?Writing your first smart contractNomadFor those coming from another blockchain. Study how things work on TON in comparison and go through hands-on guides for migration.Coming from EthereumCompare the execution model and the ecosystem of TONYour first smart contractWrite and deploy a contract that can be interacted withAceFor amateurs, experts, and learners alike. Take a deep dive into the low-level details, or do a quick reference check and return to your project.BlueprintDevelopment environmentTVM Exit codesComplete list of compute phase exit codesTVM InstructionsComplete list of instructions and opcodesAPI providersTON Center v2 and v3, and othersTON ConnectIntegrate TON into dApps and walletsBlockchain nodesPick the right kind and setup your nodeLooking for something else? Search documentation with Ctrl + K and ask AI right there, or open the assistant panel by pressing Ctrl + I. If nothing was found, ask the community of TON developers, builders and enthusiasts.Join the communityTroubleshoot issues or discuss best practices with other community members.Get supportLearn how to get help on the dedicated pageTelegramAdd the folder with many developer chatsTON TalentsSeek skilled professionals and agencies⌘I",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "dapp",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:23:03.453Z"
  },
  {
    "id": "docs-ton-org--start-here",
    "title": "Start here",
    "url": "https://docs.ton.org/start-here",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationStart hereStart hereCopy pageCopy pageThe documentation is organized by layers of detail, with lower-level details appearing later. EcosystemTools and libraries for developing on TON, and how to use them.Payment processingGuides on monitoring and handling blockchain transactions for business applications, such as exchanges.Standard contractsWorking with most popular standardized contracts.Contract developmentGuides on developing smart-contracts.LanguagesReference documentation for TON-specific languages.TON Virtual MachineDescription of the low-level language that runs smart-contracts, and details of the runtime.Blockchain foundationsComprehensive description of the blockchain. Includes web version of whitepapers.ContributeDocumentation on writing this documentation. This is a condensed description of TON. The rest of the documentation may assume that all of this is already known to the reader. TON is a blockchain. It provides a distributed platform for storing data and code, as well as running computations, all the ingredients to host applications. Roughly speaking, it works as if it were a single server executing all the code. The hosted applications are called smart-contracts. The platform runs on a set of servers, called nodes. Most important type of nodes, validators, are owned by individuals or organizations with a large stake in TON and great interest in keeping the platform safe, fair, and operational. Validators have to reach consensus on the state of the blockchain. Typically, the process takes 5 seconds to reach transaction finality, a time to mint a new block. Toncoin is TON’s primary cryptocurrency. It is used to pay for the execution of smart contracts, the storage of their data, and network traffic. Such payments are called fees. There are two instances of TON blockchain: mainnet and testnet. Mainnet is the “real” network. It’s where actual payments in Toncoin are made. Applications use mainnet by default. The other network is testnet, and it is used by TON developers to check that their applications work correctly before deploying them to mainnet. It uses “test coins” that barely have any value. Usually when the TON blockchain gets an update, it is first deployed to testnet, and then to mainnet after a brief period of testing, so sometimes they may run different software. Also their configuration, availability, and throughput might be different. Each network is split into workchains that can freely interact with each other, but their implementations may differ significantly. At the moment, there are two workchains: basechain (workchain_id = 0) for regular use, and a very similar masterchain (workchain_id = -1) for TON’s internal bookkeeping. The masterchain follows mostly the same rules, except that using it is more expensive to limit the amount of traffic that interferes with TON’s internals. To be freely scalable, each workchain is split into shards. The number of shards is determined dynamically based on the current network load. Internally, every shard is implemented as a separate blockchain. Except for increased latency, the effect on the user-facing code is minimal. The nodes that run the blockchain interact via the ADNL protocol. User-facing applications usually use servers that proxy JSON HTTP requests into the ADNL network. The official version of such a proxy server is provided by the liteserver software. There are public instances of liteserver, so developers are not required to host one on their own servers. ADNL works over TCP, so it’s impossible to connect to ADNL from a web page. Browsers intentionally do not provide an API to send arbitrary TCP traffic. Servers do not have this limitation, as they can interact with the blockchain over ADNL, either by raw TCP or by wrapping ADNL through HTTP. It’s easiest to visualize the blockchain as a set of accounts. Each account has an address and a status. Over its lifetime, an account changes its status among four values: nonexist: There wasn’t a single operation with the account, or it was removed. It has neither a balance, nor code. uninit: If some Toncoin is transferred to an account, it now exists, but there is still no smart contract code on it. It now has a balance. active: After a deploy message (see below) with code and initial data is sent to an account, it becomes active and can process other messages. It now has a balance, code, and internal state. frozen: If an account is overdue on its storage fees, it will be frozen until the fees are paid. If the overdue amount reaches a maximum limit specified by the blockchain, the account goes completely bankrupt, is removed, and ceases to exist. The code on an active account is a smart contract. The term contract is often used for an account that holds the code. The internal address of an account is a pair of two numbers: its workchain ID and a 256-bit number. It may be displayed in the raw format (e.g., 0:4098805d2272a61b375350c6b2f5faaaf27c8267d8e7521ff2045104fdc7de76), but is usually shown in a user-friendly format (e.g., UQBKgXCNLPexWhs2L79kiARR1phGH1LwXxRbNsCFF9doczSI). Addresses specify where messages should be delivered. There are three types of messages: internal messages are sent between accounts; incoming external messages are sent from code outside the blockchain to a contract; outgoing external messages are broadcast to the external network; somewhat similar to adding them into the globally available list of all outgoing external messages that ever happened. Every internal message should have some Toncoin attached to it so that it can pay for the cost of handling it. External messages cannot have Toncoin attached to them because they spend some of their time outside the blockchain, and only the blockchain can prove the transfer of Toncoin is correct. Incoming external messages come from an external address, and outgoing external messages go to an external address. The state of the account changes only when it handles messages. Messages also change the account’s balance. Usually, to have a state and a balance, and to handle messages, the account must be active. Formally, a message is only an intent: it has a destination, possibly some Toncoin, and data. After the message is handled and all the necessary changes are applied to the blockchain, the message is packed, along with a description of those changes, into a single packet of data, called a transaction. A transaction records the state changes on an account. Some transactions might happen without any message. A message might also be a deploy message if it has a StateInit structure attached with its initial code and data. When such a message is sent, the hash of StateInit must match the destination address. If it does, the code and data are stored in the account at that address, and the account becomes active. Both the code and data stored in the account may change in the future, but its address will remain the same as when it was originally deployed. Internal and incoming external messages execute the account’s code. The code is interpreted by TON Virtual Machine (TVM). It is written in bitcode, a binary format specific to TVM. In the future, TVM might support multiple binary languages, codepages, but at the moment there is only codepage 0 (CP0). Most development is done in the Tolk, a high-level programming language. Its compiler is included in the Blueprint development environment and will be available to all projects created from the template. Originally, Fift, a Forth-like assembly language, and FunC, a C-like intermediate-level language, were used for contract development. When execution starts, the message and current account state are provided to the code. By the end of execution, the account might change its state or code, or send internal or outgoing external messages. The execution follows a process whose steps are called phases. Fees are deducted during this process. Fees might be deducted from the account’s balance or from the Toncoin the message carries, depending on the mode of the message, or by explicit choice made in the contract’s code. Execution cost is first measured in gas units, then converted to Toncoin. This unit is separate so that if code execution becomes computationally cheaper (or more expensive), validators can vote to change the price of gas in Toncoin. If something goes wrong, a non-zero exit code might be returned, no changes to state or code are saved, and no further messages are sent. If the message that resulted in a failed transaction is marked as bounceable, a bounce message is sent back to the sender. Bounce messages are used to inform the sender that handling of their message failed. They can carry either truncated or full body of the original message. The most common reason a code is executed is when some account has received a mes",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "testnet",
      "mainnet",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:23:05.474Z"
  },
  {
    "id": "docs-ton-org--get-support",
    "title": "Get support",
    "url": "https://docs.ton.org/get-support",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationGet supportGet supportCopy pageCopy page​Chats, forums, and Telegram bots https://t.me/tondev_eng - the official TON Developers chat. https://t.me/tondev - the Russian-speaking TON Developers chat. https://t.me/ton_help_bot - support for TON Core products for users (bridge, vesting, multisig, etc). Zendesk + Telegram Bot. https://t.me/toncenter_help_bot - public Ton Center API support, Zendesk + Telegram Bot. https://t.me/validators_help_bot - public support for validators, Zendesk + Telegram Bot. https://t.me/ton_node_help - public chat group for blockchain node administrators. ​Builders portal https://builders.ton.org - main entry point for projects. ​TON Hubs https://builders.ton.org/opportunities/hubs - regional communities of builders. ​Security audit firms, agencies, and freelancers https://ton.org/en/talents - open database aims to connect teams willing to build products on TON with skilled professionals and agencies. https://ton.org/en/talents?Auditors - security auditors for smart contracts and TON-based applications. ​Bug bounty programs https://github.com/ton-blockchain/bug-bounty - TON Blockchain bug bounty program. https://t.me/ton_bugs_bot - security bug bounty, Telegram Bot. https://hackenproof.com/programs/ton-society - Websites, web apps, and mini apps operated by TON Society. Was this page helpful?YesNoSuggest editsRaise issuePreviousComing from EthereumNext⌘IgithubxtelegramPowered by MintlifyOn this pageChats, forums, and Telegram botsBuilders portalTON HubsSecurity audit firms, agencies, and freelancersBug bounty programs",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:23:07.103Z"
  },
  {
    "id": "docs-ton-org--from-ethereum",
    "title": "Coming from Ethereum",
    "url": "https://docs.ton.org/from-ethereum",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationComing from EthereumComing from EthereumCopy pageCopy pageLearn how to develop and build on TON coming from the Ethereum (EVM) ecosystem. ​Execution model ​Asynchronous blockchain A fundamental aspect of TON development is the asynchronous execution model. Messages sent by one contract take time to arrive at another, so the resulting transactions for processing incoming messages occur after the current transaction terminates. Compared to Ethereum, where multiple messages and state changes on different contracts can be processed within the same atomic transaction, a TON transaction represents a state change only for one account and only for a processing of a single message. Even though in both blockchains a signed included-in-block unit is called a “transaction”, one transaction on Ethereum usually corresponds to several transactions on TON, that are processed over a span of several blocks. Action descriptionEthereumTONSingle message processing with state change on one contractMessage call or “internal transaction”TransactionNumber of state changes and messages on different accounts produced from initial contract callTransactionChain of transactions or “trace” Consider a practical example: liquidity withdrawal on a DEX. On Ethereum, it appears as a single atomic transaction with multiple contract calls inside it. This transaction has a single hash and is included in one block. The same operation on TON consists of a sequence of more than 10 transactions. Each arrow on this image represents a distinct finalized transaction, with its own hash, inclusion block, and all the other properties: Executing a large transaction on Ethereum or any other EVM-based blockchain comes with certain limitations: call depth of 1,024 nested calls and the block gas limit. With TON’s asynchronous execution model, a trace — a chain of transactions — can have any length, as long as there are enough fees to continue it. For example, the trace resulting from this message consisted of more than 1.5 million transactions, lasting more than 4,000 blocks until completion. ​On-chain get methods Another difference is in the get methods. Both Ethereum and TON support them, allowing data to be retrieved from contracts without paying fees. However, in TON, get methods cannot be called on-chain: a contract cannot synchronously retrieve data from another contract during a transaction. This is a consequence of TON’s asynchronous model: by the moment transaction that called a get method would start its execution, data might already change. ​Account model In Ethereum, there are two types of accounts: externally owned accounts (EOA), and contract accounts. EOAs are human-controlled entities, each represented by a private-public key pair. They sign transactions and each has its own balance; the community often refers to them as “wallets”. In TON, there is no such separation. Every valid address represents an on-chain account, each with its own state and balance, that could be changed through transactions. This means that “wallets” in TON are smart contracts that operate under the same rules as any other contract on the blockchain. The TON wallet smart contract works as a proxy: handles an external message, checks message is sent by the wallet’s owner using regular public-key cryptography, and sends an internal message somewhere further in the network. ​Limited contract storage In Ethereum, it’s possible to store any amount of data in a single contract. Unbounded maps and arrays are considered standard practice. TON sets a limit to the amount of data a contract can store. This means that ERC-20-like fungible tokens cannot be implemented in the same way as in an EVM chain, using a single map within a single contract. The limit for contract storage is 65,536 unique cells contract storage, where a cell stores up to 1,023 bits. Messages are constrained by two size limits: 8,192 cells or 221 bits among them, whichever is smaller. Every map that is expected to grow beyond 1,000 values is dangerous. In the TVM map, key access is asymptotically logarithmic, meaning that gas consumption continuously increases to find keys as the map grows. Instead, sharding should be used. ​Ecosystem ​Tooling The recommended programming language for smart contract development in TON is Tolk. Other established languages are also used in the ecosystem; more information about them is available here. For off-chain software, Typescript is the most adopted language in TON. Most of the tooling, bindings and SDKs are implemented in Typescript. Use caseEthereum toolTON counterpartBlockchain interactionEthers, Web3.js, Viem@ton/ton, Asset-sdkWallet connection protocolWalletconnect, WagmiTonConnectDev environment framework / scriptingHardhat, TruffleBlueprintSimulation engineRevm & RethSandbox For low-level manipulation of TON-specific data structures, there is @ton/core. Another library with wrappers for most important contracts and HTTP APIs is @ton/ton. ​Services Web3 developers often rely on specific products and services for on-chain development. The following table showcases some use cases that existing TON services support. Use caseEthereum serviceTON serviceUser-friendly explorerEtherscanTonviewer, TonscanOpen-source dev explorerBlockscoutTON ExplorerDebuggerRemix DebuggerTxTracerIDERemix IDEWeb IDEAsm playground and compilation explorerEVM.CodesTxTracer ​Standards The table maps Ethereum standards and proposals, including ERC and EIP, to their TON counterparts, referred to as TEP. Due to significant differences in execution models, most of the standards in TON differ significantly in semantics and general approach compared to their Ethereum analogs. DescriptionEthereum standardTON Standard (TEP)Fungible token standardERC-20Jettons (TEP-0074)Non-fungible token standardERC-721NFT standard (TEP-0062)Token metadataERC-4955 (Not exactly, but close match)Token Data Standard (TEP-0064)NFT royalty standardEIP-2981NFT Royalty Standard (TEP-0066)DNS-like registryENS (EIP-137)DNS Standard (TEP-0081)Soulbound / account-bound token conceptEIP-4973SBT Standard (TEP-0085)Wallet connection protocolWalletConnect / EIP-1193TonConnect (TEP-0115)Was this page helpful?YesNoSuggest editsRaise issuePreviousOther resourcesNext⌘IgithubxtelegramPowered by MintlifyOn this pageExecution modelAsynchronous blockchainOn-chain get methodsAccount modelLimited contract storageEcosystemToolingServicesStandards",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:23:10.343Z"
  },
  {
    "id": "docs-ton-org--more-tutorials",
    "title": "Other resources",
    "url": "https://docs.ton.org/more-tutorials",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationOther resourcesOther resourcesCopy pageCopy pageThis page collects additional learning resources beyond this documentation. You’ll find a mix of official content not hosted in this documentation and community-created materials to help you continue your journey. Whether you prefer structured courses, in-depth articles, video tutorials, or real code examples, there is something here to match your learning style and current skill level. ​Courses ​Blockchain basics with TON Deprecated This course introduces blockchain basics, focusing on practical skills in the TON ecosystem. You will understand how blockchain functions and its diverse applications. This course is for junior developers, people new to crypto, non-technical IT professionals, and anyone curious about blockchains. English Chinese Russian ​TON & Telegram Blockchain development Deprecated The course is aimed at developers and IT specialists interested in gaining practical knowledge about the technologies and concepts of the TON Blockchain, such as FunC, dApps, decentralization, smart contracts, contract testing, as well as the creation of Mini Apps within Telegram. English Chinese Russian ​Articles Introductory: How a Blockchain Can Help You on a Deserted Island Beginner-friendly: What is Blockchain? What is a Smart Contract? What is Gas? ​”Hello World” guide series A step-by-step tutorial series that starts with creating a new TON wallet and ends with a working, test-covered, and deployed smart contract, along with a Telegram Mini App frontend for it. Part 1: Working with your first TON wallet Part 2: Writing your first smart contract Part 3: Building your first web client Part 4: Testing your first smart contract ​Videos Introductory: Crypto Networks and Why They Matter ​Playlists Beginner-friendly: TON Development with Tact ​Interactive learning ​Code playgrounds TxTracer - Trace and analyze TON Blockchain transactions with tools to visualize execution, inspect and debug smart contracts with a code editor and user-friendly interface. Assembly Playground - Experiment with TVM assembly code directly in your browser. Write, test, and debug assembly instructions with real-time execution. Code Explorer - Compile FunC or Tolk code to assembly and explore the generated bytecode to understand how your smart contracts work under the hood. TVM Instruction table - Browse the TVM instruction reference with detailed descriptions, opcodes, stack effects, and control flow information for every instruction. Sandbox - Inspect transactions produced by your local tests using the @ton/sandbox package. Visualize messages, transaction info, VM logs and exit codes with an interactive UI. ​Challenges and exercises Hack the TON - TON-based wargame inspired by The Ethernaut, played in the TON Virtual Machine. Each level is a smart contract that needs to be hacked. Our goal is to help you to learn how to develop safe TON smart contracts and build a thriving community around this craft. ​Smart contract examples Examples of smart contracts on TON include wallets, electors (which manage validator elections on TON), multi-signature wallets, and many more. They can serve as an excellent reference for those studying on real projects. Tolk benchmark contracts - Tolk vs. FunC gas benchmarks and, simultaneously, reference Tolk contracts. ​Join the community All TON communities Telegram Dev chats Was this page helpful?YesNoSuggest editsRaise issuePreviousOld documentationNext⌘IgithubxtelegramPowered by MintlifyOn this pageCoursesBlockchain basics with TONTON & Telegram Blockchain developmentArticles”Hello World” guide seriesVideosPlaylistsInteractive learningCode playgroundsChallenges and exercisesSmart contract examplesJoin the community",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "dapp",
      "frontend",
      "api",
      "sdk",
      "transaction",
      "testing",
      "tutorial",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:23:12.579Z"
  },
  {
    "id": "docs-ton-org--ecosystem-sdks",
    "title": "SDKs",
    "url": "https://docs.ton.org/ecosystem/sdks",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationEcosystemSDKsEcosystemSDKsCopy pageCopy pageThere are several ways to interact with TON blockchain: HTTP libraries connect through HTTP JSON APIs to read and write to the blockchain. HTTP servers mostly relay these requests to the ADNL network. ADNL libraries connect to liteserver. Here’s a small comparison of these protocols: HTTPADNLStandardizedNoYesCan connect from a web pageYesNoHas free third-party serversYesYesCan be self-hostedYesYesRequires trusting third partiesYes1NoFirst connection takes time for data synchronizationNoYes2 1 Some HTTP servers do provide proofs, but there is no out‑of‑the‑box library that verifies them. 2 If proofs returned by liteservers are ignored, the first connection skips data synchronization; however, this requires trusting the liteserver. SDKs might also provide some other functionality: Core libraries implement standard TON data structures (cell, slice), formats (address, mnemonic), cryptography, etc. Wrappers provide high-level APIs for interacting with standard contracts (Wallet, Jetton, NFT). Emulator libraries provide an execution environment similar to a real blockchain for testing purposes. HTTPADNLCoreWrappersEmulatorLanguage⭐@ton/ton✅✅TypeScriptCodeChat⭐@ton/core✅TypeScriptCodeDocs⭐@ton/sandbox✅TypeScriptCode⭐ton4j✅✅✅JavaCodeChat⭐tonutils-go✅✅✅GoCodeChatadnl✅TypeScriptCodetonutils✅TypeScriptCodetonlib-java✅JavaCodetonutils✅✅✅PythonCodeDocsChattonlib✅C++CodeDocston-kotlin✅✅KotlinCodeDocspytonlib✅PythonCodepytoniq✅PythonCodeDocsChatpytoniq-core✅PythonCodeDocsChatmytonlib✅✅PythonCodetonpy✅PythonCodeDocstvm_valuetypes✅PythonCodepytvm✅PythonCodetongo✅✅✅✅GoCodeton✅PHPCodeinterop✅PHPCodeton-rs✅✅✅✅RustCodeton-grpc✅RustCodetonsdk.net✅✅C#CodeChattonlib.net✅✅✅C#Codeton✅ElixirCode@tetherto/wdk-wallet-ton✅✅JavaScriptCodeDocs@tetherto/wdk-wallet-ton-gasless✅✅JavaScriptCodeDocstonlib-go✅GoCodetonweb✅JavaScriptCodenode-tonlib✅JavaScriptCodetontools✅✅PythonCodeswiftyton✅SwiftCodetonlib-xcframework✅SwiftCodetonlib-rs✅✅✅✅RustCode See also: WDK Core, JavaScript - Modular library from Tether, which supports wallet management and various swap, bridge, and lending services for many blockchains at once. Was this page helpful?YesNoSuggest editsRaise issuePreviousOverviewNext⌘IgithubxtelegramPowered by Mintlify",
    "category": "sdk",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "python",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:23:14.543Z"
  },
  {
    "id": "docs-ton-org--ecosystem-status",
    "title": "Network status",
    "url": "https://docs.ton.org/ecosystem/status",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationEcosystemNetwork statusEcosystemNetwork statusCopy pageCopy pageThis page lists websites that show if specific parts of TON blockchain are working normally. https://tonstat.us/HTTP and ADNL server availability and performance.https://status.toncenter.com/Low-level metrics, such as latencies, rates, and loads.https://validators.ton.org/Official validation dashboard.https://tonscan.com/validationPretty validation dashboard.https://t.me/tonstatusNotifications and requests for action for mainnet validators.https://t.me/testnetstatusNotifications and requests for action for testnet validators.https://t.me/validatorsBot for validator owners to track their status.Was this page helpful?YesNoSuggest editsRaise issuePreviousOverviewNext⌘IgithubxtelegramPowered by Mintlify",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "testnet",
      "mainnet",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:23:16.728Z"
  },
  {
    "id": "docs-ton-org--ecosystem-bridges",
    "title": "Bridges",
    "url": "https://docs.ton.org/ecosystem/bridges",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationEcosystemBridgesEcosystemBridgesCopy pageCopy pageIn the TON ecosystem, bridges allow users to transfer assets and data between TON and other major blockchains like Ethereum, BNB Chain, and Polygon. In this article, we will explore cross-chain bridges on TON. ​What are Cross-Chain Bridges? Cross-chain bridges are protocols that allow users to transfer cryptocurrencies, tokens, and sometimes arbitrary data from one blockchain to another. They act as connectors between otherwise isolated blockchain networks, enabling a multi-chain ecosystem where assets can move freely across different platforms. Bridges typically work by locking assets on the source blockchain and minting equivalent wrapped tokens on the destination blockchain. When users want to move assets back, the wrapped tokens are burned on the destination chain, and the original assets are unlocked on the source chain. ​Types of Cross-Chain Bridges ​1. Trustless vs. Custodial Bridges Trustless Bridges: Use smart contracts and cryptographic proofs for validation No single point of failure Decentralized verification mechanisms Centralized Bridges: Rely on trusted entities or multi-signature wallets Single point of failure risk Generally, they are easier to implement ​2. Asset Transfer Methods Lock-and-Mint Bridges: Lock original assets on the source chain Mint wrapped tokens on the destination chain Most common bridge type Burn-and-Mint Bridges: Burn tokens on the source chain Mint new tokens on the destination chain Used for native multi-chain tokens ​Bridges on TON The TON blockchain has a bridge ecosystem that connects it to major EVM-compatible networks. There are several kinds of bridge providers on TON. ​Legacy: Official TON Bridges During the early development of TON ecosystem (2021-2023) there were a few official TON bridges, supported at the protocol level. Now, they are considered legacy and not recommended for usage since they can be deprecated at any moment. TON blockchain supports several official bridges configured at the protocol level: ​Outbound Bridges (Config parameters 71-73) These bridges wrap TON into other networks: ETH-TON Bridge (Config Parameter 71) BNB-TON Bridge (Config Parameter 72) Polygon-TON Bridge (Config Parameter 73) ​Inbound Bridges (Config parameters 79, 81-82) These bridges wrap tokens from other networks into TON: ETH-TON Bridge (Config Parameter 79) BNB-TON Bridge (Config Parameter 81) Polygon-TON Bridge (Config Parameter 82) You can read more about these bridge configuration parameters on the TON Config page. ​Third-Party Bridge Ecosystem The TON ecosystem features multiple bridge providers offering different features and supported networks. You can read more about them in TON Bridges page. You can see existing bridges statistics on TON Foundation Bridge Dashboard.Was this page helpful?YesNoSuggest editsRaise issuePreviousOverviewNext⌘IgithubxtelegramPowered by MintlifyOn this pageWhat are Cross-Chain Bridges?Types of Cross-Chain Bridges1. Trustless vs. Custodial Bridges2. Asset Transfer MethodsBridges on TONLegacy: Official TON BridgesOutbound Bridges (Config parameters 71-73)Inbound Bridges (Config parameters 79, 81-82)Third-Party Bridge Ecosystem",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:23:20.317Z"
  },
  {
    "id": "docs-ton-org--ecosystem-analytics",
    "title": "Analytics and data providers",
    "url": "https://docs.ton.org/ecosystem/analytics",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationEcosystemAnalytics and data providersEcosystemAnalytics and data providersCopy pageCopy pageDevelopers often need to run analytical queries on top of on-chain data — for example, to track historical changes and aggregate data from multiple accounts. Since blockchains are not designed for analytical workloads, you need to build an indexing pipeline and run off-chain analytical queries. Creating such pipelines from scratch can be resource-consuming, so we recommend using one of the tools mentioned on this page. ​Dune analytics Dune analytics is one of the leading platforms for running analytical queries and building dashboards. It comes with 100+ blockchain integrations, and TON is among them. Basically, one needs to be familiar with SQL language to write queries, but the Dune AI prompt engine allows users to start working with data even without SQL knowledge. ​Raw and decoded tables Dune analytics consumes data from the public TON Data Lake (see below) and comes with a variety of raw and decoded tables. The raw tables include: Blocks Transactions Messages — includes raw body and StateInit data. Balances history — allows you to get a precise point-in-time balance for any account. Jetton events — comes with transfers, burns, and mints. Since mints are not covered by the TEP-74 standard, it is not possible to reconstruct balances based solely on jetton events, so the balance history should be used. Apart from raw tables, there are decoded tables that allow you to work with high-level structures in a unified manner: NFT events — comprehensive source of NFT-related data, including sales, transfers, and mints. DEX trades — includes a unified data model for DEX trades. The full list of supported DEXs is available here. DEX pools — comes with the full history of DEX pool balances and TVL estimations. Finally, two tables with off-chain metadata are available: Jetton metadata NFT metadata. ​Bespoke data marts Dune analytics allows projects to build bespoke data marts for each protocol — it is widely used for EVMs with the help of ABIs. ​Decoding raw data Since TON handles complex data structures and doesn’t have ABIs, a special decoding framework was created. It works on top of the Spellbook — a powerful tool for building custom tables with dbt and Jinja macros. It helps decode important information from raw protocol message payloads. The following protocols are decoded using this framework and serve as examples: EVAA (implementation) Affluent (implementation) StormTrade (implementation) TON DNS (implementation) ​Custom views In addition to decoding raw data, the Spellbook allows building custom materialized views. Some of them are widely used and maintained to be up to date: ton.prices_daily — prices calculated based on all other tables. The prices include jettons traded on DEXs, LP tokens for DEXs, perpetuals, tsUSDe, and other core assets. It is recommended to use this table if you need to build an estimation of assets denominated in TON or USD. ton.accounts — materialized view with information about all accounts. It comes with the latest TON balance, interface (if any), funding information, and other fields. ton.latest_balances — helper table to get the latest balances for TON and Jettons. All tables mentioned above are updated daily. ​Getting started with Dune If you’re just starting to explore TON data on Dune, we recommend checking these articles first: TON data quick startTON on-chain data analysis: quickstart on DuneHow to Analyze TON Users and Token Flows on Dune: A Practical Guide For inspiration to build your own dashboards, check out these examples: Application ActivityTON & Ethena Boost Rewards CampaignTelegram Gifts Dashboard ​Public Data Lake Dune integration runs on the public data lake from the TON-ETL project. TON-ETL is built on top of TON Center indexer and allows extraction of data from TON Node into data formats suitable for MPP (Massively Parallel Processing) engines: Presto, Apache Spark, etc. You can deploy it on your own infrastructure or use publicly available data from the S3 bucket: s3://aws-public-blockchain/v1.1/ton/. This dataset is part of the AWS Public Blockchain Data project and is optimized for use within the AWS big data stack.Examples of AWS Athena and AWS Bedrock integration can be found in this article. The TON-ETL extracts raw data and performs decoding to create a unified view of high-level on-chain activity. The most important part is decoding DEX activity. The decoding implementation must solve the following tasks: Decoding of swap events. The code must check the authenticity of the swap. For example, you cannot rely on the opcode alone since anyone can generate messages with your opcode. Extracting all swap-related fields: tokens sold and bought, amounts, query IDs, trader, router (if any), and pool. Fetching pool reserves and LP token supply, if applicable. To add support for a new DEX and decode its activity, you need to prepare a relevant PR on GitHub to TON-ETL’s repo. Use those past PRs as a reference: BidAsk, CoffeeSwap, MemesLab. ​Real-time streams In addition to bulk data export, TON-ETL provides real-time data streaming via Kafka. A public endpoint is available free of charge for non-profit projects. For projects that don’t meet the non-profit criteria or require an in-house solution, you can deploy the infrastructure yourself by: Running your own TON node Launching ton-etl Setting up ton-index-worker ​TON Labels While data availability and integrations are essential, building insightful dashboards requires enriching data with address labels. The TON Labels project simplifies this process by providing a comprehensive taxonomy of addresses in TON Ecosystem. It covers active addresses across various categories, including centralized exchanges (CEXs), decentralized applications (dApps), and DeFi protocols. You can access the latest labels either directly from the build branch or through Dune analytics using the dune.ton_foundation.dataset_labels table. ​Other platforms Chainbase offers a set of raw and decoded tables with TON data. It allows you to run SQL queries and fetch results via API. TON Console provides analysts with Analytics Service. TokenTerminal comes with high-level metrics across TON Ecosystem. Artemis contains key metrics for TON and allows you to build customized charts. Was this page helpful?YesNoSuggest editsRaise issuePreviousOverviewNext⌘IgithubxtelegramPowered by MintlifyOn this pageDune analyticsRaw and decoded tablesBespoke data martsDecoding raw dataCustom viewsGetting started with DunePublic Data LakeReal-time streamsTON LabelsOther platforms",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "dapp",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:23:23.029Z"
  },
  {
    "id": "docs-ton-org--payments-overview",
    "title": "Payment processing overview",
    "url": "https://docs.ton.org/payments/overview",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationPayment processingPayment processing overviewPayment processingPayment processing overviewCopy pageCopy pagePayment processing on TON refers to monitoring and handling blockchain transactions for business applications. While simple use cases can rely entirely on smart contracts, most real-world payment systems require off-chain processing to track deposits, manage user balances, send confirmations, and integrate with existing business logic. ​On-chain vs off-chain processing On-chain processing executes all payment logic within smart contracts. When a user sends TON or Jettons to a contract, the contract immediately processes the payment and updates state. This works for simple scenarios like direct peer-to-peer transfers or automated market makers, but becomes impractical when you need user accounts, payment history, refunds, or integration with external systems. Off-chain processing monitors blockchain state changes from outside the network. Your application observes transactions, verifies their validity, updates internal databases, and triggers business logic. Exchanges, merchants, and payment processors use this approach because it provides flexibility to implement complex workflows, maintain user data, and integrate with traditional systems. ​Transaction finality TON achieves transaction finality after a single masterchain block confirmation, typically within 5 seconds. Once a transaction from a shardchain appears in a masterchain block, it becomes irreversible. This differs from blockchains like Ethereum where merchants wait for multiple confirmations (usually 12-15 blocks, taking 2-3 minutes) or Bitcoin where 6 confirmations are standard (about 60 minutes). The masterchain coordinates all workchain activity and produces blocks approximately every 5 seconds. When monitoring payments, you need to verify that the transaction was included in a masterchain block rather than just in a shardchain. Most TON APIs provide methods to check whether a transaction has achieved masterchain finality or, better yet, only consider transaction included in masterchain as finalized by the network. ​Supported assets TON supports several asset types for payment processing: Toncoin is the native currency of the network. Every wallet can receive Toncoin directly without additional setup. Transfers are simple value transfers between addresses, making Toncoin the easiest asset to process. Jettons are fungible tokens following the TON Enhancement Proposal 74 (TEP-74) standard. Each Jetton type has a master contract and individual wallet contracts for each holder. When processing Jetton payments, you monitor the Jetton wallet contract associated with your deposit address. Transfer notifications include sender information and transfer amounts. Read more about how Jettons work. Toncoin processing Jetton processing ​Implementation approaches Three main approaches exist for implementing payment processing on TON: Self-built solution: You run your own service that connects to some TON API or liteserver, monitors blocks for relevant transactions, and maintains a database of payment events. This requires building infrastructure to fetch blocks, parse transactions, handle reconnections, and manage state. The advantage is complete control over the implementation and no dependency on external services. The disadvantage is significant development and maintenance effort. Self-hosted payment processor: Open-source payment processors like Bicycle provide ready-to-deploy solutions that handle blockchain monitoring and expose APIs for your application. You deploy the processor on your infrastructure, configure it for your wallet addresses and asset types, and consume its API to track payments. This balances control with reduced development effort, though you still manage the infrastructure. Third-party payment processor: External services handle all blockchain interaction and provide simple APIs or webhooks for payment notifications. You integrate their SDK or API, and they manage infrastructure, monitoring, and maintenance. This is fastest to implement but introduces dependency on the service provider and typically involves transaction fees. The choice depends on your requirements for control, development resources, and operational complexity. High-volume applications often build custom solutions, while smaller merchants prefer third-party services. ​Monitoring payments Payment monitoring requires polling for new blocks and filtering transactions that affect your addresses. For Toncoin, you check for incoming messages to your wallet address. For Jettons, you monitor the Jetton wallet contract associated with your address for transfer notifications. The typical monitoring flow involves fetching the latest workchain blocks, retrieving all transactions from them, filtering for transactions involving your addresses, parsing transaction data to extract amounts and metadata, verifying the transaction reached finality, and updating your internal payment records. Most applications poll for new blocks every few seconds. More sophisticated systems use multiple strategies: polling for recent data, webhooks from indexing services for real-time notifications, and periodic reconciliation to catch any missed transactions.Was this page helpful?YesNoSuggest editsRaise issuePreviousToncoinNext⌘IgithubxtelegramPowered by MintlifyOn this pageOn-chain vs off-chain processingTransaction finalitySupported assetsImplementation approachesMonitoring payments",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:23:24.191Z"
  },
  {
    "id": "docs-ton-org--payments-toncoin",
    "title": "Toncoin payments processing",
    "url": "https://docs.ton.org/payments/toncoin",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationPayment processingToncoin payments processingPayment processingToncoin payments processingCopy pageCopy pageProcessing Toncoin payments requires choosing between two architectural approaches: invoice-based deposits to a single address, common to all users unique deposit addresses per user. Wallets in Ton are smart-contracts, not external accounts like in Ethereum. Each wallet has its own address, code, and storage. Deposits are incoming messages to these wallet contracts. Do not send funds to a wallet address that you cannot initialize. Derive addresses deterministically based on contracts initial state. ​Deposit methods comparison Invoice-based flow Unique deposit address flow Comparison table CriteriaInvoice-based depositsUnique deposit addresses Security exposureOne shared hot wallet; a key leak drains the full poolEach wallet isolates funds; compromise affects only the impacted userUser input requirementsUser must include an invoice ID comment; missing or malformed comments need manual recovery workflowsUser only needs the destination addressParsing and validationBackend parses comments on every deposit and matches to invoicesNo parsing; deposit attribution is address-basedDeployment and storage costsDeploy and maintain a single wallet; storage rent limited to that contractDeploy many wallets; storage rent and deployment gas scale with user countMonitoring workloadPoll one address; comment parsing adds CPU but RPC calls stay lowTrack many addresses; RPC queries and state tracking grow with the active user baseWithdrawal handlingHighload wallet can batch withdrawals from one balanceNeed sweeps or coordinated withdrawals from many wallets; extra gas and sequencing logicSharding behaviorAll activity hits one shard; throughput limited by that shardWallets are distributed across shards; helps spread load ​Invoice-based deposits Invoice-based processing uses one wallet address to receive payments from all users. Each payment includes a unique identifier in the transaction comment field, allowing the service to attribute deposits to specific users. The implementation deploys one wallet contract (typically Highload) and generates unique invoice identifiers for each deposit. Users send Toncoin to this shared address with their invoice identifier as the comment. The service polls the wallet’s transaction history, extracts comments from incoming messages, matches them against stored invoices, and credits user accounts accordingly. Transaction comments in TON use the text message format; read more in How TON wallets work. Funds at riskRisk: deposits without the correct invoice identifier may be lost. Scope: incoming transfers to the shared deposit address. Mitigation: enforce invoice format; reject or hold unmatched deposits; provide a recovery workflow; document comment entry in the UI. Environment: validate the full flow on testnet before enabling mainnet. Advantages: Single wallet simplifies key management Reduced gas costs for deployments Withdrawals can batch multiple user requests into one transaction using a Highload wallet Disadvantages: Access leak to the single hot wallet could lead to all user funds loss Users must correctly input the invoice identifier, and mistakes result in lost or misdirected funds Comment parsing adds complexity Some user wallet applications don’t support comments, limiting accessibility Single wallet network load won’t be sharded Not production-ready code, use only for educational purposes To understand this approach in greater detail, see the following TypeScript implementation: Invoice-based Toncoin deposits. ​Unique deposit addresses Unique address deposits use a separate wallet contract for each user. The user deposits to their dedicated address, and the service monitors all deployed wallets for incoming transactions. No comment parsing is required since each address maps to exactly one user. Implementation requires a wallet generation strategy. A common approach uses a deterministic scheme based on a single master keypair and user identifiers, deriving unique addresses for V4 and V5 wallets using different subwallet_id values. Alternatively, generate a unique keypair per user, though this increases key management complexity. Funds at riskFunds sent to a non-existent or wrong address are irrecoverable. Derive addresses deterministically and double check. Wallet deployment happens lazily when users first request their deposit address. Generate the address deterministically without deploying the contract. When the user sends their first deposit to the not deployed address, send the transaction in non-bounceable mode. The contract doesn’t exist yet, so bounceable messages would return the funds. After the first deposit arrives, deploy the contract using funds from that deposit or from an external source. Sending non-bounceable messages to nonexistent accounts without testing it first is particularly bad practice. Always test to ensure the address is correct and the deployment flow works as expected. Monitor all user wallets by maintaining a list of deployed addresses and polling their transactions. For large user bases, this becomes resource-intensive. Optimization strategies include monitoring only active wallets (those with recent deposits), using batched RPC calls to check multiple wallets per request. TON’s sharding mechanism splits the network across multiple chains based on address prefixes. The shard prefix comes from the first bits of the address hash. Deploying wallets in the same shard reduces cross-shard communication overhead. Keys and funds at riskRisk: leaked or mishandled private keys enable wallet takeover and fund loss. Scope: generation, storage, and access to per-user wallet keys and deployment workflow. Mitigation: encrypt keys at rest; restrict access; rotate keys; monitor deployment status; verify destination addresses before crediting deposits. Environment: validate key management and deployment flow on testnet before mainnet. Withdrawal processing must gather funds from multiple wallets. Either maintain a minimum balance in each wallet for gas fees or implement a fund collection system that periodically sweeps deposits to a central hot wallet. Highload wallets handle batch withdrawals efficiently, while standard V4/V5 wallets process messages sequentially using seqno, creating bottlenecks under high load. Advantages: No comment parsing removes a major source of user error Better security since each user has a unique keypair Transaction monitoring is straightforward - any incoming transaction to a user’s address is their deposit Disadvantages: Higher operational complexity managing multiple wallets Deployment costs multiply by the number of users Withdrawal processing requires coordination across wallets Storage fees apply to each deployed contract (currently ~0.001 TON per year per contract) Not production-ready code, use only for educational purposes To understand this approach in greater detail, see the following TypeScript implementation: Unique address Toncoin deposits. ​Withdrawal batching When withdrawing, do not send funds to a wallet address that you cannot initialize later, based on contracts initial state. Highload wallets support parallel message processing by storing processed request identifiers instead of sequential seqno. This enables batching multiple withdrawals into one transaction, reducing fees and improving throughput. ​Common abuse patterns Reusing a previously settled invoice identifier to trigger duplicate credits when the backend does not invalidate the invoice after the first use. Changing the Toncoin amount but leaving the original invoice identifier to obtain services at a lower price if expected amounts are not enforced. Crafting comments that mimic another users invoice identifier in order to hijack their pending credit. Submitting large numbers of dust payments to inflate processing costs or exhaust rate limits on transaction polling. ​Monitoring best practices Implement exponential backoff for RPC failures. Network issues or node maintenance can interrupt transaction polling. When getTransactions fails, wait before retrying with increasing delays to avoid overwhelming the endpoint. Store transaction state persistently. Record the last processed lt value (lt here is logical time) and transaction hash to resume monitoring after restarts without reprocessing transactions. This prevents duplicate deposit credits. Use multiple RPC endpoints for reliability. TON has several public API providers and liteserver networks. Implement fallback logic to switch endpoints if the primary becomes unavailable. Compare results across endpoints to detect potential inconsistencies. Log all processing decisions including deposit credits, withdrawal submissions, and failed transactions. These logs a",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "backend",
      "api",
      "sdk",
      "testnet",
      "mainnet",
      "transaction",
      "deployment",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:23:25.745Z"
  },
  {
    "id": "docs-ton-org--payments-jettons",
    "title": "Jettons payments processing",
    "url": "https://docs.ton.org/payments/jettons",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationPayment processingJettons payments processingPayment processingJettons payments processingCopy pageCopy pageProcessing jetton payments requires understanding TON’s sharded token architecture. Unlike single-contract token systems, each jetton type consists of a master contract and individual wallet contracts for each holder. Jettons are fungible tokens on TON. Each jetton has a master contract (minter) and separate wallet contracts for every holder. Read more in How Jettons Work. Jetton processing is security-critical. Incorrect validation of jetton wallet addresses or transfer notifications can lead to accepting fake tokens or crediting wrong amounts. ​Key concepts Before implementing jetton payment processing, understand these core concepts: Jetton architecture: Each jetton type has one master contract that stores metadata and total supply. Each address holding the jetton has a separate jetton wallet contract at a deterministic address derived from the master contract and owner address. Transfer flow: Jetton transfers involve multiple messages. A user sends a transfer message to their jetton wallet, which sends an internal_transfer to the recipient’s jetton wallet, which then sends a transfer_notification to the recipient’s address if forward_ton_amount > 0. Jetton transfers are considered successful only when the recipient receives transfer_notification. Services must set forward_ton_amount to at least 0.000000001 TON (1 nanoton) when sending tokens to trigger notifications. Without this, transfers won’t be compliant and may not be processed by exchanges and other services. Security model: Always validate that jetton wallets belong to the expected master contract. Anyone can deploy fake jetton wallet contracts with arbitrary balances. This article covers processing jetton deposits using transfer notifications. All approaches require maintaining an allowlist of trusted jetton master contracts. For architectural patterns and deposit methods comparison, see Toncoin processing. ​Processing deposits Funds at riskSkipping any validation step or changing their order can lead to incorrect deposit processing and potential loss of funds. ​Setup Processing jetton deposits requires: Allowlist of trusted jetton masters: List of jetton master contract addresses to accept Deposit wallet address: Service wallet (e.g., wallet v4 or v5) ​Initial configuration For each allowlisted jetton master, derive the jetton wallet address for the deposit wallet using the master contract’s get_wallet_address() method Store the mapping of jetton master → jetton wallet → deposit wallet in the database Begin monitoring transactions to the deposit wallet address ​Processing incoming transactions When a transaction arrives at the deposit wallet: Check that tx.in_msg.source matches a known jetton wallet for this deposit wallet Verify the master → jetton wallet relationship: Call get_wallet_address(deposit-wallet) on the master contract Confirm the returned address matches the sender Verify there are no outgoing messages (tx.out_msgs.length === 0) Parse the message body: Check the opcode (first 32 bits of tx.in_msg.body) equals 0x7362d09c (transfer_notification) Extract query_id, amount, sender, and forward_payload according to TL-B Verify the amount matches the expected value ​Crediting user accounts After validation, extract deposit information: For invoice-based deposits: Parse the invoice ID from forward_payload, match it against the database, and credit the corresponding user account For address-based deposits: Match the deposit-wallet address against the database and credit the user account Not production-ready code, use only for educational purposes To understand invoice-based deposit approach in greater detail, see the following TypeScript implementation: Invoice-based Jetton deposits. For unique TypeScript implementation addresses see: Unique address Toncoin deposit. ​Security considerations ​Master-wallet verification Never trust jetton wallet addresses without verification. Always perform these checks: Get the jetton master address from the allowlist Call jetton_master.get_wallet_address(owner_address) Verify the returned address matches the jetton wallet that sent the notification ​Transfer notification validation When processing deposits via transfer_notification: Verify the opcode is exactly 0x7362d09c Check the sender address is an expected jetton wallet Extract amount in base units (not decimal) Validate the sender field against expected user addresses Parse forward_payload carefully—it may be malformed Check for bounce indicators (single outgoing message back to sender) ​Fake jetton detection Attackers can deploy jettons with identical names, symbols, and images: Always verify the jetton master address against the allowlist Never trust metadata (name, symbol, image) for authentication Display the master contract address in admin interfaces Implement a manual approval workflow for adding new jettons ​Common attack patterns ​Fake jetton wallets Attack: Attacker deploys a contract claiming to be a jetton wallet with an inflated balance. Mitigation: Verify the master-wallet relationship by calling get_wallet_address() on the master contract. ​Invoice ID reuse Attack: User attempts to reuse a settled invoice identifier. Mitigation: Mark invoices as used after the first successful deposit. ​Master contract spoofing Attack: Deploying a fake master contract that validates the attacker’s fake jetton wallets. Mitigation: Maintain a strict allowlist of trusted master contracts and verify all jetton wallets against it. ​Implementation checklist Before enabling jetton processing in production: ​Testing Deploy and test on testnet with real user scenarios Verify master-wallet relationships for all allowlisted jettons Test with fake jetton wallets to confirm rejection Validate transfer notification parsing with various payload formats Test bounce detection and handling Test invoice ID collision and reuse scenarios Test full flow: deposit → credit → withdrawal → confirmation Was this page helpful?YesNoSuggest editsRaise issuePreviousHow they workNext⌘IgithubxtelegramPowered by MintlifyOn this pageKey conceptsProcessing depositsSetupInitial configurationProcessing incoming transactionsCrediting user accountsSecurity considerationsMaster-wallet verificationTransfer notification validationFake jetton detectionCommon attack patternsFake jetton walletsInvoice ID reuseMaster contract spoofingImplementation checklistTesting",
    "category": "tokens",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "testnet",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:23:27.008Z"
  },
  {
    "id": "docs-ton-org--standard-vesting",
    "title": "Vesting contracts",
    "url": "https://docs.ton.org/standard/vesting",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationStandard contractsVesting contractsStandard contractsVesting contractsCopy pageCopy pageA vesting contract is a financial agreement that outlines how and when an individual earns rights to certain assets over a specified period. On TON, vesting contracts enable secure, scheduled distribution of Toncoin assets with built-in staking capabilities. ​What is vesting Vesting is a mechanism that locks assets for a defined period and gradually releases them according to a predetermined schedule. Traditional vesting includes a cliff period where no rights are granted initially, followed by gradual vesting over time. On TON, vesting contracts function as smart escrow services that lock Toncoin and release it according to configurable parameters. These contracts also support staking locked funds, allowing recipients to earn rewards while tokens remain locked. ​How staking works with vesting When funds are locked in a vesting contract, they cannot be sent to arbitrary addresses until unlocked. However, the contract supports a whitelist mechanism that allows sending locked funds to specific, approved destinations—primarily for staking purposes. The vesting sender controls which addresses can receive locked funds by adding them to a whitelist. This security measure ensures that locked funds can only move to trusted, verified contracts that support staking operations. Once whitelisted, locked funds can be staked through various methods: Direct validation through the system Elector Single nominator pools Liquid staking protocols Standard nominator pools Staking rewards accumulate normally and remain accessible even while funds are locked. The vesting contract enforces restrictions only on destinations, not on the funds themselves once they are staked. ​Contract capabilities A vesting contract operates with two key roles: Vesting sender: The entity that creates the contract and locks the funds. The sender can: Add addresses to the whitelist at any time Receive funds back to their address at any time (even if locked) Cannot remove addresses from the whitelist once added Owner: The recipient of the vesting contract who can: Send funds from the contract to whitelisted addresses or the sender address Send unlocked funds to any address after the vesting period ends Stake funds through approved methods The contract maintains a whitelist of approved destinations. Funds can be sent to whitelisted addresses even while locked, enabling staking operations. Once unlocked, funds can be sent anywhere without restrictions. ​Unlock mechanism The vesting contract uses a time-based unlock schedule with these parameters: Vesting start time: Unix timestamp when the vesting period begins Total duration: Total vesting period in seconds (e.g., 31,104,000 for one year) Unlock period: Time interval between releases in seconds (e.g., 2,592,000 for monthly) Cliff duration: Initial lock period before the first release (e.g., 5,184,000 for two months) Before the vesting start time, all funds are locked. After the start time, funds unlock proportionally according to the schedule. If a cliff period exists, nothing unlocks during that time. Once the cliff ends, funds unlock according to the formula. Example: With a total duration of 10 months, unlock period of 1 month, and total amount of 500 TON, the contract unlocks 50 TON each month. If a 3-month cliff exists, nothing unlocks for the first 3 months, then 150 TON unlocks at once, followed by 50 TON monthly. Use the get_locked_amount(int at_time) method to calculate how much remains locked at any specific time. ​Deploy and verify a vesting contract Deploying a vesting contract requires careful verification before sending funds. Follow these steps: ​Step 1: Prepare recipient wallet The vesting sender requests the recipient’s TON wallet address. If the wallet is not deployed, the sender transfers 1 TON to the recipient and requests they send it back. This verifies wallet access and ensures deployment. ​Step 2: Create the vesting contract Visit vesting.ton.org Enter the recipient’s wallet address in the “Address” field Select “Create new vesting for this user” ​Step 3: Configure vesting parameters Provide these details: Vesting start date: Choose a deferred date for lockup without accumulation before the date Total amount: Total vesting amount in TON Total vesting duration: Duration in days (including cliff), e.g., 760 days for 2 years Cliff duration: Period in days after vesting starts when vesting accumulates but cannot be withdrawn (zero if no cliff) Unlocking frequency: Frequency in days (equal to total duration if no partial unlocking), e.g., 30 days for monthly In masterchain: Check this if direct validation from the vesting wallet is required. Direct validation means participating in the blockchain’s proof-of-stake consensus as a validator with a stake of 300,000 TON or more Whitelist addresses: Add addresses for staking contracts (e.g., single nominator pool addresses) Constraints: Total vesting duration must be divisible by unlocking frequency Cliff duration must be divisible by unlocking frequency ​Step 4: Deploy and verify Select “Create” to generate the vesting wallet contract (costs 0.5 TON) The vesting wallet page opens after creation Verify all parameters are correct before proceeding Share the link with the recipient so they can verify parameters ​Step 5: Verify contract code hash Before sending funds to the deployed contract, verify the contract code hash matches the official version: Official vesting contract code hash: b48b531abec3b714638291f7d77ed6dc9f6a2729efca20477137374d4ae8b590 To verify: Open the vesting contract address in a block explorer Check the contract code hash Verify it matches the official hash above Security: Verify code hashNever send funds to a vesting contract until the code hash is verified to match the official version. A mismatched code hash indicates a modified or malicious contract that could steal funds. ​Step 6: Verify parameters via get-method After deployment but before sending funds, verify all parameters using the get_vesting_data() get-method: Confirm all time parameters match expectations Verify sender and owner addresses are correct Check that duration constraints are satisfied Example result on Tonviewer: ​Step 7: Send funds Only after verification is complete, send the vesting amount to the contract address from any wallet. ​Reviewing contracts for whitelist Before adding any address to the whitelist, verify the contract is legitimate and safe: Check contract verification: Use a block explorer to verify the contract is verified and matches known contract code hashes Verify contract type: Confirm the contract is one of the supported types (single nominator pool, liquid staking protocol, etc.) Review contract source: If available, review the contract source code or audit reports Check operational history: Review the contract’s transaction history for suspicious activity Verify addresses: Double-check addresses match official documentation from the protocol Supported whitelist destinations include: System Elector address (-1:3333333333333333333333333333333333333333333333333333333333333333) System Config address (-1:5555555555555555555555555555555555555555555555555555555555555555) Single nominator pool contracts Liquid staking protocol contracts (Tonstakers, Bemo) Standard nominator pool contracts Whales nominator pool contracts Technically, any address can be added to the whitelist, including regular wallet addresses like wallet-v4. However, adding a wallet address defeats the purpose of vesting, as the owner would be able to withdraw locked funds immediately. Whitelist addresses should only include contracts that support staking operations and cannot be used for direct withdrawals. Whitelist securityOnce an address is added to the whitelist, it cannot be removed. Review all addresses carefully before adding them. Only add addresses from trusted, verified protocols. ​Sending messages via UI The vesting contract can be managed through the vesting.ton.org interface: Open the vesting contract page using the shared link Connect the owner wallet Select “Send from Vesting” to create a new transaction Enter the destination address Enter the amount For staking operations, add the appropriate message body: Empty message for single nominator pools or Bemo Text comment “d” for standard nominator pools (deposit) Text comment “w” for standard nominator pools (withdraw) Text comment “Stake” for Whales pools Text comment “Withdraw” for Whales pools Select the message format: Text, Base64, or HEX. Use Text for simple text comments, and Base64 or HEX for serialized BoC messages (e.g., Tonstakers deposit operations). Review and confirm the transaction The interface handles message formatting automatically, ensuring complianc",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "deployment",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:23:28.663Z"
  },
  {
    "id": "docs-ton-org--contract-dev-first-smart-contract",
    "title": "Your first smart contract",
    "url": "https://docs.ton.org/contract-dev/first-smart-contract",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationContract developmentYour first smart contractContract developmentYour first smart contractCopy pageCopy pageWelcome to your journey into TON smart contract development! In this comprehensive tutorial, you’ll learn to build, deploy, and interact with a smart contract from scratch. ​What you’ll learn By the end of this tutorial, you’ll have: ✅ Built a complete smart contract in Tolk ✅ Deployed it to TON testnet ✅ Interacted with it using TypeScript scripts ✅ Mastered the fundamentals of TON development ​What is a TON smart contract? ​Understanding the basics A smart contract is a computer program stored on TON Blockchain — a distributed database that many computers maintain together. It runs on the TVM (TON Virtual Machine) — the “computer” that runs smart contract code on TON. The contract is made of two parts: Code (compiled TVM instructions) - the “rules” or “program logic” Data (persistent state) - the “memory” that remembers things between interactions Both are stored at a specific address on TON Blockchain, a unique identifier for each smart contract. ​Prerequisites Basic programming - Understanding of variables, functions, if/else statements Command line basics - Comfortable opening terminal and running commands Node.js (v22 or later) — Download here Check if installed: node -v in terminal TON wallet ​Tutorial overview This tutorial is organized into six clear steps that build upon each other: StepWhat You’ll DoKey SkillsStep 1Set up Blueprint toolkitProject structure, development environmentStep 2Learn contract architectureStorage, messages, getters conceptStep 3Write contract in TolkProgramming, message handling, data structuresStep 4Compile to bytecodeBuild process, TVM compilationStep 5Deploy to blockchainTestnet deployment, wallet integrationStep 6Interact with contractMessage sending, get methods, TypeScript integration Let’s dive into development! ​Step 1: Development environment setup We’ll use Blueprint as our development toolkit for smart contracts. Start a new project with: CopyAsk AInpm create ton@latest -- Example --contractName FirstContract --type tolk-empty This will create a project Example with a contract FirstContract. The project structure will look like this: CopyAsk AIExample/ ├── contracts/ # Smart contract source code │ └── first_contract.tolk # Main contract file ├── scripts/ # Deployment and on-chain interaction scripts │ └── deployFirstContract.ts # Script to deploy the contract ├── tests/ # Testing specifications │ └── FirstContract.spec.ts # Contract test file └── wrappers/ # TypeScript wrappers for contract interaction ├── FirstContract.ts # Wrapper class for the smart contract └── FirstContract.compile.ts # Configuration for compiling contract TON provides plugins that add syntax support for various IDEs and code editors. Check out the IDE & plugins section for VS Code and JetBrains support. Now, move into the project directory: CopyAsk AIcd Example ​Step 2: Understanding smart contract architecture Every smart contract in TON is typically divided into three sections: storage, messages, and getters. Storage: Defines the contract’s persistent data. For example, our counter variable must keep its value across calls from different users. Messages: Define how the contract reacts to incoming messages. On TON, the primary way to interact with contracts is by sending messages. Each processed message produces a transaction — a recorded change on the blockchain (like “Alice sent 5 TON to Bob”). Getters: Provide read-only access to contract data without modifying state. For example, we’ll create a getter to return the current value of the counter. Due to the TON architecture, getters cannot be called from other contracts. Inter-contract communication is possible only through messages. ​Step 3: Writing the smart contract We’ll build a simple counter contract: The counter starts from an initial number. Users can send an increase message to increment it, or a reset message to drop it to zero. A getter function will let anyone query the current counter value. We’ll use Tolk to implement this. Tolk looks familiar if you know TypeScript or Rust, but it’s designed specifically for smart contract development. ​3.1 Defining contract storage First, we need a way to store the counter value. Tolk makes this simple with structures: ./contracts/first_contract.tolkCopyAsk AIstruct Storage { counter: uint64 // the current counter value } // load contract data from persistent storage fun Storage.load() { return Storage.fromCell(contract.getData()) } // save contract data to persistent storage fun Storage.save(self) { contract.setData(self.toCell()) } Behind the scenes, structures know how to serialize and deserialize themselves into cells — the fundamental way TON stores data. This happens through the fromCell and toCell functions - Tolk automatically converts between your nice structures and the cell format that TON understands. You may think of cells like containers that hold data on TON: Each cell can store up to 1023 bits of data. Cells can reference other cells (like links). Everything on TON (contracts, messages, storage) is made of cells. Now that we can store data, let’s handle our first messages. ​3.2 Implementing message handlers The main entry point for processing messages in a Tolk contract is the onInternalMessage function. It receives one argument — the incoming message. Among its fields, the most important one for us is body, which contains the payload sent by a user or another contract. Tolk structures are also useful for defining message bodies. In our case, we’ll define two messages: IncreaseCounter — with one field increaseBy, used to increment the counter. ResetCounter — used to reset the counter to zero. Each structure has a unique prefix (0x7e8764ef and 0x3a752f06), widely called opcodes, that lets the contract distinguish between them. ./contracts/first_contract.tolkCopyAsk AIstruct (0x7e8764ef) IncreaseCounter { increaseBy: uint32 } struct (0x3a752f06) ResetCounter {} To group them together, we’ll use a union. Unions allow multiple types to be bundled into a single type that can be serialized and deserialized automatically: ./contracts/first_contract.tolkCopyAsk AItype AllowedMessage = IncreaseCounter | ResetCounter Now we can write our message handler: ./contracts/first_contract.tolkCopyAsk AIfun onInternalMessage(in: InMessage) { // use `lazy` to defer parsing until fields are accessed val msg = lazy AllowedMessage.fromSlice(in.body); // matching our union to determine body structure match (msg) { IncreaseCounter => { // load contract storage lazily (efficient for large or partial reads/updates) var storage = lazy Storage.load(); storage.counter += msg.increaseBy; storage.save(); } ResetCounter => { var storage = lazy Storage.load(); storage.counter = 0; storage.save(); } // this match branch would be executed if the message body does not match IncreaseCounter or ResetCounter structures else => { // reject user message (throw) if body is not empty assert(in.body.isEmpty()) throw 0xFFFF } } } Tolk Language Guide - Complete language documentation View the complete contract on GitHub ​3.3 Adding getter functions Finally, let’s implement a getter so users can read the current counter value: ./contracts/first_contract.tolkCopyAsk AIget fun currentCounter(): int { val storage = lazy Storage.load(); return storage.counter; } ​3.4 Complete contract code We now have a complete smart contract with: Storage: persistent counter value Messages: IncreaseCounter and ResetCounter handlers Getter: currentCounter Here’s the full source code of contracts/first_contract.tolk: ./contracts/first_contract.tolkCopyAsk AIstruct Storage { counter: uint64 } fun Storage.load() { return Storage.fromCell(contract.getData()); } fun Storage.save(self) { contract.setData(self.toCell()); } struct (0x7e8764ef) IncreaseCounter { increaseBy: uint32 } struct (0x3a752f06) ResetCounter {} type AllowedMessage = IncreaseCounter | ResetCounter fun onInternalMessage(in: InMessage) { val msg = lazy AllowedMessage.fromSlice(in.body); match (msg) { IncreaseCounter => { var storage = lazy Storage.load(); storage.counter += msg.increaseBy; storage.save(); } ResetCounter => { var storage = lazy Storage.load(); storage.counter = 0; storage.save(); } else => { assert(in.body.isEmpty()) throw 0xFFFF; } } } get fun currentCounter(): int { val storage = lazy Storage.load(); return storage.counter; } See all 47 lines 🎉 Congratulations — you’ve built your first smart contract in Tolk! You can find the full working code for this tutorial in our GitHub repository. This includes all contract files, scripts, and wrappers ready to use. ​Step 4: Compiling your contract The next step is to build our contract — compile it into bytecode that can be executed by the TVM. With Blueprint, th",
    "category": "smart-contracts",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "testnet",
      "mainnet",
      "transaction",
      "deployment",
      "testing",
      "tutorial",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "react",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:23:30.925Z"
  },
  {
    "id": "docs-ton-org--contract-dev-debug",
    "title": "Debugging smart contracts",
    "url": "https://docs.ton.org/contract-dev/debug",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationContract developmentDebugging smart contractsContract developmentDebugging smart contractsCopy pageCopy pageAll examples from this article are available on GitHub. Errors in smart contracts can produce an exit code, often indicating a bug in the contract. Use debugging methods to locate and fix the issue. ​Log to the console Most commonly used to print common values: transactions and get-method results. Use findTransaction() to find a transaction by its properties. Use flattenTransaction() to inspect transactions in a more human-readable format. TypeScriptCopyAsk AIimport '@ton/test-utils'; import { toNano } from '@ton/core'; import { Blockchain } from '@ton/sandbox'; import { Test } from './output/sample_Test'; import { findTransaction } from '@ton/test-utils'; import { flattenTransaction } from '@ton/test-utils'; const setup = async () => { const blockchain = await Blockchain.create(); const owner = await blockchain.treasury('deployer'); const contract = blockchain.openContract( await Test.fromInit(), ); const deployResult = await contract.send( owner.getSender(), { value: toNano(0.5), bounce: true }, null, ); return { blockchain, owner, contract, deployResult }; }; it('should deploy correctly', async () => { const { contract, deployResult } = await setup(); const txToInspect = findTransaction( deployResult.transactions, { to: contract.address, deploy: true, }, ); if (txToInspect === undefined) { throw new Error('Requested tx was not found.'); } // User-friendly output console.log(flattenTransaction(txToInspect)); // Verbose output console.log(txToInspect); }); ​Dump values from a contract There are three TVM debug instructions: DUMPSTK, STRDUMP, and DUMP. These instructions are wrapped in functions with different names in each language: Tolk: Functions on a global debug object. FunC: Global functions from stdlib.fc. Tact: dumpStack for DUMPSTK and the dump function for the other two. Tact also prints the exact line where dump is called, so it can quickly be found in the code. Debug instructions consume gas and affect gas measurement. Remove them before measuring gas or deploying to production. ​Explore TVM logs TypeScriptCopyAsk AIconst blockchain = await Blockchain.create(); blockchain.verbosity.vmLogs = \"vm_logs\"; Of all verbosity levels, the two are the most useful: vm_logs — outputs VM logs for each transaction; includes executed instructions and occurred exceptions. vm_logs_full — outputs full VM logs for each transaction; includes executed instructions with binary offsets, the current stack for each instruction, and gas used by each instruction. Typical output for vm_logs looks like this: CopyAsk AI... execute SWAP execute PUSHCONT x30 execute IFJMP execute LDU 64 handling exception code 9: cell underflow default exception handler, terminating vm with exit code 9 The contract attempts to load a 64-bit integer from the slice using LDU 64. Since there is not enough data, execution stops with exit code 9. Inspect the same code with the vm_logs_full verbosity level. The output is heavily truncated at the top. CopyAsk AI... execute PUSHCONT x30 gas remaining: 999018 stack: [ 500000000 CS{Cell{02b168008d0d4580cd8f09522be7c0390a7a632bda4a99291c435b767c95367ebe78e9af0023d36bc5f97853f4c898f868f95b035ae8f555a321d0ffce8d9f6165e2252d7a9077359400060e9fc800000000003d0902d1b85b3919} bits: 711..711; refs: 2..2} 0 Cont{vmc_std} ] code cell hash: F9EAC82B7999AEEF696D592FE2469B9069FB05ED35C92213D7EE516F45AB97CA offset: 344 execute IFJMP gas remaining: 999000 stack: [ 500000000 CS{Cell{02b168008d0d4580cd8f09522be7c0390a7a632bda4a99291c435b767c95367ebe78e9af0023d36bc5f97853f4c898f868f95b035ae8f555a321d0ffce8d9f6165e2252d7a9077359400060e9fc800000000003d0902d1b85b3919} bits: 711..725; refs: 2..2} ] code cell hash: F9EAC82B7999AEEF696D592FE2469B9069FB05ED35C92213D7EE516F45AB97CA offset: 352 execute LDU 64 handling exception code 9: cell underflow default exception handler, terminating vm with exit code 9 To investigate the error in more detail, examine the TVM source code for the LDU instruction. Sometimes several instructions are implemented within a single exec_* method. For example, LDU (load_uint), LDI (load_int) and it’s preload versions (preload_uintandpreload_int).Check how LDU is implemented. Stack is printed as [bottom, ..., top], where top is the top of the stack. Here, the stack contains two values: Top: the slice from which data is being read — CS{Cell{...} bits: 711..725; refs: 2..2} Bottom: an integer value — 500000000 However, the slice contains only 725 bits, of which 711 bits and both references have already been read. The contract attempted to read 64 more bits, but the slice did not contain enough remaining data. In FunC, locate the load_uint(64) call causing the issue and ensure enough bits are available or adjust the read width. ​TVM log limits The size of TVM debug output depends on the verbosity level: LevelSettingMax size0none256 bytes (default)1–4vm_logs vm_logs_location vm_logs_gas vm_logs_full1 MB5vm_logs_verbose32 MB When the output exceeds its limit, it is truncated from the bottom — older entries are discarded, and only the most recent lines are kept. Logs are not rotated. ​Explore the trace For traces that are not too large, print all transactions and inspect them. TypeScriptCopyAsk AIconst result = await contract.send( owner.getSender(), { value: toNano(0.5), bounce: true }, null, ); for (const tx of result.transactions) { console.log(flattenTransaction(tx)); } For large traces, use a GUI tool. Two tools are commonly used: TonDevWallet trace view — requires the TonDevWallet application; does not require a custom @ton/sandbox; requires the @tondevwallet/traces package. TxTracer Sandbox — requires a custom @ton/sandbox package; runs in the browser. Also, these tools allow to explore logs of each transaction. ​Debugging with TVM Retracer Even when a contract executes successfully (exit code = 0) with no errors, the actions may not produce the expected on-chain result. TVM Retracer replays the transaction and displays VM-level execution in detail. ​Scenarios for retracing All execution phases complete without errors, yet the expected outcome is missing. An action is skipped, or a transfer does not reach its destination. A step-by-step view of how the TVM executes contract logic is required, i.e. to trace a bug in a high-level smart-contract language compiler. ​How to analyze a transaction Obtain the transaction hash from a blockchain explorer. Open TVM Retracer and enter the transaction hash. Review the execution: Inspect Logs section for executed instructions and exceptions. Examine Actions cell (C5) to review data passed between contracts. Check message modes — some modes can suppress errors, causing actions to be skipped. Was this page helpful?YesNoSuggest editsRaise issuePreviousSigning messagesNext⌘IgithubxtelegramPowered by MintlifyOn this pageLog to the consoleDump values from a contractExplore TVM logsTVM log limitsExplore the traceDebugging with TVM RetracerScenarios for retracingHow to analyze a transaction",
    "category": "smart-contracts",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:23:32.511Z"
  },
  {
    "id": "docs-ton-org--contract-dev-signing",
    "title": "Signing messages",
    "url": "https://docs.ton.org/contract-dev/signing",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationContract developmentSigning messagesContract developmentSigning messagesCopy pageCopy pageCryptographic signatures are the foundation of access control. Contracts verify signatures on-chain and implement their own authorization policies for wallet operations, server-authorized actions, gasless transactions, multisig wallets, and delegation. ​Ed25519 in TON TON uses Ed25519 as the standard signature scheme. All wallets (v1–v5) and highload wallets rely on Ed25519. Specification: Public key size: 256 bits Signature size: 512 bits Curve: Ed25519 The public key is not the wallet address. The address is derived from the contract’s initial code and data that are included in StateInit structure. Multiple contracts can use the same public key but have different addresses. ​Other primitives TVM exposes additional cryptographic primitives beyond Ed25519. These are useful for cross-chain compatibility and advanced protocols: PrimitivePurposesecp256k1Ethereum-style ECDSA via ECRECOVER; x-only pubkey operations (TVM v9+)secp256r1 (P-256)ECDSA verification via P256_CHKSIGNS and P256_CHKSIGNUBLS12-381Pairing-based operations for signature aggregation and zero-knowledge proofsRistretto255Prime-order group over Curve25519 for advanced cryptographic constructions For details, see crypto instructions in TVM instructions. This guide focuses on Ed25519, usually used for TON. ​Signing pipeline Ed25519 signatures in TON typically work with hashes rather than raw data, because signing the hash takes a smaller and constant amount of time. Off-chain (TypeScript) Serialize message data into a cell Compute its hash (256 bits) Sign the hash with private key Signature (512 bits) On-chain (Tolk) Contract receives signature and data Recomputes the hash Verifies signature matches the hash and public key TVM provides two signature verification methods: CHKSIGNS checks signature of data; CHKSIGNU checks signature of hash. Hash-based verification (CHKSIGNU) is preferred because CHKSIGNS only processes data from a single cell (up to 127∗8=1016127 * 8 = 1016127∗8=1016 bits) and ignores cell references. For messages containing multiple cells or references, hashing the entire structure first is required. ​Signature interaction patterns Signatures are used in different ways depending on who signs the message, who sends it, and who pays for execution. Here are three real-world examples. ​Example 1: Standard wallets (v1–v5) Standard wallet contracts are described in more detail in the wallets section. How it works: User signs a message off-chain (includes replay protection data and transfer details) User sends external message to blockchain Wallet contract verifies the signature Wallet contract checks seqno for replay protection Wallet contract accepts message (pays gas from wallet balance) Wallet contract increments seqno Wallet contract executes the transfer Key characteristics: Who signs: User Who sends: User (external message) Who pays gas: Wallet contract This is the most common pattern. ​Example 2: Gasless transactions (Wallet v5) How it works: User signs a message off-chain that includes two transfers: one to recipient, one to service as payment User sends signed message to service via API Service verifies the signature Service wraps signed message in internal message Service sends internal message to user’s wallet (pays gas in TON) Wallet contract verifies user’s signature Wallet contract checks seqno for replay protection Wallet contract increments seqno Wallet contract executes both transfers (to recipient and to service) Key characteristics: Who signs: User Who sends: Service (internal message) Who pays gas: Service (in TON), gets compensated in Jettons This pattern enables users to pay gas in Jettons instead of TON. ​Example 3: Server-controlled operations How it works: User requests authorization from server Server validates request and signs authorization message (includes validity period and operation parameters) User sends server-signed message to contract (with payment) Contract verifies server’s signature Contract checks validity period Contract performs authorized action (deploy, mint, claim) If user tries to send same message again, contract ignores it (state already changed) Key characteristics: Who signs: Server Who sends: User (internal message with payment) Who pays gas: User This pattern is useful when backend needs to authorize specific operations (auctions, mints, claims) without managing private keys for each user. Real-world example: telemint contract uses server-signed messages to authorize NFT deployments. ​Message structure for signing When designing a signed message, the choice is how to organize the signed data — the message fields that will be hashed and verified. The key question: is the signed data a slice (part of a cell) or a cell (separate cell)? This affects gas consumption during signature verification. ​Approach 1: Signed data as slice After loading the signature from the message body, the signed data remains as a slice — a part of the cell that may contain additional data and references. Used in: Wallet v1-v5 Schema — Wallet v3r2: CopyAsk AImsg_body$_ signature:bits512 subwallet_id:uint32 seqno:uint32 valid_until:uint32 mode:uint8 message_to_send:^Cell = ExternalInMessage; Verification in FunC: CopyAsk AIslice signature = in_msg_body~load_bits(512); slice signed_data = in_msg_body; // Remaining data int hash = slice_hash(signed_data); // 526 gas throw_unless(35, check_signature(hash, signature, public_key)); Gas analysis: After loading the signature, the remaining data is a slice. To verify the signature, the contract needs to hash this slice. In TVM, the method for hashing a slice is slice_hash(), which costs 526 gas. Why expensive? slice_hash() internally rebuilds a cell from the slice, copying all data and references. Optimization availableRecent TVM versions support builder_hash() for efficient hashing. Convert the slice to a builder and hash it — this costs less than 100 gas total. See Optimization: Builder hashing below for details. ​Approach 2: Signed data as cell The signed data is stored in a separate cell, placed as a reference in the message body. Used in: Preprocessed Wallet v2, Highload Wallet v3 Schema — Preprocessed Wallet v2: CopyAsk AI_ valid_until:uint64 seqno:uint16 actions:^Cell = MsgInner; msg_body$_ signature:bits512 msg_inner:^MsgInner = ExternalInMessage; Verification in FunC: CopyAsk AIslice signature = in_msg_body~load_bits(512); cell signed_data = in_msg_body~load_ref(); // Signed data as cell int hash = cell_hash(signed_data); // 26 gas throw_unless(35, check_signature(hash, signature, public_key)); Gas analysis: The signed data is loaded as a cell from the reference. To get its hash, the contract uses cell_hash(), which costs only 26 gas. Why efficient? Every cell in TON stores its hash as metadata. cell_hash() reads this precomputed value directly — no rebuilding, no copying. Trade-off: This approach adds one extra cell to the message, slightly increasing the forward fee. However, the gas savings (~500 gas) outweigh the forward fee increase. ​Optimization: Builder hashing Recent TVM versions introduced efficient builder hashing (HASHBU instruction), which makes signed data as slice approach much more gas-efficient. Verification in FunC (optimized): CopyAsk AIslice signature = in_msg_body~load_bits(512); slice signed_data = in_msg_body; builder b = begin_cell().store_slice(signed_data); int hash = b.builder_hash(); throw_unless(35, check_signature(hash, signature, public_key)); Gas comparison: MethodGas costNotesslice_hash()526 gasRebuilds cell from sliceBuilder hashing (slice)<100 gasWith HASHBU: cheap builder hashingcell_hash() (cell)26 gasUses precomputed cell hash Conclusion: With builder hashing optimization, both approaches are gas-efficient. New contracts can choose based on code simplicity and forward fee considerations. Reference: GlobalVersions.md — TVM improvements ​How to sign messages in TypeScript ​Prerequisites Node.js 18+ or TypeScript environment @ton/core, @ton/crypto packages installed Install required packages: CopyAsk AInpm install @ton/core @ton/crypto ​Step 1: Generate or load a mnemonic A mnemonic is the wallet’s master secret. It derives the private key used to sign messages. Generate a new mnemonic: CopyAsk AIimport { mnemonicNew } from '@ton/crypto'; const mnemonic = await mnemonicNew(24); // Array of 24 words Load an existing mnemonic: CopyAsk AI// Read from environment; do not inline secrets const mnemonic = (process.env.MNEMONIC ?? 'MNEMONIC_WORDS').split(' '); Protect the mnemonicAnyone with access to the mnemonic can control the wallet and all funds. Store it securely (password manager, hardware wallet, encrypted storage). Never commit it to version control. ​Step 2: Derive the keypair Convert the",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "backend",
      "api",
      "sdk",
      "transaction",
      "deployment",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:23:33.778Z"
  },
  {
    "id": "docs-ton-org--contract-dev-contract-sharding",
    "title": "Contract sharding",
    "url": "https://docs.ton.org/contract-dev/contract-sharding",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationContract developmentContract shardingContract developmentContract shardingCopy pageCopy pageSome protocols need to store a lot of information in contracts, for example, tokens that have many users. In TON, there is a limit on how much can be stored in a single contract. The solution in TON is to split the data across many different contracts, where you can quickly find the right contract by a key and retrieve the required information from it. In such protocols, there is a child contract that initially contains the information identified by a key. In some protocols, it is important to know the Parent contract, which acts as the information manager. To avoid having to know the key upfront, we do not populate that field in StateInit; we only populate the key field. This makes it easy to locate the required contract later. Child contracts should store information about the Parent so that only it can authorize important state changes. Consider NFTs: the collection serves as the Parent contract, and the NFT items are the child contracts. The key in this case is the index, and only a message from the collection can set the initial owner. For Jettons, the Parent is the minter and the Children are user wallets. The key is the user’s smart contract address, and the value is the user’s token balance. In general, jettons and NFTs share this principle, but broadly speaking, jetton protocols have a unique contract per user, while NFTs have a single contract per item (by index) that is shared across all users. ​Unbounded data structures An interesting property of this pattern is that the number of potential children is unbounded! We can have an infinite number of children. In general, infinite data structures that can actually scale to billions are very difficult to implement on blockchain efficiently. This pattern showcases the power of TON. TactCopyAsk AIimport \"@stdlib/deploy\"; // we have multiple instances of the children contract TodoChild { seqno: Int as uint64; // when deploying an instance, we must specify its index (sequence number) init(seqno: Int) { self.seqno = seqno; } // this message handler will just debug print the seqno so we can see when it's called receive(\"identify\") { dump(self.seqno); } } // we have one instance of the parent contract TodoParent with Deployable { numChildren: Int as uint64; init() { self.numChildren = 0; } // this message handler will cause the contract to deploy another child receive(\"deploy another\") { self.numChildren = self.numChildren + 1; let init: StateInit = initOf TodoChild(self.numChildren); send(SendParameters{ to: contractAddress(init), value: ton(\"0.1\"), // pay for message, the deployment, and give some TON for storage mode: SendIgnoreErrors, code: init.code, // attaching the `StateInit` will cause the message to deploy data: init.data, body: \"identify\".asComment() // we must piggyback the deployment on another message }); } get fun numChildren(): Int { return self.numChildren; } } Was this page helpful?YesNoSuggest editsRaise issuePreviousSecurity best practicesNext⌘IgithubxtelegramPowered by MintlifyOn this pageUnbounded data structures",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "deployment",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:23:36.238Z"
  },
  {
    "id": "docs-ton-org--contract-dev-security",
    "title": "Security best practices",
    "url": "https://docs.ton.org/contract-dev/security",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationContract developmentSecurity best practicesContract developmentSecurity best practicesCopy pageCopy pageThere are several anti-patterns and potential attack vectors that smart contract developers should be aware of. These can affect the security, efficiency, and correctness of the contracts. Below are some common pitfalls and best practices to avoid them. ​Signed/unsigned integer vulnerabilities Improper handling of signed integers can allow attackers to exploit overflow/underflow conditions. ​Vulnerable code CopyAsk AI(cell,()) transfer_voting_power(cell votes, slice from, slice to, int amount) impure { int from_votes = get_voting_power(votes, from); int to_votes = get_voting_power(votes, to); from_votes -= amount; // Can become negative! to_votes += amount; votes~set_voting_power(from, from_votes); votes~set_voting_power(to, to_votes); return (votes,()); } ​Secure implementation CopyAsk AI(cell,()) transfer_voting_power(cell votes, slice from, slice to, int amount) impure { int from_votes = get_voting_power(votes, from); int to_votes = get_voting_power(votes, to); throw_unless(998, from_votes >= amount); // Validate sufficient balance from_votes -= amount; to_votes += amount; votes~set_voting_power(from, from_votes); votes~set_voting_power(to, to_votes); return (votes,()); } ​Sending sensitive data on-chain The entire smart contract computation is transparent; confidential runtime values can be retrieved through emulation. ​Vulnerable code CopyAsk AI;; DON'T: Storing password hash or private data cell private_data = begin_cell() .store_slice(\"secret_password_hash\") .store_uint(user_private_key, 256) .end_cell(); ​Account destruction race conditions Destroying accounts using send mode 128 + 32 without proper checks can lead to fund loss in race conditions. ​Vulnerable code CopyAsk AI() recv_internal(msg_value, in_msg_full, in_msg_body) { if (in_msg_body.slice_empty?()) { return (); ;; Dangerous: empty message handling } ;; Process and destroy account send_raw_message(msg, 128 + 32); ;; Destroys account } ​Secure approach CopyAsk AI() recv_internal(msg_value, in_msg_full, in_msg_body) { ;; Proper validation before any destruction throw_unless(error::unauthorized, authorized_sender?(sender)); ;; Ensure no pending operations throw_unless(error::pending_operations, safe_to_destroy?()); ;; Then proceed with destruction if really needed } ​Missing replay protection Replay protection is a security mechanism that prevents an attacker from reusing a previous message. External messages without replay protection can be re-executed multiple times by an attacker which could lead to fund loss or other undesired behavior. ​Secure implementation CopyAsk AI() recv_external(slice in_msg) impure { slice ds = get_data().begin_parse(); int stored_seqno = ds~load_uint(32); int msg_seqno = in_msg~load_uint(32); throw_unless(33, msg_seqno == stored_seqno); ;; Prevent replay accept_message(); ;; Update sequence number set_data(begin_cell().store_uint(stored_seqno + 1, 32).end_cell()); } ​Unconditional accepting of external messages Incoming external messages do not transfer funds. Receiving smart contract must pay for their processing from its balance. Upon receiving an external message, a smart contract can spend some free gas (gas_credit) in order to decide whether it is ready to accept it, and then pay for its further processing. External messages are usually accepted through the ACCEPT TVM instruction, which sets gas_limit to its maximum possible value specified in the network configuration, and sets gas_credit to zero. From this point on, the contract will have to pay for the entire processing of the incoming message. Therefore, if ACCEPT is not guarded by a condition, an attacker might repeatedly send messages, and spend the entire balance of the contract. The SETGASLIMIT instruction can lead to the same issue. ​Vulnerable code CopyAsk AI() recv_external(slice in_msg) { accept_message(); ;; ... } ​Secure implementation Checks before accepting an external message vary by use case. The following example is a part of wallet v3 code, that doesn’t accept a message if it isn’t signed by the wallet’s owner. CopyAsk AI() recv_external(slice in_msg) impure { ;; parse message and contract storage (omitted) throw_unless(33, msg_seqno == stored_seqno); throw_unless(34, subwallet_id == stored_subwallet); throw_unless(35, check_signature(slice_hash(in_msg), signature, public_key)); accept_message(); ;; handle the message (omitted) } ​Invalid throw values Exit codes 0 and 1 indicate normal execution of the compute phase of the transaction. Execution can be unexpectedly aborted by calling a throw directly with exit codes 0 and 1. This can make debugging very difficult since such aborted execution would be indistinguishable from a normal one. ​Gas limitation Be careful with the Out of gas error. It cannot be handled, so try to pre-calculate the gas consumption whenever possible. This will help avoid wasting extra gas, as the transaction will fail anyway. ​Secure implementation CopyAsk AImessage Vote { votes: Int as int32 } contract VoteCounter() { const voteGasUsage = 10000; // precompute with tests receive(msg: Vote) { require(context().value > getComputeFee(self.voteGasUsage, false), \"Not enough gas!\"); // ...subsequent logic... } // Empty receiver for the deployment, // which forwards the remaining value back to the sender receive() { cashback(sender()) } } ​Insecure random numbers Generating truly secure random numbers in TON is challenging. The built-in random functions are pseudo-random and depend on logical time. An attacker can predict the randomized number by brute-forcing the logical time in the current block. ​Secure approach For critical applications, avoid relying solely on on-chain solutions. Use built-in random functions with randomized logical time to enhance security by making predictions harder for attackers without access to a validator node. Note, however, that it is still not entirely foolproof. Consider using the commit-and-disclose scheme: Participants generate random numbers off-chain and send their hashes to the contract. Once all hashes are received, participants disclose their original numbers. Combine the disclosed numbers (e.g., summing them) to produce a secure random value. Don’t use randomization in external message receivers, as it remains vulnerable even with randomized logical time. ​Executing third-party code Executing untrusted code can compromise contract security. ​Prevention CopyAsk AI;; Validate all external code before execution throw_unless(error::untrusted_code, verify_code_signature(code)); throw_unless(error::invalid_code, validate_code_safety(code)); ​Race condition of messages A message cascade can be processed over many blocks. Assume that while one message flow is running, an attacker can initiate a second message flow in parallel. That is, if a property was checked at the beginning, such as whether the user has enough tokens, do not assume that it will still be satisfied at the third stage in the same contract. ​Preventing front-running with signature verification In TON blockchain, all pending messages are publicly visible in the mempool. Front-running can occur when an attacker observes a pending transaction containing a valid signature and quickly submits their own transaction using the same signature before the original transaction is processed. ​Secure approach Include critical parameters like the recipient address (to) within the data that is signed. This ensures that the signature is valid only for the intended operation and recipient, preventing attackers from reusing the signature for their benefit. Also, implement replay protection to prevent the same signed message from being used multiple times. CopyAsk AIstruct RequestBody { to: Address; seqno: Int as uint64; } message(0x988d4037) Request { signature: Slice as bytes64; requestBody: RequestBody; } contract SecureChecker( publicKey: Int as uint256, seqno: Int as uint64, // Add seqno for replay protection ) { receive(request: Request) { // Verify the signature against the reconstructed data hash require(checkSignature(request.requestBody.toCell().hash(), request.signature, self.publicKey), \"Invalid signature!\"); // Check replay protection require(request.requestBody.seqno == self.seqno, \"Invalid seqno\"); // Assuming external message with seqno self.seqno += 1; // Increment seqno after successful processing // Ensure the message is sent to the address specified in the signed data message(MessageParameters { to: request.requestBody.to, // Use the 'to' from the signed request value: 0, mode: SendRemainingBalance, // Caution: sending the whole balance! bounce: false, body: \"Your action payload here\".asComment(), // Example body }); } // Empty receiver for the deployment, // which forwar",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "deployment",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:23:37.865Z"
  },
  {
    "id": "docs-ton-org--contract-dev-gas",
    "title": "Estimate gas usage in TON contracts",
    "url": "https://docs.ton.org/contract-dev/gas",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationContract developmentEstimate gas usage in TON contractsContract developmentEstimate gas usage in TON contractsCopy pageCopy pageContracts which receive a user’s message are referred to as receiver contracts. Other contracts in the same system are called internal contracts. This terminology is local to the current article. Consider a contract system with three contracts: receiver, and internal contracts A and B. In that system the typical trace looks like this (transactions move from left to right): This article covers abstract contracts system, not connected to any existing project. However, it’s primarily applicable to contract systems that use a carry-value pattern. It is important to understand that there is no separate message balance and contract balance. After the message is received, coins from the message are stored to the contract balance, and then the contract is executed. Sending message modes and reserve actions help to properly divide contract balance in the action phase. This diagram of a possible value flow illustrates this. Receiver contracts must verify that the attached Toncoin is sufficient to cover fees for all contracts in the subsequent trace. If an entry contract accepts a user message it must guarantee that the message will not later fail due to insufficient attached TON. “Accept” doesn’t mean the call to accept_message(), but semantic acceptance, i.e., no throw and no asset returns. The reason for this requirement is that reverting the contract system state is usually not possible, because the Toncoin is already spent. When a contract system’s correctness depends on successful execution of the remaining transaction trace, it must guarantee that an incoming message carries enough attached Toncoin to cover all fees. This article describes how to compute those fees. Define variables for limits and initialize them with zero. We will set them to actual values afterwards. Use descriptive names for the operation and the contract. It’s best to store them in a dedicated file with constants. CopyAsk AIconst GasSwapRequest: Int = 0; Run tests covering all execution paths. Missing a path might hide the most expensive one. Extract resource consumption from the send() method’s return value. The sections below describe ways to compute consumption of different kinds of resources. Use expect(extractedValue).toBeLessThanOrEqual(hardcodedConstant) to verify that the hardcoded limit was not exceeded. CopyAsk AIimport {findTransactionRequired} from \"@ton/test-utils\"; const result = await contract.send(/* params */); const vaultTx = findTransactionRequired(result.transactions, { on: contract.address, op: 0x12345678, }); expect( getComputeGasForTx(vaultTx), ).toBeLessThanOrEqual(GasSwapRequest); After the first run, use the displayed error message to find the actual value for the constant. CopyAsk AIexpect(received).toBeLessThanOrEqual(expected) Expected: <= 0n Received: 11578n CopyAsk AIconst GasSwapRequest: Int = 12000; ​Compute fees There are two kinds of values: gas units and Toncoin. The price of contract execution is fixed in gas units. However, the price of the gas itself is determined by the blockchain configuration. Conversion of gas to Toncoin on-chain using currently set blockchain config parameters can be performed with CopyAsk AIlet fee = getComputeFee(hardcodedGasValue, isAccountInMasterchain); This function uses the GETGASFEE TVM opcode. ​Forward fees Forward fee is calculated with this formula: CopyAsk AIfwdFee = lumpPrice + priceForCells * (msgSizeInCells - 1) + priceForBits * (msgSizeInBits - bitsInRoot) where lumpPrice is the fixed value from config paid once for the message. msgSizeInCells is the number of cells in the message. msgSizeInBits is the number of bits in all the cells of the message. In Tolk, cell.calculateSizeStrict() can be used to compute msgSizeInCells and msgSizeInBits. In TVM, it’s implemented as CDATASIZE instruction. In Tolk, the formula above is implemented in calculateForwardFee(). In TVM, it’s implemented as GETFORWARDFEE instruction. CopyAsk AIlet sizeMsg = computeDataSize( msg.toCell(), 8192 ); let fwdFee = getForwardFee( sizeMsg.cells - 1, sizeMsg.bits - msg.toCell().bits(), isAccountInMasterchain ); The computeDataSize() function consumes large, unpredictable amount of gas. If at all it is possible to precompute the size, it is recommended to do so.If required, the function has the second argument: maximum number of cells to visit. Usually it is set to 8192 since it is the limit for message size. It might be used to limit amount of spent gas. In Tolk, both computations can be performed with a call to msg.send() with mode 1024. In TVM, it’s implemented as SENDRAWMSG. It will consume approximately the same amount of gas. ​Optimized forward fee calculation If the size of the outgoing message is bounded by the size of the incoming message, we can estimate the forward fee of an outgoing message to be no larger than the forward fee of the incoming message, that was already computed by TVM. Thus, we don’t have to calculate it again. Note that this estimation is correct only for a contract system in the same workchain, because gas prices depend on the workchain. TolkCopyAsk AIfun onInternalMessage(in: InMessage) { val fwdFee = in.originalForwardFee; // ... } ​Complex forward fee calculation Assume the contract receives a message with an unknown size and forwards it further adding fields with total of a bits and b cells to the message, e.g., StateInit. For this case, in Tolk, there is a function calculateForwardFeeWithoutLumpPrice(). In TVM, it’s implemented as GETFORWARDFEESIMPLE. This function does not take lumpPrice into account. TolkCopyAsk AIfun onInternalMessage(in: InMessage) { val origFwdFee = in.originalForwardFee; // \"Out\" message will consist of fields from // \"in\" message, and some extra fields. // Forward fee for \"out\" message is estimated // from a forward fee for \"in\" message val additionalFwdFee = getSimpleForwardFee( additionalFieldsSize.cells, additionalFieldsSize.bits, isAccountInMasterchain ); val totalFwdFee = origFwdFee + additionalFwdFee; // Remember to multiply totalFwdFee by the number // of hops in the trace } ​Storage fees For calculating storage fees, maximum possible size of the contract in cells and bits should be known. Calculating it manually might be hard, if the contract stores a hashmap or some other complex data structure in its state.It might be easier to compute it by writing a test that will occupy maximum possible size, and use the measured value. There are helper functions for doing these measurements. We cannot predict storage fees that we have to pay for sending messages because it depends on how long the target contract didn’t pay storage fee. Storage fees differ in this way from forward and compute fees, as they should be handled both in receiver and internal contracts. ​Maintain a positive reserve Always keep a minimum balance on all contracts in the system. Storage fees get deducted from this reserve. The reserve get replenished with each user interaction. Do not hardcode Toncoin values for fees. Instead, hardcode the maximum possible contract size in cells and bits. This approach affects code of internal contracts. It is the developer’s decision for how long the storage fees should be reserved. Popular options are 5 and 10 years. CopyAsk AIconst secondsInFiveYears: Int = 5 * 365 * 24 * 60 * 60; receive(msg: Transfer) { let minTonsForStorage: Int = getStorageFee( maxCells, maxBits, secondsInFiveYears, isAccountInMasterchain ); nativeReserve( max(oldBalance, minTonsForStorage), ReserveAtMost ); // Process operation with remaining value... } // Also this contract probably will require some code, that will allow owner to withdraw TONs from this contract. In this approach, a receiver contract should calculate maximum possible storage fees for all contracts in trace. CopyAsk AIconst secondsInFiveYears: Int = 5 * 365 * 24 * 60 * 60; receive(msg: UserIn) { // Suppose trace will be // receiver -> A -> B let storageForA = getStorageFee( maxCellsInA, maxBitsInA, secondsInFiveYears, isAccountInMasterchain ); let storageForB = getStorageFee( maxCellsInB, maxBitsInB, secondsInFiveYears, isAccountInMasterchain ); let totalStorageFees = storageForA + storageForB; // compute compute + forward fees here let otherFees = 0; require( messageValue() >= totalStorageFees + otherFees, \"Not enough TONs\" ); } Verify the hardcoded contract size in tests. ​Cover storage on demand The order of phases depends on the bounce flag of an incoming message. If all messages in the protocol are unbounceable, then the storage phase comes after the credit phase. So, the contract’s storage fees are deducted from the joint balance of the contract and incoming message. In this case the pattern where the contract’s ",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:23:40.017Z"
  },
  {
    "id": "docs-ton-org--contract-dev-on-chain-jetton-processing",
    "title": "On-chain Jetton processing",
    "url": "https://docs.ton.org/contract-dev/on-chain-jetton-processing",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationContract developmentOn-chain Jetton processingContract developmentOn-chain Jetton processingCopy pageCopy pageRead this article after understanding the Jetton architecture. Contracts routinely process jettons for DEX, escrow, and lending protocols. Each contract must determine which jetton type arrived when a JettonNotify message shows up. ​Known Jetton or trusted deployer When someone does a Jetton transfer, they deploy a new JettonWallet, that has an address depending on the address of JettonMinter and the address of the receiver, and then send a message with a type JettonNotify to the regular wallet (or other kind of contract) that tells the transfer succeeded. The attacker might send a JettonNotify message from a contract that is not a valid JettonWallet, so handling it requires care. To handle the JettonNotify message, it’s preferable to precompute the address of the JettonWallet for a specific minter (i.e. Jetton type) in advance, so that the validation only consists of checking two addresses for equality. Here is an example of a contract that handles JettonNotify messages. It’s deployed along with a SetTrustedJettonWallet message with an address of JettonWallet that is owned by this same contract. When deploying with this pattern, calculate the Jetton wallet address that must receive top-ups. It is impossible to hardcode the jetton wallet address in the contract’s StateInit, because the wallet address depends on the contract address and creates a circular dependency. To handle several Jetton types with a single contract, trustedJettonWallet should be modified to store several addresses. The jettonMinter address is included in Storage, because otherwise every instance of this contract owned by the same owner will deploy to the same address, even if there was an intent to have them with different trustedJettonWallets. This approach is used by Bidask. CopyAsk AItolk 1.2; struct Storage { owner: address; trustedJettonWallet: address?; jettonMinter: address; } fun Storage.load(): Storage { return Storage.fromCell(contract.getData()); } fun Storage.save(self) { return contract.setData(self.toCell()) } struct (0x7362d09c) JettonNotify { queryId: uint64 jettonAmount: coins transferInitiator: address jettonVaultPayload: RemainingBitsAndRefs } struct (0x12345678) SetTrustedJettonWallet { trustedJettonWallet: address } type AllowedMessage = JettonNotify | SetTrustedJettonWallet; fun onInternalMessage(in: InMessage) { val msg = lazy AllowedMessage.fromSlice(in.body); match (msg) { SetTrustedJettonWallet => { var storage = Storage.load(); if (storage.owner != in.senderAddress || storage.trustedJettonWallet != null) { return; } storage.trustedJettonWallet = msg.trustedJettonWallet; storage.save(); }, JettonNotify => { var storage = Storage.load(); if (storage.trustedJettonWallet == null || storage.trustedJettonWallet != in.senderAddress) { return; } // Process jettons } } } See all 50 lines ​Unknown TEP-89 Jetton or untrusted deployer In the previous example, addresses of jettonMinter and trustedJettonWallet are chosen off-chain by a deploying party. Someone who depends on this contract has to trust that the wallet belongs to this minter, which is not a problem, for example, for an exchange. If deployer might be monetarily interested to break this invariant, the previous approach is not suitable, and the address of the trustedJettonWallet address must be computed on-chain. Most modern Jettons implement TEP-89, that defines a message provide_wallet_address that requests a Jetton wallet address for an arbitrary owner, and take_wallet_address message with a response. The contract works similarly to the example above, except it’s deployed along with a InitContract message, that asks a JettonMinter what jettonWalletAddress should be. This approach is used by DeDust. The contract that initializes the jetton wallet with this pattern can look like this: CopyAsk AItolk 1.2 struct Storage { jettonMinterAddress: address jettonWalletAddress: address? } fun Storage.load(): Storage { return Storage.fromCell(contract.getData()); } fun Storage.save(self) { return contract.setData(self.toCell()) } struct (0x2c76b973) ProvideWalletAddress { queryId: uint64 ownerAddress: address includeAddress: bool } struct (0xd1735400) TakeWalletAddress { queryId: uint64 walletAddress: address ownerAddress: Cell<address>? } struct (0x7362d09c) JettonNotify { queryId: uint64 jettonAmount: coins transferInitiator: address jettonVaultPayload: RemainingBitsAndRefs } // Unlike other opcodes here, this can be set arbitrarily struct (0x12345678) InitContract {} type AllowedMessage = InitContract | TakeWalletAddress | JettonNotify fun onInternalMessage(in: InMessage) { val msg = lazy AllowedMessage.fromSlice(in.body); match (msg) { InitContract => { var storage = Storage.load(); val msg = createMessage({ bounce: true, value: 0, dest: storage.jettonMinterAddress, body: ProvideWalletAddress { queryId: 0, ownerAddress: contract.getAddress(), includeAddress: false, }, }); msg.send(SEND_MODE_CARRY_ALL_REMAINING_MESSAGE_VALUE); } TakeWalletAddress => { var storage = Storage.load(); if (storage.jettonMinterAddress != in.senderAddress) { return; } storage.jettonWalletAddress = msg.walletAddress; storage.save(); // After receiving such message contract is initialized } JettonNotify => { var storage = Storage.load(); if (storage.jettonWalletAddress == null || storage.jettonWalletAddress != in.senderAddress) { return; } // Process jettons } } } See all 75 lines ​Unknown TEP-74 Jetton and untrusted deployer Jettons that do not have TEP-89 methods for computing a wallet address on-chain are rare. TONCO DEX rejects them, while platforms such as DeDust allow them after a manual approval flow. There are two approaches, both using get-method emulation. ​Running get-method on-chain Given a Jetton minter state, we can emulate execution of the minter on-chain via RUNVM instruction. During the emulation, it calls the get_wallet_address get-method to derive the wallet address for any owner. This helper uses Fift, because it’s impossible to assign a type to c7. CopyAsk AIfun calculateJettonWallet(owner: address, jettonData: cell, jettonCode: cell, jettonMinter: address): address asm \"\"\" c7 PUSHCTR // Unpack environment information from c7 // https://docs.ton.org/tvm/registers#c7-%E2%80%94-environment-information-and-global-variables 0 INDEX SWAP 8 SETINDEX SWAP DUP ROTREV 10 SETINDEX // Make it singleton 1 TUPLE // owner md mc c7 ROTREV CTOS // owner_addr c7 md mc\" 2 PUSHINT // owner_addr c7 md mc args\" 103289 PUSHINT // owner_addr c7 md mc args get_jwa_method_id\" 5 0 REVERSE // owner_addr get_jwa_method_id args mc md c7\" // Moves the top stack value (ONE) to the third position: [A, B, C] -> [B, C, A]. We expect only 1 return value. Flag +256 for runvm enables this argument ONE 2 -ROLL // We use only these modes: // +1 = same_c3 (set c3 to code) // +4 = load c4 (persistent data) from stack and return its final value // +16 = load c7 (smart-contract context) // +256 = pop number N, return exactly N values from stack (only if res=0 or 1; if not enough then res=stk_und) // Mode 256 is crucial, because it ignores all stack values except the first one, and protects us from stack poisoning 277 RUNVM // address exit_code c4'\" 2 BLKDROP // address\"; \"\"\" See all 31 lines ​Approach 1: non-vanity addresses If the JettonMinter was not deployed with a vanity contract, address and StateInit match. The logic for the contract that handles JettonNotify messages is thus get the StateInit of JettonMinter off-chain; deploy the contract with the address of JettonMinter in its data; send a message to the contract with the StateInit of JettonMinter; contract validates that this StateInit matches the address of the JettonMinter; contract runs calculateJettonWallet owner - address of the contract (contract.getAddress()); jettonData, jettonCode - StateInit of JettonMinter; jettonMinter - address of JettonMinter. ​Approach 2: where the previous method fails If the JettonMinter was deployed with a vanity contract, or otherwise lacks get_wallet_address method, or get_wallet_address returns incorrect addresses, we have to use the current state of the contract instead. To prove that the state is currently at the Jetton minter address, a full state proof is required.Was this page helpful?YesNoSuggest editsRaise issuePreviousUsing on-chain librariesNext⌘IgithubxtelegramPowered by MintlifyOn this pageKnown Jetton or trusted deployerUnknown TEP-89 Jetton or untrusted deployerUnknown TEP-74 Jetton and untrusted deployerRunning get-method on-chainApproach 1: non-vanity addressesApproach 2: where the previous method fails",
    "category": "tokens",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:23:41.730Z"
  },
  {
    "id": "docs-ton-org--contract-dev-using-on-chain-libraries",
    "title": "Using on-chain libraries",
    "url": "https://docs.ton.org/contract-dev/using-on-chain-libraries",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationContract developmentUsing on-chain librariesContract developmentUsing on-chain librariesCopy pageCopy pageIt is recommended to read Library cells first. You should always monitor the balance of the account that hosts the library. It should be sufficient for at least 10 years. ​Fee savings Library cells help reduce fees in two main ways. Forwarding fees. For example, in jettons, the StateInit must be forwarded with each transfer, resulting in high forwarding fees. Moving the code into a library cell significantly reduces these fees. Storage costs. Because a library must be hosted in the Masterchain, where storage is approximately 1,000 times more expensive than in the Basechain, hosting a copy of the code in the Basechain may be cheaper if there are fewer than 1,000 instances of the contract. The 1,000 factor is not constant and is subject to change. Consult blockchain config parameter 18 for the latest value. However, due to the savings on forwarding fees, you should calculate whether this approach is cost-effective for your specific use case. Everything in TON is stored in cells, even the account code. One of the most common use cases for libraries is to store code shared by multiple contracts. When a library cell is part of an account’s code, it is automatically dereferenced on first access. This allows you to replace part of the contract code—or even the entire code—with a library cell. Replacing the entire code with a library cell is widely used in TON smart contracts. Some common examples: USDT (and other popular jettons) Jetton wallet contracts The Order contract in Multisig v2 NFT item contracts in popular collections You can check if a contract is using a library as its code by looking into its code cell in an explorer. Fragment of USDT jetton-wallet accountCopyAsk AI... code:(just value:(raw@^Cell x{} SPECIAL x{028F452D7A4DFD74066B682365177259ED05734435BE76B5FD4BD5D8AF2B7C3D68} )) ... While it is not crucial to understand the exact representation shown on the TON Explorer (more about explorers), the key point is that there is only one cell in the contract code, tagged as SPECIAL, indicating it is an exotic cell. Following this is the hexadecimal representation of the library cell’s internals. The first byte equals 2, indicating that it is a library cell, and the remaining bytes contain the hash of the referenced cell. Here you can see that the entire contract code consists of the 8-bit tag equal to 2 and a 256-bit representation hash of the referenced cell. If you don’t want to put the entire code in a library cell, you can make only part of it a library cell. For example, if the same function is used in multiple different contracts, it makes sense to turn it into a library. However, you will likely need to set up the build process for such code yourself. ​Using @ton/core You can construct a library cell entirely in TypeScript using the @ton/core library. Here’s how to do it in a Blueprint project: CopyAsk AIimport { Cell, beginCell } from '@ton/core'; const libPrep = beginCell().storeUint(2, 8).storeBuffer(jwalletCodeRaw.hash()).endCell(); const jwalletCode = new Cell({ exotic: true, bits: libPrep.bits, refs: libPrep.refs }); View source ​Publishing an ordinary cell in the Masterchain library context The following example was taken from multisig v2 repository. CopyAsk AI;; Simple library keeper #include \"../imports/stdlib.fc\"; #include \"../messages.func\"; const int DEFAULT_DURATION = 3600 * 24 * 365 * 10; ;; 10 years, can top-up in any time const int ONE_TON = 1000000000; ;; https://docs.ton.org/tvm.pdf, page 138, SETLIBCODE () set_lib_code(cell code, int mode) impure asm \"SETLIBCODE\"; cell empty_cell() asm \"<b b> PUSHREF\"; () recv_internal(int msg_value, cell in_msg_full, slice in_msg_body) impure { slice in_msg_full_slice = in_msg_full.begin_parse(); int msg_flags = in_msg_full_slice~load_msg_flags(); slice sender_address = in_msg_full_slice~load_msg_addr(); cell lib_to_publish = get_data(); int initial_gas = gas_consumed(); (int order_cells, int order_bits, _) = compute_data_size(lib_to_publish, 1000); ;; according network config, max cells in library = 1000 int size_counting_gas = gas_consumed() - initial_gas; int to_reserve = get_simple_compute_fee(MASTERCHAIN, size_counting_gas) + get_storage_fee(MASTERCHAIN, DEFAULT_DURATION, order_bits, order_cells); raw_reserve(to_reserve, RESERVE_BOUNCE_ON_ACTION_FAIL); send_message_with_only_body(sender_address, 0, begin_cell(), NON_BOUNCEABLE, SEND_MODE_CARRY_ALL_BALANCE); ;; https://docs.ton.org/tvm.pdf, page 138, SETLIBCODE set_lib_code(lib_to_publish, 2); ;; if x = 2, the library is added as a public library (and becomes available to all smart contracts if the current smart contract resides in the masterchain); ;; brick contract set_code(empty_cell()); set_data(empty_cell()); } The main benefit of using this contract to publish library cells is that it requires you to provide sufficient TON for at least 10 years of storage. This prevents a common problem where, after a short time, the library freezes and becomes inaccessible, which can lead to unexpected scenarios. The core of this contract is the line: set_lib_code(lib_to_publish, 2);. This function call publishes an ordinary cell with the flag set to 2, which indicates that the library is public and can be used by anyone. Note that this contract becomes bricked after the cell is published, so no further operations on this contract can be performed. ​Testing in Blueprint When testing smart contracts locally, there are two ways to register libraries in your blockchain environment. ​Option 1: Automatic Library Deployment Enable automatic library detection by passing the autoDeployLibs flag when creating the blockchain: CopyAsk AIconst blockchain = await Blockchain.create({ autoDeployLibs: true }); In your contract, deployed in Masterchain, deploy the library using the librarian example above. This allows the contract to dynamically install and register the library at runtime, with the environment automatically tracking and using it as needed. ​Option 2: Manual Library Deployment If autoDeployLibs is not enabled, you’ll need to register libraries manually: CopyAsk AIconst blockchain = await Blockchain.create(); const code = await compile('Contract'); // Create a dictionary of library hash → library cell const libsDict = Dictionary.empty(Dictionary.Keys.Buffer(32), Dictionary.Values.Cell()); libsDict.set(code.hash(), code); // Manually assign the libraries blockchain.libs = beginCell().storeDictDirect(libsDict).endCell(); This gives you full control but requires explicitly managing which libraries are available during testing. An example implementation can be found here. ​Get methods for library-cell-based contracts When working with a Jetton wallet where the code is stored in a library cell, you may need to check its balance. To do so, you must execute a get method in the code. If you call methods using one of HTTP APIs or LiteServer, the library cell will be automatically resolved and the method will be executed. Alternatively, take the account state to your local system and execute methods there. In that case, you will need to pull the account state and resolve all library reference cells (in most cases, if the contract is using libraries, the whole code of the contract is a library reference). To resolve a library, the only thing you need is to call getLibraries method ​Retrieving a library cell with LiteServer To retrieve library cells from LiteServer, use the liteServer.getLibraries method. CopyAsk AIimport { LiteClient, LiteRoundRobinEngine, LiteSingleEngine } from \"ton-lite-client\"; import { Cell } from \"@ton/core\"; import { z } from \"zod\"; function intToIP(int: number): string { const buf = Buffer.alloc(4); buf.writeUInt32BE(int >>> 0, 0); return Array.from(buf).join(\".\"); } const Server = z.object({ ip: z.number(), port: z.number(), id: z.object({ key: z.string() }), }); const Response = z.object({ liteservers: z.array(Server), }); // testnet https://ton.org/testnet-global.config.json // mainnet https://ton.org/global.config.json const configEndpoint = \"https://ton.org/global.config.json\"; async function getServers() { const data = Response.parse(await (await fetch(configEndpoint)).json()); return data.liteservers.map((server) => { return new LiteSingleEngine({ host: `tcp://${intToIP(server.ip)}:${server.port}`, publicKey: Buffer.from(server.id.key, 'base64'), }); }); } async function getLibraryByHash(hash: Buffer) { const engine = new LiteRoundRobinEngine(await getServers()); const client = new LiteClient({ engine }); const libs = await client.getLibraries([hash]); const lib = libs.result[0]; if (!lib || libs.result.length !== 1) { throw new Error(\"Library not found\"); } const roots = Cell.fromBoc(lib.data); const root = roots[0]; if (!root |",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "testnet",
      "mainnet",
      "transaction",
      "deployment",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:23:43.114Z"
  },
  {
    "id": "docs-ton-org--contract-dev-random",
    "title": "Random number generation",
    "url": "https://docs.ton.org/contract-dev/random",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationContract developmentRandom number generationContract developmentRandom number generationCopy pageCopy pageGenerating random numbers is a common task in smart contracts for applications such as gaming, NFT trait generation, and decentralized lotteries. TON provides built-in functions like random(), but their results can be predicted by validators unless additional techniques are used. Single-block randomness (such as randomize_lt()) is not secure against validators who can influence or predict values. For stronger guarantees, use multi-phase schemes such as commit-reveal. ​Why on-chain randomness is challenging Computers cannot generate truly random information because they strictly follow instructions. Instead, pseudorandom number generators (PRNGs) rely on a seed value to produce a sequence of pseudorandom numbers. Running the same program with the same seed will always produce identical results. In TON, the seed varies for each block and is generated by validators. While this prevents regular users from predicting random values before block production, validators themselves can influence randomness in two ways: Generating different seeds when creating blocks Choosing which blocks to include external messages in This fundamental limitation means all approaches to on-chain randomness involve trade-offs between speed, security, and decentralization guarantees. ​Approach 1: Single-block randomness with randomize\\_lt() ​Mechanism The randomize_lt() function mixes the transaction’s logical time into the random seed before generating random numbers. This provides basic entropy from blockchain state. ​How it works Call randomize_lt() once before using random() or rand() functions. The logical time adds variability to the seed, making it harder for observers to predict the outcome without executing the transaction. CopyAsk AIrandomize_lt(); // Generates values from 0 to 99 int random_number = rand(100); ​Security model ✅ Safe against regular users who cannot predict logical time ⚠️ Vulnerable to colluding validators who can generate seeds or choose message inclusion blocks ​Speed Fast (single-block operation) ​Use cases Non-critical applications (gaming, cosmetic features) NFT trait randomization Scenarios where validator trust is assumed Validators can predict single-block randomness. Do not use it for high-value applications such as financial lotteries or significant asset distribution. ​Approach 2: Block skipping ​Mechanism Instead of using randomness from the current block, the contract waits for several blocks to pass before using their entropy. This approach sends messages across multiple blocks, making it harder for a single validator to control the final outcome. ​How it works The contract initiates an operation, then waits for responses that arrive several blocks later. The random seed from future blocks—which the initiating validator does not control—determines the result. ​Security model ✅ Resistant to regular users ✅ More resistant to single validators than randomize_lt() ⚠️ Still vulnerable to determined validators who can coordinate timing across multiple blocks they generate ​Speed Slow (requires multiple blocks to finalize) ​Use cases Medium-stakes applications Lottery systems with moderate value Scenarios requiring better security than single-block randomness While block skipping improves security over single-block randomness, it only delays the threat. A validator representing 1/250 of the network can still choose optimal timing to influence outcomes in blocks they generate. ​Approach 3: Commit-reveal scheme ​Mechanism Participants commit to secret values by publishing hashes, then reveal those values in a later phase. The final randomness is derived from combining all revealed values, ensuring no single party can determine the outcome alone. When properly implemented, this approach provides cryptographically secure randomness suitable for high-value applications. ​How it works Commit phase: Each participant generates a random number off-chain and submits its hash to the contract. Reveal phase: After all commitments are received, participants disclose their original numbers. Combination: The contract combines the revealed numbers (e.g., by XOR or sum) to produce the final random value. ​Security model ✅ Cryptographically secure when properly implemented ✅ Resistant to both user and validator manipulation; no single party can predict or influence the outcome ⚠️ Requires incentives and penalties to prevent participants from refusing to reveal ⚠️ Validators can influence timing or censor messages, but cannot determine the random value ​Speed Very slow (multi-phase, multi-block process) ​Implementation requirements On-chain verification of commitments Penalty mechanisms for non-reveals or invalid reveals Timeout handling for missing participants ​Use cases High-value applications (significant lotteries, auctions) Decentralized gaming with financial stakes Systems requiring Byzantine fault tolerance Commit-reveal schemes require careful incentive design. Participants may refuse to reveal if the outcome is unfavorable. Use penalties or collateral to enforce honest behavior. ​Comparison of approaches Factorrandomize_lt()Block skippingCommit-revealSpeedFastSlowVery slowImplementation complexityLowMediumHighResistance to user manipulationHighHighCryptographically secureResistance to validator manipulationLowMediumHigh (validators cannot predict)Cost (gas + storage)LowMediumHighSuitable for high-value applications❌ No⚠️ Use with caution✅ Yes (recommended for critical use) When choosing an approach, consider the value at risk and required time-to-finality. For high-stakes applications such as lotteries with significant funds, use commit-reveal. Audit implementations through formal verification when possible. ​Best practices Avoid standalone random() calls. Validators controlling the block seed can predict the output. Keep randomness out of external message receivers. External messages remain vulnerable even with randomize_lt(). Use hybrid or off-chain entropy for critical applications. Combine on-chain randomness with off-chain entropy or external randomness oracles when significant value is at risk. Test randomness behavior across different blocks. Verify that the contract behaves correctly when randomness is manipulated within validator capabilities. ​How block random seeds work Understanding the underlying mechanism helps evaluate security trade-offs. ​Seed generation by validators Each block’s random seed is generated by the validator (or collator) creating that block. The validator node code generates 32 random bytes using cryptographically secure primitives: CopyAsk AIprng::rand_gen().strong_rand_bytes(rand_seed->data(), 32); A single validator generates this seed when creating a block, giving them control over the seed value. This is why single-block randomness is vulnerable to validator manipulation. ​Per-contract randomization The block seed is not used directly in contracts. Instead, it is hashed with the contract address to produce a per-contract seed: CopyAsk AIcontract_seed = SHA256(block_seed || contract_address) This ensures different contracts in the same block receive different random seeds, preventing cross-contract randomness correlation. ​Random number generation The RANDU256 TVM instruction implements the actual random number generation. When called: Take the current seed r (32 bytes) Compute SHA512(r) Use the first 32 bytes as the new seed Return the remaining 32 bytes as the random number Subsequent calls continue this chain, producing a deterministic sequence from the initial seed. Because the random sequence is deterministic once the initial seed is known, anyone who knows both the block seed and contract address can predict all random values generated during a transaction. Regular users cannot predict these values before block production, but validators generating the block can, since they control the block seed.Was this page helpful?YesNoSuggest editsRaise issuePreviousUpgrading contractsNext⌘IgithubxtelegramPowered by MintlifyOn this pageWhy on-chain randomness is challengingApproach 1: Single-block randomness with randomize\\_lt()MechanismHow it worksSecurity modelSpeedUse casesApproach 2: Block skippingMechanismHow it worksSecurity modelSpeedUse casesApproach 3: Commit-reveal schemeMechanismHow it worksSecurity modelSpeedImplementation requirementsUse casesComparison of approachesBest practicesHow block random seeds workSeed generation by validatorsPer-contract randomizationRandom number generation",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:23:45.330Z"
  },
  {
    "id": "docs-ton-org--contract-dev-upgrades",
    "title": "Upgrading contracts",
    "url": "https://docs.ton.org/contract-dev/upgrades",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationContract developmentUpgrading contractsContract developmentUpgrading contractsCopy pageCopy pageThe address of a contract is determined by its initial code and state. A contract can upgrade its code while preserving its address. This is useful for fixing bugs, adding features, or adapting to protocol changes without migrating to a new address. Upgrades are critical when other contracts reference the contract being upgraded. For example, NFT items reference their collection contract. The collection admin cannot modify these references stored in existing NFT items. Without upgrades, fixing bugs or adding features would require deploying a new collection and migrating all items—an expensive and complex process. Upgrades solve this by allowing the collection contract to evolve in place while preserving all existing references. The pattern is also essential for vanity contracts and protocols such as distributed exchange (DEX) where preserving the contract address is critical. ​How upgrades work Tolk provides two functions for upgrades. contract.setCodePostponed(code: cell) — schedules the code to be replaced during the action phase. The new code takes effect after the current transaction completes. contract.setData(data: cell) — immediately replaces the contract’s persistent storage. This happens during the compute phase, before the transaction ends. Key difference: setCodePostponed() applies changes after the current transaction, while setData() applies changes immediately. This means the new code won’t run until the next message arrives, but the new data is already active. Funds at riskContract upgrades change code behavior and can affect funds or contract state. Unauthorized upgrades can cause loss of control or funds. Restrict upgrade messages to trusted admin addresses only. EthicsUse delayed upgrades to allow users to react to compromised admin keys or unwanted updates. ​Basic upgrade pattern The contract accepts upgrade messages containing new code and data. Only the admin can trigger upgrades. ​How it works Admin sends upgrade message. The message contains new code, data, or both. Contract verifies sender. Checks that the sender is the admin address. Code is scheduled. If new code is provided, setCodePostponed() schedules it for replacement. Data is upgraded. If new data is provided, setData() immediately replaces the storage. Transaction completes. The action phase executes, applying the new code. Next message uses new code. Subsequent messages execute with the upgraded logic. The upgrade happens immediately in a single transaction. The new code becomes active after the transaction completes. Any data replacement happens during the compute phase, so the new data is immediately available when the transaction ends. If there’s not enough Toncoin to execute action phase with the code update, but enough to execute compute phase with data update, the contract state changes will be reverted. Make sure to thoroughly test the upgrade script for possible gas issues, and provide enough Toncoin to execute the upgrade transaction completely. ​Example TolkCopyAsk AIstruct (0x1111) UpgradeContract { data: cell? code: cell? } type AllowedMessages = UpgradeContract fun onInternalMessage(in: InMessage) { val msg = lazy AllowedMessages.fromSlice(in.body); match (msg) { UpgradeContract => { var storage = lazy Storage.load(); assert (in.senderAddress == storage.adminAddress) throw 1111; if (msg.code != null) { contract.setCodePostponed(msg.code!); } if (msg.data != null) { contract.setData(msg.data!); } } else => { // just accept TON } } } struct Storage { adminAddress: address } fun Storage.load() { return Storage.fromCell(contract.getData()); } fun Storage.save(self) { contract.setData(self.toCell()); } See all 42 lines ​Delayed upgrades for production safety When upgrading protocols that are already running and have users, delayed upgrades are a best practice. This provides additional security layers: if an admin is compromised, there is time to react. Users can also see the upgrade and withdraw funds from the protocol if it has been compromised. The pattern adds a time delay between requesting and approving an upgrade. The admin must first request an upgrade, wait for a timeout period, then approve it. ​How it works Admin requests upgrade. Sends RequestUpgrade message with new code and data Contract verifies and stores. Validates admin, ensures no pending request, stores upgrade details with timestamp Timeout period. The contract enforces a waiting period before approval Admin approves upgrade. Sends ApproveUpgrade message after timeout expires Contract verifies timeout. Checks that enough time has passed since the request Upgrade applies. Schedules new code with setCodePostponed() and upgrades data with setData() Request cleared. Removes the pending request from storage The admin can also send RejectUpgrade at any time to cancel a pending upgrade. This three-message flow (request → wait → approve or reject) gives users time to review changes and react if the admin account is compromised. ​Example TolkCopyAsk AIstruct UpgradeContract { data: cell? code: cell? } struct CurrentRequest { newUpgrade: UpgradeContract timestamp: uint32 } struct (0x00000001) RequestUpgrade { newUpgrade: UpgradeContract } struct (0x00000002) RejectUpgrade { } struct (0x00000003) ApproveUpgrade { } type AllowedMessages = | RequestUpgrade | RejectUpgrade | ApproveUpgrade fun onInternalMessage(in: InMessage) { val msg = lazy AllowedMessages.fromSlice(in.body); match (msg) { RequestUpgrade => { var storage = lazy Storage.load(); assert (in.senderAddress == storage.adminAddress) throw 100; assert (storage.CurrentRequest == null) throw 101; storage.CurrentRequest = { newUpgrade: msg.newUpgrade, timestamp: blockchain.now() }; storage.save(); } RejectUpgrade => { var storage = lazy Storage.load(); assert (in.senderAddress == storage.adminAddress) throw 100; assert (storage.CurrentRequest != null) throw 201; storage.CurrentRequest = null; storage.save(); } ApproveUpgrade => { var storage = lazy Storage.load(); assert (in.senderAddress == storage.adminAddress) throw 100; assert (storage.CurrentRequest != null) throw 301; assert (storage.CurrentRequest!.timestamp + storage.timeout < blockchain.now()) throw 302; if (storage.CurrentRequest!.newUpgrade.code != null) { contract.setCodePostponed(storage.CurrentRequest!.newUpgrade.code!); } if (storage.CurrentRequest!.newUpgrade.data != null) { contract.setData(storage.CurrentRequest!.newUpgrade.data!); } else { storage.CurrentRequest = null; storage.save(); } } else => { // just accepted tons } } } get fun currentRequest() { var storage = lazy Storage.load(); return storage.CurrentRequest; } struct Storage { adminAddress: address, timeout: uint32, CurrentRequest: CurrentRequest? } fun Storage.load() { return Storage.fromCell(contract.getData()); } fun Storage.save(self) { contract.setData(self.toCell()); } See all 97 lines ​Hot upgrades for frequently upgraded contracts Standard upgrade methods fail when a contract receives frequent updates. For example, DEX pools that update prices every second or lending protocols that continuously adjust interest rates. The problem: it is not possible to predict what data will be in storage when the upgrade transaction executes. When an upgrade message with new code and data is sent, other transactions may execute before the upgrade arrives. By the time the upgrade applies, the prepared data may be stale. For a DEX pool, this can overwrite current price data with outdated values, breaking the protocol. Hot upgrades solve this by scheduling a code change and immediately calling a migration function with the new code. The migration function runs in the same transaction that applies the upgrade. It reads the old storage structure, transforms it to match the new schema, and writes the upgraded storage. This preserves all state changes that happened between preparing the upgrade and executing it. ​How it works Admin sends upgrade message. The message contains new code cell and optional additional data Contract verifies sender. Checks that the sender is the admin address Schedule code change. setCodePostponed() schedules the code replacement Switch to new code. setTvmRegisterC3() immediately activates the new code in register C3 Call migration. Invoke hotUpgradeData() which now runs with the new code Migration executes. The function reads old storage, transforms it, and writes new storage The key mechanism: setTvmRegisterC3() switches the code register so the migration function executes with the new code in the same transaction. The migration reads the current storage state (preserving all updates), transforms it to the new schema, and saves it. When the transaction completes, the new code becomes permanent through setCodePostpone",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "testnet",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "react",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:23:48.456Z"
  },
  {
    "id": "docs-ton-org--contract-dev-vanity",
    "title": "How to use a vanity contract",
    "url": "https://docs.ton.org/contract-dev/vanity",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationContract developmentHow to use a vanity contractContract developmentHow to use a vanity contractCopy pageCopy pageA vanity contract allows customization of the address of a smart contract being deployed. It does this by making its own StateInit depend on constant data that is randomly generated many times until a desired address is found. It is often used to deploy contracts with a specific prefix or suffix so the address is visible in block explorers. The contract code and data are included in the vanity deploy message. The vanity contract is first deployed with a StateInit that produces the desired address (see Addresses overview), and then immediately sets its actual state from the payload. This is a special case of upgrading contract’s code. ​Prerequisites OpenCL-capable GPU Python 3 pyopencl Blueprint ​How it works The vanity contract code: CopyAsk AI(int) slice_equal(slice s1, slice s2) asm \"SDEQ\"; () recv_internal(cell in_msg_cell, slice in_msg) impure { ;; Parse data var ds = get_data().begin_parse(); ds~skip_bits(5); ;; Padding var owner = ds~load_msg_addr(); ds~skip_bits(256); ds.end_parse(); ;; Parse message var cs = in_msg_cell.begin_parse(); var flags = cs~load_uint(4); ;; int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool slice sender = cs~load_msg_addr(); ;; Allow deployment only to the owner throw_unless(8, slice_equal(sender, owner)); ;; Set code and data var code = in_msg~load_ref(); var data = in_msg~load_ref(); in_msg.end_parse(); set_code(code); set_data(data); } See all 26 lines It checks whether the message comes from the owner specified in the data, then replaces its code and data with the ones provided in the incoming message. The owner field is required, because someone might intercept an external message, find salt in it, and concurrently deploy their own contract with this salt. Because a value of the owner field changes the address in an unpredictable way, an intercepted salt will be useless, unless attacker can send the message from the same owner address. The 256-bit salt is stored in this contract’s StateInit in addition to five padding bits and the owner address. The salt is not used by the contract’s logic (it is skipped with ds~skip_bits(256);); it only influences the resulting address via the StateInit hash. Because a contract address is derived from the StateInit hash, changing the salt changes the address deterministically. The search for a suitable salt happens entirely off-chain: a Python script (with an OpenCL kernel for speed) generates many random salt values, computes the resulting address, and reports matches. The on-chain vanity contract does not brute-force salts; it only verifies the owner and then sets the provided code and data when deployed. ​Generate salt To generate the salt, copy the code from src/generator in the same repository. It includes the run.py script and the vanity.cl OpenCL kernel. Run the command with the desired search parameters, including -w for the workchain and the owner address allowed to perform the deployment. The example below searches on the basechain for the specified suffix. CopyAsk AIpython3 run.py -w 0 --end '<SUFFIX>' --case-sensitive <OWNER_ADDR> Where: <SUFFIX> — desired address suffix; case sensitive when --case-sensitive is set. <OWNER_ADDR> — address allowed to deploy via the vanity contract. After running, the script prints logs and starts the search, printing every found salt. It also writes found salts to the found.txt file. The search continues until it is stopped or exits after the first match when --only-one is set. Example output: CopyAsk AISearching wallets case-sensitive, with \"TEST\" in the end Owner: UQCSQnz9h3iilIHMueOPs8RaryGqzb-bJpReZuZAUsm6TDRo Flags: 1100 Kernel conditions: result[44] == 'T' && result[45] == 'E' && result[46] == 'S' && result[47] == 'T' Using device: Apple M2 Max Speed: 198 Mh/s, miss: 4, found: 0 Speed: 204 Mh/s, miss: 2, found: 0 Found: EQBas7IlwGKmd6CT7_l0PLynkUv2fmrANn2FFgcMntBATEST salt: 1045adb4ffb9af72021354a07a6f3e64ebc9822775f80b7d98beb195f57093df Speed: 207 Mh/s, miss: 1, found: 1 Speed: 206 Mh/s, miss: 4, found: 1 Found: EQB1p467NtIyNpwVAF0qZYDCaXzA56mk8P6nqt6QJFeQTEST salt: fa683a39082696af7bafecaa63f6172b615f5b7d89fea24c941d52aa3310bbc3 Speed: 208 Mh/s, miss: 0, found: 2 Speed: 205 Mh/s, miss: 2, found: 2 Speed: 208 Mh/s, miss: 2, found: 2 Found: EQBXaec9-r5Ge65hXTQopw7akH6LQr4rms9DdzkhxcUiTEST salt: e7336b387099b3f8a31fa114ff801b799f14f3fe7f6c27c6cf0ccbb542ab743d Speed: 206 Mh/s, miss: 2, found: 3 Speed: 203 Mh/s, miss: 2, found: 3 Speed: 203 Mh/s, miss: 3, found: 3 The more specific the search, the rarer the matches, and the more compute is required to find one. A 4-character match typically appears in a few seconds on a laptop. TON user-friendly addresses are Base64, so each character encodes 6 bits; four characters correspond to 24 bits, i.e., about 1 in 224 trials on average. Once a salt is found, it can be used to deploy an arbitrary smart contract at that address. ​Deploy the contract Deploy of the vanity contract and the message that replaces its code and data usually come in a single message: CopyAsk AIinit: code: vanity contract code data: owner: owner's address salt: generated salt body: code: new contract's code data: new contract's data This example uses Blueprint to create and send this message. Define a vanity contract wrapper at wrappers/VanityContract.ts: CopyAsk AIimport { Address, beginCell, Cell, Contract, contractAddress, ContractProvider, Sender, SendMode } from '@ton/core'; export type VanityContractConfig = { owner: Address; salt: Buffer; }; export function vanityContractConfigToCell( config: VanityContractConfig ): Cell { return beginCell() .storeUint(0, 5) .storeAddress(config.owner) .storeBuffer(config.salt, 32) .endCell(); } // from https://github.com/ton-community/vanity-contract/blob/6baeb39500de0fee79bd241047699ca65ee71f55/src/contract/vanity-address.cell const vanityCode = Cell.fromBoc( Buffer.from( 'b5ee9c72010102010032000114ff00f4a413f4bcf2c80b010046d3ed44d075d721fa408307d721d102d0d30331fa403058c705f288d4d4d101fb04ed54', 'hex', ), )[0]; export class VanityContract implements Contract { constructor( readonly address: Address, readonly init?: { code: Cell; data: Cell }, ) {} static createFromAddress(address: Address) { return new VanityContract(address); } static createFromConfig( config: VanityContractConfig, workchain = 0 ) { const data = vanityContractConfigToCell(config); const init = { code: vanityCode, data, }; return new VanityContract( contractAddress(workchain, init), init, ); } async sendDeploy( provider: ContractProvider, via: Sender, value: bigint, newCode: Cell, newData: Cell, ) { const body = beginCell() .storeRef(newCode) .storeRef(newData) .endCell(); await provider.internal(via, { value, sendMode: SendMode.PAY_GAS_SEPARATELY, body, }); } } See all 68 lines Create scripts/deployExampleContract.ts: CopyAsk AIimport { toNano, Address } from '@ton/core'; import { ExampleContract } from '../wrappers/ExampleContract'; import { VanityContract } from '../wrappers/VanityContract'; import { compile, NetworkProvider } from '@ton/blueprint'; export async function run(provider: NetworkProvider) { const vanityContract = provider.open( VanityContract.createFromConfig({ owner: Address.parse('<OWNER_ADDR>'), salt: Buffer.from('<SALT_HEX>', 'hex'), }), ); const exampleContract = provider.open( ExampleContract.createFromConfig( {}, await compile('ExampleContract'), ), ); const init = exampleContract.init!; await vanityContract.sendDeploy( provider.sender(), toNano('0.01'), // attach value for deployment fees init.code, init.data, ); await provider.waitForDeploy(vanityContract.address); } See all 31 lines Where: <OWNER_ADDR> — address allowed to deploy via the vanity contract. <SALT_HEX> — 32-byte salt in hex found by the generator. Run the script via npx blueprint run. The deployment succeeds when <OWNER_ADDR> matches the address of the wallet used for actual deployment. ExampleContract can be replaced with any contract; the vanity contract does not depend on the specifics of the code or data.Was this page helpful?YesNoSuggest editsRaise issuePreviousZero-knowledge proofsNext⌘IgithubxtelegramPowered by MintlifyOn this pagePrerequisitesHow it worksGenerate saltDeploy the contract",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "deployment",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "python",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:23:49.952Z"
  },
  {
    "id": "docs-ton-org--contract-dev-zero-knowledge",
    "title": "Zero-knowledge proofs on TON",
    "url": "https://docs.ton.org/contract-dev/zero-knowledge",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationContract developmentZero-knowledge proofs on TONContract developmentZero-knowledge proofs on TONCopy pageCopy pageThis guide shows how to create, compile, and test a simple Circom scheme and verify a ZK-proof using the zk-SNARK Groth16 protocol. This guide is also applicable to circuits written in the Noname language, since the export-ton-verifier library integrates with snarkjs, which in turn integrates with the Noname language.Other examples can be found here. ​Prerequisites Node.js 18 or a later LTS. circom snarkjs Blueprint ​Project setup Create a new project using Blueprint: CopyAsk AInpm create ton@latest ZkSimple cd ZkSimple Install libraries for working with ZK-proofs: CopyAsk AInpm install snarkjs @types/snarkjs Install the verifier export utility for TON: CopyAsk AInpm install export-ton-verifier@latest This utility exports verifier contracts for FunC, Tolk, and Tact. ​Create the Circom circuit Create the directory circuits/Multiplier and the file Multiplier.circom: CopyAsk AImkdir -p circuits/Multiplier cd circuits/Multiplier CopyAsk AIpragma circom 2.2.2; template Multiplier() { signal input a; signal input b; signal output c; c <== a*b; } component main = Multiplier(); This circuit proves knowledge of two numbers a and b, whose product is equal to the public output c, without revealing a and b themselves. ​Compile Run in circuits/Multiplier: CopyAsk AIcircom Multiplier.circom --r1cs --wasm --sym --prime bls12381 After compilation, the following files will appear: Multiplier.r1cs — circuit constraints (R1CS) Multiplier.sym — symbolic signal map Multiplier.wasm — artifact for generating proof Check constraints: CopyAsk AIsnarkjs r1cs info Multiplier.r1cs Output example: CopyAsk AI[INFO] snarkJS: Curve: bls12-381 [INFO] snarkJS: # of Wires: 4 [INFO] snarkJS: # of Constraints: 1 [INFO] snarkJS: # of Private Inputs: 2 [INFO] snarkJS: # of Public Inputs: 0 [INFO] snarkJS: # of Outputs: 1 snarkjs supports the alt_bn128 and bls12-381 curves. Ethereum uses alt_bn128, but bls12-381 is used for TON, so it is the one chosen in this guide. ​Trusted setup (Groth16) The trusted setup is a one-time ceremony that generates the proving and verification keys for a circuit. It’s called “trusted” because if the setup parameters are compromised, proofs could be forged. For production use, participate in a multi-party trusted setup ceremony. For local development and testing, a simplified single-party setup is sufficient. For local tests, perform a simplified trusted setup ceremony. The “power of tau” parameter (10) has to be chosen as low as possible, because it affects execution time; high enough, because the more constraints in the scheme, the higher the parameter required. CopyAsk AI# first phase snarkjs powersoftau new bls12-381 10 pot10_0000.ptau -v snarkjs powersoftau contribute pot10_0000.ptau pot10_0001.ptau --name=\"First contribution\" -v -e=\"some random text\" # second phase (depends on the compiled scheme) snarkjs powersoftau prepare phase2 pot10_0001.ptau pot10_final.ptau -v snarkjs groth16 setup Multiplier.r1cs pot10_final.ptau Multiplier_0000.zkey snarkjs zkey contribute Multiplier_0000.zkey Multiplier_final.zkey --name=\"1st Contributor\" -v -e=\"some random text\" # export verification key snarkjs zkey export verificationkey Multiplier_final.zkey verification_key.json Clear up unnecessary artifacts: CopyAsk AIrm pot10_0000.ptau pot10_0001.ptau pot10_final.ptau Multiplier_0000.zkey ​Export the verifier contract CopyAsk AI# export FunC contract (default) npx export-ton-verifier ./circuits/Multiplier/Multiplier_final.zkey ./contracts/verifier_multiplier.fc # export Tolk contract npx export-ton-verifier ./circuits/Multiplier/Multiplier_final.zkey ./contracts/verifier_multiplier.tolk --tolk # export Tact contract npx export-ton-verifier ./circuits/Multiplier/Multiplier_final.zkey ./contracts/verifier_multiplier.tact --tact For FunC and Tolk, wrappers must be generated manually: CopyAsk AInpx export-ton-verifier import-wrapper ./wrappers/Verifier.ts --force This command generates a TypeScript wrapper file that provides type-safe methods to interact with the verifier contract. ​Testing and verification In tests/ZkSimple.spec.ts: CopyAsk AIimport * as snarkjs from 'snarkjs'; import path from 'path'; import { dictFromInputList, groth16CompressProof } from 'export-ton-verifier'; // for Tact (After running `npx blueprint build --all`) import { Verifier } from '../build/Verifier_tact/tact_Verifier'; // for FunC and Tolk import { Verifier } from '../wrappers/Verifier'; Local verification: CopyAsk AIconst wasmPath = path.join(__dirname, '../circuits/Multiplier', 'Multiplier.wasm'); const zkeyPath = path.join(__dirname, '../circuits/Multiplier', 'Multiplier_final.zkey'); const verificationKey = require('../circuits/Multiplier/verification_key.json'); const input = { a: '342', b: '1245' }; const { proof, publicSignals } = await snarkjs.groth16.fullProve(input, wasmPath, zkeyPath); const okLocal = await snarkjs.groth16.verify(verificationKey, publicSignals, proof); On-chain verification: CopyAsk AIconst { pi_a, pi_b, pi_c, pubInputs } = await groth16CompressProof(proof, publicSignals); // Quick check via get-method: verifies the proof locally without changing blockchain state. expect(await verifier.getVerify({ pi_a, pi_b, pi_c, pubInputs })).toBe(true); // Send the proof to the contract in a message // The contract will run verification; handling the result/flow is up to the developer using this template. await verifier.sendVerify(deployer.getSender(), { pi_a, pi_b, pi_c, pubInputs, value: toNano('0.15') }); Build the contracts before running tests. For Tact contracts, run npx blueprint build --all first. For FunC/Tolk, ensure the wrappers are generated. ​Other Languages This tutorial follows the path Circom → snarkjs → export-ton-verifier → TON. The same workflow applies to other stacks — the key requirement is to obtain a proof and a verification key in snarkjs format. In the example repository — zk-ton-examples — there are already templates for noname, gnark, and arkworks: proofs can be generated in any of these stacks, then converted into snarkjs format and verified both locally and on-chain in the same way. Two utilities are available that help convert proofs and verification keys into a format compatible with snarkjs: ark-snarkjs: use for exporting from arkworks gnark-to-snarkjs: use for exporting from gnark The idea is always the same: generate proof.json and verification_key.json in snarkjs format, then use export-ton-verifier and perform verification in TON. ​Arkworks (Rust) Use the arkworks library to generate the proof and verification key, then convert them into snarkjs format with ark-snarkjs. Set up an Arkworks project: CopyAsk AIcargo init cargo add ark-bls12-381 ark-ff ark-groth16 ark-r1cs-std ark-relations ark-snark ark-snarkjs ark-std [email protected] The packages listed above are the core dependencies needed for most arkworks circuits. Depending on the specific circuit implementation, additional packages may be required. Write the circuit in Rust. Implement the circuit logic using arkworks primitives, similar to how a Circom circuit would be written. Learn how to write constraints in arkworks by following the Arkworks R1CS tutorial. A working example of a simple multiplication circuit can be found in the zk-ton-examples repository. Compile, generate proof, and perform trusted setup following the same workflow as in the Circom section above. Export the proof and verification key to JSON using ark-snarkjs: CopyAsk AIuse ark_snarkjs::{export_proof, export_vk}; use ark_bls12_381::{Bls12_381, Fr}; let _ = export_proof::<Bls12_381, _>(&proof, &public_inputs, \"json/proof.json\"); let _ = export_vk::<Bls12_381, _>( &params.vk, public_inputs.len(), \"json/verification_key.json\", ); The directory and files will be created automatically. Export the verifier contract: CopyAsk AI# FunC contract npx export-ton-verifier ./circuits/Arkworks/MulCircuit/json/verification_key.json ./contracts/verifier_ark.fc # Tact contract npx export-ton-verifier ./circuits/Arkworks/MulCircuit/json/verification_key.json ./contracts/verifier_ark.tact --tact # Tolk contract npx export-ton-verifier ./circuits/Arkworks/MulCircuit/json/verification_key.json ./contracts/verifier_ark.tolk --tolk ​gnark (Go) Use the gnark library to generate the proof and verification key, then convert them into snarkjs format with gnark-to-snarkjs. Set up a gnark project. You can find an example circuit in the gnark repository. A working example of a cubic circuit can be found in the zk-ton-examples repository. Add gnark-to-snarkjs as a dependency: CopyAsk AIgo get github.com/mysteryon88/gnark-to-snarkjs@latest Export the proof and verification key: CopyAsk AI{ proof_out, _ := os.Create(\"proof.json\") defer proof_o",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "tutorial",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:23:52.431Z"
  },
  {
    "id": "docs-ton-org--languages-tact",
    "title": "Tact language",
    "url": "https://docs.ton.org/languages/tact",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationLanguagesTact languageLanguagesTact languageCopy pageCopy pageThe official language of TON Blockchain is Tolk, and all other languages are deemed legacy. They are not necessarily outdated or deprecated, so you can still use them and contribute to their development, tooling, or documentation. Tact is a fresh programming language for TON Blockchain, focused on efficiency and ease of development. It is a good fit for complex smart contracts, quick onboarding and rapid prototyping. Developed by TON Studio, powered by the community — at the start of 2025, the number of unique code1 contracts deployed on the mainnet reached almost 28 thousand, of which about 33% were written in Tact. You can view some selected projects here: Tact in production. Tact has undergone a comprehensive security audit by Trail of Bits, a leading Web3 security firm. Try it online!Tact documentationAwesome Tact ​Features The most prominent and distinctive features of Tact are: Familiar and user-friendly TypeScript-like syntax. Strong static type system with built-in Structs, Messages, and maps, among others. First-class maps support, with many methods and a convenient foreach statement for traversing. Automatic (de)serialization of incoming messages and data structures. Automatic routing of internal, external, and bounced messages. Automatic handling of message types, including binary, text, and fallback slices. No boilerplate functions for sending messages and deploying child contracts. Reusable behaviors through traits. Support for low-level programming with asm functions. Generation of single-file TypeScript wrappers for convenient interactions with compiled contracts, which include: Type definitions for Structs and Messages are observable in the compilation report. Corresponding storeStructureName() and loadStructureName() functions for (de)serialization. All global and contract-level constants. Bi-directional records of exit codes: from their names to numbers and vice versa. Opcodes of all Messages. A contract wrapper class with various helper functions for initialization, deployment, and message exchange. Rich standard library. Extensive documentation. Robust tooling. …and there’s much more to come! ​Security Security audit of Tact by the Trail of Bits (2025, PDF) Backup link: PDF Report ​Tact in production Some selected software and applications based on contracts written in Tact, deployed in production, and consumed by end users: Open source or source available Proof-of-capital - proof-of-capital is a market-making smart contract that protects the interests of all holders. See the security audit report by Nowarp. Closed source Tradoor - Fast and social DEX on TON. See the security audit report by TonBit. PixelSwap - First modular and upgradeable DEX on TON. See the security audit report by Trail of Bits. GasPump - TON memecoin launchpad and trading platform. See Tact in production on the Awesome Tact list. ​Installation ​Compiler The Tact compiler is distributed as an NPM package bundled with the Tact standard library. The recommended Node.js version is 22 or higher, while the minimum version is 18. Use your favorite package manager to install it into a Node.js project: CopyAsk AI# yarn is recommended, but not required yarn add @tact-lang/compiler # you can also use npm npm i @tact-lang/compiler@latest # or pnpm pnpm add @tact-lang/compiler # or bun bun add @tact-lang/compiler Alternatively, you can install it globally as such: CopyAsk AInpm i -g @tact-lang/compiler It will make the tact compiler available on your PATH, as well as: a convenient unboc disassembler of a contract’s code compiled into a bag of cells .boc format. a formatter tact-fmt, which can format or check the formatting of individual Tact files and directories. ​Tooling Extensions and plugins VS Code extension - powerful and feature-rich extension for Visual Studio Code (VSCode) and VSCode-based editors like VSCodium, Cursor, Windsurf, and others. Get it on the Visual Studio Marketplace. Get it on the Open VSX Registry. Or install from the .vsix files in nightly releases. JetBrains IDEs plugin - provides syntax highlighting, code navigation, and more. Language Server (LSP Server) - supports Sublime Text, (Neo)Vim, Helix, and other editors with LSP support. tact.vim - Vim 8+ plugin. tact-sublime - Sublime Text 4 package. Get it on the Package Control. Security Misti - Static smart contract analyzer. TON Symbolic Analyzer (TSA) - Static smart contract analysis tool based on symbolic execution. Utility Formatter (tact-fmt) — The official formatter. It ships with the Tact Language Server, VS Code extension, and as a standalone binary with the compiler. You can invoke it by running npx tact-fmt in your Tact projects. BoC Disassembler (unboc) — Disassembler for .boc files. Ships as a standalone binary with the compiler. You can invoke it by running npx unboc in your Tact projects. ​Getting started For a quick start, read the “Let’s start!” mini-guide in the Tact documentation. It uses the Blueprint development environment for writing, testing, and deploying smart contracts on TON Blockchain. If you want more manual control, use tact-template. It’s a ready-to-use template with the development environment set up, including the Tact compiler with TypeScript + Jest, a local TON emulator, AI-based editor support, and examples of how to run tests. CopyAsk AIgit clone --depth 1 https://github.com/tact-lang/tact-template ​Community If you can’t find the answer in the docs, or you’ve tried to do some local testing and it still didn’t help, don’t hesitate to reach out to Tact’s flourishing community: @tactlang on Telegram - Main community chat and discussion group. @tactlang_ru on Telegram (Russian) @tact_kitchen on Telegram - Channel with updates from the team. @tact_language on X/Twitter tact-lang organization on GitHub @ton_studio on Telegram @thetonstudio on X/Twitter ​Contributing Contributions are welcome! To help develop the compiler, see the contributing guide. Footnotes The “unique code” means that each contract in the data sample has at least one TVM instruction that differs from the other contracts, excluding many preprocessed wallets with everything inlined — even seqno and a public key for signature verification! ↩ Was this page helpful?YesNoSuggest editsRaise issuePreviousOverviewNext⌘IgithubxtelegramPowered by MintlifyOn this pageFeaturesSecurityTact in productionInstallationCompilerToolingGetting startedCommunityContributing",
    "category": "languages",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "mainnet",
      "transaction",
      "deployment",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:23:54.256Z"
  },
  {
    "id": "docs-ton-org--tvm-overview",
    "title": "Overview",
    "url": "https://docs.ton.org/tvm/overview",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationTVM: TON Virtual MachineOverviewTVM: TON Virtual MachineOverviewCopy pageCopy pageTON Virtual Machine (TVM) is a stack-based virtual machine which executes smart contracts on TON blockchain. TVM is invoked when a message is sent to an account that has deployed contract code, when a get method is called on an account, and in some more rare cases. Executing code on same inputs and prior state deterministically produces same outputs, so that validators can agree on whether code was executed correctly. Every instruction consumes gas. Gas exhaustion stops execution. This limit is imposed so that expensive computations (i.e. infinite loops) cannot be used to exhaust validators’ computation resources, causing denial of service. ​Data model TVM has no random-access memory. Instead it uses a stack of values as a scratchpad. There are no memory addresses. Most instructions either store their parameters directly in the code, or take them from the top of the stack. All values are immutable. Most of the data is stored as immutable tree of cells. Reading and writing of cells is done with slices and builders. There are no function addresses or function pointers. Code is executed from bitcode inside continuations. ​TVM state On incoming messages or get method call, a new instance of TVM is started, with a new state. Derivation of the initial state from the message is described in its own article. The total state of TVM consists of the following components: Stack. A regular stack data structure. The vast majority of instructions pop() operands from the top and push() results back. Control registers. A small fixed set of special registers, denoted as c0, c1, …, c5, and c7 (c6 does not exist). Gas counter. Tracks remaining computation budget. Each instruction decrements gas. When counter hits zero/negative value, an exception is raised, and the run aborts. Current continuation (cc). A special register that stores a list of the next instructions to execute. Similar to the instruction pointer in traditional architectures. Current codepage (cp). Determines how to decode the next instruction in cc. Different codepages may implement different instruction sets, allowing for adding new features to TVM without affecting old smart contracts. Currently, only codepage 0 (cp0) is implemented. Smart contract runs SETCP0 instruction to explicitly use codepage 0. ​TVM data types Values on the stack and inside of registers are of one of the following seven types: TypeDescriptionInteger257-bit signed integer. Has the special NaN value representing arithmetic faults.CellNode of a tree with bit string on it (<= 1023 bits), and up to 4 arrows (refs).SliceRead cursor over a Cell.BuilderWrite cursor to construct a new Cell.TupleList of 0..255 elements of any of seven types. Types of elements can be distinct.ContinuationExecutable Slice with TVM bitcode. Continuations are callable like functions.NullEmpty value. ​Example of a smart contract: counter Here is a sample contract, written in Fift. It implements the following logic: If an event is not an internal message, stop execution. Read 32-bit number (msg_counter) from internal message’s body. Check that it is equal to the 32-bit number stored in c4 (persistent account storage). Increment it. Save it back to c4. When an account with this code gets an internal message, TVM stack is initialized with these values: s0 (top of the stack), function selector, is 0. For other events, e.g., external messages or get method calls, selector will be non-zero. s1, message body. The example contract expects exactly 32 bits here. Three more values s2, s3, s4 are pushed by TVM onto a stack. They won’t be used in the example. After execution finishes, they’ll still be on the stack, and will be silently ignored. In Current stack comments, we represent stack at that moment of execution, keeping its top to the right (e.g., s2 s1 s0, where s0 is the top of the stack). FiftCopyAsk AI<{ // Current stack: msg_body selector // Use codepage 0. Picks the only available instruction set. SETCP0 // This instruction does not affect the stack. // Current stack: msg_body selector // Consume `selector` from the top of the stack. // Stop execution if `selector != 0`, // i.e. \"is not an internal message\". IFRET // Continue execution if we received an internal message. // Current stack: msg_body // Load (LD) unsigned (U) 32-bit integer from a slice. // This instruction pops (consumes) a slice from the stack, // pushes an integer, and then pushes a new slice with // 32 bits cut from it 32 LDU // Current stack: msg_counter msg_body' // msg_body' is a slice whose read cursor was moved by 32 bits // when we loaded a 32-bit integer. // For example, if we had slice x{00000001} on the stack and // then invoked 32 LDU, there will be integer `1` and `x{}` // (empty slice) on the stack // Assert the END of a slice (S). // These instructions consume a slice and check that it is // empty (no more data to read), otherwise it throws an // exception, because there was more data than we expected. ENDS // Current stack: msg_counter // Push c4 (persistent storage) on the stack. // `storage` is a cell c4 PUSH // Current stack: msg_counter storage // Convert Cell to a Slice, i.e. make it readable CTOS // Current stack: msg_counter storage_slice // Read 32-bit unsigned integer from `storage_slice` 32 LDU // Current stack: msg_counter storage_counter storage_slice' // Assert there is no more data in the storage ENDS // Current stack: msg_counter storage_counter // Duplicate s0 (top of stack) under two top values TUCK // Current stack: storage_counter msg_counter storage_counter // Check counters are equal EQUAL // Current stack: storage_counter msg_counter==storage_counter? // Throw an exception with code 33 if it is not equal 33 THROWIFNOT // Current stack: storage_counter // Increase counter INC // Current stack: storage_counter+1 // Create an empty Builder NEWC // Current stack: storage_counter+1 builder // Store (ST) unsigned (U) 32-bit integer `storage_counter+1` to a builder 32 STU // Current stack: builder' // Finalize Builder to a Cell ENDC // Current stack: new_storage // Save `new_storage` to c4 (persistent storage) c4 POP // Current stack: (no values) }> Was this page helpful?YesNoSuggest editsRaise issuePreviousTxTracerNext⌘IgithubxtelegramPowered by MintlifyOn this pageData modelTVM stateTVM data typesExample of a smart contract: counter",
    "category": "infrastructure",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:23:57.128Z"
  },
  {
    "id": "docs-ton-org--tvm-instructions",
    "title": "Instructions",
    "url": "https://docs.ton.org/tvm/instructions",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationTVM: TON Virtual MachineInstructionsTVM: TON Virtual MachineInstructionsCopy pageInteractive reference for TVM instructionsCopy page ​00 NOPDoes nothing. Category: Stack Basic (stack_basic)FiftCopyAsk AINOP ​0i XCHG_0IInterchanges s0 with s[i], 1 <= i <= 15. Category: Stack Basic (stack_basic)FiftCopyAsk AIs[i] XCHG0 Aliases: SWAP Same as s1 XCHG0. ​10ij XCHG_IJInterchanges s[i] with s[j], 1 <= i < j <= 15. Category: Stack Basic (stack_basic)FiftCopyAsk AIs[i] s[j] XCHG ​11ii XCHG_0I_LONGInterchanges s0 with s[ii], 0 <= ii <= 255. Category: Stack Basic (stack_basic)FiftCopyAsk AIs0 [ii] s() XCHG ​1i XCHG_1IInterchanges s1 with s[i], 2 <= i <= 15. Category: Stack Basic (stack_basic)FiftCopyAsk AIs1 s[i] XCHG ​2i PUSHPushes a copy of the old s[i] into the stack. Category: Stack Basic (stack_basic)FiftCopyAsk AIs[i] PUSH Aliases: DUP Same as s0 PUSH. OVER Same as s1 PUSH. ​3i POPPops the old s0 value into the old s[i]. Category: Stack Basic (stack_basic)FiftCopyAsk AIs[i] POP Aliases: DROP Same as s0 POP, discards the top-of-stack value. NIP Same as s1 POP. ​4ijk XCHG3Equivalent to s2 s[i] XCHG s1 s[j] XCHG s[k] XCHG0. Category: Stack Complex (stack_complex)FiftCopyAsk AIs[i] s[j] s[k] XCHG3 ​50ij XCHG2Equivalent to s1 s[i] XCHG s[j] XCHG0. Category: Stack Complex (stack_complex)FiftCopyAsk AIs[i] s[j] XCHG2 ​51ij XCPUEquivalent to s[i] XCHG0 s[j] PUSH. Category: Stack Complex (stack_complex)FiftCopyAsk AIs[i] s[j] XCPU ​52ij PUXCEquivalent to s[i] PUSH SWAP s[j] XCHG0. Category: Stack Complex (stack_complex)FiftCopyAsk AIs[i] s[j-1] PUXC ​53ij PUSH2Equivalent to s[i] PUSH s[j+1] PUSH. Category: Stack Complex (stack_complex)FiftCopyAsk AIs[i] s[j] PUSH2 ​540ijk XCHG3_ALTLong form of XCHG3. Category: Stack Complex (stack_complex)FiftCopyAsk AIs[i] s[j] s[k] XCHG3_l ​541ijk XC2PUEquivalent to s[i] s[j] XCHG2 s[k] PUSH. Category: Stack Complex (stack_complex)FiftCopyAsk AIs[i] s[j] s[k] XC2PU ​542ijk XCPUXCEquivalent to s1 s[i] XCHG s[j] s[k-1] PUXC. Category: Stack Complex (stack_complex)FiftCopyAsk AIs[i] s[j] s[k-1] XCPUXC ​543ijk XCPU2Equivalent to s[i] XCHG0 s[j] s[k] PUSH2. Category: Stack Complex (stack_complex)FiftCopyAsk AIs[i] s[j] s[k] XCPU2 ​544ijk PUXC2Equivalent to s[i] PUSH s2 XCHG0 s[j] s[k] XCHG2. Category: Stack Complex (stack_complex)FiftCopyAsk AIs[i] s[j-1] s[k-1] PUXC2 ​545ijk PUXCPUEquivalent to s[i] s[j-1] PUXC s[k] PUSH. Category: Stack Complex (stack_complex)FiftCopyAsk AIs[i] s[j-1] s[k-1] PUXCPU ​546ijk PU2XCEquivalent to s[i] PUSH SWAP s[j] s[k-1] PUXC. Category: Stack Complex (stack_complex)FiftCopyAsk AIs[i] s[j-1] s[k-2] PU2XC ​547ijk PUSH3Equivalent to s[i] PUSH s[j+1] s[k+1] PUSH2. Category: Stack Complex (stack_complex)FiftCopyAsk AIs[i] s[j] s[k] PUSH3 ​55ij BLKSWAPPermutes two blocks s[j+i+1] ... s[j+1] and s[j] ... s0.0 <= i,j <= 15Equivalent to [i+1] [j+1] REVERSE [j+1] 0 REVERSE [i+j+2] 0 REVERSE. Category: Stack Complex (stack_complex)FiftCopyAsk AI[i+1] [j+1] BLKSWAP Aliases: ROT2 Rotates the three topmost pairs of stack entries. ROLL Rotates the top i+1 stack entries.Equivalent to 1 [i+1] BLKSWAP. ROLLREV Rotates the top i+1 stack entries in the other direction.Equivalent to [i+1] 1 BLKSWAP. ​56ii PUSH_LONGPushes a copy of the old s[ii] into the stack.0 <= ii <= 255 Category: Stack Complex (stack_complex)FiftCopyAsk AI[ii] s() PUSH ​57ii POP_LONGPops the old s0 value into the old s[ii].0 <= ii <= 255 Category: Stack Complex (stack_complex)FiftCopyAsk AI[ii] s() POP ​58 ROTEquivalent to 1 2 BLKSWAP or to s2 s1 XCHG2. Category: Stack Complex (stack_complex)FiftCopyAsk AIROT ​59 ROTREVEquivalent to 2 1 BLKSWAP or to s2 s2 XCHG2. Category: Stack Complex (stack_complex)FiftCopyAsk AIROTREV -ROT ​5A SWAP2Equivalent to 2 2 BLKSWAP or to s3 s2 XCHG2. Category: Stack Complex (stack_complex)FiftCopyAsk AISWAP2 2SWAP ​5B DROP2Equivalent to DROP DROP. Category: Stack Complex (stack_complex)FiftCopyAsk AIDROP2 2DROP ​5C DUP2Equivalent to s1 s0 PUSH2. Category: Stack Complex (stack_complex)FiftCopyAsk AIDUP2 2DUP ​5D OVER2Equivalent to s3 s2 PUSH2. Category: Stack Complex (stack_complex)FiftCopyAsk AIOVER2 2OVER ​5Eij REVERSEReverses the order of s[j+i+1] ... s[j]. Category: Stack Complex (stack_complex)FiftCopyAsk AI[i+2] [j] REVERSE ​5F0i BLKDROPEquivalent to DROP performed i times. Category: Stack Complex (stack_complex)FiftCopyAsk AI[i] BLKDROP ​5Fij BLKPUSHEquivalent to PUSH s(j) performed i times.1 <= i <= 15, 0 <= j <= 15. Category: Stack Complex (stack_complex)FiftCopyAsk AI[i] [j] BLKPUSH ​60 PICKPops integer i from the stack, then performs s[i] PUSH. Category: Stack Complex (stack_complex)FiftCopyAsk AIPICK PUSHX ​61 ROLLXPops integer i from the stack, then performs 1 [i] BLKSWAP. Category: Stack Complex (stack_complex)FiftCopyAsk AIROLLX ​62 -ROLLXPops integer i from the stack, then performs [i] 1 BLKSWAP. Category: Stack Complex (stack_complex)FiftCopyAsk AI-ROLLX ROLLREVX ​63 BLKSWXPops integers i,j from the stack, then performs [i] [j] BLKSWAP. Category: Stack Complex (stack_complex)FiftCopyAsk AIBLKSWX ​64 REVXPops integers i,j from the stack, then performs [i] [j] REVERSE. Category: Stack Complex (stack_complex)FiftCopyAsk AIREVX ​65 DROPXPops integer i from the stack, then performs [i] BLKDROP. Category: Stack Complex (stack_complex)FiftCopyAsk AIDROPX ​66 TUCKEquivalent to SWAP OVER or to s1 s1 XCPU. Category: Stack Complex (stack_complex)FiftCopyAsk AITUCK ​67 XCHGXPops integer i from the stack, then performs s[i] XCHG. Category: Stack Complex (stack_complex)FiftCopyAsk AIXCHGX ​68 DEPTHPushes the current depth of the stack. Category: Stack Complex (stack_complex)FiftCopyAsk AIDEPTH ​69 CHKDEPTHPops integer i from the stack, then checks whether there are at least i elements, generating a stack underflow exception otherwise. Category: Stack Complex (stack_complex)FiftCopyAsk AICHKDEPTH ​6A ONLYTOPXPops integer i from the stack, then removes all but the top i elements. Category: Stack Complex (stack_complex)FiftCopyAsk AIONLYTOPX ​6B ONLYXPops integer i from the stack, then leaves only the bottom i elements. Approximately equivalent to DEPTH SWAP SUB DROPX. Category: Stack Complex (stack_complex)FiftCopyAsk AIONLYX ​6Cij BLKDROP2Drops i stack elements under the top j elements.1 <= i <= 15, 0 <= j <= 15Equivalent to [i+j] 0 REVERSE [i] BLKDROP [j] 0 REVERSE. Category: Stack Complex (stack_complex)FiftCopyAsk AI[i] [j] BLKDROP2 ​6D NULLPushes the only value of type Null. Category: Tuple (tuple)FiftCopyAsk AINULL PUSHNULL Aliases: NEWDICT Returns a new empty dictionary.It is an alternative mnemonics for PUSHNULL. ​6E ISNULLChecks whether x is a Null, and returns -1 or 0 accordingly. Category: Tuple (tuple)FiftCopyAsk AIISNULL Aliases: DICTEMPTY Checks whether dictionary D is empty, and returns -1 or 0 accordingly.It is an alternative mnemonics for ISNULL. ​6F0n TUPLECreates a new Tuple t=(x_1, ... ,x_n) containing n values x_1,…, x_n.0 <= n <= 15 Category: Tuple (tuple)FiftCopyAsk AI[n] TUPLE Aliases: NIL Pushes the only Tuple t=() of length zero. SINGLE Creates a singleton t:=(x), i.e., a Tuple of length one. PAIR Creates pair t:=(x,y). TRIPLE Creates triple t:=(x,y,z). ​6F1k INDEXReturns the k-th element of a Tuple t.0 <= k <= 15. Category: Tuple (tuple)FiftCopyAsk AI[k] INDEX Aliases: FIRST Returns the first element of a Tuple. SECOND Returns the second element of a Tuple. THIRD Returns the third element of a Tuple. ​6F2n UNTUPLEUnpacks a Tuple t=(x_1,...,x_n) of length equal to 0 <= n <= 15.If t is not a Tuple, or if |t| != n, a type check exception is thrown. Category: Tuple (tuple)FiftCopyAsk AI[n] UNTUPLE Aliases: UNSINGLE Unpacks a singleton t=(x). UNPAIR Unpacks a pair t=(x,y). UNTRIPLE Unpacks a triple t=(x,y,z). ​6F3k UNPACKFIRSTUnpacks first 0 <= k <= 15 elements of a Tuple t.If |t|<k, throws a type check exception. Category: Tuple (tuple)FiftCopyAsk AI[k] UNPACKFIRST Aliases: CHKTUPLE Checks whether t is a Tuple. If not, throws a type check exception. ​6F4n EXPLODEUnpacks a Tuple t=(x_1,...,x_m) and returns its length m, but only if m <= n <= 15. Otherwise throws a type check exception. Category: Tuple (tuple)FiftCopyAsk AI[n] EXPLODE ​6F5k SETINDEXComputes Tuple t' that differs from t only at position t'_{k+1}, which is set to x.0 <= k <= 15If k >= |t|, throws a range check exception. Category: Tuple (tuple)FiftCopyAsk AI[k] SETINDEX Aliases: SETFIRST Sets the first component of Tuple t to x and returns the resulting Tuple t'. SETSECOND Sets the second component of Tuple t to x and returns the resulting Tuple t'. SETTHIRD Sets the third component of Tuple t to x and returns the resulting Tuple t'. ​6F6k INDEXQReturns the k-th element of a Tuple t, where 0 <= k <= 15. In other words, returns x_{k+1} if t=(x_1,...,x_n). If k>=n, or if t is Null, returns a Null instead of x. Category: Tuple (tuple)FiftCopyAsk A",
    "category": "infrastructure",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:24:00.328Z"
  },
  {
    "id": "docs-ton-org--tvm-builders-and-slices",
    "title": "Builders and Slices",
    "url": "https://docs.ton.org/tvm/builders-and-slices",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationTVM: TON Virtual MachineBuilders and SlicesTVM: TON Virtual MachineBuilders and SlicesCopy pageCopy pageIn TVM, the Cell type contains only metadata of the cell: level, hashes, and depths. To read actual data, TVM need to load cell from celldb, key-value storage of the node, which stores cells by their representation hashes. CTOS instruction loads a cell by its metadata from Cell type, and provides a Slice, a read-only wrapper for the cell’s content. To simplify coding cell deserializers in smart contracts, instead of behaving like a simple bit/ref array, Slice is a “read cursor”: it allows loading a piece of data from the beginning of the slice, returning that data and the slice that contains remaining data. On the other hand, there is a Builder type, which provides a convenient way to serialize data to a cell. Only the Cell type can be used outside of TVM: in output actions and in persistent storage. ​Builder Builder provides a way to construct a cell from a sequence of values of the following TVM types: integers, cells (as references), slices, and builders. Tuples, continuations, and null are not serializable. For example, serialize the following numbers to a cell: CopyAsk AI1 (uint4) 2 (uint4) -1 (int8) First, create an empty builder using NEWC: FiftCopyAsk AINEWC // returns empty builder x{} Then, put a number on the stack: FiftCopyAsk AI1 INT // stack: x{} 1 And call STU (“STore Unsigned integer”) to store integer into builder (swapping builder and value to meet STU input order): FiftCopyAsk AISWAP // stack: 1 x{} 4 STU // stack: x{0001} Then, store the other two numbers: FiftCopyAsk AI2 INT // x{0001} 2 SWAP // 2 x{0001} 4 STU // x{00010010} -1 INT // x{00010010} -1 SWAP // -1 x{00010010} 8 STI // x{0001001011111111} And, finally, ENDC instruction finalizes the builder to a cell. ​Slice Slice allows reading data back from a cell, field by field. For example, deserialize bitstring x{0001001011111111} created above. CTOS (“Cell TO Slice”) loads a Cell to a Slice. FiftCopyAsk AI// assume a cell with bitstring x{0001001011111111} is on the stack CTOS // x{0001001011111111} Then, call LDU (“LoaD Unsigned integer”) to read first value (uint4). FiftCopyAsk AI4 LDU // 1 x{001011111111} LDU takes the first 4 bits from a slice and creates a new slice without these 4 bits: x{0001|001011111111} slices into a number 0001 and a slice x{001011111111}. Similarly, read another two numbers: FiftCopyAsk AI4 LDU // 1 2 x{11111111} 8 LDI // 1 2 -1 x{} A common way to ensure there is no data left inside the slice is to call ENDS.Was this page helpful?YesNoSuggest editsRaise issuePreviousContinuationsNext⌘IgithubxtelegramPowered by MintlifyOn this pageBuilderSlice",
    "category": "infrastructure",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:24:01.893Z"
  },
  {
    "id": "docs-ton-org--tvm-continuations",
    "title": "Continuations",
    "url": "https://docs.ton.org/tvm/continuations",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationTVM: TON Virtual MachineContinuationsTVM: TON Virtual MachineContinuationsCopy pageCopy pageContinuation is a value that contains executable code. Continuations are used whenever non-linear code execution is required: conditions loops function calls throwing and catching exceptions Continuation can be thought as “pointer to a code”, with an important distinction that, unlike pointers on other machines, it’s not a number. ​Ordinary continuation The most common kind of continuations are the ordinary continuations, which are just code Slices, containing (the remainder of) TVM bitcode. Optionally, it can contain any of the additional parameters: Stack. A list of values that will be pushed on stack before continuation is executed. Savelist. A list of values for registers before continuation is executed. Codepage. Bitcode version used to run this continuation. Number of arguments (nargs). Number of values from call-side stack to push onto new stack before continuation is executed. ​Control flow ​Jumps The simplest way to change cc is to use JMPREF instruction. It just sets cc to the reference operand of JMPREF (stack and registers are not affected). The following rules are applied during the jump: Initialize a new stack with the target continuation initial stack Move nargs elements from the caller stack to the new stack, if the target continuation has nargs If the target continuation nargs is not defined, move all elements from the caller stack to the new stack Pop register values from target continuation savelist Due to the limitation of the Cell type, one continuation can contain no more than 1023 bits of bitcode. To execute longer functions, we could pass JMPREF as a last instruction, which will continue execution of a function in a new continuation. FiftCopyAsk AI// some instructions <{ // next instructions that exceed the 1023-bit limit are placed in a child cell }> JMPREF To simplify things, TVM has an implicit jump mechanism, which automatically jumps to the next reference of cc when there are no more instructions to execute. ​Calls Call is a special type of jump, which also saves cc to c0, so the callee can pass execution back to the caller. That is how CALLREF works. FiftCopyAsk AI2 PUSHINT 3 PUSHINT <{ ADD }> CALLREF // returns 5 After ADD is executed, there are no more instructions to execute in cc, and also no references for implicit jumps. Implicit return sets cc back to c0, which was a previous cc. Let’s look at the composition of continuations which CALLREF produces: During the call, the remaining of the current continuation is saved to c0. Also, current c0 is pushed to the savelist of cc to restore its original value after return. If we would call function f1, then call f2 inside f1 and f3 inside f2, there will be a callstack formed by savelists of continuations: c0 value inside f3 can be represented as (rest of f2) ◦0 (rest of f1) ◦0 (rest of the caller). a ◦i b is a continuation composition operator, which saves continuation b as a ci register of continuation b, so, we can say that b is executed after a by register ci. ​Extraordinary continuations ​Quit TL-B: vmc_quit$1000 exit_code:int32 = VmCont Exits TVM with exit_code. During initialization of TVM, c0 is set to Quit(0), and c1 to Quit(1). ​ExcQuit TL-B: vmc_quit_exc$1001 = VmCont Default exception handler. Terminates TVM with exception code popped from the stack. During initialization of TVM, c2 is set to ExcQuit. ​PushInt TL-B: vmc_pushint$1111 value:int32 next:^VmCont = VmCont Pushes value on the stack and jumps to next. This continuation is only used in BOOLEVAL instruction. ​Envelope TL-B: vmc_envelope$01 cdata:VmControlData next:^VmCont = VmCont Updates current VM state with cdata and jumps to next. ​Repeat TL-B: vmc_repeat$10100 count:uint63 body:^VmCont after:^VmCont = VmCont Executes body count times, then jumps to after. Under the hood, it just sets body c0 to Repeat(count - 1, body, after) if count > 0, otherwise jumps to after. Used in REPEAT and variants. ​Again TL-B: vmc_again$110001 body:^VmCont = VmCont Executes body infinite times by setting body c0 to Again(body). Used in AGAIN and variants. ​Until TL-B: vmc_until$110000 body:^VmCont after:^VmCont = VmCont Pops bool from stack, jumps to body with c0 = Until(body, after) if bool is false, otherwise jumps to after. Used in UNTIL and variants. ​WhileCondition TL-B: vmc_while_cond$110010 cond:^VmCont body:^VmCont after:^VmCont = VmCont Represents a branching point of a while loop. Pops a bool from the stack, jumps to body with c0 = WhileBody(cond, body, after) if the bool is true, otherwise jumps to after. Used in WHILE and variants. ​WhileBody TL-B: vmc_while_body$110011 cond:^VmCont body:^VmCont after:^VmCont = VmCont Represents a delayed iteration of a while loop. Jumps to cond with c0 = WhileCondition(cond, body, after). It is assumed that the evaluation of cond leaves a bool at the top of the stack for the following WhileCondition to check. Used in WHILE and variants.Was this page helpful?YesNoSuggest editsRaise issuePreviousRegistersNext⌘IgithubxtelegramPowered by MintlifyOn this pageOrdinary continuationControl flowJumpsCallsExtraordinary continuationsQuitExcQuitPushIntEnvelopeRepeatAgainUntilWhileConditionWhileBody",
    "category": "infrastructure",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:24:03.357Z"
  },
  {
    "id": "docs-ton-org--tvm-registers",
    "title": "Registers",
    "url": "https://docs.ton.org/tvm/registers",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationTVM: TON Virtual MachineRegistersTVM: TON Virtual MachineRegistersCopy pageCopy pageTVM registers hold special values, such as contract storage, list of output actions, or exception handler Only c4 (new state) and c5 (final actions) represent durable effects of a successful on‑chain run. Everything else is transient. ​c0 — return continuation Type: Continuation Initial value: Quit — extraordinary continuation which terminates TVM with exit code 0. When RET is called or the current continuation remains no instructions (implicit ret), c0 is invoked. Call-like instructions use it to store the current continuation in order to return to it after executing the inner function. ​c1 — alternative return continuation Type: Continuation Initial value: Quit — extraordinary continuation which terminates TVM with exit code 1. Both exit codes 0 and 1 are considered successful terminations of TVM. Same as c0, but invoked only in special control flow instructions, such as RETALT, IFRETALT, and others. ​c2 — exception handler Type: Continuation Initial value: ExcQuit — extraordinary continuation which terminates TVM with an exception. In this case, the exit code is an exception number. Invoked implicitly on any exception that occurs during TVM execution. Can be invoked explicitly by THROW-like instructions. To set a custom exception handler, use TRY. ​c3 — function selector Type: Continuation Initial value: Root cell of code currently executing in TVM. Invoked by CALLDICT instruction with a function ID (integer) passed on the stack. The function selector should jump to a function with that ID. Fift-ASM assembler constructs following function selector (Asm.fif:1624): FiftCopyAsk AISETCP0 <{ // a dictionary which maps 19-bit function id (integer) => function code (slice) }> DICTPUSHCONST DICTIGETJMPZ // get a function with given id from dictionary and execute it 11 THROWARG // if no function found, throw with exit code 11 and function id as additional argument ​c4 — persistent account storage Type: Cell Initial value: Root cell of account data. This register helps to store some information between smart contract invocations. When the transaction succeeds, the final value of c4 is saved as new account data. ​c5 — outbound actions accumulator Type: Cell Initial value: Empty cell. List of actions to perform in the action phase after TVM execution: send a message, reserve funds, update code, and install libraries. c5 has an OutList structure: TL-BCopyAsk AIout_list_empty$_ = OutList 0; out_list$_ {n:#} prev:^(OutList n) action:OutAction = OutList (n + 1); action_send_msg#0ec3c86d mode:(## 8) out_msg:^(MessageRelaxed Any) = OutAction; action_set_code#ad4de08e new_code:^Cell = OutAction; action_reserve_currency#36e6b809 mode:(## 8) currency:CurrencyCollection = OutAction; libref_hash$0 lib_hash:bits256 = LibRef; libref_ref$1 library:^Cell = LibRef; action_change_library#26fa1dd4 mode:(## 7) libref:LibRef = OutAction; The previous action is always the first reference of the next one. If action itself has a reference, it is stored as the second reference in the list. At the beginning of the list, an empty cell is stored as the first reference of the first action. ​c7 — environment information and global variables Type: Tuple Initial value: Tuple[Tuple[0x076ef1ea, 0, 0, ...]]. The zero element of the c7 tuple is an environment information (which itself is also a tuple). The remaining 255 slots are used for global variables. [i] SETGLOB modifies c7, inserting an element with index i, [i] GETGLOB reads i-th element from c7. ​Structure of environment information tuple #InstructionFieldTypeDescription0-0x076ef1eaintegertag of the SmartContractInfo TL-B structure1-actions countintegerincrements when new action is pushed to c5.2-messages sentintegerincrements when new action_send_msg is pushed to c53NOWunix timeintegercurrent time (timestamp of block collation)4BLOCKLTcurrent block LT (logical time)integer5LTIMEcurrent transaction LTinteger6RANDSEEDrandom seedintegersha256(block_rand_seed . account_address)7BALANCEsmart contract balancetupletuple of integer (TON balance) and cell or null (extra currencies dictionary)8MYADDRsmart contract addressslice9CONFIGROOTglobal blockchain configurationcell or null (dictionary)10MYCODEsmart contract codecell11INCOMINGVALUEvalue of incoming messagetupletuple of integer (TON value) and cell or null (extra currencies dictionary)12STORAGEFEESfees collected during storage phaseinteger13PREVBLOCKSINFOTUPLE, PREVMCBLOCKS_100last 16 masterchain blocks, last keyblock, and last 16 masterchain blocks with seqno divisible by 100tupletuple has following PrevBlocksInfo structure:CopyAsk AI[ wc:Integer shard:Integer seqno:Integer root_hash:Integer file_hash:Integer ] = BlockId; [ last_mc_blocks:BlockId[] prev_key_block:BlockId last_mc_blocks_divisible_by_100:BlockId[] ] = PrevBlocksInfo; 14UNPACKEDCONFIGTUPLEunpacked config valuestuple 0: StoragePrices from the ConfigParam 18 — not the whole dictionary, but only the one StoragePrices entry which corresponds to the current time 1: ConfigParam 19, global ID 2: ConfigParam 20, masterchain gas prices 3: ConfigParam 21, non-masterchain gas prices 4: ConfigParam 24, masterchain forward fees 5: ConfigParam 25, non-masterchain forward fees 6: ConfigParam 43, size limits 15DUEPAYMENTcurrent debt for storage fee in nanotonsinteger16GETPRECOMPILEDGASgas usage for the current contract if it is precompiled, null otherwiseinteger or nullsee ConfigParam 4517INMSGPARAMSinbound message parameterstuple 0: bounce: boolean — can bounce 1: bounced: boolean — did bounce 2: src_addr: slice — sender 3: fwd_fee: int 4: created_lt: int 5: created_at: int 6: orig_value: int — this is sometimes different from the value in INCOMINGVALUE and TVM stack because of storage fees 7: value: int — same as in INCOMINGVALUE and on the initial TVM stack 8: value_extra: cell or null — same as in INCOMINGVALUE 9: state_init: cell or null For external messages, tick-tock transactions and get methods: bounce, bounced, fwd_fee, created_lt, created_at, orig_value, value are 0, value_extra is null. For tick-tock transactions and get methods, src_addr is addr_none.Was this page helpful?YesNoSuggest editsRaise issuePreviousGasNext⌘IgithubxtelegramPowered by MintlifyOn this pagec0 — return continuationc1 — alternative return continuationc2 — exception handlerc3 — function selectorc4 — persistent account storagec5 — outbound actions accumulatorc7 — environment information and global variablesStructure of environment information tuple",
    "category": "infrastructure",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:24:04.862Z"
  },
  {
    "id": "docs-ton-org--tvm-gas",
    "title": "Gas",
    "url": "https://docs.ton.org/tvm/gas",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationTVM: TON Virtual MachineGasTVM: TON Virtual MachineGasCopy pageCopy pageEach instruction executed in TVM consumes gas. All instructions consume basic gas, which is calculated from the size of the instruction in the bitcode. Some instructions may consume extra gas, which is often not fixed but calculated based on the input data. ​Basic gas usage (per bit of executed code) Each instruction consumes a fixed amount of 10 gas and 1 gas for each bit of this instruction, not including variable-length operands and references. Examples: InstructionTL-BGasNotesNEWC#C8188-bit prefix without operandsSTU#CB cc:uint8268-bit prefix, 8-bit operandPUSHINT_LONG#82 l:(## 5) xxx:(int (8 * l + 19))238-bit prefix, 5-bit operand, length of xxx depends on l, so it is not includedSTSLICE_CONST#CFC0_ x:(## 2) y:(## 3) c:(x * ^Cell) sss:((8 * y + 2) * Bit)249-bit prefix (CF is 8 bits, C0_ is C_, which is just bit 1), 2-bit and 3-bit operands, refs c and variable-length sss are not included ​Cell operations When any instruction internally finalizes a Builder to a Cell, it consumes 500 gas. When a Cell is loaded as a Slice, it consumes 100 gas for the first access in current smart contract invocation, and 25 gas for each subsequent load from cache. Cells are identified by representation hash, e.g., loading cell with the same hash for the second time will always cost 25 gas. This applies to all instructions that internally operate with cells (including dictionary operations). The only exceptions are: BTOS converts a Builder to a Slice without consuming gas for cell operations. HASHBU computes hash without consuming gas for converting Builder to a Cell ​Exceptions TVM consumes 50 gas when any exception is thrown, both explicitly by THROW-like instructions or implicitly during execution of other instructions. This happens before the jump to the exception handler c2. ​Implicit jumps and returns When the current continuation ends and there is a remaining reference, TVM jumps to it and consumes 10 gas. When there are no instructions to execute and references to jump to, implicit return to c0 occurs, which consumes 5 gas. ​Nested continuations Calling more than 8 extraordinary continuations in a chain consumes 1 gas for each subsequent continuation. ​Tuple operations TUPLE, TUPLEVAR, UNTUPLE, UNTUPLEVAR, UNPACKFIRST, UNPACKFIRSTVAR, EXPLODE, EXPLODEVAR consumes 1 gas for each entry been pushed or popped into a tuple. TPUSH, TPOP, SETINDEX, SETINDEXVAR, SETINDEXQ/SETINDEXVARQ consumes len(tuple) gas for the resulting tuple size after push/pop/set. Same applies to instructions operating with c7: SETGLOB/SETGLOBVAR, RANDU256/RAND, SETRAND, ADDRAND. ​Stack operations TVM consumes 1 gas for each stack element deeper than 32 elements inside the resulting new stack each time stack gets copied: when calling or jumping to a continuation with a non-empty argument number, an initial stack, or both, when extending a continuation stack using SETCONTARGS and similar instructions, when using RUNVM (both for initial and resulting stacks of the vm). ​Extra currency The first 5 executions of GETEXTRABALANCE consume at most 26 + 200 gas each. The subsequent executions incur the full gas cost of 26 (normal instruction cost) plus gas for loading cells (up to 3300 if the dictionary has maximum depth). ​RUNVM RUNVM and RUNVMX consume 40 extra gas before starting a VM. ​Cryptography ​CHKSIGNS/CHKSIGNU CHKSIGNS and CHKSIGNU can be invoked 10 times without extra gas cost. Next checks will cost 4000 gas each. ​HASHEXT HASHEXT* instructions always consume 1 extra gas for each part of the input. Additionally, the following gas is consumed for each hashed byte: AlgorithmGas consumedSHA2561/33 per byteSHA5121/16 per byteBLAKE2B1/19 per byteKECCAK2561/11 per byteKECCAK5121/6 per byte Only the integer part of the gas is consumed; for example, 0-32 bytes of SHA256 cost 0 gas, 33-64 bytes cost 1 gas, and so on. ​RIST255 Instructions consume constant extra gas. InstructionExtra gasRIST255_FROMHASH600RIST255_VALIDATE200RIST255_ADD600RIST255_MUL2000RIST255_MULBASE750 ​Other instructions ECRECOVER consumes 1500 extra gas. SECP256K1_XONLY_PUBKEY_TWEAK_ADD consumes 1250 extra gas. P256_CHKSIGNU and P256_CHKSIGNS consume 3500 extra gas. ​BLS ​Signature verification and aggregation InstructionGas consumedNotesBLS_VERIFY61000BLS_AGGREGATE-2650 + 4350 * nn is the number of signatures aggregated.BLS_FASTAGGREGATEVERIFY58000 + 3000 * nn is the number of public keys verified against one message/signature pair.BLS_AGGREGATEVERIFY38500 + 22500 * nn is the number of (public key, message) pairs checked against one signature. ​G1 group helpers InstructionGas consumedBLS_G1_ADD / BLS_G1_SUB3900BLS_G1_NEG750BLS_G1_MUL5200BLS_MAP_TO_G12350BLS_G1_INGROUP2950 BLS_G1_MULTIEXP consumes 11375 + 630 * n + (8820 * n) / max(log₂ n, 4) extra gas, where n is the number of (point, scalar) pairs. Instructions BLS_G1_ZERO and BLS_G1_ISZERO do not charge additional gas. ​G2 group helpers InstructionGas consumedBLS_G2_ADD / BLS_G2_SUB6100BLS_G2_NEG1550BLS_G2_MUL10550BLS_MAP_TO_G27950BLS_G2_INGROUP4250 BLS_G2_MULTIEXP consumes 30388 + 1280 * n + (22840 * n) / max(log₂ n, 4) gas, where n is the number of (point, scalar) pairs. Instructions BLS_G2_ZERO and BLS_G2_ISZERO do not charge additional gas. ​Pairing and constants InstructionGas consumedNotesBLS_PAIRING20000 + 11800 * nn is the number of (G1, G2) pairs supplied for the pairing product check. BLS_PUSHR do not charge additional gas. ​GasLimits structure TVM has inner structure GasLimits for gas manipulations. Its fields are: gas_max: the equivalent of contract’s balance at the start of the compute phase in gas units. gas_limit: the amount of gas that can be consumed during the virtual machine execution. At the start of the execution, it equals: minimum of gas_max and the amount of gas that can be bought with the incoming message value (i.e., the amount of TON coins attached to the message) in the case of an internal message; 0 in the case of an external message. gas_credit: the amount of free gas that can be spent during the execution before accepting an external message. At the start of the execution, it equals: minimum of gas_max and corresponding value in configuration parameter 20 for masterchain and 21 for basechain in the case of an external message; 0 in the case of an internal message. gas_remaining: the amount of available but not spent gas. At the start of the execution, it equals gas_limit + gas_credit. It decreases after each instruction execution by the amount of gas consumed by the instruction. gas_base: an auxiliary parameter that is necessary for rebasing and shows the initial value of gas_remaining. At the start of the execution, it equals gas_remaining. Instructions SETGASLIMIT and ACCEPT change all above values except gas_max: SETGASLIMIT sets gas_limit to the minimum of the indicated value and gas_max, gas_credit to zero, gas_base to the new gas_limit, and gas_remaining to gas_remaining + (new gas_base - old gas_base). ACCEPT is equivalent to SETGASLIMIT with the new gas limit equal to 2**63 - 1 (the maximum value of a signed 64-bits integer). The final value (in gas units) that will be deducted from contract’s balance after the execution is gas_base - gas_remaining. Note that this value will be deducted if and only if after the execution gas_credit is zero, i.e. if SETGASLIMIT or ACCEPT was called at least once during the execution in the case of incoming external message. Without condition gas_credit == 0, there will be no commit of the new code and data.Was this page helpful?YesNoSuggest editsRaise issuePreviousInitializationState of TVM before smart contract executionNext⌘IgithubxtelegramPowered by MintlifyOn this pageBasic gas usage (per bit of executed code)Cell operationsExceptionsImplicit jumps and returnsNested continuationsTuple operationsStack operationsExtra currencyRUNVMCryptographyCHKSIGNS/CHKSIGNUHASHEXTRIST255Other instructionsBLSSignature verification and aggregationG1 group helpersG2 group helpersPairing and constantsGasLimits structure",
    "category": "infrastructure",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:24:07.131Z"
  },
  {
    "id": "docs-ton-org--tvm-initialization",
    "title": "Initialization",
    "url": "https://docs.ton.org/tvm/initialization",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationTVM: TON Virtual MachineInitializationTVM: TON Virtual MachineInitializationCopy pageState of TVM before smart contract executionCopy page​Initialization of cc, cp, and gas limits The original cc, current continuation, is initialized using the cell slice created from the code section of the smart contract. If the account is frozen or uninitialized, the code must be provided in the init field of the incoming message. The cp, current TVM codepage, is set to the default value of 0. The gas limit values are initialized based on the results of the credit phase. ​Registers initialization For more info about registers, take a look at Registers c0: Quit — extraordinary continuation which terminates TVM with exit code 0. c1: Quit — extraordinary continuation which terminates TVM with exit code 1. Both exit codes 0 and 1 are considered successful terminations of TVM. c2: ExcQuit — extraordinary continuation which terminates TVM with an exception. In this case, the exit code is an exception number. c3: root cell of code currently executing in TVM. c4: root cell of account data. c5: empty cell. c7: Tuple[Tuple[0x076ef1ea, 0, 0, ...]]. ​Stack The contents of the stack depend on the event that triggered the transaction: Internal message External message Tick-tock Split prepare Merge install Get method (off-chain) The top of the stack is always the function selector, an integer that identifies the event that caused the transaction. The following function selectors are defined: IDNameDescription0onInternalMessageReceived an internal message-1onExternalMessageReceived an external message-2onRunTickTockReceived a tick-tock event-3onSplitPrepareReceived a split prepare event (unimplemented yet)-4onSplitInstallReceived a split install event (unimplemented yet) Get methods can have arbitrary IDs and should not overlap with the ones listed above. ​External/internal message IndexNameTypeDescriptions0Function selectorInteger-1 for external messages, 0 for internal messages.s1Message bodySliceThis is an arbitrary payload of a message, which can be used for text comments (when sending TONs from one wallet to another) or for smart contract commands.s2MessageCellCell containing message metadata (sender, receiver, amount) as well as message body.s3Message valueIntegerAmount of received nanotons (0 for externals).s4Contract balanceIntegerCurrent account balance in nanotons. ​Tick‑tock IndexNameTypeDescriptions0Function selectorInteger-2 for tick-tock transactions.s1Tick or tock?Integer0 for tick transactions, -1 for tock transactions.s2Account addressInteger256-bit raw account address (without workchain).s3ContractIntegerCurrent account balance in nanotons. ​Split/merge events These events are not implemented yet. Possible stack layout for split/merge events is described in TON Blockchain whitepaper. However, it is subject to change.Was this page helpful?YesNoSuggest editsRaise issuePreviousExit codesNext⌘IgithubxtelegramPowered by MintlifyOn this pageInitialization of cc, cp, and gas limitsRegisters initializationStackExternal/internal messageTick‑tockSplit/merge events",
    "category": "infrastructure",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:24:08.460Z"
  },
  {
    "id": "docs-ton-org--tvm-exit-codes",
    "title": "Exit codes",
    "url": "https://docs.ton.org/tvm/exit-codes",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationTVM: TON Virtual MachineExit codesTVM: TON Virtual MachineExit codesCopy pageCopy pageThis page currently gives code examples in Tact language. They will be rewritten in Tolk in the near future. An exit code is a 32-bit signed integer that indicates whether the compute or action phase of the transaction was successful. If not, it holds the code of the exception that occurred. Each transaction on TON Blockchain consists of multiple phases. An exit code is a 32-bit signed integer that indicates whether the compute or action phase of the transaction was successful, and if not, holds the code of the exception that occurred. Each exit code represents its own exception or the resulting state of the transaction. Exit codes 0 and 1 indicate normal (successful) execution of the compute phase. Exit (or result) code 0 indicates normal (successful) execution of the action phase. Any other exit code indicates that a certain exception has occurred and that the transaction was not successful in one way or another, i.e., the transaction was reverted or the inbound message has bounced back. TON Blockchain reserves exit code values from 0 to 127. The range from 256 to 65535 is free for developer-defined exit codes. While an exit (or result) code is a 32-bit signed integer on TON Blockchain, an attempt to throw an exit code outside the bounds of a 16-bit unsigned integer (0−655350 - 655350−65535) will cause an error with exit code 5. This is done intentionally to prevent some exit codes from being produced artificially, such as exit code -14. ​Table of exit codes The following table lists exit codes with their origin (where they can occur) and a short description for each. Exit codeOriginBrief description 0Compute and action phasesStandard successful execution exit code.1Compute phaseAlternative successful execution exit code. Reserved, but does not occur.2Compute phaseStack underflow.3Compute phaseStack overflow.4Compute phaseInteger overflow.5Compute phaseRange check error — an integer is out of its expected range.6Compute phaseInvalid TVM opcode.7Compute phaseType check error.8Compute phaseCell overflow.9Compute phaseCell underflow.10Compute phaseDictionary error.11Compute phaseDescribed in TVM docs as “Unknown error, may be thrown by user programs.”12Compute phaseFatal error. Thrown by TVM in situations deemed impossible.13Compute phaseOut of gas error.-14Compute phaseSame as 13. Negative, so that it cannot be faked.14Compute phaseVM virtualization error. Reserved, but never thrown.32Action phaseAction list is invalid.33Action phaseAction list is too long.34Action phaseAction is invalid or not supported.35Action phaseInvalid source address in outbound message.36Action phaseInvalid destination address in outbound message.37Action phaseNot enough Toncoin.38Action phaseNot enough extra currencies.39Action phaseOutbound message does not fit into a cell after rewriting.40Action phaseCannot process a message — not enough funds, the message is too large, or its Merkle depth is too big.41Action phaseLibrary reference is null during library change action.42Action phaseLibrary change action error.43Action phaseExceeded the maximum number of cells in the library or the maximum depth of the Merkle tree.50Action phaseAccount state size exceeded limits. Often enough, you might encounter the exit code 65535 (or 0xffff), which usually means the same as the exit code 130 — the received opcode is unknown to the contract, as no receivers were expecting it. When writing contracts, the exit code 65535 is set by the developers and not by TVM or the Tolk compiler. ​Exit codes in Blueprint projects In Blueprint tests, exit codes from the compute phase are specified in the exitCode field of the object argument for the toHaveTransaction() method of the expect() matcher. The field for the result codes (exit codes from the action phase) in the same toHaveTransaction() method is called actionResultCode. Additionally, one can examine the result of sending a message to a contract and discover the phases of each transaction and their values, including exit (or result) codes for the compute phase (or action phase). Note that to do so, you’ll have to perform a couple of type checks first: CopyAsk AIit('tests something, you name it', async () => { // Send a specific message to our contract and store the results const res = await your_contract_name.send({/* … */}); // Now, we have access to an array of executed transactions, // with the second one (index 1) being the one we look for const tx = res.transactions[1]!; // To do something useful with it, let's ensure that its type is 'generic' // and that the compute phase in it wasn't skipped if (tx.description.type === \"generic\" && tx.description.computePhase.type === \"vm\") { // Finally, we're able to freely peek into the transaction for general details, // such as printing out the exit code of the compute phase if we so desire console.log(tx.description.computePhase.exitCode); } }); ​Compute and action phases ​0: Normal termination This exit (or result) code indicates the successful completion of the compute phase (or action phase) of the transaction. ​Compute phase TVM initialization and all computations occur in the compute phase. If the compute phase fails (the resulting exit code is neither 0 nor 1), the transaction skips the action phase and proceeds to the bounce phase. In this phase, a bounce message is formed for transactions initiated by the inbound message. ​1: Alternative termination This is an alternative exit code for the successful execution of the compute phase. It is reserved but never occurs. ​2: Stack underflow If an operation consumes more elements than exist on the stack, an error with exit code 2 is thrown: Stack underflow. TactCopyAsk AIasm fun drop() { DROP } contract Loot { receive(\"I solemnly swear that I'm up to no good\") { try { // Removes 100 elements from the stack, causing an underflow repeat (100) { drop() } } catch (exitCode) { // exitCode is 2 } } } Useful linksTVM overview. ​3: Stack overflow If there are too many elements copied into a closure continuation, an error with exit code 3 is thrown: Stack overflow. This occurs rarely unless you’re deep in the Fift and TVM assembly trenches: TactCopyAsk AI// Remember kids, don't try to overflow the stack at home! asm fun stackOverflow() { x{} SLICE // s BLESS // c 0 SETNUMARGS // c' 2 PUSHINT // c' 2 SWAP // 2 c' 1 -1 SETCONTARGS // ← this blows up } contract ItsSoOver { receive(\"I solemnly swear that I'm up to no good\") { try { stackOverflow(); } catch (exitCode) { // exitCode is 3 } } } Useful linksTVM overview. ​4: Integer overflow If the value in a calculation goes beyond the range from −2256-2^{256}−2256 to 2256−12^{256} - 12256−1 inclusive, or there’s an attempt to divide or perform modulo by zero, an error with exit code 4 is thrown: Integer overflow. TactCopyAsk AIlet x = -pow(2, 255) - pow(2, 255); // -2^{256} try { -x; // integer overflow by negation // since the max positive value is 2^{256} - 1 } catch (exitCode) { // exitCode is 4 } try { x / 0; // division by zero! } catch (exitCode) { // exitCode is 4 } try { x * x * x; // integer overflow! } catch (exitCode) { // exitCode is 4 } // There can also be an integer overflow when performing: // addition (+), // subtraction (-), // division (/) by a negative number or modulo (%) by zero ​5: Integer out of expected range A range check error occurs when some integer is out of its expected range. Any attempt to store an unexpected amount of data or specify an out-of-bounds value throws an error with exit code 5: Integer out of expected range. Examples of specifying an out-of-bounds value: TactCopyAsk AItry { // Repeat only operates on an inclusive range from 1 to 2^{31} - 1 // Any valid integer value greater than that causes an error with exit code 5 repeat (pow(2, 55)) { dump(\"smash. logs. I. must.\"); } } catch (exitCode) { // exitCode is 5 } try { // Builder.storeUint() function can only use up to 256 bits, thus 512 is too much: let s: Slice = beginCell().storeUint(-1, 512).asSlice(); } catch (exitCode) { // exitCode is 5 } ​6: Invalid opcode If you specify an instruction that is not defined in the current TVM version or attempt to set an unsupported code page, an error with exit code 6 is thrown: Invalid opcode. TactCopyAsk AI// There's no such code page, and an attempt to set it fails asm fun invalidOpcode() { 42 SETCP } contract OpOp { receive(\"I solemnly swear that I'm up to no good\") { try { invalidOpcode(); } catch (exitCode) { // exitCode is 6 } } } ​7: Type check error If an argument to a primitive is of an incorrect value type or there is any other mismatch in types during the compute phase, an error with exit code 7 is thrown: Type check error. TactCopyAsk AI// The actual returned value type doesn't match the decla",
    "category": "infrastructure",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:24:11.301Z"
  },
  {
    "id": "docs-ton-org--tvm-get-method",
    "title": "Get methods",
    "url": "https://docs.ton.org/tvm/get-method",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationTVM: TON Virtual MachineGet methodsTVM: TON Virtual MachineGet methodsCopy pageCopy pageGet methods are smart contract methods that are supposed to be executed off-chain. They are useful for structured retrieval of data from a smart contract (get_collection_data get-method on an NFT collection), and for any logic that is a part of a smart contract but is needed off-chain (get_nft_address_by_index get-method on an NFT collection). Under the hood of APIs, this happens by fetching the actual state of the smart contract from the blockchain and executing TVM to get the result. This process is purely read-only and does not modify the blockchain state in any way. ​Defining Get methods are processed by the function selector. By convention, the ID of a get method is calculated as crc16(\"name\") | 0x10000 where name is set by the developer. This simplifies practical usage because a human-readable name has to be used instead of some arbitrary number. The algorithm used for hashing is CRC‑16/XMODEM (poly=0x1021, init=0x0000, refin=false, refout=false, xorout=0x0000). A minimal example of a smart contract that has a get method that follows the ID convention: CopyAsk AI\"Asm.fif\" include <{ // The ID from the top of the stack is compared with 97865 97865 EQINT // If ID != 97865, an 11 error is thrown by convention 11 THROWIFNOT // Otherwise, 123 is pushed as the result 123 PUSHINT }>s But in practice, it is easier to use PROGRAM{ from the Fift assembler that handles function selector logic. CopyAsk AI\"Asm.fif\" include PROGRAM{ DECLPROC main // crc16(\"get_x\") | 0x10000 = 97865 97865 DECLMETHOD get_x main PROC:<{ }> get_x PROC:<{ 123 PUSHINT }> }END>s The above is equivalent to the following Tolk code, which compiles to almost identical Fift code. TolkCopyAsk AIfun main() { } get fun get_x(): int { return 123; } ​Executing In order to execute a get method, the actual state of the smart contract has to be fetched, and TVM has to be executed with c7 initialized and the desired parameters pushed on the stack. ​Local way With all the required values known, it is possible to execute a get method completely locally. A minimal example that uses a placeholder c7 for simplicity, as it is only necessary when the get method uses data from it during execution: CopyAsk AI\"Asm.fif\" include // example code // could also be defined as a constant cell without using assembly PROGRAM{ DECLPROC main 97865 DECLMETHOD get_x main PROC:<{ }> get_x PROC:<{ 123 PUSHINT }> }END>s constant code // example data // empty in this case <b b> constant data // example c7 // placeholder for simplicity 0 tuple 0x076ef1ea , 1 tuple constant c7 // execute method 97865 97865 code data c7 runvmctx .s // result: 123 0 C{96A296D224F285C67BEE93C30F8A309157F0DAA35DC5B87E410B78630A09CFC7} // where: // 123 is the value returned by the get method // 0 is the exit code // C{...} is a new data cell Note that if the get method uses some values from c7, for example with instructions such as NOW or MYCODE, the c7 tuple should be populated according to its structure. ​Decentralized way The process of fetching the actual contract state and initializing c7 can be handled by liteserver for easier execution. To execute a get method via liteserver, the request follows the liteServer.runSmcMethod TL schema. In that request, params:bytes is a BoC of a serialized VmStack object containing the stack with arguments. The response follows the liteServer.runMethodResult TL schema. Apart from the values used for initialization and proofs, the result is included as result:mode.2?bytes, which is a BoC of a serialized VmStack object, similarly to the request. An example execution via liteclient that handles serialization: CopyAsk AIrunmethod UQBKgXCNLPexWhs2L79kiARR1phGH1LwXxRbNsCFF9doczSI get_public_key Result: CopyAsk AIarguments: [ 78748 ] result: [ 37001869727465363790964079650574219024351072622925678701060821828351030750605 ] ​High-level API The easiest path is using a high-level API, such as TON Center. It has a /api/v3/runGetMethod endpoint that takes a smart contract address, a get method name, and arguments and returns the resulting stack. Example usage: CopyAsk AIcurl -X 'POST' \\ 'https://toncenter.com/api/v3/runGetMethod' \\ -H 'accept: application/json' \\ -H 'Content-Type: application/json' \\ -d '{ \"address\": \"EQBG-g6ahkAUGWpefWbx-D_9sQ8oWbvy6puuq78U2c4NUDFS\", \"method\": \"get_nft_address_by_index\", \"stack\": [ { \"type\": \"num\", \"value\": \"123\" } ] }' The result for this call is presented below. The stack in this case contains a single cell element in BoC format. CopyAsk AI{ \"gas_used\": 4049, \"exit_code\": 0, \"stack\": [ { \"type\": \"cell\", \"value\": \"te6cckEBAQEAJAAAQ4AVoN3BhVDLKet4AYoVxOHz8WkaFncQfg/M79YWJEV4pxDg5fQi\" } ] } Was this page helpful?YesNoSuggest editsRaise issuePreviousCellsNext⌘IgithubxtelegramPowered by MintlifyOn this pageDefiningExecutingLocal wayDecentralized wayHigh-level API",
    "category": "infrastructure",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:24:14.129Z"
  },
  {
    "id": "docs-ton-org--foundations-status",
    "title": "Account status",
    "url": "https://docs.ton.org/foundations/status",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationBlockchain foundationsAccount statusBlockchain foundationsAccount statusCopy pageCopy pageThis article describes the four possible states of an account on TON Blockchain. Understanding these states is crucial for accurately predicting transaction outcomes and ensuring the correct deployment. ​What is the account status? The account status is a formal indicator of what actions can occur with an account, what it can store, and whether it contains a contract code. In other words, it is one of the main factors determining the behavior of a given account during a transaction. The account status at the beginning and end of a transaction is recorded in the corresponding TL-B block in the fields orig_status and end_status. Thus, it allows developers to always view the current status of an account before sending it a message and restore the history of its status changes. ​Status variety Each account exists in one of the following statuses: nonexist: the default status for accounts with no transaction history or that were deleted. Contains no code, data, or balance. All 2256 accounts start in this status. uninit: holds a balance and metadata, but no code and persistent data. It cannot execute logic but retains funds (and accumulates the storage fee) until the contract code is deployed. active: contains code, data, and a balance. Fully deployed and operational, capable of processing messages. frozen: occurs when the storage debt of an active account exceeds 0.1 TON. Only the hashes of the previous code and data cells are preserved. While frozen, the contract cannot be executed. To unfreeze, send a message with the valid StateInit and sufficient funds for storage fees. Recovery is complex; avoid reaching this state. A project to unfreeze accounts is available here. ​Why exactly these four statuses? Although the need for the active and nonexist statuses is obvious, the purpose of the uninit and frozen statuses is not immediately clear. nonexist vs uninit: As was mentioned above, each account starts in the nonexist status. Besides code and persistent data, in this status, an account also has no metadata, so it does not accumulate the storage fee. At the same time, the uninit status of an account indicates that some actions were performed with it and, possibly, it is prepared for deployment. So, the uninit account always has a positive balance and some additional information for which it must pay a storage fee. Sending an internal message with a valid state_init and proper value to nonexist account results in its deployment and the status changes to active. The key point is that the deployment occurs during the compute phase, which requires a suitable number of nanotons to run. But often you want to be able to deploy an account through an external message, to which you can also attach state_init, but it is impossible to attach value! This is also the purpose for which uninit exists. You can initially transfer the balance to the account via an internal message, notifying the rest of the blockchain participants of your intention to deploy an account in the future. And only then, including through an external message, to deploy. frozen vs uninit: When the active account’s storage debt exceeds 0.1 TON, it becomes frozen or uninit. It is possible to restore the account from these statuses by paying off the debt and attaching state_init. If the account code and its persistent data have not changed during the lifetime of the account, then there is no problem restoring it from uninit. But what if they have changed? Since the uninit status does not allow you to store any information about the account’s history, its last state will be lost forever. To prevent such situations, the frozen status exists. The main difference between the uninit and frozen statuses is that in addition to metadata, the frozen account contains hash of the last account state. Thus, it becomes possible to restore the last state of an account before it was frozen by sending a state_nint to it, whose hash matches the one recorded on the account. ​Status transitions We present here a diagram that describes all potential changes in the account status during the receipt of internal or external messages. ​Diagram In the diagram below, there are four nodes representing the four different account statuses. Each arrow and loop corresponds to a change in the account status at the end of a given transaction. The parameters in the blocks above the arrows (and loops) briefly describe what caused the transaction and also contain some fields that affect the change in the account status. So, let’s look at what changes can occur to a nonexist account depending on the messages that come to it. Receiving external messages: no changes. Receiving internal messages: With a valid state_init and sufficient value: the contract is deployed on its address that becomes active before processing the message. Without/with invalid state_init or with insufficient value: if the message is bounceable, then it returns to the sender, and the account status isn’t changed. Otherwise, with no value in the message, the account status isn’t changed. Finally, it becomes uninit if it received a valid state_init but insufficient nanotons or if state_init is absent or invalid. With the diagram Legend below, you can inspect all possible changes in the account status when receiving messages with different parameters. ​Legend type: message type. any; internal; external; bounce: bounce flag of an internal message. any; true; false; value: an amount of nanotons in a message. any; 0; > 0. state_init: StateInit structure. any; none; invalid: the address computed from a given state_init does not match the recipient address; valid: the computed address matches a recipient address; valid last state: must be state_init of the last successful transaction before the account becomes frozen. balance: The account balance in nanotons after Storage phase of the transaction. 0; > 0; < 40000; >= 40000; (0, 40000). storage_fees_due: the number of storage fees that were charged but could not be collected. In the diagram, this field indicates storage_fees_due after the Storage phase. 0; < 0.1; < 1; >= 0.1; >= 1. send_dest_if_zero: is there any outgoing message with flag 32 in Action phase? any; false; true; invalid: there was no Action phase. zero_bal_after_dest_act: Whether the account balance became zero when sending some of the messages with the flag 32. This field is meaningful only if there’s at least one such message during Action phase. any; false; true. action_phase_is_successful: was Action phase successful? false; true. account_state_changed: has the account’s state changed during its lifetime? false; true. ​Key points We additionally review some important points regarding the statuses except nonexist. Sending to uninit account: Messages of any type without state_init: changes to nonexist if its balance becomes zero. Messages of any type with valid state_init: changes to active if the balance is at least 40000 nanotons. Sending to frozen account: Messages of any type: Changes to nonexist if its storage_fees_due exceeds 1 TON and the balance is zero. Internal message with valid state_init (non-bounceable): changes to active if its storage_fees_due becomes zero. Internal message with valid state_init (bounceable): changes to active with the same debt, and the account balance equals the message’s balance minus compute and action fees. Sending to active account: Messages of any type: changes to frozen if its storage_fees_due exceeds 0.1 TON and the account’s state has ever changed. Messages of any type: changes to uninit if its storage_fees_due exceeds 0.1 TON and the account’s state has never changed. Messages of any type: if in the action list there is an outgoing message with the flag 32 but Action phase was unsuccessful or the balance after this action is positive, the account status doesn’t change. Messages of any type with any state_init: new state_init will be ignored and therefore doesn’t change the account status. Deployment strategy: The standard practice for deploying a wallet is to first send a non-bounceable message with Toncoin to its address. This transitions the account to the uninit status. The wallet owner can then deploy the contract in a subsequent transaction, using the pre-funded balance. Protection against errors: standard wallets and applications manage these complexities by automatically setting the bounce flag based on the status of the destination account. Developers of custom applications must implement similar logic to prevent fund loss. ​Summary The account status (nonexist, uninit, active, frozen) defines behavior. Correct handling of state_init and the bounce flag is crucial for successful deployment and avoiding unintended fund transfers.",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "deployment",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:24:16.821Z"
  },
  {
    "id": "docs-ton-org--foundations-phases",
    "title": "Execution phases",
    "url": "https://docs.ton.org/foundations/phases",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationBlockchain foundationsExecution phasesBlockchain foundationsExecution phasesCopy pageCopy pageWhen an event occurs on an account in The Open Network (TON) blockchain, it triggers a transaction. The most common event is receiving a message, but other events like tick-tock, merge, and split can also initiate transactions. Each transaction consists of up to five phases: Storage phase: calculates storage fees for the contract based on the space it occupies in the blockchain state. Credit phase: updates the contract balance by accounting for incoming message values and storage fees. Compute phase: executes the contract code on the TON Virtual Machine (TVM). The result includes exit_code, actions, gas_details, new_storage, and other data. Action phase: processes actions from the compute phase if it succeeds. Actions may include sending messages, updating contract code, or modifying libraries. If an action fails (for example, due to a lack of funds), the transaction may revert or skip the action, depending on its mode. For example, mode = 0, flag = 2 means that any errors arising while processing this message during the action phase are ignored. Bounce phase: If the compute phase ends with an error and the inbound message has the bounce flag set, this phase generates a bounce message. If the send_msg action failed and it had the +16 flag set, then the bounce phase will also be triggered. Compute, Action and Bounce phases may be skipped Execution order notesFor non-bounceable messages: Credit → Storage → Compute → Action → BounceFor bounceable messages: Storage → Credit → Compute → Action → Bounce ​Fee deduction sequence Import fee (before the first phase) Storage fee (storage phase) Gas fee (compute phase) Action fee + forward fee (action phase) Additional forward fees (bounce phase) ​Storage phase Cannot be skipped. In this phase, the blockchain processes fees related to the account’s persistent storage. Let’s start by looking at the TL-B schema: CopyAsk AItr_phase_storage$_ storage_fees_collected:Grams storage_fees_due:(Maybe Grams) status_change:AccStatusChange = TrStoragePhase; The storage_fees_due field is of type Maybe because it is only present when the account has insufficient balance to cover the storage fees. When the account has enough funds, this field is omitted. Note: Grams are unsigned integers, so account balances cannot be negative. The AccStatusChange field indicates whether the account’s status changed during this phase. For example, see account status variety. ​Credit phase Cannot be skipped. This phase is relatively small and straightforward. The main logic of this phase is to credit the contract’s balance with the remaining value from the incoming message. The credit phase is serialized in TL-B as follows: CopyAsk AItr_phase_credit$_ due_fees_collected:(Maybe Grams) credit:CurrencyCollection = TrCreditPhase; This phase consists of the following two fields: FieldTypeDescriptiondue_fees_collectedMaybe GramsAmount of previously due storage fees collected (present only if storage fees were due and collected in this phase).creditCurrencyCollectionThe amount credited to the account as a result of receiving the incoming message. ​Compute phase The compute phase is one of the most complex stages of a transaction. This is where the smart contract code, stored in the account’s state, is executed. Unlike previous phases, the TL-B definition for the compute phase includes multiple variants. CopyAsk AItr_phase_compute_skipped$0 reason:ComputeSkipReason = TrComputePhase; tr_phase_compute_vm$1 success:Bool msg_state_used:Bool account_activated:Bool gas_fees:Grams ^[ gas_used:(VarUInteger 7) gas_limit:(VarUInteger 7) gas_credit:(Maybe (VarUInteger 3)) mode:int8 exit_code:int32 exit_arg:(Maybe int32) vm_steps:uint32 vm_init_state_hash:bits256 vm_final_state_hash:bits256 ] = TrComputePhase; cskip_no_state$00 = ComputeSkipReason; cskip_bad_state$01 = ComputeSkipReason; cskip_no_gas$10 = ComputeSkipReason; cskip_suspended$110 = ComputeSkipReason; ​When the compute phase is skipped To start, note that the compute phase can be skipped entirely. In that case, the reason for skipping is explicitly recorded and can be one of the following: Skip reasonDescriptioncskip_no_stateThe smart contract has no state and, therefore, no code, so execution is not possible.cskip_bad_stateRaised in two cases: when the fixed_prefix_length field has an invalid value or when the StateInit provided in the incoming message does not match account’s address.cskip_no_gasThe incoming message did not provide enough TON to cover the gas required to execute the smart contract.cskip_suspendedThe address is suspended; execution is disabled (used to limit early miner accounts). Bad stateThe fixed_prefix_length field can be used to specify a fixed prefix for the account address, ensuring that the account resides in a specific shard. This topic is outside the scope of this guide, but more information is available in Shards page. ​Action phase Once the smart contract code has finished executing, the Action phase begins. If any actions were created during the compute phase, they are processed at this stage. There are precisely 4 types of actions in TON: CopyAsk AIaction_send_msg#0ec3c86d mode:(## 8) out_msg:^(MessageRelaxed Any) = OutAction; action_set_code#ad4de08e new_code:^Cell = OutAction; action_reserve_currency#36e6b809 mode:(## 8) currency:CurrencyCollection = OutAction; libref_hash$0 lib_hash:bits256 = LibRef; libref_ref$1 library:^Cell = LibRef; action_change_library#26fa1dd4 mode:(## 7) libref:LibRef = OutAction; TypeDescriptionaction_send_msgSends a message.action_set_codeUpdates the smart contract’s code.action_reserve_currencyReserves a portion of the account’s balance. This is especially useful for gas management.action_change_libraryChanges the library used by the smart contract. These actions are executed in the order in which they were created during code execution. A total of up to 255 actions can be made. Here is the TL-B schema, which defines the structure of the action phase: CopyAsk AItr_phase_action$_ success:Bool valid:Bool no_funds:Bool status_change:AccStatusChange total_fwd_fees:(Maybe Grams) total_action_fees:(Maybe Grams) result_code:int32 result_arg:(Maybe int32) tot_actions:uint16 spec_actions:uint16 skipped_actions:uint16 msgs_created:uint16 action_list_hash:bits256 tot_msg_size:StorageUsed = TrActionPhase; ​Bounce phase If the Compute phase or Action phase ends with an error, and the incoming message has the bounce flag set, the system triggers the Bounce phase. Bounce on errorFor the bounce phase to trigger due to an error in the action phase, the failed action must have flag 16 set, which enables bounce on error. CopyAsk AItr_phase_bounce_negfunds$00 = TrBouncePhase; tr_phase_bounce_nofunds$01 msg_size:StorageUsed req_fwd_fees:Grams = TrBouncePhase; tr_phase_bounce_ok$1 msg_size:StorageUsed msg_fees:Grams fwd_fees:Grams = TrBouncePhase; The tr_phase_bounce_negfunds type is not used in the current version of the blockchain. The other two types function as follows: TypeDescriptiontr_phase_bounce_nofundsIndicates that the account does not have enough funds to process the message that should be bounced back to the sender.tr_phase_bounce_okIndicates that the system successfully processes the bounce and sends the message back to the sender. In this phase, msg_fees and fwd_fees are calculated from the total_fwd_fees: approximately 13\\frac{1}{3}31​ goes to msg_fees and 23\\frac{2}{3}32​ go to fwd_fees. See Fees → Forward fee for more info. ​Key points If the receiver cannot parse the message and terminates with a non-zero exit code, the message bounces back automatically. The bounced message has its bounce flag cleared and bounced flag set, and contains 0xffffffff (32-bit) opcode followed by the original message body. Always check the bounced flag before parsing op to avoid treating a bounce as a new query. Was this page helpful?YesNoSuggest editsRaise issuePreviousTransaction feesNext⌘IgithubxtelegramPowered by MintlifyOn this pageFee deduction sequenceStorage phaseCredit phaseCompute phaseWhen the compute phase is skippedAction phaseBounce phaseKey points",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:24:19.187Z"
  },
  {
    "id": "docs-ton-org--foundations-fees",
    "title": "Transaction fees",
    "url": "https://docs.ton.org/foundations/fees",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationBlockchain foundationsTransaction feesBlockchain foundationsTransaction feesCopy pageCopy pageFees in TON align with the execution phases of a transaction: Storage fees are charged in the storage phase. Compute fees are charged in the compute phase. Forward and action fees are charged in the action and bounce phases. Import fees apply at the start of smart contract execution, not a specific phase. The total transaction fee is the sum of these components. Validators set fee levels through voting: Storage fees are set in config parameter 18. Compute fees are set in config parameters 20 and 21. Forward, import, and action fees are set in config parameters 24 and 25. ​Storage fees CopyAsk AIbasic_price = (account.bits * bit_price + account.cells * cell_price) storage_fee = ceil(basic_price * time_delta / 2^16) The storage fee uses account.bits and account.cells from AccountStorage, excluding ExtraCurrencyCollection stored in the other field. The other field is replaced with a single 0 bit that represents an empty HashmapE. CopyAsk AIextra_currencies$_ dict:(HashmapE 32 (VarUInteger 32)) = ExtraCurrencyCollection; currencies$_ grams:Grams other:ExtraCurrencyCollection = CurrencyCollection; account_storage$_ last_trans_lt:uint64 balance:CurrencyCollection state:AccountState = AccountStorage; DeduplicationStorage and forward fees treat identical subtrees referenced in multiple branches as one cell. Reused subtrees share a single stored copy and do not accrue additional charges. ​Compute fees All computation is measured in gas units. A TVM operation typically has a fixed gas cost, but that is not always the case. Network configuration defines gas prices; users cannot override them. ​Flat gas limit A contract invocation pays for at least flat_gas_limit gas units. Spending up to that limit costs flat_gas_price TON. If the contract spends gasUsed gas units, the fee is: CopyAsk AIconst gasUsed = 50_000n; // 0 = basechain, -1 = masterchain const prices = getGasPrices(configCell, 0); const gasFee = gasUsed <= prices.flat_gas_limit ? prices.flat_gas_price : prices.flat_gas_price + (prices.gas_price * (gasUsed - prices.flat_gas_limit)) / 65536n; ​Forward fee Forward fee is calculated with this formula: CopyAsk AIbodyFwdFee = priceForCells * (msgSizeInCells - 1) + priceForBits * (msgSizeInBits - bitsInRoot) fwdFee = lumpPrice + ceil(bodyFwdFee / 2^16) where: lumpPrice is the fixed value from config paid once for the message. msgSizeInCells is the number of cells in the message. msgSizeInBits is the number of bits in all the cells of the message. bitsInRoot is the number of bits in the root cell of the message. The formula excludes the message root cell because it mainly contains headers. lumpPrice covers that root cell. ​Action fee Action fee is the portion of fwdFee granted to the validator of the message’s source shard. The remaining fwdFee - actionFee amount goes to the validator of the destination shard. Action fee exists only for internal messages. CopyAsk AIaction_fee = floor(fwd_fee * first_frac / 2^16) Starting with Global Version 4, a failed SENDMSG action incurs a penalty proportional to the attempted message size. It is calculated as: CopyAsk AIfine_per_cell = floor((cell_price >> 16) / 4) max_cells = floor(remaining_balance / fine_per_cell) action_fine = fine_per_cell * min(max_cells, cells_in_msg); ​Import fee Import fee mirrors forward fee for inbound external messages. The root cell and its contents are covered by lumpPrice in the same way as internal messages. ​Helper functions (full code) CopyAsk AIimport { Cell, Slice, beginCell, Dictionary, Message, DictionaryValue } from '@ton/core'; export type GasPrices = { flat_gas_limit: bigint, flat_gas_price: bigint, gas_price: bigint }; export type StorageValue = { utime_since: number, bit_price_ps: bigint, cell_price_ps: bigint, mc_bit_price_ps: bigint, mc_cell_price_ps: bigint }; export class StorageStats { bits: bigint; cells: bigint; constructor(bits?: number | bigint, cells?: number | bigint) { this.bits = bits !== undefined ? BigInt(bits) : 0n; this.cells = cells !== undefined ? BigInt(cells) : 0n; } add(...stats: StorageStats[]) { let cells = this.cells, bits = this.bits; for (let stat of stats) { bits += stat.bits; cells += stat.cells; } return new StorageStats(bits, cells); } addBits(bits: number | bigint) { return new StorageStats(this.bits + BigInt(bits), this.cells); } addCells(cells: number | bigint) { return new StorageStats(this.bits, this.cells + BigInt(cells)); } } function shr16ceil(src: bigint) { const rem = src % 65536n; let res = src / 65536n; if (rem !== 0n) res += 1n; return res; } export function collectCellStats(cell: Cell, visited: Array<string>, skipRoot: boolean = false): StorageStats { let bits = skipRoot ? 0n : BigInt(cell.bits.length); let cells = skipRoot ? 0n : 1n; const hash = cell.hash().toString(); if (visited.includes(hash)) { return new StorageStats(); } visited.push(hash); for (const ref of cell.refs) { const r = collectCellStats(ref, visited); cells += r.cells; bits += r.bits; } return new StorageStats(bits, cells); } export function getGasPrices(configRaw: Cell, workchain: 0 | -1): GasPrices { const config = configRaw.beginParse().loadDictDirect(Dictionary.Keys.Int(32), Dictionary.Values.Cell()); const ds = config.get(21 + workchain)!.beginParse(); if (ds.loadUint(8) !== 0xd1) throw new Error('Invalid flat gas prices tag'); const flat_gas_limit = ds.loadUintBig(64); const flat_gas_price = ds.loadUintBig(64); if (ds.loadUint(8) !== 0xde) throw new Error('Invalid gas prices tag'); return { flat_gas_limit, flat_gas_price, gas_price: ds.preloadUintBig(64) }; } export function computeGasFee(prices: GasPrices, gas: bigint): bigint { if (gas <= prices.flat_gas_limit) return prices.flat_gas_price; return prices.flat_gas_price + (prices.gas_price * (gas - prices.flat_gas_limit)) / 65536n; } export const storageValue: DictionaryValue<StorageValue> = { serialize: (src, builder) => { builder .storeUint(0xcc, 8) .storeUint(src.utime_since, 32) .storeUint(src.bit_price_ps, 64) .storeUint(src.cell_price_ps, 64) .storeUint(src.mc_bit_price_ps, 64) .storeUint(src.mc_cell_price_ps, 64); }, parse: (src) => { return { utime_since: src.skip(8).loadUint(32), bit_price_ps: src.loadUintBig(64), cell_price_ps: src.loadUintBig(64), mc_bit_price_ps: src.loadUintBig(64), mc_cell_price_ps: src.loadUintBig(64) }; } }; export function getStoragePrices(configRaw: Cell): StorageValue { const config = configRaw.beginParse().loadDictDirect(Dictionary.Keys.Int(32), Dictionary.Values.Cell()); const storageData = Dictionary.loadDirect(Dictionary.Keys.Uint(32), storageValue, config.get(18)!); const values = storageData.values(); return values[values.length - 1]; } export function calcStorageFee(prices: StorageValue, stats: StorageStats, duration: bigint) { return shr16ceil((stats.bits * prices.bit_price_ps + stats.cells * prices.cell_price_ps) * duration); } export const configParseMsgPrices = (sc: Slice) => { const magic = sc.loadUint(8); if (magic !== 0xea) throw new Error('Invalid message prices magic number'); return { lumpPrice: sc.loadUintBig(64), bitPrice: sc.loadUintBig(64), cellPrice: sc.loadUintBig(64), ihrPriceFactor: sc.loadUintBig(32), firstFrac: sc.loadUintBig(16), nextFrac: sc.loadUintBig(16) }; }; export type MsgPrices = ReturnType<typeof configParseMsgPrices>; export const getMsgPrices = (configRaw: Cell, workchain: 0 | -1) => { const config = configRaw.beginParse().loadDictDirect(Dictionary.Keys.Int(32), Dictionary.Values.Cell()); const prices = config.get(25 + workchain); if (prices === undefined) throw new Error('No prices defined in config'); return configParseMsgPrices(prices.beginParse()); }; export function computeDefaultForwardFee(msgPrices: MsgPrices) { return msgPrices.lumpPrice - ((msgPrices.lumpPrice * msgPrices.firstFrac) >> 16n); } export function computeFwdFees(msgPrices: MsgPrices, cells: bigint, bits: bigint) { return msgPrices.lumpPrice + shr16ceil(msgPrices.bitPrice * bits + msgPrices.cellPrice * cells); } export function computeFwdFeesVerbose(msgPrices: MsgPrices, cells: bigint | number, bits: bigint | number) { const fees = computeFwdFees(msgPrices, BigInt(cells), BigInt(bits)); const res = (fees * msgPrices.firstFrac) >> 16n; return { total: fees, res, remaining: fees - res }; } export function computeCellForwardFees(msgPrices: MsgPrices, msg: Cell) { const storageStats = collectCellStats(msg, [], true); return computeFwdFees(msgPrices, storageStats.cells, storageStats.bits); } export function computeMessageForwardFees(msgPrices: MsgPrices, msg: Message) { if (msg.info.type !== 'internal') throw new Error('Helper intended for internal messages'); let storageStats = new StorageStats(); const defaultFwd = computeDefaultForwardFee(msgPrices); if (msg.info.forwardFee === default",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:24:21.267Z"
  },
  {
    "id": "docs-ton-org--foundations-traces",
    "title": "Traces",
    "url": "https://docs.ton.org/foundations/traces",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationBlockchain foundationsTracesBlockchain foundationsTracesCopy pageCopy pageA trace is a partially ordered set of messages. This set includes all dependent messages. In other words, if message B was sent while message A was being processed, then both of these messages belong to exactly one trace. Strictly speaking, this set is partially ordered according to the causal relation “A is sent as a result of processing B.” When drawing a trace, messages are usually drawn on the edges, and the addresses of the accounts to which the messages are sent are drawn at the vertices. Transactions that occurred on the account at that moment in time are also usually signed at the vertex. ​Start of the trace Most often, a trace begins with an external message. It is the first one, since there is no message that could generate an external-in. However, trace may be started not only by external messages but also by tick-tock transactions, commonly used within TON Blockchain system contracts. Traces can also start with split and merge transactions, but since they are not currently implemented, this will not occur in a real network. As a result, messages in the trace are partially ordered by their logical time (lt), reflecting their logical dependencies. The diagram shows transactions on independent accounts, each triggered by an incoming message, with lt values indicated for every message. It is important to note that in the network in general, lt is formed as follows: lt transactions = lt incoming message + 1 lt outgoing message = lt transaction + outgoing message index This scheme is not applicable to the first vertex if the trace is started by special transactions mentioned above, as in that case there is no incoming message for the first vertex. ​Traces representation in Tonviewer In Tonviewer, traces are visualized as directed acyclic graphs (DAGs), where transactions are nodes and messages are edges, showing the full sequence of account state changes. ​Examples The NFT transfer illustrates a single operation that consists of multiple messages. To learn how to read traces, follow this article. This trace is started with an external message and can be inspected in Tonviewer Here is the example of the trace that started with tick-tock transaction ​Access using API To fetch traces data, use the GET /traces endpoint. This method allows finding a trace if any of its parameters are known.Was this page helpful?YesNoSuggest editsRaise issuePreviousBlockchain shardingNext⌘IgithubxtelegramPowered by MintlifyOn this pageStart of the traceTraces representation in TonviewerExamplesAccess using API",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:24:23.165Z"
  },
  {
    "id": "docs-ton-org--foundations-shards",
    "title": "Blockchain sharding",
    "url": "https://docs.ton.org/foundations/shards",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationBlockchain foundationsBlockchain shardingBlockchain foundationsBlockchain shardingCopy pageCopy pageTON Blockchain is a collection of blockchains that are called workchains. Each workchain might have different formats of account addresses, formats of transactions, and different virtual machines for smart contracts. TON Blockchain dynamically splits workchains into halves when the transaction rate is above the threshold, and merges them when it decreases below the threshold. This is called Infinite Sharding Paradigm. Sharding is the general concept used to split the load into several parts, to ease requirements on a single computing element of some system. Each account is the sole citizen of its corresponding blockchain, accountchain. Each accountchain describes the state and state transitions of only one account. An accountchain is a virtual concept used in explanations. Regularly creating empty blocks for rarely updated accountchains would be too expensive. To reduce the cost, accountchains are grouped into shardchains, where each block is a collection of blocks of accountchains that have been assigned to this shard. ​Sharding process There might be up to 2^32 workchains, identified with workchain_id. Each workchain might use its own format for account_id, but every such ID must be at least 64-bit long. A pair of workchain_id and account_id uniquely identifies an account. Each shardchain is identified by a pair (workchain_id, shard_prefix), where shard_prefix is a bit string of length at most 60. Accounts that have account_id starting with shard_prefix (have shard_prefix as the most significant bits) will be assigned to this shardchain. When the volume of transactions per block exceeds the threshold, validators decide to split shards into halves. Assume a workchain initially has one shardchain with an empty shard_prefix, i.e., it contains all accounts of that workchain. Then the load exceeded the threshold and the validators decide to split this shardchain into two with shard_prefix equal to 0 and 1, respectively. After that, all accounts with an account_id starting with bit 0 will be assigned to the first shardchain, and all accounts with account_id starting with bit 1 will be assigned to the second shardchain. If some shardchain with shard_prefix equal to p needs to be split, then two new shardchains with shard_prefix equal to p0 and p1 will be created. When a merge is needed, two shardchains with shard_prefix equal to p0 and p1 merge into one shardchain with shard_prefix equal to p. After the merge, all accounts with account_id starting with p will be assigned to this new single shardchain. As a result of sharding process, the number of shardchains in each workchain is a power of two, and can vary dynamically from 1 to 2^60. ​Messages between shardchains Shardchains can exchange messages with each other. It works both for shardchains of the same and different workchains. Size of the block sets a limit to how many transactions a shardchain can process in a single block. Every shardchain can do computations asynchronously and in isolation from each other, so due to mismatch in the rate of message processing there might be an congestion: one shard sends messages to another, and it cannot process them at the moment. During congestion, handling of messages that do not fit into current block is delayed to next blocks. Unprocessed messages are still stored only in blocks of sending shardchains, and receiving shardchain would have to check for all the possible sending shardchains for possible unprocessed messages. In the case of a large number of shardchains, the inspection time for all sending shardchains may be too long. In addition, if a shardchain can receive messages from all other shardchains, then its blocks can fill up very quickly, which will lead to a large delay in outgoing messages in the remaining shardchains. Minimizing the time it takes to transfer data between different shardchains is crucial for complex protocols, such as token processing and decentralized exchanges (DEX). In these scenarios, different participants may be located in different shardchains, making it essential to optimize the communication process. To reduce the number of possible sending shardchains to only 16 * 15 neighboring shardchains, a hypercube routing mechanism is used. ​Hypercube routing The set of all shardchains of a given workchain and their connection to neighboring shardchains can be represented as a hypercube. Each vertex of the hypercube corresponds to a shardchain, and two shardchains are connected by an edge if they are neighbors. Omitting the technical details, the neighborhood relation is determined using the differences in the shard_prefix of the two shardchains. Finally, messages are routed between shardchains by moving them along the edges of such hypercube. As a simple example, consider a workchain that has eight shardchains with shard_prefix equal to 000, 001, 010, 011, 100, 101, 110, and 111. These shardchains can be represented as vertices of a three-dimensional cube, where two shardchains are connected by an edge if their shard_prefix differ by exactly one bit. Thus, a message from 001 shardchain to 110 shardchain will be routed along the edges of the cube following the path 001 -> 101 -> 111 -> 110. Hence, there are three hops between 001 and 110 shardchains. TON Blockchain uses a more complex version. The hypercube has 15 dimensions, and each shardchain has up to 16 neighboring shardchains (include itself) along each dimension. Hence, each shardchain has up to 16 * 15 = 240 neighboring shardchains in total and the maximum number of hops between any two shardchains in the same workchain is 15. If the source and destination shardchains belong to different workchains, then an additional hop between workchains is needed. The hypercube routing mechanism also has some additional features to ensure reliability and efficiency of message delivery, such as preventing double delivery of messages, processing messages in order of their logical time creation, and so on. For a detailed acquaintance with these processes, the reader can refer to the TON Blockchain whitepaper.Was this page helpful?YesNoSuggest editsRaise issuePreviousLimitsNext⌘IgithubxtelegramPowered by MintlifyOn this pageSharding processMessages between shardchainsHypercube routing",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:24:26.054Z"
  },
  {
    "id": "docs-ton-org--foundations-limits",
    "title": "Blockchain limits",
    "url": "https://docs.ton.org/foundations/limits",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationBlockchain foundationsBlockchain limitsBlockchain foundationsBlockchain limitsCopy pageCopy pageThis document contains the current limits and configuration parameters used in the TON blockchain. There are two sources of network parameter definitions: Blockchain config Node source code You can check all the blockchain parameters live in the explorers: Tonviewer or Tonscan.Parameters defined in the code can be found in the source code repository. ​Message and transaction limits NameDescriptionValueUnitsTypeDefined in max_sizeMaximum external message size in bytes65535bytesuint32mc-config.h:392max_depthMaximum external message depth512levelsuint16mc-config.h:393max_msg_bitsMaximum message size in bits2097152bitsuint32mc-config.h:395max_msg_cellsMaximum number of cells a message can occupy8192cellsuint32mc-config.h:396max_vm_data_depthMaximum cell depth in messages and c4 and c5 registers512levelsuint16mc-config.h:398max_actionsMaximum number of actions256countuint32transaction.hmax_library_cellsMaximum number of library cells1000cellsuint32mc-config.h:397max_acc_state_cellsMaximum number of cells that an account state can occupy65536cellsuint32mc-config.h:400max_acc_state_bitsMaximum account state size in bits67043328bitsuint32mc-config.h:401max_acc_public_librariesMaximum number of public libraries per account256countuint32mc-config.h:402 ​Gas and fee parameters NameDescriptionValueUnitsTypeDefined in free_stack_depthStack depth without gas consumption32stack entriesenum_valuevm.h:120runvm_gas_priceVM start gas consumption40gas unitsenum_valuevm.h:122flat_gas_limitGas below flat_gas_limit is provided at the price of flat_gas_price100gas unitsuint64config21flat_gas_priceCosts of launching the TON Virtual Machine40000nanotonsuint64config21gas_pricePrice of gas in the network in nanotons per 65536 gas units26214400nanotonsuint64config21special_gas_limitLimit on gas for special (system) contract transactions1000000gas unitsuint64config21gas_limitMaximum amount of gas per transaction1000000gas unitsuint64config21gas_creditGas credit for checking external messages10000gas unitsuint64config21block_gas_limitMaximum gas per block10000000gas unitsuint64config21 ​Storage fees and limits NameDescriptionValueUnitsTypeDefined in freeze_due_limitStorage fees (nanotons) for contract freezing100000000nanotonsuint64config21delete_due_limitStorage fees (nanotons) for contract deletion1000000000nanotonsuint64config21bit_price_psStorage price for one bit for 65536 seconds1nanotons/bituint64config18cell_price_psStorage price for one cell for 65536 seconds500nanotons/celluint64config18 ​Block size limits NameDescriptionValueUnitsTypeDefined in bytes_underloadBlock size limit for underload state131072bytesuint32config23bytes_soft_limitBlock size soft limit524288bytesuint32config23bytes_hard_limitAbsolute maximum block size in bytes1048576bytesuint32config23gas_underloadBlock gas limit for underload state2000000gas unitsuint32config23gas_soft_limitBlock gas soft limit10000000gas unitsuint32config23gas_hard_limitAbsolute maximum block gas20000000gas unitsuint32config23lt_delta_underloadLogical time delta limit for underload state1000lt unitsuint32config23lt_delta_soft_limitLogical time delta soft limit5000lt unitsuint32config23lt_delta_hard_limitAbsolute maximum logical time delta10000lt unitsuint32config23 ​Message forwarding costs NameDescriptionValueUnitsTypeDefined in lump_priceBase price for message forwarding400000nanotonsuint64config25bit_priceCost per 65536 bits of message forwarding26214400nanotons/bituint64config25cell_priceCost per 65536 cells for message forwarding2621440000nanotons/celluint64config25ihr_factorFactor for immediate hypercube routing cost98304factoruint32config25first_fracFraction for first transition in message route21845fractionuint32config25next_fracFraction for subsequent transitions in message route21845fractionuint32config25 ​Masterchain specific parameters NameDescriptionValueUnitsTypeDefined in mc_bit_price_psStorage price for one bit for 65536 seconds1000nanotons/bituint64config18mc_cell_price_psStorage price for one cell for 65536 seconds500000nanotons/celluint64config18mc_flat_gas_limitGas below flat_gas_limit on masterchain100gas unitsuint64config20mc_flat_gas_priceVM launch cost on masterchain1000000nanotonsuint64config20mc_gas_priceGas price on masterchain655360000nanotonsuint64config20mc_special_gas_limitSpecial contract gas limit on masterchain70000000gas unitsuint64config20mc_gas_limitMaximum gas per transaction on masterchain1000000gas unitsuint64config20mc_gas_creditGas credit for checking external messages10000gas unitsuint64config20mc_block_gas_limitMaximum gas per masterchain block2500000gas unitsuint64config20mc_freeze_due_limitStorage fees for contract freezing100000000nanotonsuint64config20mc_delete_due_limitStorage fees for contract deletion1000000000nanotonsuint64config20mc_bytes_underloadBlock size limit for underload state131072bytesuint32config22mc_bytes_soft_limitBlock size soft limit524288bytesuint32config22mc_bytes_hard_limitAbsolute maximum block size in bytes1048576bytesuint32config22mc_gas_underloadBlock gas limit for underload state200000gas unitsuint32config22mc_gas_soft_limitBlock gas soft limit1000000gas unitsuint32config22mc_gas_hard_limitAbsolute maximum block gas2500000gas unitsuint32config22mc_lump_priceBase price for message forwarding10000000nanotonsuint64config24mc_bit_priceCost per 65536 bits of message forwarding655360000nanotons/bituint64config24mc_cell_priceCost per 65536 cells for message forwarding65536000000nanotons/celluint64config24mc_ihr_factorFactor for immediate hypercube routing cost98304factoruint32config24mc_first_fracFraction for first transition in message route21845fractionuint32config24mc_next_fracFraction for subsequent transitions in route21845fractionuint32config24mc_lt_delta_underloadLogical time delta limit for underload state1000lt unitsuint32config22mc_lt_delta_soft_limitLogical time delta soft limit5000lt unitsuint32config22mc_lt_delta_hard_limitAbsolute maximum logical time delta10000lt unitsuint32config22mc_catchain_lifetimemasterchain catchain groups lifetime in seconds250secondsuint32config28 ​Validator parameters NameDescriptionValueUnitsTypeDefined in shard_catchain_lifetimeshardchain catchain groups lifetime in seconds250secondsuint32config28shard_validators_lifetimeshardchain validators group lifetime in seconds1000secondsuint32config28shard_validators_numNumber of validators in shardchain validation group23countuint32config28masterchain_block_feeReward for block creation1700000000nanotonsGramsconfig14basechain_block_feeBasechain block fee1000000000nanotonsGramsconfig14 ​Time parameters NameDescriptionValueUnitsTypeDefined in utime_sinceInitial Unix timestamp for price application0secondsUnixTimeconfig18 Was this page helpful?YesNoSuggest editsRaise issuePreviousConfigNext⌘IgithubxtelegramPowered by MintlifyOn this pageMessage and transaction limitsGas and fee parametersStorage fees and limitsBlock size limitsMessage forwarding costsMasterchain specific parametersValidator parametersTime parameters",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:24:27.056Z"
  },
  {
    "id": "docs-ton-org--foundations-config",
    "title": "Blockchain config",
    "url": "https://docs.ton.org/foundations/config",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationBlockchain foundationsBlockchain configBlockchain foundationsBlockchain configCopy pageCopy pageYou can view live values by using Tonviewer. This page provides a description of the configuration parameters used in the TON Blockchain. TON features a complex configuration consisting of many technical parameters, some of which are utilized by the blockchain itself, while others serve the ecosystem. However, only a limited number of individuals fully understand the significance of these parameters. This article aims to offer users a straightforward explanation of each parameter and its purpose. ​Prerequisites This material should be read alongside the parameter list. You can view the parameter values in the current configuration, and the method of writing them into cells is outlined in the block.tlb file in TL-B format. Configuration values are TL-B typed cells serialized into Bags of Cells (BoC). All parameters are in place, and you won’t get lost. For your convenience, please use the right sidebar for quick navigation. ​Param 0: config address This parameter is the address of a special smart contract that stores the blockchain’s configuration. The configuration is stored in the contract to simplify its loading and modification during validator voting. In the configuration parameter, only the hash portion of the address is recorded, as the contract always resides in the masterchain (workchain -1). Therefore, the full address of the contract will be written as -1:<value of the configuration parameter>. Parameter #0 on mainnet ​Param 1: elector address This parameter is the address of the elector smart contract, responsible for appointing validators, distributing rewards, and voting on changes to blockchain parameters. Parameter #1 on mainnet ​Param 2: TON minting address This parameter represents the address of the system, on behalf of which new Toncoin are minted and sent as rewards for validating the blockchain. If parameter 2 is missing, parameter 0 is used instead (newly minted Toncoin come from the configuration smart contract). Parameter #2 on mainnet ​Param 3: fee collector address This parameter is the address of the transaction fee collector. If this parameter is missing (for the time being), transaction fees are directed to the elector smart contract (parameter 1). Parameter #3 on mainnet ​Param 4: root DNS address This parameter is the address of the root DNS contract of the TON network. For details, see the original specification.This contract is not responsible for selling .ton domains. Parameter #4 on mainnet ​Param 6: extra currency fee This parameter is responsible for minting fees for new currencies. Parameter #6 on mainnet ​Param 7: extra currency volume This parameter stores the volume of each extra currency in circulation. The data is organized as a dictionary (also referred to as a hashmap). The structure uses the format currency_id -> amount, where the amount is represented as a VarUInteger 32, which is an integer ranging from 0 to 2^248-1. Parameter #7 on mainnet ​Param 8: network version This parameter indicates the network version and additional capabilities supported by the validators. Validators are nodes in the TON Blockchain network that are responsible for creating new blocks and verifying transactions. version: This field specifies the version. capabilities: This field is a set of flags that are used to indicate the presence or absence of certain features or capabilities. Thus, when updating the network, validators will vote to change parameter 8. This way, the TON Blockchain network can be updated without downtime. Parameter #8 on mainnet ​Param 9: mandatory params This parameter contains a list (binary tree) of mandatory parameters. It ensures that certain configuration parameters are always present and cannot be removed by a proposal to change the configuration until parameter 9 changes. Parameter #9 on mainnet ​Param 10: critical params This parameter represents a list (binary tree) of critical TON parameters whose change significantly affects the network, so more voting rounds are held. Parameter #10 on mainnet ​Param 11: config params This parameter indicates under what conditions proposals to change the TON configuration are accepted. min_tot_rounds: The minimum number of rounds before a proposal can be applied. Currently, this parameter is not used: only max_tot_round (when the proposal will be rejected) and min_wins (when the proposal will be accepted) matter. max_tot_rounds: The maximum number of rounds, upon reaching which the proposal will automatically be rejected min_wins: The required number of wins (3/4 of validators by the sum of the pledges must vote in favor) max_losses: The maximum number of losses, upon reaching which the proposal will automatically be rejected min_store_sec and max_store_sec determine the possible time interval during which the proposal will be stored bit_price and cell_price indicate the price of storing one bit or one cell of the proposal Parameter #11 on mainnet ​Param 12: Workchain config This parameter represents the configuration of a workchain in the TON Blockchain. workchains are designed as independent blockchains that can operate in parallel, allowing TON to scale and process a large number of transactions and smart contracts. ​Workchain configuration parameters enabled_since: A UNIX timestamp of the moment this workchain was enabled. actual_min_split: The minimum depth of the split (sharding) of this workchain, supported by validators. min_split: The minimum depth of the split of this workchain, set by the configuration. max_split: The maximum depth of the split of this workchain. basic: A boolean flag (1 for true, 0 for false) indicating whether this workchain is basic (handles TON coins, smart contracts based on the TON Virtual Machine). active: A boolean flag indicating whether this workchain is active at the moment. accept_msgs: A boolean flag indicating whether this workchain is accepting messages at the moment. flags: Additional flags for the workchain (reserved, currently always 0). zerostate_root_hash and zerostate_file_hash: Hashes of the first block of the workchain. version: Version of the workchain. format: The format of the workchain, which includes vm_version and vm_mode - the virtual machine used there. Parameter #12 on mainnet ​Param 13: complaint cost This parameter defines the cost of filing complaints about the incorrect operation of validators in the elector smart contract. Parameter #13 on mainnet ​Param 14: block reward This parameter indicates the reward for creating a block in the TON Blockchain. Values are in nanotons (also referred to as nanograms); therefore, the reward for block creation in the masterchain is 1.7 Toncoin, while in the basechain, it is 1.0 Toncoin. In the event of a workchain split, the block reward is also divided: if there are two shardchains within the workchain, then the reward for each shard block will be 0.5 Toncoin. Parameter #14 on mainnet ​Param 15: elections timing This parameter contains the duration of different stages of elections and validators’ work in the TON Blockchain. For each validation period, there is an election_id equal to the UNIX-format time at the start of the validation. You can get the current election_id (if elections are ongoing) or the past one by invoking the elector smart contract’s respective get-methods active_election_id and past_election_ids. ​Election and validation timing parameters validators_elected_for: The number of seconds the elected validators perform their role (one round). elections_start_before: The seconds before the end of the current round, when the election process for the next period will start. elections_end_before: The seconds before the end of the current round, the validators for the next round will be chosen. stake_held_for: The period for which a validator’s stake is held (for handling complaints) after the round expires. Each value in the arguments is determined by the uint32 data type. ​Examples In the TON Blockchain, validation periods are typically divided into even and odd rounds that alternate. Voting for the next round occurs during the previous one, so a validator must allocate their funds into two separate pools to participate in both rounds. ​Mainnet Current values: CopyAsk AIconstants = { 'validators_elected_for': 65536, # 18.2 hours 'elections_start_before': 32768, # 9.1 hours 'elections_end_before': 8192, # 2.2 hours 'stake_held_for': 32768 # 9.1 hours } Scheme: ​How to calculate periods? Let election_id = validation_start = 1600032768. Then: CopyAsk AIelection_start = election_id - constants['elections_start_before'] = 1600032768 - 32768 = 1600000000 election_end = delay_start = election_id - constants['elections_end_before'] = 1600032768 - 8192 = 1600024576 hold_st",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "testnet",
      "mainnet",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:24:29.034Z"
  },
  {
    "id": "docs-ton-org--foundations-services",
    "title": "Web3 services",
    "url": "https://docs.ton.org/foundations/services",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationBlockchain foundationsWeb3 servicesBlockchain foundationsWeb3 servicesCopy pageCopy pageAlthough many people refer to TON only as a blockchain, The Open Network is a combination of the following components: A flexible multi-blockchain platform with Turing-complete smart contracts (TON Blockchain) A peer-to-peer network used by Blockchain Nodes (TON Network) A distributed file storage technology (TON Storage) A network proxy/anonymizer layer (TON Proxy) A Kademlia-like distributed hash table (TON DHT) A service for assigning human-readable names to accounts, smart contracts, services, and network nodes (TON DNS) A platform for micro-payments (TON Payments) This article provides a general overview of TON Services, beyond the blockchain. ​TON Network TON Network is a peer-to-peer network used for accessing the TON Blockchain, sending transactions, and receiving updates. Also, it can support arbitrary distributed services, blockchain-related or not. The cornerstone in TON networking is the ADNL protocol, built on top of the TCP/UDP stack. The TON Distributed Hash Table (DHT) plays a crucial role in the networking component of the TON Project, as it is used to locate other nodes in the network. You can think of it as a big, persistent key-value data storage. The keys of the TON DHT are simply 256-bit integers. In most cases, they are computed as sha256 hashes of a TL-serialized objects. The values assigned to these 256-bit keys are essentially arbitrary byte strings of limited length. ​TON Storage TON Storage allows users to share and store files using The Open Network. Since storing files on-chain isn’t practical, TON Storage only stores Merkle proofs for file content on-chain. It uses TON DHT to find the nodes that have a copy of a required file (e.g., a snapshot of the state of a shardchain, or an old block). Then, one might essentially create a torrent for this file and use TON DHT as a “distributed torrent tracker” for this torrent. ​TON Proxy TON Proxy provides a protocol where nodes wishing to offer their services (with or without compensation) as tunnels for ADNL network traffic can register. Those needing them can then choose one of these nodes based on the price, latency, and bandwidth offered. Since ADNL traffic is encrypted, Proxy can’t access tunneled data, meaning that this protocol is secure. Running TON Proxy allows you to visit TON Sites (HTTP over ADNL). This can be combined with TON DNS and other TON Services, forming together what is called “Open Network”. ​TON DNS TON DNS is a service that translates human-readable domain names like test.ton or mysite.temp.ton into TON smart contract addresses, ADNL addresses used by services on the TON Network such as TON Sites, and more. The standard is implemented using smart contracts and config parameters. TON Domain names are well-established in the ecosystem - various wallet applications and explorers recognize them. TON Domains can be assigned to any ADNL address, meaning that it is possible to assign names to TON Storage files (bags). ​TON Payments TON Payments platform enables “instant payments” - a way to transfer monetary values without the need to commit all transactions to the blockchain. This protocol is built on top of TON Blockchain, using a system of smart contracts. The core idea for such a “lightning network” is point-to-point payment channels. Two parties create a shared “money pool” and then update the balance inside it. The overall overhead of such instant payments is so small that one can use them for micro-payments. For example, a TON file-storing service might charge the user for every 128 KiB of downloaded data, or a paid TON Proxy might require some tiny micro-payment for every 128 KiB of traffic relayed.Was this page helpful?YesNoSuggest editsRaise issuePreviousOverviewNext⌘IgithubxtelegramPowered by MintlifyOn this pageTON NetworkTON StorageTON ProxyTON DNSTON Payments",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:24:30.415Z"
  },
  {
    "id": "docs-ton-org--foundations-system",
    "title": "System contracts",
    "url": "https://docs.ton.org/foundations/system",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationBlockchain foundationsSystem contractsBlockchain foundationsSystem contractsCopy pageCopy pageThese are low-level TON Blockchain internals. You typically do not need to write or deploy these contracts. System contracts are smart contracts and have on‑chain addresses. See config parameters 1–4. The Config account stores the Config contract address. To track changes, review proposals to the Config contract. In TON, a set of special smart contracts controls consensus parameters for node operation — including TVM, catchain, fees, and chain topology — and how these parameters are stored and updated. Unlike older blockchains that hardcode these parameters, TON enables transparent on‑chain governance. The current governance contracts include the Elector and Config contracts, with expansion plans (for example, the extra‑currency Minter). ​Elector The Elector smart contract manages validator elections, validation rounds, and reward distribution. To become a validator and interact with the Elector, follow the validator instructions. ​Data storage The Elector stores: Non-withdrawn Toncoin in the credits hashmap. New validator applications in the elect hashmap. Past election data in the past_elections hashmap (including complaints and frozen stakes held for stake_held_for periods, defined in ConfigParam 15). ​Key functions Process validator applications Conduct elections Handle validator misbehavior reports Distribute validation rewards ​Processing applications To apply, a validator must: Send a message to the Elector with their Abstract Datagram Network Layer (ADNL) address, public key, max_factor, and stake (TON amount). The Elector validates the parameters and either registers the application or refunds the stake. Note: Only masterchain addresses can apply. ​Conducting elections The Elector is a special smart contract triggered by Tick and Tock transactions (forced executions at the start and end of each block). It checks whether it’s time to conduct a new election during each block. Process details: Take applications with stake ≥ min_stake (ConfigParam 17). Arrange candidates by stake in descending order. If applicants exceed max_validators (ConfigParam 16), discard the lowest-staked candidates. For each subset size i (from 1 to remaining candidates): Assume the i-th candidate (lowest in the subset) defines the baseline. Calculate effective stake (true_stake) for each j-th candidate (j < i) as: not runnableCopyAsk AImin(stake[i] * max_factor[j], stake[j]) Track the subset with the highest total effective stake (TES). Submit the winning validator set to the Config contract. Return unused stakes and excess amounts (e.g., stake[j] - min(stake[i] * max_factor[j], stake[j])) to credits. Example breakdown: Case 1: 9 candidates stake 100,000 TON (max_factor=2.7), 1 candidate stakes 10,000. Without the 10,000-stake candidate: TES = 900,000. With the 10,000-stake candidate: TES = 9 * 27,000 + 10,000 = 253,000. Result: 10,000-stake candidate are excluded. Case 2: 1 candidate stakes 100,000-stake (max_factor=2.7), 9 stake 10,000. Effective stake for the 100,000-stake candidate: 10,000 * 2.7 = 27,000. Excess: 100,000 - 27,000 = 73,000 → sent to credits. Result: All 10 participate. Election constraints: min_validators ≤ participants ≤ max_validators (ConfigParam 16). Stakes must satisfy: min_stake ≤ stake ≤ max_stake min_total_stake ≤ total stake ≤ max_total_stake Stake ratios ≤ max_stake_factor (ConfigParam 17). If conditions aren’t met, elections are postponed. ​Report validator misbehavior Each validator is periodically assigned the duty to create new blocks, with the frequency of assignments determined by their weight. After a validation round, anyone can audit the blocks to check whether the actual number of blocks produced by a validator significantly deviates from the expected number (based on their weight). A statistically significant underperformance (e.g., fewer blocks created than expected) constitutes misbehavior. To report misbehavior, a user must: Generate a Merkle proof demonstrating the validator’s failure to produce the expected blocks. Propose a fine proportional to the severity of the offense. Submit the proof and fine proposal to the Elector contract, covering the associated storage costs. The Elector registers the complaint in the past_elections hashmap. Current round validators then verify the complaint. If the proof is valid and the proposed fine aligns with the severity of the misbehavior, validators vote on the complaint. Approval requires agreement from over two-thirds of the total validator weight (not just a majority of participants). The fine is deducted from the validator’s frozen stake in the relevant past_elections record if approved. These funds stay locked for the period defined by ConfigParam 15 (stake_held_for). ​Distributing rewards The Elector releases frozen stakes and rewards (gas fees plus block rewards) proportionally to past validators. Funds move to credits, and the election record clears from past_elections. ​Config The Config contract manages TON’s configuration parameters, validator set updates, and proposal voting. ​Validator set updates The Elector notifies Config of a new validator set. Config stores it in ConfigParam 36 (next validators). At the scheduled time (utime_since), Config: Moves the old set to ConfigParam 32 (previous validators). Promotes ConfigParam 36 to ConfigParam 34 (current validators). ​Proposal/voting mechanism Submit a proposal: Pay storage fees to propose parameter changes. Vote: Validators (from ConfigParam 34) sign approval messages. Outcome: Approved: After min_wins rounds (ConfigParam 11) with ≥3/4 weighted votes. Rejected: After max_losses rounds. Critical parameters (ConfigParam 10) require more rounds. ​Emergency updates Reserved indexes (-999, -1000, -1001) allow urgent updates to Config/Elector code. A temporary emergency key (assigned to the TON Foundation in 2021) accelerated fixes but couldn’t alter contracts. Key retired on Nov 22, 2023 (block 34312810), replaced with zeros. Later patched to a fixed byte sequence (sha256(\"Not a valid curve point\")) to prevent exploits. Historical uses: Apr 2022: Increased gas limits (blocks 19880281/19880300) to unblock elections. Mar 2023: Raised special_gas_limit to 25M (block 27747086) for election throughput. Was this page helpful?YesNoSuggest editsRaise issuePreviousPrecompiled contractsNext⌘IgithubxtelegramPowered by MintlifyOn this pageElectorData storageKey functionsProcessing applicationsConducting electionsReport validator misbehaviorDistributing rewardsConfigValidator set updatesProposal/voting mechanismEmergency updates",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:24:31.725Z"
  },
  {
    "id": "docs-ton-org--foundations-precompiled",
    "title": "Precompiled contracts",
    "url": "https://docs.ton.org/foundations/precompiled",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationBlockchain foundationsPrecompiled contractsBlockchain foundationsPrecompiled contractsCopy pageCopy pageA precompiled smart contract is a contract with a native C++ implementation in the validator node. When a validator processes a transaction for such a contract, it can execute this native implementation instead of TVM. This improves performance and reduces computation fees. ​Config The list of precompiled contracts is stored in the blockchain configuration: CopyAsk AIprecompiled_smc#b0 gas_usage:uint64 = PrecompiledSmc; precompiled_contracts_config#c0 list:(HashmapE 256 PrecompiledSmc) = PrecompiledContractsConfig; _ PrecompiledContractsConfig = ConfigParam 45; The list:(HashmapE 256 PrecompiledSmc) represents a mapping of contract code hash to constant gas amount. A contract is considered precompiled if its code hash exists in this map. View current values on mainnet at ConfigParam 45 on Tonviewer. ​Accessing precompiled gas value Contracts can check their precompiled gas value using the GETPRECOMPILEDGAS opcode: Returns the configured gas_usage value if the contract code hash is in ConfigParam 45 Returns null if the contract code hash is not in ConfigParam 45 The value is also available in the c7 register environment tuple. ​Execution modes When a validator processes a transaction, the execution mode depends on whether the contract code hash is listed in ConfigParam 45. ​1. Contract is not precompiled The contract code hash is not in ConfigParam 45. TVM executes normally with standard gas accounting. GETPRECOMPILEDGAS returns null. Transaction result: gas_used reflects actual TVM consumption. ​2. Contract is precompiled The contract code hash exists in ConfigParam 45. The validator checks the contract balance against the configured gas_usage. If insufficient, the compute phase fails with cskip_no_gas. Otherwise, execution proceeds via one of two paths. ​Contract has native C++ implementation The native C++ implementation is available and enabled in the validator node. The validator executes the C++ code directly without invoking TVM. Transaction result: gas_used set to the value from ConfigParam 45 vm_steps, vm_init_state_hash, vm_final_state_hash set to zero ​Contract has no native C++ implementation The native C++ implementation is disabled or unavailable in the validator node. TVM executes the contract code normally. GETPRECOMPILEDGAS returns the configured gas value during execution. After execution completes, the validator overrides the compute phase values. Transaction result: gas_used set to the value from ConfigParam 45 vm_steps, vm_init_state_hash, vm_final_state_hash set to zero The override ensures that both execution paths produce identical transaction results. This allows validators with and without native C++ implementations to coexist in the network and enables gradual adoption when adding new entries to ConfigParam 45. ​Example: Stablecoin jetton wallet The jetton wallet from the stablecoin-contract project is the first contract code hash added to ConfigParam 45 on mainnet. This jetton wallet is optimized as a precompiled contract to reduce computation fees for stablecoin transfers. The contract implements standard jetton wallet functionality with additional governance features. The precompiled gas logic is implemented in gas.fc.Was this page helpful?YesNoSuggest editsRaise issuePreviousOverviewNext⌘IgithubxtelegramPowered by MintlifyOn this pageConfigAccessing precompiled gas valueExecution modes1. Contract is not precompiled2. Contract is precompiledContract has native C++ implementationContract has no native C++ implementationExample: Stablecoin jetton wallet",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "mainnet",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:24:32.897Z"
  },
  {
    "id": "docs-ton-org--foundations-glossary",
    "title": "Glossary",
    "url": "https://docs.ton.org/foundations/glossary",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationBlockchain foundationsGlossaryBlockchain foundationsGlossaryCopy pageCopy page​A ​Airdrop a free distribution of tokens among specific participants. ​Altcoin all cryptocurrencies, except Bitcoin, are called altcoins. ​Application Programming Interface (API) a mechanism that allows two programs to interact with each other through a series of protocols. ​Annual Percentage Yield (APY) a calculated yearly interest rate for a given asset. ​B ​Bearish the term “bearish” is used when the price of an asset has declined due to investors selling. (The term is often used to describe the overall market sentiment.) ​Binance a major cryptocurrency exchange. Website. ​Bitcoin (BTC) the preeminent cryptocurrency and the first decentralized network with open-source code, which laid the groundwork for the proliferation of blockchain technology. Wikipedia. ​Blockchain a distributed ledger of data in the form of a chain of blocks recording transaction information for every event on the network. ​Bag of Cells (BoC) serialization format for cells. Commonly used in code. Article. ​Bot a program written for two ecosystems to interact with each other — e.g., The Open Network and the Telegram messenger. On Telegram, bots are accounts in the messenger operated by software. ​Bridge a program connecting various blockchains to transfer tokens and data from one network to another. Article. ​Bullish the term “bullish” is used to describe an asset whose value is appreciating. (“Bullish” is the opposite of “bearish” — i.e., when the market’s overall value is increasing.) ​Burning the act of permanently removing tokens from circulating and total supply. ​C ​Centralized exchange (CEX) a centralized cryptocurrency exchange to trade tokens. ​CoinMarketCap (CMC) a crypto information aggregator that closely follows changes in token prices and market capitalization. Website. ​Coinbase a major cryptocurrency exchange based in the United States. Website. ​Cryptobot a peer-to-peer (P2P) bot service for buying, trading, and selling Toncoin and other cryptocurrencies. ​Custodial a type of crypto wallet where a third party stores cryptocurrencies, and not their true owner. ​D ​Decentralized application (dApp) applications run on-chain and rely on smart contracts for computation, storage, and communication. ​Dollar-cost averaging (DCA) an investment strategy whereby investors buy a fixed amount at regular intervals regardless of price to reduce timing risk. ​Decentralization one of the main tenets behind TON and other blockchains. Without decentralization, Web3 would be impossible to achieve; therefore, every element of the TON ecosystem revolves around maximizing decentralization. ​DeFi the decentralized analog to traditional finance; it includes accessible financial services and applications based on smart contracts. ​Decentralized exchange (DEX) an exchange where users can trade cryptocurrencies without any intermediaries. The online entity needed to guarantee safe transactions is the blockchain itself. ​Diamond hands a colloquial term describing an investor who has no intention of selling their assets regardless of the state of the market — even if there’s a crash or the market is bearish. ​Domain Name System (DNS) a technology that translates human-readable domain names (e.g. ton.org) to machine-readable IP addresses (e.g. 192.0.2.44). ​Dolphin an investor who has relatively small capital but has an influence on the community. ​Donate a bot service on Telegram through which people can donate money, and content creators can monetize their channels and services in Toncoin. ​Dump rapidly selling a cryptocurrency or asset, often causing a price decline. ​Durov Pavel Durov, a Russian entrepreneur who is famous for having founded the VK social network and Telegram messenger. Nikolai Durov is Pavel’s brother, who helped develop VK, Telegram, and TON. ​Do Your Own Research (DYOR) the process by which you do research on a project, company or cryptocurrency before deciding to invest. ​E ​Ethereum Virtual Machine (EVM) a machine behaving like a decentralized computer, it computes the state of the Ethereum blockchain after each new block and executes smart contracts. ​Exchange a place for trading and using other market instruments. ​F ​Farming lending your crypto assets to receive rewards. ​Fiat regular money issued by central banks or financial authorities. ​Fear of missing out (FOMO) a psychological state that consumes some investors when the idea of losing potential gains from an opportunity is present. It usually appears during a bull market and when traders don’t do their due diligence analyzing a particular project. ​Fungible tokens cryptocurrencies that carry the same value as any other token of the same kind at any given moment. ​FUD “fear, uncertainty, and doubt,” market sentiments based on many factors. ​Full node a computer on blockchain that synchronizes and copies the entire blockchain. ​FunC the smart contract language on TON. ​G ​Gas the fee paid for transactions on the blockchain. ​GitHub a platform for hosting code and collaborating via Git repositories. ​H ​Hackathon a collaborative event where programmers and builders develop software projects. ​Hash a fixed-size digest computed from data using a hashing algorithm. ​Hash rate the indication of how much computational power is being used on a network for crypto mining. ​Hold saving — i.e., not selling — an asset or assets from your portfolio. ​I ​Initial Coin Offering (ICO) a method for crypto projects to attract capital in the early stages. ​Initial Decentralized exchange Offering (IDO) a method of attracting capital when launching a cryptocurrency or token on a decentralized exchange. ​Inflation the process when the value of a currency — e.g., U.S. dollar or the euro — decreases. Toncoin has predictable issuance and a low inflation rate. ​K ​Know Your Customer (KYC) the process by which a user verifies their identity when creating an account for a crypto service. ​L ​Launchpad a platform for crypto startups that brings investors and projects together. ​Liquidity pool grouping together crypto assets and freezing them in a smart contract. Liquidity pools are used for decentralized trading, loans, and other endeavors. ​M ​Mainnet the main network of a blockchain. ​Market capitalization (market cap) the total market value of a cryptocurrency’s circulating supply. ​Masterchain the main chain that references shard and workchain blocks; a shard block is finalized once a Masterchain block references it. ​Metaverse a digital universe similar to a video game where users create avatars and interact with the digital representations of other people or users. ​Moon a crypto term that describes a crypto asset’s vertical trajectory on a price chart — i.e., it quickly gains value. ​N ​”Not financial advice” (NFA) acronym used as a disclaimer to avoid liability or responsibility when investors discuss cryptocurrencies or projects with other people. ​Non-fungible token (NFT) a unique digital token on a blockchain that cannot be duplicated or minted more than once. ​Nominator those who provide financial resources to validators so the latter can confirm blocks on TON blockchain. ​Non-custodial a kind of crypto wallet that gives full control over assets to the owner/user. ​O ​Off-ramp ways to convert cryptocurrencies into fiat money. ​On-ramp ways to convert (buy) cryptocurrency by spending fiat money. ​Onion routing a technology similar to Tor that allows anonymous interactions on a network. All messages are encrypted in various layers akin to an onion. TON Proxy applies such a technique. ​P ​Paper hands an investor who’s inclined to panic-sell — an inexperienced investor. ​Proof-of-stake a consensus mechanism to process transactions in new blocks on the blockchain. ​Proof-of-work a consensus algorithm where one party proves to another that a specific amount of computational work was spent. By expending a little energy, a party can verify this. ​Proxy a service on a computer network that allows clients to establish indirect network connections with other network services. ​Pump artificially inflating the price of a cryptocurrency or asset. ​Peer-to-peer (P2P) transactions among users without the help of a third party or intermediary. ​R ​Roadmap a project’s strategic plan that displays when its products, services, updates, etc. will be released. ​Return on investment (ROI) the profits made from investments. ​S ​Soulbound token (SBT) an NFT that can never be transferred because it contains information about its owner and their accomplishments. ​Scalability the ability of a blockchain network to process complex transactions as well as a large number of them. ​Securities and Exchange Commission (SEC) a financial regulator in the United States. Website. ​Shard a mecha",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "dapp",
      "api",
      "sdk",
      "testnet",
      "mainnet",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:24:34.984Z"
  },
  {
    "id": "docs-ton-org--contribute-style-guide",
    "title": "Documentation style guide",
    "url": "https://docs.ton.org/contribute/style-guide",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationContributeDocumentation style guideContributeDocumentation style guideCopy pageCopy pageThis guide covers the basics: how to structure pages, write examples, and keep docs consistent and safe. ​Write for the reader Default audience: experienced software developers new to blockchain. Explain TON-specific concepts. Do not re-teach general programming. This keeps pages focused. Be answer‑first. Start with what the reader will achieve, what they need, and the steps. This shortens the time to success. Lead with a working example. Show a copy‑pasteable snippet early and the expected output. This shows it works. Use a neutral, precise tone. Write in the present tense, active voice, and second person (“Run the node”). This makes actions clear. Avoid marketing or hype (“blazingly fast”, “seamless”, “revolutionary”) and vague praise. Prefer measurable facts or omit the claim. Keep it scannable. Use short sections and paragraphs, clear headings, lists, and tables. Most readers skim to find the next action. Aim for one main idea per sentence. Split long, multi‑clause sentences or turn them into lists. Use bold only for a few scan‑worthy words in a paragraph, not full sentences or tokens. If a skimming reader loses nothing when the bold is removed, drop it. Use italics for new or defined terms and subtle emphasis; use bold for words a skimming reader should find quickly. Draft in plain text first. During editing, add minimal emphasis and remove any styling that does not change meaning. ​Page types Step-by-step guides — for beginners; handhold from zero to first success on one happy path; explain from scratch, define terms, and link out for depth. How-tos — a focused recipe for a specific outcome; assume concepts known and show only what’s needed. Explanation — concepts, architecture, and trade‑offs; clarify why and when, with minimal examples. Reference — exact, complete facts (APIs, CLI, types, errors); stable anchors and minimal prose. Don’t mix types on the same page. ​Where pages go Keep the flow linear; follow the docs.json sidebar. In each topic group, order pages: Explanation → How‑to → Reference. Canonical specs — reference/. Link to it; don’t duplicate tables or parameters. ​Structure pages for success Start with Objective and Prerequisites so readers know they’re in the right place. Use Prerequisites for things the reader must have or have done; use an Audience note for skills or knowledge. Make each step a single action; use sub‑bullets for options. Include Verify and Troubleshoot so readers can confirm success and fix common errors. End with Next steps / See also only if essential (1–3 links). Prefer a linear path that needs no extra navigation. ​Examples that run Make commands copy‑pasteable. Do not include shell prompts like $ or >. Prompts break commands when pasted. Separate command and output. Use two fenced blocks. Mixing them causes copy errors. Use <ANGLE_CASE> placeholders in commands and prose and define each on first use (for example, <RPC_URL>). In code, use UPPER_SNAKE if < > clashes with syntax. One clear convention prevents hard‑coded values from slipping in. Tag code fences with a language (bash, json, rust, and so on). This enables correct highlighting and tooling. Prefer end‑to‑end examples on testnet by default. Safe defaults encourage trying the steps. Label partial snippets as Not runnable and link to a complete example. Do not hard‑wrap long commands. Use soft wrap in the UI or safe continuation if the shell supports it. Hard wraps break execution. For UI buttons, menu items, and key names, wrap the label in <kbd>…</kbd> instead of quotes or bold. This keeps controls easy to spot and consistent with the main style guide. Good CopyAsk AIton-node start --ledger <LEDGER_DIR> --network testnet Expected output CopyAsk AINode started. Workchain: 0 Shard: -1 Status: running Define placeholders <LEDGER_DIR> — local ledger directory. <RPC_URL> — HTTPS endpoint of your TON RPC provider. ​Safety warnings Add a Caution or Warning when a step moves funds, changes fees or withdrawals, exposes or stores private keys or mnemonics, modifies validator or network settings, or performs chain‑affecting operations such as resharding, pruning, halting, or replay. These actions can cause irreversible loss or outages. On long guides with many risky commands, combine a clear page‑level warning at the top (covering risk, scope, rollback where feasible, and environment) with short local notes next to each critical step. Local notes can be brief if they point back to the main warning. Pattern Warning — funds at risk Running the next command on mainnet transfers funds irreversibly. Safer first (testnet): CopyAsk AIjetton transfer --to <ADDR> --amount <AMOUNT> --network testnet If you must use mainnet: no rollback; on‑chain transfers are final. Default to testnet in task pages. Make destructive flags opt‑in and document mitigations. ​Necessary disclaimers Add a Caution or Warning when a page or step: Moves funds or changes fee/withdrawal behavior. Exposes, stores, or transmits private keys or mnemonics. Modifies validator configuration, networking, or other consensus‑affecting parameters. Performs chain‑affecting operations (for example, resharding, pruning, halting, replay). Uses destructive flags or commands that delete, rewrite, or lock state (for example, --purge, --force). Runs on mainnet, where actions are irreversible; label the environment and give the safer testnet first. Make sure the guide as a whole clearly covers the risk, scope, rollback or mitigation (where feasible), and the environment label (testnet vs mainnet). For a single hazardous step, put these points directly in its callout. On long risky guides, put a big safety callout at the top and keep step‑level notes short, pointing back to that summary. ​Titles and headings Use sentence case. Keep headings concise and unique. Use imperatives for tasks (“Deploy a validator”); nouns for concepts (“Validator architecture”). Titles should signal action vs. explanation. Don’t style headings, except when an identifier needs code font. Use clear section labels such as Verify, Troubleshoot, and See also. ​Link to details, don’t duplicate On first useful mention, link flags, parameters, error codes, and data types to their reference anchors. Do not paste reference tables into guides. Link instead. Duplicated tables go stale. Use descriptive link text that names the destination, not generic labels like “click here”, “here”, or “this page”, and avoid mechanics-focused link labels like “click” or “go to”. Link core TON terms to the Glossary on first useful mention unless you define them on the page. Internal links MUST be root‑absolute (start with /). Deep‑link to the exact section or anchor that contains the needed fact (not the page top). MUST NOT use relative segments like ./ or ../ in any Markdown/MDX link. (Why: content moves frequently; root‑absolute links survive reorganizations.) ​Images Use the <Image> component for all images. Markdown image syntax ![...](...) and raw <img ...> are not allowed. Store images under resources/images/ and reference them with root‑absolute paths, for example <Image src=\"/resources/images/<GROUP>/<FILE>.png\" />. MUST NOT use relative src such as ./ or ../. Provide meaningful, non‑empty alt text (never alt=\"\"); add darkSrc when the dark theme needs different contrast. Keep sizes/aspect ratios consistent across a page. SVGs: if you omit darkSrc, colors are auto‑inverted in dark mode; add darkSrc if inversion isn’t correct. ​Terminology and names Use the project term bank for canonical spellings, casing, and preferred terms. One vocabulary prevents drift. Examples: TON, jetton, smart contract, BoC (bag of cells), accountchain, shardchain, workchain, masterchain, basechain. Prefer allowlist and denylist over whitelist and blacklist. These are clearer and inclusive. Use mainnet and testnet as common nouns. Use TON Mainnet and TON Testnet for the proper names. This distinguishes the generic type from the named network. ​Files, front matter, labels Filenames use kebab-case.md or kebab-case.mdx (for example, validator-setup.mdx). This is readable and consistent across platforms. Optional front matter can declare doc_type, audience, and status (experimental or deprecated). If deprecated, add an Important callout with the replacement and timeline. Keep sidebar labels short (2–4 words) and mirror in‑page headings. ​Accessibility Use plain English; avoid idioms and culture-specific references. Use American English spelling (e.g., color, analyze). Write descriptive headings and link text. Tables should have headers and units (for example, “Latency (ms)”) and keep cells brief. Provide text alternatives for complex figures when possible. Avoid emojis. Only use them where they follow a common",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "testnet",
      "mainnet",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:24:37.467Z"
  },
  {
    "id": "docs-ton-org--contract-dev-blueprint-overview",
    "title": "Blueprint overview",
    "url": "https://docs.ton.org/contract-dev/blueprint/overview",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentOverviewSmart contract developmentDeployment and interactionCollecting test coverageBenchmarking performanceConfiguring BlueprintBlueprint CLIBlueprint TypeScript APITestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationDevelopment environmentBlueprint overviewContract developmentDevelopment environmentBlueprint overviewCopy pageCopy pageFor smart contract development on TON Blockchain, Blueprint is an all-in-one development environment designed to enhance the process of creating, testing, and deploying smart contracts. It includes: Blueprint — core tools for building contracts. Sandbox — fast local testing in an isolated blockchain. Create TON App — scaffolding a ready-to-use project. Testing utils — testing helpers and unit test matchers. This section covers development, testing, smart contracts deployment and interaction, performance benchmarks, and blueprint configuration and reference. ​Quick start To get started immediately, run the following command to create a new project and follow the on-screen instructions: CopyAsk AInpm create ton@latest ​Key features Project scaffolding — create a ready-to-use development environment with npm create ton@latest. Streamlined workflow — build, test, and deploy smart contracts efficiently. Simple deployment — publish contracts to Mainnet and Testnet directly from your wallet. Fast local testing — run multiple contracts in an isolated in-process blockchain. ​Requirements Node.js version 22 or later Verify the version with node -v ​IDE plugins List of plugins JetBrains IDEs Visual Studio Code ​Environment setup Run and follow the on-screen instructions: npm create ton@latest. From the project directory, run npm install to install dependencies. ​Project structure contracts/ — smart contract source code and imports. scripts/ — deployment scripts for Mainnet and Testnet, as well as scripts for interacting with live contracts. tests/ — TypeScript test suite for all contracts, using Sandbox for in-process execution. wrappers/ — TypeScript interface classes for all contracts except Tact. Each wrapper implements the Contract interface from @ton/core. Provides message serialization and deserialization, getter wrappers, and compilation helpers. Used in both the test suite and client code to interact with contracts from TypeScript. build/ — compilation artifacts generated by the build command. Was this page helpful?YesNoSuggest editsRaise issuePreviousSmart contract developmentNext⌘IgithubxtelegramPowered by MintlifyOn this pageQuick startKey featuresRequirementsIDE pluginsEnvironment setupProject structure",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "testnet",
      "mainnet",
      "transaction",
      "deployment",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:24:40.076Z"
  },
  {
    "id": "docs-ton-org--ecosystem-ton-connect",
    "title": "TON Connect overview",
    "url": "https://docs.ton.org/ecosystem/ton-connect",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectOverviewIntegrate a dAppIntegrate a walletManifestsMessage lookupWalletKitTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationTON ConnectTON Connect overviewEcosystemTON ConnectTON Connect overviewCopy pageCopy pageTo integrate with TON, the standard wallet connection protocol is used — TON Connect. It is similar to WalletConnect on Ethereum, but made specifically for TON and covers basic integration aspects. For deeper integrations, it’s common to utilize various supplementary SDKs and APIs. ​About TON Connect Your browser does not support the <video> tag. TON Connect enables secure communication between wallets and decentralized applications, allowing users to authorize transactions while maintaining control of their private keys. Currently, TON Connect supports over 30 wallets and connects to hundreds of major applications across the TON ecosystem. As the mandatory connection protocol for all Telegram Mini Apps, it serves as the gateway to TON’s entire ecosystem of applications and services. Think of it as the essential infrastructure that your institutional clients will need to access any TON-based services — from DeFi protocols to gaming applications to payment systems. For technical architecture details: TON Connect protocol specification on GitHub. ​Are you building a web3 app? Explore the demo apps made with React. Demo TON dApp with ReactDemo TON dApp GitHub repository Proceed with integration and usage recipes. How to integrate a dApp with TONCommon usage examples Skim the related reference pages. App manifest@tonconnect/sdk@tonconnect/ui@tonconnect/ui-react ​Are you building a web3 wallet? Follow the step-by-step guide. How to make a wallet on TON Or skim the related reference pages. Wallet manifestWalletKit reference@tonconnect/protocol For more, see the TON Connect articles from Google Docs. QA GuideNative or web walletsIn-app or browser extension wallets ​Join the community If you have questions about integrating TON into your project, need help troubleshooting issues, or want to discuss best practices with other developers, join our community channels. Telegram folder with many developer chatsList of skilled professionals and agencies ​See also Technical specification of the TON Connect protocol (GitHub) Official list of wallets that support TON Connect (GitHub) HTTP bridge for TON Connect Was this page helpful?YesNoSuggest editsRaise issuePreviousIntegrate a dAppNext⌘IgithubxtelegramPowered by MintlifyOn this pageAbout TON ConnectAre you building a web3 app?Are you building a web3 wallet?Join the communitySee also",
    "category": "integration",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "dapp",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "react",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:24:42.755Z"
  },
  {
    "id": "docs-ton-org--ecosystem-node-overview",
    "title": "Overview",
    "url": "https://docs.ton.org/ecosystem/node/overview",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeOverviewRun a node with MyTonCtrlRun a validatorIntegrate MyTonCtrl with PrometheusSetting up a local blockchain using MyLocalTonMyTonCtrl referenceStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationBlockchain nodeOverviewEcosystemBlockchain nodeOverviewCopy pagePick the right TON node setup and understand the operational work it requires.Copy pageA full node is a software that stores the whole blockchain state locally, opposite to lite-clients, which request small pieces of data from liteservers when needed. It does not solve any problem itself, but provides a base for other services requiring a full blockchain state (validator, liteserver, etc). Usually, full nodes keep only the latest part of the blockchain state, which is vital for ensuring client applications’ network stability and operation. Full nodes prune the state of the TON blockchain they keep. This means the full node automatically removes earlier blocks that become unnecessary for the network to manage its data volume effectively. To allow client applications to look for blocks and transactions and send new transactions into the TON blockchain, full nodes are equipped with the liteserver functionality. A full node can be set up using mytonctrl tool, which also activates validator or liteserver mode for you. ​Full node modes RoleWhat it doesWhen to use itLiteserverStores the latest shards, tracks the masterchain, and serves data to lite-clients.Required for custom infrastructure, analytics, or to back your own APIs.Archive liteserverStores all blockchain data, including old blocks and states.Required for explorers and other services working with historical data.ValidatorSigns blocks, participates in elections, and earns rewards.Needed to run validation with your stake or to operate a nominator pool service.CollatorProduces blocks for validators.Needed to reduce load on your validators by setting up block creation on a separate machine.Nominator poolAccepts funds from stakers and runs a validator with their stake.Needed when you want to securely accept stakes from multiple parties and share rewards between them.Single nominatorSecure way to run a validator without depositing all funds to a hot wallet.Generally, you should use it each time you want to run a new validator.Liquid stakingSame as nominator pool, but exchanges stakers’ funds for a synthetic token to be used in DeFi.Needed to run a liquid staking protocol. ​Do you need your own node? Run your own full node when you need guaranteed uptime or to serve high-volume workloads without third-party rate limits. Validators and staking services need to install a node and activate validator mode. Rely on public endpoints when building prototypes or light integrations. Community liteservers and APIs such as TON Center or other RPC providers already expose the blockchain for read access and transaction submission. ​Pick your target environment If you needRunValidator or nominator capacitySetting up a node using MyTonCtrl with the validator, nominator pool, or single nominator workflows; the wrapper automates validator wallets, overlays, elections, and upgrades.Liteserver APIsSetting up a node using MyTonCtrl with liteserver option (and archive mode if needed) to expose API for applications.An isolated development networkSetting up a local blockchain using MyLocalTon to spin up a local shard, explorer, and APIs for rapid iterations with no mainnet impact. ​Full node The full node is a basic node type within the TON blockchain. It serves as the backbone of the TON blockchain by keeping its block history — in other words, its current state. Compared to archive nodes, full nodes keep only the latest part of the blockchain state, which is vital for ensuring client applications’ network stability and operation. Full nodes prune the state of the TON blockchain they keep. This means the full node automatically removes earlier blocks that become unnecessary for the network to manage its data volume effectively. To allow client applications to look for blocks and transactions and send new transactions into the TON blockchain, full nodes are equipped with the liteserver functionality. ​Archive node The archive node is a full node that keeps the entire block history of the TON blockchain. These nodes act as the decentralized point of truth to ensure consistency of the whole blockchain history. They are a backend for blockchain explorers and other applications relying on deep transaction history. Archive nodes do not prune the blockchain state, elevating system requirements, especially in storage. According to the latest estimations, while full and validator nodes require about 1 TB of disk space, archive nodes need about 12 TB to store the complete block history. ​Validator node Validator nodes or validators are the TON network participants who propose new blocks and verify transactions according to the TON’s proof-of-stake mechanism. In this way, validators contribute to the overall blockchain security. Validators get rewards in TON for successful participation in the validation process. To be entitled to propose and validate blocks, other participants elect validators based on the amount of TON they hold — in other words, their stake. The more TON a validator stakes, the higher its chances of being elected, validating blocks for the network, and earning rewards. As a rule, validator operators motivate other TON holders to stake with them to get passive income from the resulting rewards. In this way, validators ensure network stability and security and contribute to its growth. ​Interacting with TON nodes TON nodes can run in liteserver mode, which allows external applications to interact with the TON blockchain. In this mode, the nodes process requests from clients, enabling them to access blockchain data, send transactions, and retrieve information about blocks and transactions. Liteserver uses the Abstract Datagram Network Layer (ADNL) protocol, so you generally also use ton-http-api (a TON Center-like API), which acts as an HTTP-to-ADNL frontend and exposes an HTTP API. Full and archive nodes typically enable liteserver mode because they store blockchain history and handle external requests. In contrast, validator nodes do not need it as they focus on validating new blocks efficiently without extra workload from external queries. You have two options to allow your application to interact with the TON blockchain: To have a stable connection, you can set up your own full or archive node with a liteserver mode and ton-http-api enabled using MyTonCtrl. If you cannot set up your TON node with a liteserver, you can use TON Center or other RPC providers. Was this page helpful?YesNoSuggest editsRaise issuePreviousRun a node with MyTonCtrlProvision hardware, install MyTonCtrl, and follow runbooks for validator, liteserver, or archive roles.Next⌘IgithubxtelegramPowered by MintlifyOn this pageFull node modesDo you need your own node?Pick your target environmentFull nodeArchive nodeValidator nodeInteracting with TON nodes",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "frontend",
      "backend",
      "api",
      "sdk",
      "mainnet",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:24:45.588Z"
  },
  {
    "id": "docs-ton-org--ecosystem-staking-overview",
    "title": "Staking overview",
    "url": "https://docs.ton.org/ecosystem/staking/overview",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingOverviewAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationStakingStaking overviewEcosystemStakingStaking overviewCopy pageCopy pageStaking in TON enables earning rewards by locking Toncoin to support network security and validation. This guide covers the main staking options available and how to choose the right approach. ​Staking options This page focuses on practical staking methods. TON offers several staking approaches, each with different requirements, benefits, and use cases: ​Classic staking Classic staking involves running a validator node directly using MyTonCtrl. This method provides full control over validation and requires technical expertise to set up and maintain. Stake requirementsTechnical minimum stake is 300,000 TON, but validators compete for 400 slots per validation round. The actual minimum stake is ~700,000 TON. Check current validator stakes at tonscan.org/validators (scroll to the bottom to see the validator with the lowest stake). Documentation: See MyTonCtrl validator documentation for detailed setup and management instructions. ​Liquid staking Liquid staking protocols tokenize staked positions, enabling stakers to receive liquid tokens that represent staked TON. These tokens can be used in DeFi while the underlying TON earns rewards. Benefits: Liquidity: Access staked funds without unstaking delays Composability: Use tokens in DeFi protocols and dApps Decentralization: Flexible staker-validator connections without central pools Accessibility: Low minimum deposits for broader participation Voting power: Some protocols allow governance influence Safety: Reduced slashing risks via diversification Diversification: Easy fund spreading across validators Tonstakers: Minimum stake: 1 TON Liquid token: tsTON Withdrawal: Instant if funds available; otherwise up to 18 hours Voting for network proposals Automated compounding Decentralized validation Bemo: Minimum stake: 1 TON Liquid token: bmTON Withdrawal: 36-72 hours cooldown Centralized validation Hipo: Minimum stake: Varies Liquid token: hTON Withdrawal: Average 30 hours; instant (1 minute) if funds available Centralized validation Protocol comparison: ProtocolMin depositLiquidityVotingWithdrawalDecentralized validationTonstakers1 TONYes (tsTON)YesUp to 18h (instant possible)YesBemo1 TONYes (bmTON)No36-72h cooldownNoHipoVariesYes (hTON)NoAvg 30h (instant possible)NoTON Whales50 TONNoNoUp to 18hNoTON Nominators10,000 TONNoYesUp to 18hNo All validators participating in these protocols use MyTonCtrl for validation. For validator setup instructions, see: Tonstakers setup Nominator pool setup Single nominator pool setup ​Nominator pools Nominator pools are smart contracts that allow nominators to delegate their Toncoin to a validator for staking. The pool ensures validator funds are used exclusively for validation and guarantees proper reward distribution. How it works: Nominators deposit funds into a pool managed by a validator The validator uses combined funds (validator’s own + nominators’) for validation Rewards are distributed proportionally: validator receives a share (set by validator_reward_share), remaining rewards go to nominators based on their stake size If validator performs poorly and gets fined, the fine is deducted from validator’s balance first; if insufficient, losses are deducted from nominators proportionally Validator must maintain sufficient funds to cover maximum possible fines Key parameters: Minimum nominator stake: 10,000 TON (recommended configuration) Maximum nominators per pool: 40 Operational costs: ~5 TON per validation round (paid by validator) Partial withdrawals: Not supported — only full withdrawal available Voting: Nominators can vote on network configuration proposals When to use: Staking below validator minimum (300,000 TON) Delegating to trusted validators without running infrastructure Participating in network governance through voting Simple staking without liquidity tokens or DeFi participation How to stake: Find a suitable pool on TON Nominators — check pool parameters, validator commission, and minimum stake requirements Send a message to the nominator pool contract with TON and text comment \"d\" (deposit) Amount must be ≥ min_nominator_stake + 1 TON (1 TON is deducted as deposit fee) If pool is not validating, deposit is credited immediately; otherwise, it’s added to pending deposits How to withdraw: Send a message to the nominator pool contract with text comment \"w\" (withdraw) and ~1 TON for network fee If pool has sufficient balance, withdrawal is immediate; otherwise, a withdrawal request is created Only full withdrawal is supported — partial withdrawals are not available How to vote: Find the proposal hash posted in @tonblockchain or @tonstatus Send a message with comment \"y<HASH>\" to vote for, or \"n<HASH>\" to vote against (e.g., \"yD855FFBCF813E50E10BEAB902D1177529CE79785CAE913EB96A72AE8EFBCBF47\") Attach ~1 TON for network fee Reward calculation: Use TON Center Nominator Pools API to calculate nominator rewards for each round of validation Available API methods: getPoolBookings — get all the bookings (debits and credits) in specified pool getNominatorBookings — get nominator bookings (debits and credits) in specified pool getNominatorEarnings — get nominator income in specified pool with his stake on each timepoint getNominator — get nominator’s balances in all pools where he participates getPool — get pool data with all its nominators Setup for validators: MyTonCtrl nominator pools — standard pools with multiple nominators Nominator pools can be configured with minimum stake of 100 TON (not recommended — 10,000 TON is the tested and recommended configuration) Use nominator pool contract to deploy a pool without MyTonCtrl ​TON Whales nominator pools TON Whales is a nominator pool service built on custom smart contracts by the TON Whales team. It provides the same core functionality as standard nominator pools but with different implementation and lower entry threshold. Key differences from standard nominator pools: Lower minimum stake: 50 TON (vs 10,000 TON in standard pools) Custom contract architecture: Uses separate Owner, Controller, Proxy, and Pool contracts Fee structure: Deposit and withdrawal fees vary by pool (check pool information before staking) Creating a pool: Whales contracts allow creating pools with minimum stake as low as 1 TON (not recommended) How it works: Nominators deposit funds into Whales pools managed by validators Rewards are distributed proportionally minus validator commission Validator covers operational costs and is responsible for validation quality Funds are secured by smart contracts, but validators control pool operations When to use: Small to medium stakes (50+ TON) Simple staking without technical knowledge No validator setup required How to stake: Use TON Whales staking website to find a suitable pool and stake Alternatively, send a message to any Whales-type nominator pool contract with TON and text comment \"Stake\" (capitalization is important) Amount must be desired_stake + deposit_fee (check pool for current deposit fee) How to withdraw: Send a message with text comment \"Withdraw\" (capitalization is important) and withdraw_fee (check pool for current fee) Withdrawal is a two-step process: first request, then withdraw when solidified Sometimes withdrawal can be immediate if pool has sufficient balance See also: TON Whales staking TON Whales nominator pool contracts ​Single nominator pools Single nominator pools are security-focused smart contracts designed for validators with sufficient self-stake who want to validate independently without other participants. This is a simplified, more secure version of the nominator pool that supports only one nominator. Stake requirementsTrack actual minimum stakes at tonscan.org/validators. The current minimum is about ~700,000 TON. Key features: Security-first design: Separates cold wallet (owner) from hot wallet (validator) to prevent theft if validator node is compromised Simplified architecture: Reduced complexity compared to multi-nominator pools, making it secure and easy to audit Emergency safeguards: Owner can recover stakes even in extreme scenarios like Elector contract upgrades How it works: Owner (cold wallet) holds staking funds securely offline Owner deposits funds into single nominator pool contract Validator (hot wallet on node) instructs contract to participate in validation cycles Contract sends stake to Elector for validation After cycle completion, validator instructs contract to recover stake Owner can withdraw funds at any time (only owner can withdraw) Security benefits: Validator’s hot wallet cannot steal funds — only owner can withdraw If validator is compromised, owner can change validator address immediately Owner can send raw messages to recover stakes in emergency situations Owner can upgrade",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "dapp",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:24:48.158Z"
  },
  {
    "id": "docs-ton-org--foundations-whitepapers-ton",
    "title": "The Open Network",
    "url": "https://docs.ton.org/foundations/whitepapers/ton",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersOverviewTVMTON BlockchainThe Open NetworkCatchain consensusGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationWhitepapersThe Open NetworkBlockchain foundationsWhitepapersThe Open NetworkCopy pageWhitepaper by Dr. Nikolai DurovCopy pageAuthors: Nikolai Durov, TON Core Date: July 26, 2021 : Original whitepaper, PDF ​Abstract The aim of this text is to provide a first description of the Telegram Open Network (TON) and related blockchain, peer-to-peer, distributed storage and service hosting technologies. To reduce the size of this document to reasonable proportions, we focus mainly on the unique and defining features of the TON platform that are important for it to achieve its stated goals. ​Introduction The Telegram Open Network (TON) is a fast, secure and scalable blockchain and network project, capable of handling millions of transactions per second if necessary, and both user-friendly and service provider-friendly. We aim for it to be able to host all reasonable applications currently proposed and conceived. One might think about TON as a huge distributed supercomputer, or rather a huge “superserver”, intended to host and provide a variety of services. This text is not intended to be the ultimate reference with respect to all implementation details. Some particulars are likely to change during the development and testing phases. ​1 Brief Description of TON Components The Telegram Open Network (TON) is a combination of the following components: A flexible multi-blockchain platform (TON Blockchain; cf. Chapter 2), capable of processing millions of transactions per second, with Turing-complete smart contracts, upgradable formal blockchain specifications, multi-cryptocurrency value transfer, support for micropayment channels and off-chain payment networks. TON Blockchain presents some new and unique features, such as the “self-healing” vertical blockchain mechanism (cf. 2.1.17) and Instant Hypercube Routing (cf. 2.4.20), which enable it to be fast, reliable, scalable and self-consistent at the same time. A peer-to-peer network (TON P2P Network, or just TON Network; cf. Chapter 3), used for accessing the TON Blockchain, sending transaction candidates, and receiving updates about only those parts of the blockchain a client is interested in (e.g., those related to the client’s accounts and smart contracts), but also able to support arbitrary distributed services, blockchain-related or not. A distributed file storage technology (TON Storage; cf. 4.1.8), accessible through TON Network, used by the TON Blockchain to store archive copies of blocks and status data (snapshots), but also available for storing arbitrary files for users or other services running on the platform, with torrent-like access technology. A network proxy/anonymizer layer (TON Proxy; cf. 4.1.11 and 3.1.6), similar to the I2PI^2PI2P (Invisible Internet Project), used to hide the identity and IP addresses of TON Network nodes if necessary (e.g., nodes committing transactions from accounts with large amounts of cryptocurrency, or high-stake blockchain validator nodes who wish to hide their exact IP address and geographical location as a measure against DDoS attacks). A Kademlia-like distributed hash table (TON DHT; cf. 3.2), used as a “torrent tracker” for TON Storage (cf. 3.2.10), as an “input tunnel locator” for TON Proxy (cf. 3.2.14), and as a service locator for TON Services (cf. 3.2.12). A platform for arbitrary services (TON Services; cf. Chapter 4), residing in and available through TON Network and TON Proxy, with formalized interfaces (cf. 4.3.14) enabling browser-like or smartphone application interaction. These formal interfaces and persistent service entry points can be published in the TON Blockchain (cf. 4.3.17); actual nodes providing service at any given moment can be looked up through the TON DHT starting from information published in the TON Blockchain (cf. 3.2.12). Services may create smart contracts in the TON Blockchain to offer some guarantees to their clients (cf. 4.1.7). TON DNS (cf. 4.3.1), a service for assigning human-readable names to accounts, smart contracts, services and network nodes. TON Payments (cf. Chapter 5), a platform for micropayments, micropayment channels and a micropayment channel network. It can be used for fast off-chain value transfers, and for paying for services powered by TON Services. TON will allow easy integration with third-party messaging and social networking applications, thus making blockchain technologies and distributed services finally available and accessible to ordinary users (cf. 4.3.24), rather than just to a handful of early cryptocurrency adopters. We will provide an example of such an integration in another of our projects, the Telegram Messenger (cf. 4.3.19). While the TON Blockchain is the core of the TON project, and the other components might be considered as playing a supportive role for the blockchain, they turn out to have useful and interesting functionality by themselves. Combined, they allow the platform to host more versatile applications than it would be possible by just using the TON Blockchain (cf. 2.9.13 and 4.1). ​2 TON Blockchain We start with a description of the Telegram Open Network (TON) Blockchain, the core component of the project. Our approach here is “top-down”: we give a general description of the whole first, and then provide more detail on each component. For simplicity, we speak here about the TON Blockchain, even though in principle several instances of this blockchain protocol may be running independently (for example, as a result of hard forks). We consider only one of them. ​2.1 TON Blockchain as a Collection of 2-Blockchains The TON Blockchain is actually a collection of blockchains (even a collection of blockchains of blockchains, or 2-blockchains—this point will be clarified later in 2.1.17), because no single blockchain project is capable of achieving our goal of processing millions of transactions per second, as opposed to the now-standard dozens of transactions per second. ​2.1.1. List of blockchain types The blockchains in this collection are: The unique master blockchain, or masterchain for short, containing general information about the protocol and the current values of its parameters, the set of validators and their stakes, the set of currently active workchains and their “shards”, and, most importantly, the set of hashes of the most recent blocks of all workchains and shardchains. Several (up to 2322^{32}232) working blockchains, or workchains for short, which are actually the “workhorses”, containing the value-transfer and smart-contract transactions. Different workchains may have different “rules”, meaning different formats of account addresses, different formats of transactions, different virtual machines (VMs) for smart contracts, different basic cryptocurrencies and so on. However, they all must satisfy certain basic interoperability criteria to make interaction between different workchains possible and relatively simple. In this respect, the TON Blockchain is heterogeneous (cf. 2.8.8), similarly to the EOS (cf. 2.9.7) and PolkaDot (cf. 2.9.8) projects. Each workchain is in turn subdivided into up to 2602^{60}260 shard blockchains, or shardchains for short, having the same rules and block format as the workchain itself, but responsible only for a subset of accounts, depending on several first (most significant) bits of the account address. In other words, a form of sharding is built into the system (cf. 2.8.12). Because all these shardchains share a common block format and rules, the TON Blockchain is homogeneous in this respect (cf. 2.8.8), similarly to what has been discussed in one of Ethereum scaling proposals.1 Each block in a shardchain (and in the masterchain) is actually not just a block, but a small blockchain. Normally, this “block blockchain” or “vertical blockchain” consists of exactly one block, and then we might think this is just the corresponding block of the shardchain (also called “horizontal blockchain” in this situation). However, if it becomes necessary to fix incorrect shardchain blocks, a new block is committed into the “vertical blockchain”, containing either the replacement for the invalid “horizontal blockchain” block, or a “block difference”, containing only a description of those parts of the previous version of this block that need to be changed. This is a TON-specific mechanism to replace detected invalid blocks without making a true fork of all shardchains involved; it will be explained in more detail in 2.1.17. For now, we just remark that each shardchain (and the masterchain) is not a conventional blockchain, but a blockchain of blockchains, or 2D-blockchain, or just a 2-blockchain. ​2.1.2. Infinite Sharding Paradigm Almost all blockchain sharding proposals are “top-down”: one first imagines a single blo",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "dapp",
      "api",
      "sdk",
      "transaction",
      "deployment",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:24:51.116Z"
  },
  {
    "id": "docs-ton-org--foundations-addresses-overview",
    "title": "Addresses overview",
    "url": "https://docs.ton.org/foundations/addresses/overview",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesOverviewInternal address formatsReading and writing addressesDerivingMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationAddressesAddresses overviewBlockchain foundationsAddressesAddresses overviewCopy pageCopy pageTON implements Actor model, where all entities, including wallets, are smart contracts. Each actor: processes incoming messages; updates its internal state; generates outgoing messages. As a result, every actor must have a unique address to ensure the correct message routing. This section explains how these addresses are structured and why they are fundamental to the TON architecture. There are several types of addresses used in the TON blockchain. Here, we will focus on the two most important ones for developers: internal and external. Every account in the TON blockchain has an internal address. External addresses are intended to be used by off-chain software. ​Internal addresses Each smart contract deployed on TON blockchain has this type of the address. Let’s look at the corresponding TL-B schemes: CopyAsk AIaddr_std$10 anycast:(Maybe Anycast) workchain_id:int8 address:bits256 = MsgAddressInt; addr_var$11 anycast:(Maybe Anycast) addr_len:(## 9) workchain_id:int32 address:(bits addr_len) = MsgAddressInt. As we can see, there are two constructors: addr_std: standardized addresses with a fixed length that are suitable for SHA256 encryption. Must be used whenever possible. addr_var: represents addresses in workchains with a large workchain_id, or addresses with a length not equal to 256. Currently, it is not used and is intended for future extensions. And four components: workchain_id: the workchain ID (signed 8- or 32-bit integer). address: an address of the account (64-512 bits, depending on the workchain). In order not to confuse this field with a whole address, it is usually called account_id. addr_len: a length of the non-standardized address. anycast: not currently used in the blockchain and is always replaced with a zero bit. It was designed to implement shard splitting of global (or large) accounts, but then was deprecated since TVM 10. ​Workchain ID TON Blockchain is actually a collection of blockchains, with workchain being one of them. TON supports up to 2^32 unique workchains, each with its own rules and even virtual machines. The 8- or 32-bit workchain_id prefix in smart contract addresses ensures interoperability, allowing contracts to send and receive messages across different workchains. Currently, two workchains are active: masterchain (workchain_id = -1): contains general information about the TON blockchain protocol and the current values of its parameters, the set of validators and their stakes, the set of currently active workchains and their shards, and, most importantly, the set of hashes of the most recent blocks of all workchains and shard chains. basechain (workchain_id = 0): the default workchain for most operations. Both use 256-bit addresses for accounts. ​Account ID In the currently used workchains, an account ID is defined as the result of applying a hash function to a StateInit structure that stores initial code and data of a smart contract. CopyAsk AIaccount_id = hash(initial_code, initial_data) So, for each pair (initial_code, initial_data), there exists a unique account ID to which a smart contract with such code and data can be deployed (this logic may become more complex when TVM 11 is deployed on the main network.). Although the deployed smart contract code and data may change during its lifetime, the address where it’s deployed does not change. Additionally, a 64-bit prefix of an account ID is crucial for the sharding process and delivering messages from one shard to another during Hypercube Routing. ​External addresses External addresses are closely related to External messages: ones that originate outside the blockchain or are intended for actors outside it. These messages enable interaction between smart contracts and the external world. Actually, external addresses are ignored by the TON Blockchain software altogether, but may be used by external software for its own purposes. The corresponding TL-B schemes are as follows: CopyAsk AIaddr_none$00 = MsgAddressExt; addr_extern$01 len:(## 9) external_address:(bits len) = MsgAddressExt. addr_none: it is used as a stub for the source or destination field in incoming and outgoing external messages when there is no need to put any explanatory information for off-chain actors. It is also used as a stub for the source address of internal messages, since this field is always overwritten to the correct one by the validators. addr_extern: contains up to nine bits of additional information. For example, a special external service may inspect the destination address of all outbound external messages found in all blocks of the blockchain, and, if a special magic number is present in the external_address field, parse the remainder as an IP address and UDP port or a (TON Network) ADNL address, and send a datagram with a copy of the message to the network address thus obtained. ​Summary Every actor is a smart contract, each with a unique address for message routing. Main internal address fields: workchain_id (8- or 32-bit): identifies the workchain. account_id (256-bit): a hash of the contract’s initial code and data. Active workchains: masterchain and basechain, both using 256-bit ids. Flexibility: TON supports up to 2^32 workchains, allowing future chains to customize address lengths (64–512 bits). External addresses: may be used by external software for its own purposes but are ignored by the TON Blockchain software. ​Next steps For more technical details, refer to: Internal address formats: encoding rules and practical examples. Account status: how addresses evolve (active, frozen, etc.). Was this page helpful?YesNoSuggest editsRaise issuePreviousInternal address formatsNext⌘IgithubxtelegramPowered by MintlifyOn this pageInternal addressesWorkchain IDAccount IDExternal addressesSummaryNext steps",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:24:52.597Z"
  },
  {
    "id": "docs-ton-org--foundations-addresses-formats",
    "title": "Internal address formats",
    "url": "https://docs.ton.org/foundations/addresses/formats",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesOverviewInternal address formatsReading and writing addressesDerivingMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationAddressesInternal address formatsBlockchain foundationsAddressesInternal address formatsCopy pageCopy pageAccordingly to TEP 0002 there exist two internal address formats on TON Blockchain: raw; user-friendly. Every internal address can be represented in each of these formats. However, these representations are equivalent: refer to exactly one address, although they visually differ significantly from each other. For a detection how wallets and other applications use these formats, see the address workflow page. ​Raw format The raw format is the canonical, on-chain representation of the address of a smart contract. It is this format that is used by developers of smart contracts in the manual creation of messages and is inspired by the corresponding TL-B schemes. ​Structure In existing workchains, the raw format consists of two components separated by a colon: workchain_id: a signed 8-bit integer identifying the workchain. Examples: -1 for the masterchain and 0 for the basechain. account_id: a 256-bit identifier that is derived from a smart contract StateInit. Example: 0:ca6e321c7cce9ecedf0a8ca2492ec8592494aa5fb5ce0387dff96ef6af982a3e Uppercase letters (A–F) may be used in address strings instead of their lowercase counterparts (a-f). ​Drawbacks Raw addresses lack built-in safety features, making them unsuitable for general use: No error detection: the format includes no checksum. A single-character mistake can cause irreversible loss of funds. No metadata: for instance, each smart contract can be deployed on both Testnet and Mainnet, in which it will have the same address. An attempt to send real funds to the Testnet variant will result in their loss. It is desirable to have a flag in the address that prevents users from making such a mistake. ​User-friendly format The main purpose of the user-friendly format is to help prevent users from accidentally losing their funds due to a small mistake in the raw format, unwise use of the bounce flag, or from having to manually compose a message when they interact with the intended recipient through wallet applications (for instance, Tonkeeper). In fact, the user-friendly address format is a secure, base64-encoded (or base64url-encoded) wrapper around the raw format. It adds metadata flags and a checksum to prevent common errors and provide greater control over message routing. This format can be applied only to addresses that are described according to the addr_std TL-B scheme, see addresses general info subpage. ​Structure A user-friendly address is a 36-byte structure with the following components: Flags (1 byte): metadata that changes the handling of messages in the wallet application. 0x11 for sending bounceable messages, 0x51 for non-bounceable, add the 0x80 summand if that address should not be accepted by software running in Mainnet. workchain_id (1 byte): an 8-bit signed integer. account_id (32 bytes): the 256-bit (big-endian) account identifier. Checksum (2 bytes): a CRC16-CCITT checksum of the preceding 34 bytes. The checksum mechanism in user-friendly addresses is similar to the Luhn algorithm, providing a first-line defense against input errors by validating format integrity upfront. ​Flag definitions The first 8 bits of the user-friendly format encode the handling of messages, as defined in TEP 0002: Address prefixBinary formBounceableTestnet-onlyE...00010001YesNoU...01010001NoNok...10010001YesYes0...11010001NoYes As we can see, there are four variants of the handling: send a bounceable message to a Mainnet address; send a non-bounceable message to a Mainnet address; send a bounceable message to a Testnet address; send a non-bounceable message to a Testnet address; ​Encoding The 36-byte structure is encoded into a 48-character non-space string using either standard base64 (i.e., with digits, upper- and lowercase Latin letters, / and +) or URL-safe base64 (with _ and - instead of / and +). Both encodings are valid and must be supported by applications. Examples: Bounceable: EQDKbjIcfM6ezt8KjKJJLshZJJSqX7XOA4ff-W72r5gqPrHF Non-bounceable: UQDKbjIcfM6ezt8KjKJJLshZJJSqX7XOA4ff-W72r5gqPuwA Bounceable-Testnet: kQDKbjIcfM6ezt8KjKJJLshZJJSqX7XOA4ff-W72r5gqPgpP Non-bounceable-Testnet: 0QDKbjIcfM6ezt8KjKJJLshZJJSqX7XOA4ff-W72r5gqPleK The same encoding is used for the so-called armored versions of public keys and ADNL addresses. ​Custom address safety When developing custom solutions on TON Blockchain, it is critical to implement proper address handling logic. First, always verify whether the recipient address is initialized before sending funds to prevent unintended losses. For user-friendly format forms selection: use bounceable addresses for user smart contracts with custom logic to ensure funds are returned if the contract is invalid, and non-bounceable addresses for wallets to guarantee funds are credited even if the recipient is uninitialized. ​Drawbacks Public key extraction: it is impossible to extract the public key from the address, which is needed for some tasks (for example, to send an encrypted message to this address). Thus, until the smart contract is deployed for this address, there is no way to get the public key on-chain. UI: most OS do not allow you to select an address with a double click because of _, -, /, + base64 symbols. ​Summary Raw format is for system-level use and lacks safety features. User-friendly format is for application-level use; it includes flags and a checksum. ​Next steps For more technical details, refer to: Account status: how addresses evolve (active, frozen, etc.). Was this page helpful?YesNoSuggest editsRaise issuePreviousReading and writing addressesNext⌘IgithubxtelegramPowered by MintlifyOn this pageRaw formatStructureDrawbacksUser-friendly formatStructureFlag definitionsEncodingCustom address safetyDrawbacksSummaryNext steps",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "testnet",
      "mainnet",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:24:54.677Z"
  },
  {
    "id": "docs-ton-org--foundations-messages-overview",
    "title": "Overview",
    "url": "https://docs.ton.org/foundations/messages/overview",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsOverviewInternal messagesIncoming external messagesOutbound external messagesDeploy messageSending modesOrdinary transactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationMessages & TransactionsOverviewBlockchain foundationsMessages & TransactionsOverviewCopy pageCopy page​Messages Messages are objects of the following structure: CopyAsk AImessage$_ {X:Type} info:CommonMsgInfo init:(Maybe (Either StateInit ^StateInit)) body:(Either X ^X) = Message X; init is an optional field of StateInit type used to initialize the contract state, stored either in-place or in a ref of the cell with a message. body is the actual message content that can be stored either in-place or in a reference. Typically, it is the payload of the message that will be read by the receiver. info describes the type of the message, and fields specific to messages of this type: Internal messages are messages from one contract to another. Incoming external messages are messages from the outside world to the contract. Outbound external messages are messages from the contract to the outside world. They can be interpreted as logs. ​Transactions A transaction is a record that stores the state changes of a contract. A contract’s state cannot be changed without a transaction. When a contract processes a message, a transaction may occur as the result of its processing. When an internal message is processed, a transaction is always created. When an incoming external message is processed, a transaction will be created only if the contract accepts the message. When an outbound external message is processed, a transaction is never created, because outbound external messages can’t change contract state. However, a transaction may be created independently of message processing by tick-tock transactions, split-prepare transactions, split-install transactions, storage-tx transactions. Each transaction has the following structure: CopyAsk AI transaction$0111 account_addr:bits256 lt:uint64 prev_trans_hash:bits256 prev_trans_lt:uint64 now:uint32 outmsg_cnt:uint15 orig_status:AccountStatus end_status:AccountStatus ^[ in_msg:(Maybe ^(Message Any)) out_msgs:(HashmapE 15 ^(Message Any)) ] total_fees:CurrencyCollection state_update:^(HASH_UPDATE Account) description:^TransactionDescr = Transaction; Transactions implement the concept of AccountChain described in the TON Blockchain whitepaper. Each account state can be interpreted as a separate blockchain, so transactions follow a strict order defined by the prev_trans_hash field. Thanks to the TON consensus protocol, a transaction becomes final when the first masterchain block references it by storing the hash of the corresponding ShardChain state, which in turn stores the hash of the AccountChain state. Because transactions form the AccountChain, each one carries a logical timestamp, lt, that strictly increases with every new transaction of the account. The now field stores the Unix time when the transaction was created. The state_update field is a Merkle update that captures the difference between the previous and current state of the account. The contract status before and after the transaction is duplicated for convenience. Other fields, such as in_msg, out_msgs, and outmsg_cnt, relate to the messages processed and emitted during the transaction. A trace may start from a transaction rather than a message, in which case in_msg is Nothing. However, a trace cannot continue without messages: if it contains n transactions it must contain at least n-1 messages. Consequently, a trace can include at most one non-ordinary transaction, because messages can trigger only an ordinary transaction. The total_fees field stores the total number of fees paid by the transaction. These fees may eventually be paid in extra currencies, but that feature is not implemented yet.Was this page helpful?YesNoSuggest editsRaise issuePreviousInternal messagesNext⌘IgithubxtelegramPowered by MintlifyOn this pageMessagesTransactions",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:24:57.494Z"
  },
  {
    "id": "docs-ton-org--foundations-messages-internal",
    "title": "Internal messages",
    "url": "https://docs.ton.org/foundations/messages/internal",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsOverviewInternal messagesIncoming external messagesOutbound external messagesDeploy messageSending modesOrdinary transactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationMessages & TransactionsInternal messagesBlockchain foundationsMessages & TransactionsInternal messagesCopy pageCopy pageInternal messages are the messages sent from a contract to an arbitrary account. They are the most common type of a message. ​After processing The contents of an internal message after it was processed are as follows: CopyAsk AIint_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddressInt dest:MsgAddressInt value:CurrencyCollection extra_flags:(VarUInteger 16) fwd_fee:Grams created_lt:uint64 created_at:uint32 = CommonMsgInfo; message$_ {X:Type} info:CommonMsgInfo init:(Maybe (Either StateInit ^StateInit)) body:(Either X ^X) = Message X; ihr_disabled — unused, always set to true. bounce — whether the message is bounceable. bounced — whether the message has been bounced. src — address of the contract that sent the message. dest — address of the account that received the message. value — amount of Toncoin and extra-currency attached to the message. extra_flags — used with the new bounce format. fwd_fee — fee charged for forwarding the message. created_lt — logical time when the message was created. created_at — unix time when the message was created. ​Before processing When a contract sends a message, the requirements for the structure above are relaxed. CopyAsk AIint_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool // NB! different type src:MsgAddress dest:MsgAddressInt value:CurrencyCollection extra_flags:(VarUInteger 16) fwd_fee:Grams created_lt:uint64 created_at:uint32 = CommonMsgInfoRelaxed; message$_ {X:Type} info:CommonMsgInfoRelaxed // NB! actually StateInitWithLibs init:(Maybe (Either StateInit ^StateInit)) body:(Either X ^X) = MessageRelaxed X; _ fixed_prefix_length:(Maybe (## 5)) special:(Maybe TickTock) code:(Maybe ^Cell) data:(Maybe ^Cell) library:(HashmapE 256 SimpleLib) = StateInitWithLibs; The process of transforming the relaxed version of the structure into the strict version occurs in the action phase and is performed by the handler of send message actions. This action rewrites some fields of the structure with correct values and validates the StateInit field against the StateInitWithLibs type. ​Deploy It is possible to simultaneously send both the payload in the body field and the StateInit in the init field to initialized the contract and process the payload in the same transaction. ​Message value The message may set value field that tells to transfer Toncoin and extra-currency to the recipient of the message. The actually transferred amount depends on the value of this field and a send mode. ​Bounces A bounce message is used to inform the sender that handling of their message failed. It is sent automatically to a sender when there is enough Toncoin to send it left from handling the failed message, and the message is bounceable, and when either a message throws an error from the compute phase during message processing and state was not committed by COMMIT TVM instruction, or a message throws an error in the action phase and mode SendBounceIfActionFail is used. ​Default bounce If the bounce flag is set to true, the message is bounceable. If the bounce conditions are met, the bounce message is produced from the failed message with the following transformation: src and dest fields are swapped. The bounced flag is set to true to tell it’s the bounce message. The bounce flag is set to false to prevent infinite loop of bouncing messages until no Toncoin is left to spend. body is replaced with the concatenation of 32 bits equal to one (0xffffffff) and the first 256 bits of the old body. The new body is stored in the message in-place, with left of the Either. This message is then sent to the src address of the original message. ​New bounce format The default bounce format has a flaw, that its body is too small to store even an internal address, and thus has limited usability for real-world applications. A new bounce format was introduced to address this issue. Using the extra_flags field, it is possible to change how the new body will be constructed. All other transformations remain the same. If (extra_flags & 1) = 1 the new bounce format is enabled. The bounced message now contains the root cell of the body of the failed message, with all the refs removed from it. If (extra_flags & 2) = 2 is also set, the bounced message contains the entire body of the original message, without removing any refs. All other bits in extra_flags are reserved for future use. When a message in new bounce format is bounced, the bounce message body has the following format (new_bounce_body): CopyAsk AI_ value:CurrencyCollection created_lt:uint64 created_at:uint32 = NewBounceOriginalInfo; _ gas_used:uint32 vm_steps:uint32 = NewBounceComputePhaseInfo; // NB! 0xfffffffe is different from the old 0xffffffff new_bounce_body#fffffffe original_body:^Cell original_info:^NewBounceOriginalInfo bounced_by_phase:uint8 exit_code:int32 compute_phase:(Maybe NewBounceComputePhaseInfo) = NewBounceBody; original_body — the cell that contains the body of the original message. If extra_flags & 2 then the whole body is returned; otherwise only the root without refs is included. original_info — the value, lt, and Unix time of the original message. bounced_by_phase: 0 - compute phase was skipped. exit_code denotes the skip reason: exit_code = -1 — no state (an account is uninit or frozen, and no StateInit is present in the message). exit_code = -2 — bad state (an account is uninit or frozen, and StateInit in the message has the wrong hash). exit_code = -3 — no gas. exit_code = -4 — account is suspended. 1 — compute phase failed. exit_code is the value from the compute phase. 2 — action phase failed. exit_code is the value from the action phase. exit_code — 32-bit exit code, see above. compute_phase — exists if it was not skipped, i.e., when bounced_by_phase is not 0. gas_used — same as gas_used of TrComputePhase of the transaction. vm_steps — same as vm_steps of TrComputePhase of the transaction. The bounced message has the same 0th and 1st bits in extra_flags as the original message. The rest of the bits are set to zero.Was this page helpful?YesNoSuggest editsRaise issuePreviousIncoming external messagesNext⌘IgithubxtelegramPowered by MintlifyOn this pageAfter processingBefore processingDeployMessage valueBouncesDefault bounceNew bounce format",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:25:00.876Z"
  },
  {
    "id": "docs-ton-org--foundations-messages-external-in",
    "title": "Incoming external messages",
    "url": "https://docs.ton.org/foundations/messages/external-in",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsOverviewInternal messagesIncoming external messagesOutbound external messagesDeploy messageSending modesOrdinary transactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationMessages & TransactionsIncoming external messagesBlockchain foundationsMessages & TransactionsIncoming external messagesCopy pageCopy pageExternal messages are sent from outside the blockchain, and as such only have an optional external sender address. In cases where it is necessary to verify the sender, the public key is usually stored in the contract, and the message is signed before sending, so the contract can verify this signature with the public key. This approach is used by wallet contracts. ​Contents of external messages CopyAsk AIext_in_msg_info$10 src:MsgAddressExt dest:MsgAddressInt import_fee:Grams = CommonMsgInfo; message$_ {X:Type} info:CommonMsgInfo init:(Maybe (Either StateInit ^StateInit)) body:(Either X ^X) = Message X; where src — the external address of the sender of the message. dest — the internal address of the contract that will receive the message. import_fee — the amount of Toncoin that the contract will pay for this message. The value of these fields can be manipulated by nodes or API providers that deliver the message unless they are included in the signed payload. However, wallet contracts usually do not include these fields in the signed payload, and only the contents of the body field are signed. The import_fee field will be overwritten by validators processing the messages with a predetermined price, based on a number of cells and bits in the message. ​Deploying via external message A contract can be deployed via an external message only if the newly deployed contract will accept that message after its creation. As usual, the address of the contract must match the hash of the StateInit. ​Accepting message Incoming external messages are sent to the contract from outside the blockchain, so the sender can’t pay for them, and these messages must be paid by the contract that receives them. However, if the contract paid for all incoming external messages it received, it would drain its balance. This is why the gas_credit parameter exists. It defines how much gas the contract can consume without paying for it, giving the contract a chance to decide whether it wants to accept the message and pay for it. A contract can’t modify its state without accepting the message. If a contract accepts a message, it will pay for all gas consumed, even the gas that was previously deducted from gas_credit. Accepting a message can be done using the ACCEPT TVM instruction, or via the SETGASLIMIT instruction with an argument greater than or equal to 263-1. ​Multiple delivery When an incoming external message is sent to the blockchain, validators share them with each other, and might accidentally (or intentionally) deliver it several times. As it’s usually preferred to process a unique incoming external message only once, some measures need to be taken to ensure duplicate messages are not accepted. Some of these techniques can be found in wallet contracts.Was this page helpful?YesNoSuggest editsRaise issuePreviousOutbound external messagesNext⌘IgithubxtelegramPowered by MintlifyOn this pageContents of external messagesDeploying via external messageAccepting messageMultiple delivery",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:25:02.700Z"
  },
  {
    "id": "docs-ton-org--foundations-messages-external-out",
    "title": "Outbound external messages",
    "url": "https://docs.ton.org/foundations/messages/external-out",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsOverviewInternal messagesIncoming external messagesOutbound external messagesDeploy messageSending modesOrdinary transactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationMessages & TransactionsOutbound external messagesBlockchain foundationsMessages & TransactionsOutbound external messagesCopy pageCopy pageOutbound external messages are the messages that a contract can send to the outer world. They are primarily used for logging purposes. They can’t change any contract state or trigger a transaction. These messages are visible to anyone, and there is no guarantee that anyone outside the blockchain will process them. The structure is as follows: CopyAsk AIext_out_msg_info$11 src:MsgAddressInt dest:MsgAddressExt created_lt:uint64 created_at:uint32 = CommonMsgInfo; message$_ {X:Type} info:CommonMsgInfo init:(Maybe (Either StateInit ^StateInit)) body:(Either X ^X) = Message X; Unlike incoming external messages, a third party can’t manipulate the contents of outgoing external messages, so there is no need to sign them. src — an internal address of the contract that sends the message. It has to be a valid address, but is not important, as it will be overwritten by the address of sender after the message is sent. dest — any valid external address. created_at — arbitrary value, overwritten with the created_at field of the transaction in which the contract sent this message. created_lt — arbitrary value, overwritten with the created_lt field of the transaction, incremented by one. When sending this kind of message, the contract may fill all of these fields with any values. src, created_lt, and created_at will be overwritten by the validator processing this message. For an outbound external message, init field also can store arbitrary data, as outbound external messages can’t initialize any contract. ​Message modes As outbound external messages do not carry any Toncoin value, the price of their handling is paid similarly to SendPayFwdFeesSeparately mode. However, using any mode other than SendIgnoreErrors, SendBounceIfActionFail, or SendPayFwdFeesSeparately for outbound external messages results in exit code 34. In this case, regardless of whether the SendIgnoreErrors mode was used, the action phase will fail. Mode SendPayFwdFeesSeparately does not change the message behavior. ​Example in Tolk In Tolk, outbound external messages may be composed using the createExternalLogMessage function. TolkCopyAsk AItolk 1.2 struct(0x10) ValueWasDeposited { value: int64 } fun main(in: InMessage) { val msg = createExternalLogMessage({ dest: createAddressNone(), body: ValueWasDeposited { value: 1000, }, }); msg.send(SEND_MODE_PAY_FEES_SEPARATELY); } Was this page helpful?YesNoSuggest editsRaise issuePreviousDeploy messageNext⌘IgithubxtelegramPowered by MintlifyOn this pageMessage modesExample in Tolk",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:25:04.590Z"
  },
  {
    "id": "docs-ton-org--foundations-messages-ordinary-tx",
    "title": "Ordinary transactions",
    "url": "https://docs.ton.org/foundations/messages/ordinary-tx",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsOverviewInternal messagesIncoming external messagesOutbound external messagesDeploy messageSending modesOrdinary transactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationMessages & TransactionsOrdinary transactionsBlockchain foundationsMessages & TransactionsOrdinary transactionsCopy pageCopy pageOrdinary transactions are the most common type of transaction because they result from processing incoming external and internal messages. They can be produced only while processing such messages. The phases of a transaction are described in detail on the dedicated page. The structure of an ordinary transaction is as follows: CopyAsk AItrans_ord$0000 credit_first:Bool storage_ph:(Maybe TrStoragePhase) credit_ph:(Maybe TrCreditPhase) compute_ph:TrComputePhase action:(Maybe ^TrActionPhase) aborted:Bool bounce:(Maybe TrBouncePhase) destroyed:Bool = TransactionDescr; The fields of an ordinary transaction are: credit_first indicates whether the transaction started with the credit phase or the storage phase. This flag matches the bounce flag of the message that triggered the transaction and is true for incoming external messages. storage_ph indicates the result of the storage phase: the number of storage fees collected and any resulting contract state change. This field is never equal to Nothing in the current implementation. credit_ph indicates the result of the credit phase: the number of credits collected and the state update of the contract, if any. This field is Nothing when the transaction was triggered by an incoming external message. compute_ph holds the result of TVM execution on the contract. If this phase is skipped, for example, because there are no funds or no state on the destination account, the field stores the skip reason instead. action holds the result of the action phase. This field is Nothing if the compute phase failed and is populated otherwise. aborted indicates whether the action phase was unsuccessful. bounce holds the result of the bounce phase and is Nothing if the bounce phase was not executed. destroyed indicates whether the account was deleted in the action phase by using SendDestroyIfZero. If the contract was deleted in the action phase, this flag is true. Was this page helpful?YesNoSuggest editsRaise issuePreviousOverviewNext⌘IgithubxtelegramPowered by Mintlify",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:25:05.987Z"
  },
  {
    "id": "docs-ton-org--foundations-messages-deploy",
    "title": "Deploy message",
    "url": "https://docs.ton.org/foundations/messages/deploy",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsOverviewInternal messagesIncoming external messagesOutbound external messagesDeploy messageSending modesOrdinary transactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationMessages & TransactionsDeploy messageBlockchain foundationsMessages & TransactionsDeploy messageCopy pageCopy pageStateInit is a data structure sent as part of a message, either internal or incoming external, used to deploy a smart contract, for which it stores the initial code and data of a contract; unfreeze a contract, where its last committed code and data are used. This structure can be appended in-place or as a referenced cell to every message: CopyAsk AImessage$_ {X:Type} info:CommonMsgInfo init:(Maybe (Either StateInit ^StateInit)) body:(Either X ^X) = Message X; The StateInit structure is defined as follows: CopyAsk AI_ fixed_prefix_length:(Maybe (## 5)) special:(Maybe TickTock) code:(Maybe ^Cell) data:(Maybe ^Cell) library:(Maybe ^Cell) = StateInit; where the fields are: special: was mean to register a smart contract for tick-tock events; now is deprecated. code: the initial code of the contract. data: the initial data of the contract. library: the initial library of the contract. fixed_prefix_length: number of most significant address bits that may differ between the deploy message destination and the address derived from StateInit; the remaining bits must match. ​Deploying to specific shard Due to the way messages are sent between blockchain shards, the number of hops and, hence, latency depends on the distance between the shards of a source and a destination. The optimal performance is achieved when both addresses are in the same shard. Usually, a new contract has to be deployed by a message to the exactly same address as computed out of StateInit’s hash, i.e. the content of StateInit uniquely determines the address. Any discrepancy between the address computed from StateInit and destination address of a deploy message will result in a failed transaction. To deploy a contract to the desired shard, there is a fixed_prefix_length field in StateInit. It allows to specify the destination address that would slightly differ from the computed address. Only all the bits except for the first fixed_prefix_length have to match. To put it more formally, CopyAsk AIdrop(fixed_prefix_length, addressFrom(stateInit)) = drop(fixed_prefix_length, destination) where drop(n, x) drops the n most significant bits from a 256-bit number x, addressFrom(s) computes contract’s address from a hash of StateInit s. When fixed_prefix_length is zero or not set, the condition simplifies to CopyAsk AIaddressFrom(stateInit) = destination ​Example Assume an address D starts with 0x5ABC.... If there are 256 active shardchains, the first 8 bits of the address (i.e., 5A) correspond to shard IDs. Now, if some other contract S is deployed that intends to exchange messages with D, and computing an address from its StateInit results in 0x2623..., it will be deployed by default into a shard 26. Messages from 26 to 5A will take 2 hops and 2 blocks to arrive at the destination. To put S into the same shard as D, set fixed_prefix_length to 8 and send the deploy message to the address 0x5A23.... Then TVM will ignore the discrepancy in the first 8 bits between the computed address (0x2623...) and the passed destination (0x5A23...), because their remaining 248 bits coincide, and S will be deployed into shard 5A. ​Limits The largest value for fixed_prefix_length is set in the blockchain config (param 43), and at the moment is 8, i.e. discrepancy in only eight bits of address can be ignored.Was this page helpful?YesNoSuggest editsRaise issuePreviousSending modesNext⌘IgithubxtelegramPowered by MintlifyOn this pageDeploying to specific shardExampleLimits",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:25:07.314Z"
  },
  {
    "id": "docs-ton-org--languages-tolk-overview",
    "title": "Tolk — the language for TON",
    "url": "https://docs.ton.org/languages/tolk/overview",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedOverviewBasic syntaxIdioms and conventionsType systemSyntax detailsLanguage featuresMigrating from FunCChangelogTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationTolkTolk — the language for TONLanguagesTolkTolk — the language for TONCopy pageCopy pageTolk is a statically typed language designed for TON smart contracts. It provides declarative structures, automatic cell serialization, first-class message handling, and a modern development experience. The language compiles to TVM (TON virtual machine) with zero overhead and full control over execution. CopyAsk AItype AllowedMessage = CounterIncrement | CounterReset fun onInternalMessage(in: InMessage) { val msg = lazy AllowedMessage.fromSlice(in.body); match (msg) { CounterIncrement => { ... } CounterReset => { ... } } } get fun currentCounter() { val storage = lazy Storage.load(); return storage.counter; } ​Key features Tolk offers high-level readability while remaining low-level in nature: a robust type system to express any cell layout in TON lazy loading: unused fields are skipped automatically unified message composition and deployment a gas-efficient compiler targeting the Fift assembler friendly tooling and IDE integration Tolk is fully compatible with existing TON standards and contracts. ​Tolk is a replacement for FunC Tolk started as an evolution of FunC and is now the recommended language for TON smart contracts. If you are migrating from FunC: Look through benchmarks: notice 30–50% lower gas fees. Scan the page Tolk vs FunC to get the overall picture. Use the FunC-to-Tolk converter to migrate existing projects. ​Quick start Run the command: CopyAsk AInpm create ton@latest Enter a project name and choose “simple counter contract”. Follow the “Your first smart contract” article to get explanations. ​IDE support All major IDEs support syntax highlighting and code completion: JetBrains IDEs (WebStorm, CLion, etc.) — via the plugin => install “TON” from Marketplace, read more VS Code — via the TON extension => install “TON” from Marketplace, read more Cursor and Windsurf — via the OpenVSX registry => install from the website, read more Neovim, Vim, Zed, etc. — via the language server => download an archive, consult the link above ​Where to go next Recommended starting points: Basic syntax Idioms and conventions Type system Message handling Was this page helpful?YesNoSuggest editsRaise issuePreviousBasic syntaxNext⌘IgithubxtelegramPowered by MintlifyOn this pageKey featuresTolk is a replacement for FunCQuick startIDE supportWhere to go next",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "deployment",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:25:08.371Z"
  },
  {
    "id": "docs-ton-org--languages-fift-overview",
    "title": "Fift language overview",
    "url": "https://docs.ton.org/languages/fift/overview",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftOverviewFift and TVM assemblyDeep diveSimple multisig contractWhitepaperFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationFiftFift language overviewLanguagesFiftFift language overviewCopy pageCopy pageThe official language of TON Blockchain is Tolk, and all other languages are deemed legacy. That said, you can still use them and contribute to the surrounding tooling or documentation. Fift is a stack-based general-purpose tacit programming language optimized for creating, debugging, and managing smart contracts on TON Blockchain. It has been specifically designed to interact with TON Virtual Machine (TVM) and TON Blockchain. In particular, it offers native support for 257-bit integer arithmetic and cell manipulation, as well as an interface to the Ed25519-based cryptography employed by TON. Fift also includes a macro assembler for TVM code, which is a common intermediate target of higher-level languages such as Tolk, FunC, and Tact, as well as a common textual bitcode representation of smart contracts. For more examples of the latter, see various blockchain explorers and disassembled smart contracts. ​Installation ​Interpreter and libraries Fift interpreter binaries for Windows, macOS (Intel or Arm64), and Ubuntu can be downloaded from the latest GitHub release. Make sure to also download the necessary libraries — download and unpack the smartcont_lib.zip. The lib/ folder inside contains standard libraries of Fift, which must be exposed to it when running the interpreter. Consider the following example installation steps: 1Download the latest Fift binary Windows Linux macOSGo to the latest GitHub release, download fift.exe and place it somewhere on your PATH. To see the current state of the PATH variable, run echo $env:PATH in the PowerShell.Go to the latest GitHub release, download fift-linux-x86_64 (64-bit, x86 arch) or fift-linux-arm64 (64-bit, Arm arch), and place it somewhere on your $PATH as fift. To see the current state of the $PATH variable, run echo $PATH | tr ':' '\\n' in the terminal.Go to the latest GitHub release, download fift-mac-x86-64 (64-bit, Intel) or fift-mac-arm64 (64-bit, Apple Silicon), and place it somewhere on your $PATH as fift. To see the current state of the $PATH variable, run echo $PATH | tr ':' '\\n' in the terminal.2Download Fift's standard libraries Download smartcont_lib.zip from the latest GitHub release. Unzip it and extract the contents. Move the extracted lib/ folder somewhere convenient. You can also place it under a different name. For example, for Linux and macOS, it can be moved to ~/.local/lib/fiftlib For Windows, to ~/.fiftlib 3Run FiftTo invoke the Fift binary, you’ll need to pass it the standard libraries as such:CopyAsk AIfift -I /path/to/extracted/lib -i Asm.fif If you see errors or red-colored output lines, double-check the placement of the Fift binary and related libraries from previous steps.Otherwise, write the following and press “Enter”:CopyAsk AI2 2 + .s If you see “4 ok”, then Fift has been successfully installed on your machine!To learn about other launch options, add the -h flag by the end of the prior Fift invocation command. For Linux and macOS, it might be convenient to make an alias as such:CopyAsk AI# Within .bash_aliases or .zsh_aliases alias fift=\"/path/to/fift -I /path/to/extracted/lib -i Asm.fif\" ​Additional tooling ​Extensions and plugins VS Code extension - powerful and feature-rich extension for Visual Studio Code (VSCode) and VSCode-based editors like VSCodium, Cursor, Windsurf, and others. Get it on the Visual Studio Marketplace. Get it on the Open VSX Registry. Or install from the .vsix files in nightly releases. JetBrains IDEs plugin - provides syntax highlighting, code navigation, and more. Language Server (LSP Server) - supports Sublime Text, (Neo)Vim, Helix, and other editors with LSP support. ​Online utilities TxTracer: Assembly playground TxTracer: Code explorer with assembly output TxTracer: TVM instruction table ​Getting started Here is a simple Hello, World! example written in Fift: CopyAsk AI.\"Hello, World!\" When executed with fift binary, it produces the following output: CopyAsk AIHello, World! ok There, ok means successful end of execution of the given code snippet. When things go awry, there may still be an ok by the end, albeit prefixed with several red lines of cryptic-looking stack traces. Those are how Fift reports errors, and this is one of the major reasons why Fift is considered a legacy language.Any errors encountered during execution clear the stack!Hence, to actually know what happened, one needs to preemptively check stack contents. For that, use the “printf debugging” approach with the .s word — it dumps current stack contents to the console without modifying the stack.CopyAsk AI\"Hello, \" .s // \"Hello, \" \"World!\" .s // \"Hello, \" \"World!\" $+ // \"Hello, World!\" type // Hello, World! ok // Now, the stack is clear. To continue learning Fift, see the educational materials section, or move to the follow-up references. Fift and TVM assemblyDeep dive into FiftSimple multi-signature walletWhitepapers (see below) ​Educational materials ​Whitepapers While most of the information described there holds some truth, the fiftbase.pdf whitepaper is still considered legacy due to a lack of updates and gradual integration of its contents into actual documentation pages.However, it is the most exhaustive reference manual on Fift to date, so you can still use it to learn a lot about Fift. Fift language specification, web versionTacit stack-based programming language with a deep connection to TVM.Fift language specification, PDFOriginal documentation written by Dr. Nikolai Durov, a comprehensive whitepaper. ​Articles Introduction to Fift ​Videos and playlists «His majesty Fift»In Russian ​Examples Simple multi-signature walletMulti-signature wallet v2 ​See also Multisignature wallet v2 Forth language Factor language Uiua language Concatenative languages Was this page helpful?YesNoSuggest editsRaise issuePreviousFift and TVM assemblyNext⌘IgithubxtelegramPowered by MintlifyOn this pageInstallationInterpreter and librariesAdditional toolingExtensions and pluginsOnline utilitiesGetting startedEducational materialsWhitepapersArticlesVideos and playlistsExamplesSee also",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:25:10.297Z"
  },
  {
    "id": "docs-ton-org--languages-func-overview",
    "title": "FunC language overview",
    "url": "https://docs.ton.org/languages/func/overview",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCOverviewCookbookLanguageLibrariesChangelogKnown issuesTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationFunCFunC language overviewLanguagesFunCFunC language overviewCopy pageCopy pageTON Blockchain uses Tolk as the official language. Other languages are still available, and legacy codebases exist, but Tolk is the only actively supported language. The FunC compiler, for instance, is no longer maintained. FunC is a domain-specific, statically typed language with C-like syntax designed to write smart contracts on TON. It can be characterized as an intermediate-level language sitting on top of the Fift assembly language. Example of a FunC function for sending funds: CopyAsk AI() send_money(slice address, int amount) impure inline { var msg = begin_cell() ;; Set the message to be non-bounceable .store_uint(0x10, 6) .store_slice(address) .store_coins(amount) .end_cell(); send_raw_message(msg, 64); } where () is the return type, that stands for “do not return value”, similar to void in C; send_money is the name of the function; slice address is the first parameter, address to send money to; it’s type is slice; int amount is the second parameter, amount to be sent; it’s type is int; impure inline are specifiers, which are flags that tell the compiler to process the method in a specific way; var msg = ... defines a variable without specifying its type; it will hold a cell with a message; begin_cell() creates a cell builder; store_uint, store_slice, store_coins methods store data into the builder: flags; receiving address; amount on Toncoin to attach to the message. .end_cell() method finalizes the builder and turns it into a cell; send_raw_message function sends the message, where the parameter 64 describes a sending mode. ​Compiler The compiler converts FunC programs into Fift assembly code. The Fift assembly code is then compiled down to the TON Virtual Machine bitcode by the Fift compiler. Developers can use the compiled bitcode, structured as a bag of cells like all data in the TON blockchain, to test smart contracts, send messages, or execute it in a local TVM instance. ​End-to-end tooling The easiest way to install the FunC compiler is the @ton-community/func-js NPM package. It requires Node.js v22 or later. The package has both the FunC and Fift compilers, and produces bitcode directly from the FunC source code, without manually invoking Fift. To install it, run the following command in the project root folder: CopyAsk AInpm i @ton-community/func-js Then, to compile a specific FunC file, run the following command: CopyAsk AInpx func-js ./contract.fc --boc ./output.boc where contract.fc is the FunC source file in the project root, and output.boc is the compiled bitcode output. FunC standard library is supplied separately from the language. Download smartcont_lib.zip from the latest release, extract it, and copy stdlib.fc to the project root. Alternatively, use the Blueprint to start a project pre-configured for development in FunC. ​Compile manually using the binaries Prebuilt FunC compiler binaries for Windows, macOS (Intel or ARM64), and Ubuntu are available on the GitHub. Download the corresponding binary for operating system: Linux: func-linux-x86_64 (Intel/AMD) and func-linux-arm64 (ARM64) Mac: func-mac-x86-64 (Intel/AMD) and func-mac-arm64 (ARM64) Windows: func.exe Rename the executable, for example, to func, for easier use on the command line, and add it to system’s PATH. Download the FunC standard library. Get the smartcont_lib.zip from the same GitHub, extract it, and copy stdlib.fc to project root. Compile a FunC file to Fift assembly code. Run the following command in the project root: CopyAsk AIfunc contract.fc -o output.fif where contract.fc is the FunC file to compile, and output.fif is the generated Fift output. To compile the generated Fift file output.fif further down to TVM bitcode, use the Fift compiler. See the Fift for download and usage instructions. The last FunC compiler version is v2025.07. The FunC compiler is no longer developed. New releases are focused on the Tolk compiler. ​Tutorials The tutorials in this section are provided by external contributors and may not reflect FunC’s current development status. They are offered as additional resources for exploring FunC’s applications. Challenge 1: Simple NFT deploy Challenge 2: Chatbot contract Challenge 3: Jetton vending machine Challenge 4: Lottery/raffle Challenge 5: Create UI to interact with the contract in 5 minutes Challenge 6: Analyzing NFT sales on the Getgems marketplace TON hello world Part 2: guide for writing your first smart contract TON hello world Part 4: guide for testing your first smart contract 10 lessons for developing contracts in FunC — Russian version FunC quiz — a short Telegram quiz focused on FunC, with a few general TON questions. ​Contests ContestTasksSolutionsTSC #5 (Dec 2023)Tasks—TSC #4 (Sep 2023)Tasks1 2 3 4TSC #3 (Dec 2022)TasksSolutionsTSC #2 (Jul 2022)TasksSolutionsTSC #1 (Mar 2022)TasksSolutions ​Changelog History of FunCWas this page helpful?YesNoSuggest editsRaise issuePreviousCookbookNext⌘IgithubxtelegramPowered by MintlifyOn this pageCompilerEnd-to-end toolingCompile manually using the binariesTutorialsContestsChangelog",
    "category": "languages",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "tutorial",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:25:12.307Z"
  },
  {
    "id": "docs-ton-org--foundations-messages-modes",
    "title": "Sending modes",
    "url": "https://docs.ton.org/foundations/messages/modes",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsOverviewInternal messagesIncoming external messagesOutbound external messagesDeploy messageSending modesOrdinary transactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationMessages & TransactionsSending modesBlockchain foundationsMessages & TransactionsSending modesCopy pageCopy pageBy default, message sending process has the following properties: the forward fees are paid from the indicated message value, so it is decreased by the amount of forward fees before sending; if sending fails, the transaction is rolled back and a bounce message is not sent. The purpose of send modes is to modify the above logic by specifying: what exactly value should be in the outgoing message (will it be increased by something or even reset to some value); whether to pay forward fees from the account balance or from the message value; whether to rollback the transaction and send a bounce message if sending fails, etc. The send modes are specified via an 8-bit bitmask mode parameter of the SENDRAWMSG instruction. The resulting mode value can have the following base modes: Mode valueConvenient nameDescription0SendDefaultModeDefault mode.64SendRemainingValueComplex logic. Will be described below.128SendRemainingBalanceSend all remaining balance of the account. Additionally, the resulting mode can have the following optional flags added: Flag valueConvenient nameDescription+1SendPayFwdFeesSeparatelyPay forward fees separately from the message value.+2SendIgnoreErrorsIgnore errors during sending. No bounce message will be sent on failure.+16SendBounceIfActionFailBounce the transaction in case of any errors during the action phase.+32SendDestroyIfZeroThe current account (contract) will be destroyed if its resulting balance is zero. This flag has effect only if mode 128, SendRemainingBalance, is used. ​Behavior Notation: value – the amount of Toncoin indicated in the outgoing message. mode – the bitmask passed to the SENDRAWMSG instruction. msg_balance_remaining – the remaining value of the incoming message. At the start of the action phase it equals either the incoming message value or account’s balance before compute phase if it was less than the value of incoming message with bounce flag set to false. At the start of sending message process, it is zero if there was the previous sending message action with modes SendRemainingBalance or SendRemainingValue, otherwise it equals the value described above. remaining_balance – the remaining balance of the account at the start of the action. fwd_fees – the amount of forward fees for sending the message. gas_fees – the fees paid for gas used during the computation phase. action_fine – the accumulated fine for the previous failed and skipped send message actions. final_value – the final value of the outgoing message. req – value that will be deducted from the account balance. The algorithm for the resulting value of outgoing internal message and amount of nanotoncoins that will be deducted from account’s balance is as follows: Check that mode has flag SendBounceIfActionFail: if so, then in case of any failure the action phase will be interrupted, the bounce phase will be initiated; if not, then in case of any failure the action phase will be interrupted but no bounce message will be sent. Check that mode has flag SendIgnoreErrors: if so, then in case of almost all failure (errors on which this mode is not work are described in Errors subsection.) during sending the message an error will be ignored and the action phase will continue; Set final_value to the value. Check that mode has base mode SendRemainingBalance: if so, then set final_value to remaining_balance and remove +1 flag from mode if it is presented. Otherwise, check that mode has base mode SendRemainingValue: Check that mode has flag SendPayFwdFeesSeparately: if so, then increase final_value by msg_balance_remaining; otherwise, increase final_value by msg_balance_remaining - gas_fees - action_fine. Set req to final_value. Check that mode has flag SendPayFwdFeesSeparately: if so, then increase req by fwd_fees. otherwise, decrease final_value by fwd_fees. Set msg_balance_remaining to zero if mode has base modes SendRemainingValue or SendRemainingBalance. Decrease remaining_balance by req. Check that mode has flag SendDestroyIfZero and base mode SendRemainingBalance: if so, then destroy the current account (contract) if remaining_balance is zero. ​Example Assume that value = 0.1 TON; mode = 80 = 10010000 (that is, SendRemainingValue + SendBounceIfActionFail); msg_balance_remaining = 0 TON (for instance, there was previous sending message action with mode SendRemainingValue); remaining_balance = 2 TON; fwd_fees = 0.01 TON; gas_fees = 0.005 TON; action_fine = 0 TON. Then the sending proceeds as follows: mode has flag SendBounceIfActionFail? Yes. mode has flag SendIgnoreErrors? No. Set final_value = 0.1 TON. mode has base mode SendRemainingBalance? No. mode has base mode SendRemainingValue? Yes. mode has flag SendPayFwdFeesSeparately? No. Increase final_value by msg_balance_remaining - gas_fees - action_fine = 0 TON - 0.005 TON - 0 TON = -0.005 TON. Now, final_value = 0.1 TON - 0.005 TON = 0.095 TON. Set req = final_value = 0.095 TON. mode has flag SendPayFwdFeesSeparately? No. Decrease final_value by fwd_fees = 0.01 TON. Now, final_value = 0.095 TON - 0.01 TON = 0.085 TON. Set msg_balance_remaining to zero (it is already zero). Decrease remaining_balance by req = 0.095 TON. Now, remaining_balance = 2 TON - 0.095 TON = 1.905 TON. ​Outgoing external messages The algorithm above describes the sending process only for outgoing internal messages. However, outgoing external message can have only the following three modes: SendBounceIfActionFail, SendIgnoreErrors, and SendPayFwdFeesSeparately (use of any other leads to an error). SendPayFwdFeesSeparately can be used, but have no effect. SendBounceIfActionFail and SendIgnoreErrors have the same behavior, i.e. send bounce message in a case of any error and ignore almost all errors during the processing. There is no value field in external messages, so the forward fees are always deducted from account’s balance. ​Errors The following errors can occur during the sending message flow: Simultaneous use of modes SendRemainingBalance and SendRemainingValue, 34 exit code. Modes except SendIgnoreErrors, SendBounceIfActionFail, and SendPayFwdFeesSeparately used for outbound external messages, 34 exit code. Source address in the outbound message is not equal to addr_none or the contract address, 35 exit code. Some problems with repacking the message body and StateInit into references if the message body or StateInit is too big to be located in place, 34 exit code. Malformed message structure, 34 exit code. Invalid destination address in the outbound message, 36 exit code. Not enough value to transfer with the message: all of the inbound message value has been consumed, 37 exit code. No enough funds for processing all message references, 40 exit code. The number of bits or references in StateInit and message body is too large, 40 exit code. Message has Merkle depth more than two, 40 exit code. If a message has only one SendRemainingValue base mode and final_value after the step 5 is negative, then an error with 37 exit code is thrown. If final_value after step 7 is negative, then an error with 37 exit code is thrown. If remaining_balance after step 9 is negative, then an error with 37 exit code is thrown. If remaining_balance after pay forward fees step is negative in a case of outgoing external message, then an error with 37 exit code is thrown. Problems related to extra-currency, exit codes 37, 44, 38. The SendIgnoreErrors mode ignore all the above errors except the four first ones (simultaneous use of modes, invalid modes for external messages, source address problems, and problems with repacking).Was this page helpful?YesNoSuggest editsRaise issuePreviousOrdinary transactionsNext⌘IgithubxtelegramPowered by MintlifyOn this pageBehaviorExampleOutgoing external messagesErrors",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:25:14.541Z"
  },
  {
    "id": "docs-ton-org--standard-wallets-how-it-works",
    "title": "How TON wallets work",
    "url": "https://docs.ton.org/standard/wallets/how-it-works",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsHow they workMnemonicsComparisonPerformance benchmarkHow to interactHistoryV4V5Highload WalletsLockup walletPreprocessed Wallet V2Restricted walletTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationWalletsHow TON wallets workStandard contractsWalletsHow TON wallets workCopy pageCopy pageWallets are often the entry point of transactions in TON. See external messages. ​General principle A wallet smart contract stores two critical variables — the public key and the sequence number (seqno). Together, they secure the wallet. Using the public key, the contract verifies that the request comes from the wallet owner; using seqno, it protects against replayed transactions (see How replay protection works). ​Why wallet contracts don’t store a balance field In TON, an account’s balance is not stored inside the smart contract’s persistent data. It is a part of the protocol-level account state, maintained by validators and updated automatically when value is received/sent and when fees are paid. Therefore, a wallet contract does not and should not keep a separate balance variable in storage. Doing so would be redundant and could drift out of sync with the actual account state. From outside, the balance is exposed via RPC and blockchain explorers as part of the public account state. ​How ownership verification works Wallet contracts use the Ed25519 signature scheme. You generate a private key (keep it safe) and a public key (stored in the contract; readable by anyone). ImportantThe public key is not the wallet address. The address is derived from the contract’s StateInit. An external message is sent to the contract (containing a 512‑bit signature and the desired payload). Ed25519 verifies that the provided signature matches the hash of the message. ​How replay protection works Why do we need replay protection?Imagine Alice has 100 TON. Alice sends 10 Toncoin to Bob as a gift. Bob, being sneaky, forwards an identical message to Alice’s wallet and would receive another 10 TON — unless the wallet prevents replays. Each transaction carries a counter value (in our case, seqno) that must be unique and strictly increasing for every outgoing transaction. Because seqno changes, the message hash changes as well, making it impossible to reuse a previous signature. ​Role of valid_until valid_until is a Unix timestamp embedded into the wallet’s signing message. The wallet rejects any external message if the current time exceeds this value. This limits the lifetime of a signature and prevents an attacker from replaying a captured message indefinitely. It also makes retries safe: a client may re-send the same signed message until the deadline; after it expires, the client must re-sign with a new valid_until. Combined with seqno equality (the contract accepts only the exact current seqno and increments it on success), this provides robust replay protection. ​Subwallet ID subwallet_id is a 32‑bit identifier tied to a wallet instance. It is set at wallet creation time and is included in the signing message. On each external call, the wallet verifies that the provided subwallet_id matches its own; otherwise, the message is rejected. By varying subwallet_id, you can deploy multiple independent wallet contracts controlled by the same public key, each with its own address and seqno. This is useful for separating accounts, environments, or business lines while keeping a single keypair. ImportantChanging subwallet_id creates a different wallet address. Funds are not shared across subwallets even if they use the same public key.Was this page helpful?YesNoSuggest editsRaise issuePreviousMnemonicsNext⌘IgithubxtelegramPowered by MintlifyOn this pageGeneral principleWhy wallet contracts don’t store a balance fieldHow ownership verification worksHow replay protection worksRole of valid_untilSubwallet ID",
    "category": "wallets",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:25:16.268Z"
  },
  {
    "id": "docs-ton-org--standard-wallets-comparison",
    "title": "Comparison",
    "url": "https://docs.ton.org/standard/wallets/comparison",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsHow they workMnemonicsComparisonPerformance benchmarkHow to interactHistoryV4V5Highload WalletsLockup walletPreprocessed Wallet V2Restricted walletTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationWalletsComparisonStandard contractsWalletsComparisonCopy pageCopy pageUnlike some other blockchains, wallets in TON are represented as distinct smart contracts. They handle transaction signing, replay protection, and even gasless transfers. Different wallet versions implement different custom logic, suitable for various use cases. This article will cover the differences between these wallets and identify the best pick for each task. ​Comparison table FeatureV4V5HighloadPreprocessedMultisigSeqno1 based✅ Yes✅ Yes❌ No (query_id based)✅ Yes🟡 Has boolean flag that turns off seqno +1 incremental checkMessages throughputUp to 4 per requestUp to 255 per requestUp to 2 billion per timeoutUp to 255 per requestUp to 255 per voteMulti-owner❌ Single owner❌ Single owner❌ Single owner❌ Single owner✅ Multiple ownersMessage costStandardStandardLowerLowestHigher (multiple signatures)Support plugins✅ Yes✅ Yes❌ No❌ No❌ NoSupport gasless2❌ No✅ Yes❌ No❌ No❌ NoSubwallet ID✅ Yes✅ Yes✅ Yes❌ No❌ No 1 Seqno means “sequential number” - a persistent unsigned integer variable, which is incremented by 1 for each valid transaction submission. Also, sometimes it’s called “nonce”. It is a common way to implement replay protection. 2 “Gasless” is the kind of a transaction that doesn’t require native currency to pay network fees. There is also a separate gas and performance comparison. ​Use cases ​Retail users If you are new to TON and want to create your first wallet to engage with the ecosystem, v4 and v5 are your best choices. All major wallet apps support both standards and implement secure cryptography to ensure users’ funds are safe. It is recommended to use the v5 wallet standard, since it’s the latest and most powerful implementation to date. It supports gasless transactions and up to 255 out messages per one signed external request. Use for: Buying stablecoins: Purchase USDT and other stable assets Trading Jettons: Swap tokens on DEXes and participate in DeFi Daily payments: Send and receive TON for everyday transactions NFT collecting: Buy, sell, and store digital collectibles Staking: Participate in TON validation and earn rewards DApp interactions: Connect to games, social apps, and other TON applications Savings: Store cryptocurrency for long-term holding Key benefits: Simple setup with any major TON wallet app Low transaction fees for everyday use Battle-tested security with millions of users Full ecosystem compatibility Read more: Recommended: Wallet v5 Wallet v4 ​Shared custody For experienced institutional managers and fund operators with high security demands, Multisig wallets are your best choice when managing institutional funds, treasury assets, or any situation requiring shared custody. Multisig wallets provide the highest level of security through distributed control: Shared responsibility: No single person can move funds alone Configurable thresholds: Set up 2-of-3, 3-of-5, or any N-of-M configuration Audit trails: Every transaction requires multiple approvals, creating clear accountability Risk mitigation: Protects against key compromise, insider threats, and human error Key considerations: Higher transaction costs due to multiple signature verification Longer processing time as multiple parties must sign Requires coordination between signers for each transaction More complex setup and key management procedures While the operational overhead is higher than that of single-signature wallets, the security benefits make multisig essential for any custodial operation handling significant assets or requiring regulatory compliance. ​Payment gateways For businesses operating payment gateways, exchanges, or services requiring high-volume transaction processing, Highload wallets are your best choice when handling thousands of payments and withdrawals efficiently. Highload wallets are engineered explicitly for maximum throughput and cost efficiency: Massive throughput: Process up to 8,380,415 requests with up to 254 outgoing messages (total maximum of up to 2 billion outgoing messages) per timeout period Query-based processing: Uses query id and batch id instead of seqno for better transaction submission tracking. They help discover individual transaction submissions Use for: Cryptocurrency exchanges: Handle thousands of user withdrawals and deposits Payment processors: Process merchant payments and payouts at scale Trading platforms: Execute high-frequency trading operations Key considerations: Requires technical expertise for proper implementation More complex setup compared to standard wallets Need robust monitoring and error handling systems Read more: Highload wallet implementation Was this page helpful?YesNoSuggest editsRaise issuePreviousPerformance benchmarkNext⌘IgithubxtelegramPowered by MintlifyOn this pageComparison tableUse casesRetail usersShared custodyPayment gateways",
    "category": "wallets",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "dapp",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:25:19.444Z"
  },
  {
    "id": "docs-ton-org--standard-wallets-v5",
    "title": "Wallet V5",
    "url": "https://docs.ton.org/standard/wallets/v5",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsHow they workMnemonicsComparisonPerformance benchmarkHow to interactHistoryV4V5OverviewHow to interactHighload WalletsLockup walletPreprocessed Wallet V2Restricted walletTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationV5Wallet V5Standard contractsWalletsV5Wallet V5Copy pageCopy pageThe V5 wallet standard offers many benefits that improve the experience for both users and developers. V5 supports gasless transactions, account delegation and recovery, subscription payments using Jettons and Toncoin, and low-cost multi-transfers. In addition to retaining the previous functionality (V4), the new contract allows you to send up to 255 messages at a time. This article provides only a high-level wallet V5 contract overview. If you want to learn more about how to use its interfaces or develop extensions, check out the wallet V5 API article. Source links: Wallet V5 source code. TL-B scheme for V5 ​Persistent memory layout CopyAsk AIcontract_state$_ is_signature_allowed:(## 1) seqno:(## 32) wallet_id:(## 32) public_key:(## 256) extensions_dict:(HashmapE 256 int1) = ContractState; is_signature_allowed: 1-bit flag that restricts or allows access through the signature and stored public key. seqno: 32-bit sequence number. wallet_id: 32-bit wallet ID (equivalent to subwallet_id in previous versions). public_key: 256-bit public key. extensions_dict: dictionary containing extensions (may be empty). As you can see, the ContractState, compared to previous versions, hasn’t changed much. The main difference is the new is_signature_allowed 1-bit flag, which restricts or allows access through the signature and stored public key. We will describe the importance of this change in later topics. ​Message layout ​External message body layout wallet_id: 32-bit long wallet ID. valid_until: 32-bit long Unix time integer. msg_seqno: 32-bit long sequence number. inner: InnerRequest containing the actual actions to perform. signature: 512-bit long Ed25519 signature. ​Internal message body layout Learn more about internal message serialization here. ​Authentication process CopyAsk AIinternal_signed#73696e74 signed:SignedRequest = InternalMsgBody; internal_extension#6578746e query_id:(## 64) inner:InnerRequest = InternalMsgBody; Before we get to the actual payload of our messages — InnerRequest — let’s first look at how version 5 differs from previous versions in the authentication process. The InternalMsgBody combinator describes two ways to access wallet actions through internal messages. The first method is one we are already familiar with from version 4: authentication as a previously registered extension, the address of which is stored in extensions_dict. The second method is authentication through the stored public key and signature, similar to external requests. At first, this might seem like an unnecessary feature, but it actually enables requests to be processed through external services (smart contracts) that are not part of your wallet’s extension infrastructure — a key feature of V5. Gasless transactions rely on this functionality. Any received internal message that doesn’t pass the authentication process will be considered a transfer. ​Actions The first thing that we should notice is InnerRequest, which we have already seen in the authentication process. In contrast to the previous version, both external and internal messages have access to the same functionality, except for changing the signature mode (i.e., the is_signature_allowed flag). We can consider InnerRequest as two lists of actions: the first, OutList, is an optional chain of cell references, each containing a send message request led by the message mode. The second, ActionList, is led by a one-bit flag, has_other_actions, which marks the presence of extended actions, starting from the first cell and continuing as a chain of cell references. We are already familiar with the first two extended actions, action_add_ext and action_delete_ext, followed by the internal address that we want to add or delete from the extensions dictionary. The third, action_set_signature_auth_allowed, restricts or allows authentication through the public key, leaving the only way to interact with the wallet through extensions. This functionality might be extremely important in the case of a lost or compromised private key. Learn more about actions here. ​Exit codes Exit codeDescription 132Authentication attempt through signature while it’s disabled133seqno check failed, replay protection occurred134wallet_id does not correspond to the stored one135signature check failed136valid_until check failed137Enforce that send_mode has the +2 bit (ignore errors) set for external messages.138external_signed prefix doesn’t correspond to the received one139Add extension operation was not successful140Remove extension operation was not successful141Unsupported extended message prefix142Tried to disable auth by signature while the extension dictionary is empty143Attempt to set signature to an already set state144Tried to remove the last extension when signature is disabled145Extension has the wrong workchain146Tried to change signature mode through external message147Invalid c5, action_send_msg verification failed0Standard successful execution exit code. ​Get methods int is_signature_allowed() returns stored is_signature_allowed flag. int seqno() returns current stored seqno. int get_wallet_id() returns current wallet ID. int get_public_key() returns current stored public key. cell get_extensions() returns extensions dictionary. ​Gasless transactions Starting with v5, the wallet smart contract supports owner-signed internal messages (internal_signed), which enables gasless transactions—for example, paying network fees in USDT when transferring USDT. Gasless transactions are supported not at the network protocol level, meaning that to pay fees in USDT it is necessary to rely on some off-chain infrastructure, e.g., like in Tonkeeper. Flow scheme for Tonkeeper gasless transactions looks like this: ​Flow details When sending USDT, the user signs one message containing two outgoing USDT transfers: USDT transfer to the recipient’s address. Transfer of a small amount of USDT in favor of the service. This signed message is sent off-chain by HTTPS to the service backend. The service backend sends it to the TON Blockchain, paying Toncoin for network fees. The beta version of the gasless backend API is available at tonapi.io/api-v2. If you are developing a wallet app and have feedback about these methods, please share it in @tonapitech chat.Was this page helpful?YesNoSuggest editsRaise issuePreviousHow to interactNext⌘IgithubxtelegramPowered by MintlifyOn this pagePersistent memory layoutMessage layoutExternal message body layoutInternal message body layoutAuthentication processActionsExit codesGet methodsGasless transactionsFlow details",
    "category": "wallets",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "backend",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:25:21.873Z"
  },
  {
    "id": "docs-ton-org--standard-wallets-mnemonics",
    "title": "Mnemonics",
    "url": "https://docs.ton.org/standard/wallets/mnemonics",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsHow they workMnemonicsComparisonPerformance benchmarkHow to interactHistoryV4V5Highload WalletsLockup walletPreprocessed Wallet V2Restricted walletTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationWalletsMnemonicsStandard contractsWalletsMnemonicsCopy pageCopy page​Key pair TON Blockchain uses asymmetric cryptography, such as the Ed25519 signature scheme. There are multiple ways to derive a key pair from a mnemonic. Below is the most common approach in TON. Some apps in the TON ecosystem may use a different derivation method, eventually producing an Ed25519-conformant key pair. ​Key pair from a mnemonic To transform a mnemonic phrase into a key pair, a seed is first derived using PBKDF2, and the key pair is then derived from that seed. PBKDF2 has five input parameters: PRF, Password, Salt, c, and dkLen. Each of those parameters is assigned a concrete value. The most commonly used values are: ParameterDescriptionValuePRFPseudo-random function of two parametersHMAC‑SHA512PasswordMaster password from which a derived key is generated\"\"SaltSequence of bits, known as a cryptographic salt\"TON default seed\"cNumber of iterations desired100000dkLenDesired bit-length of the derived key64 ​Generate a key pair TypeScriptCopyAsk AIimport { mnemonicToPrivateKey, mnemonicNew } from \"@ton/crypto\"; // Replace with your own persisted mnemonic phrase (see note below). const mnemonicArray = await mnemonicNew(); // derive private and public keys from the mnemonic const keyPair = await mnemonicToPrivateKey(mnemonicArray); console.log(\"Public Key: \" + keyPair.publicKey.toString('hex')); console.log(\"Private Key: \" + keyPair.secretKey.toString('hex')); The private key is needed to sign messages, and the public key is stored in the wallet’s smart contract. When new external messages arrive on that smart contract, the public key would be used to check the authenticity of the messages signed using the corresponding private key. ImportantSave the generated mnemonic seed phrase. If you need deterministic behavior during development, print and reuse the exact phrase so the wallet derives the same key pair on every run. ​Mnemonic validation Check that all the words are from the list of BIP-39. If a password is used: the first byte of the derived seed computed with c = 1 and salt = 'TON fast seed version' must equal 0. If no password is used: the first byte of the derived seed computed with c = floor(100000/256) = 390 and salt = 'TON seed version' must equal 1. Random mnemonic phrases are generated until PBKDF2 yields a seed whose first byte matches the expected version (0 for the ‘fast seed’ parameters, 1 for the ‘seed version’ parameters); then a valid mnemonic is returned. ​Generate a mnemonic TypeScriptCopyAsk AIimport { mnemonicNew } from \"@ton/crypto\"; const mnemonicArray = await mnemonicNew(); console.log(mnemonicArray); Was this page helpful?YesNoSuggest editsRaise issuePreviousComparisonNext⌘IgithubxtelegramPowered by MintlifyOn this pageKey pairKey pair from a mnemonicGenerate a key pairMnemonic validationGenerate a mnemonic",
    "category": "wallets",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:25:24.873Z"
  },
  {
    "id": "docs-ton-org--ecosystem-wallet-apps-get-coins",
    "title": "How to get coins on testnet",
    "url": "https://docs.ton.org/ecosystem/wallet-apps/get-coins",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appswallet.ton.orgTonkeeperGet coins on testnetDeep linksAddresses workflowExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationWallet appsHow to get coins on testnetEcosystemWallet appsHow to get coins on testnetCopy pageCopy pageTestnet coins are used for development and testing on the TON testnet. To obtain testnet Toncoin, a testnet wallet is required. Depending on the required amount of Toncoin, choose one of the following options: For regular requests of 2 TON per hour, use Telegram Testgiver TON bot. For larger allocations of up to 5,000 TON, submit a request form. ​Use Testgiver TON Bot Download Telegram and create an account. Open @testgiver_ton_bot in a browser and click Open Telegram. Once the bot opens, click Start to initiate the session. After the /start command is sent, the bot displays a welcome message. Click Get 2 TON in testnet to request test coins. A captcha prompt appears. Open the image to view it in full size and enter the displayed characters. Once the captcha is complete, enter the testnet wallet address. Verify that the pasted address belongs to the testnet. Mainnet and testnet addresses are distinct. See Internal address formats for details. After submitting the address, a message confirms that the request is queued. Then, the bot processes it and sends 2 Toncoin in testnet. No additional confirmation is sent when the request is processed. To confirm receipt of the testnet Toncoin, see Verify the transfer. To request again, open the menu in the lower-left corner, select /get, and repeat the steps. ​Use request form Request up to 5,000 testnet TON by completing the token request form. The TON Foundation reviews the submission and transfers the tokens directly to the specified testnet wallet address. ​Verify the transfer After requesting tokens, use the Tonviewer Testnet explorer to verify that the transfer occurred. Open Tonviewer Testnet, enter the wallet address in the search bar, and click Find. The explorer shows the current balance and transaction history, including the testnet Toncoin received from the bot. The account state is uninit, indicating that the account is not deployed. To deploy the account send any transaction from the wallet. Was this page helpful?YesNoSuggest editsRaise issuePreviousDeep linksNext⌘IgithubxtelegramPowered by MintlifyOn this pageUse Testgiver TON BotUse request formVerify the transfer",
    "category": "wallets",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "testnet",
      "mainnet",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:25:27.134Z"
  },
  {
    "id": "docs-ton-org--ecosystem-wallet-apps-web",
    "title": "wallet.ton.org",
    "url": "https://docs.ton.org/ecosystem/wallet-apps/web",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appswallet.ton.orgTonkeeperGet coins on testnetDeep linksAddresses workflowExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationWallet appswallet.ton.orgEcosystemWallet appswallet.ton.orgCopy pageCopy pagewallet.ton.org is a self-custodial wallet web app that doesn’t require installation. It supports regular wallets, Jettons, and NFTs. Its source code can be found here. 🟡 Account balance displays the total amount of Toncoin and other tokens held on account. 🔴 Account address is shown both as a QR code and as a base64-encoded string. You can share this address to receive TON, jettons, or NFTs. 🟢 Send button opens the transfer form, allowing you to send TON or jettons to another account address. ​Create a wallet A wallet is required to do any transactions on a public global network. It is the primary way to interact with the blockchain. This step-by-step guide explains how to use wallet.ton.org app to create a testnet wallet account. Testnet is used instead of mainnet, because it is more suitable for development and experimentation, and test coins can be obtained for free on testnet. The procedure works the same way on mainnet, except funds will have to be procured in a different way. Overall procedure is: Generate a mnemonic (a key). It uniquely determines wallet’s address, but the wallet doesn’t exist on blockchain yet, i.e. is in nonexist status. Send some funds to the wallet’s account. Now it will be in uninit status, i.e. already with some balance on it, but without any code yet. Deploy wallet’s code to this address. Some of these funds will be used to pay for the deploy process. Now the wallet is in active status, and can be used for any purpose. Funds at riskAddresses of both mainnet and testnet accounts can be derived from the same mnemonic, i.e. the same key might be used for both wallets. Beware these accounts exist only in their corresponding networks.It’s possible to forget switching to testnet, and accidentally spend real funds on mainnet.It’s possible to accidentally transfer funds to a testnet wallet address on mainnet. These funds will be impossible to recover.Verify which network is used before any funds are sent. Bug!There is a bug in wallet.ton.org. Mainnet subwallet ID is used to generate the address of testnet account.If an address from wallet.ton.org doesn’t match an address computed with @ton/ton or some other library, this might be the reason. ​Generate a key Open wallet.ton.org. Click “Create Wallet”. Choose “Use Password”. Set and confirm password. Password will be used to encrypt the mnemonic that is stored in browser’s local storage. Save 24 words of the mnemonic. Pass the check that the mnemonic was actually saved. Now the app should show its main interface. ​Switch to testnet Click the “Settings” icon. In the settings window, double-click the wallet version number to open developer options. In the “Developer options” panel, locate the “Networks” section and select “Testnet”. The interface should indicate that testnet is used. Also address of the testnet wallet in the user-friendly format starts with k or 0. ​Add funds into the wallet There is a separate article on this. Message @testgiver_ton_bot in Telegram. Press the Start button or send /start message. Pass the captcha test. Enter and send the testnet wallet address displayed by wallet.ton.org. Soon after the “Request added to the queue” response, 2 TON will be sent to the wallet. There won’t be any other message that the transfer happened. Use an explorer to check the request status. The account should be in the uninit status now. ​Deploy the code Funds at riskOn-chain transfers are irreversible — verify the recipient and amount before confirming. Use testnet for practice; only use mainnet when you intend to make a real transfer. To deploy the code, send any transaction from the wallet. The recipient can be any address, including the wallet itself. Click “Send”, enter wallet address in “Recipient Address”, and the “Amount” of TON. Click “Send TON”. In the confirmation popup, verify the transaction details and click “Confirm” if correct; otherwise, “Edit”. After confirmation, the wallet will display a notification: “Coins have been sent!” Use an explorer to check wallet’s status. It should be active now. ​Check the account state Use a blockchain explorer to inspect the account. For Testnet, use Tonviewer Testnet. Paste the wallet address into the search bar. The account details will appear. In a newly created wallet, the status is nonexist, indicating the wallet is not deployed. ​Verify wallet’s version By default, wallet.ton.org creates wallets with the Wallet v5 code deployed on them. To check which wallet contract version is used: Click the “Settings” icon. In the “Wallet Versions”, you can see which contract the wallet uses. Click the field to view the current version, for example, W5. Was this page helpful?YesNoSuggest editsRaise issuePreviousTonkeeperNext⌘IgithubxtelegramPowered by MintlifyOn this pageCreate a walletGenerate a keySwitch to testnetAdd funds into the walletDeploy the codeCheck the account stateVerify wallet’s version",
    "category": "wallets",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "testnet",
      "mainnet",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:25:28.874Z"
  },
  {
    "id": "docs-ton-org--standard-tokens-overview",
    "title": "Token overview",
    "url": "https://docs.ton.org/standard/tokens/overview",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensOverviewMetadataJettonsNFTAirdropVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationTokensToken overviewStandard contractsTokensToken overviewCopy pageCopy pageThis article compares different kinds of Tokens in TON. The TON blockchain supports three distinct categories of digital tokens, each designed to serve different purposes within the ecosystem. Fungible tokens (Jettons) - this is a web3 way to create new currency on your own Non-Fungible Tokens (NFTs) - like Jettons, but each token is unique and represents a distinct entity Soul-bound Tokens (SBTs) - like NFTs, but not-transferable, bound to a single owner ​Comparison table FeatureJettonsNFTsSBTsFungibilityFungibleNon-fungibleNon-fungibleTransferability✅ Transferable.✅ Transferable❌ Non-transferableDivisibility✅ Divisible❌ Indivisible❌ IndivisiblePrimary use caseCurrency, utilityArt, collectiblesCredentials, identityValue typeMonetary valueUnique valueReputational valueOwnership modelLiquid ownershipVerifiable ownershipPermanent bindingStandardTEP-0074TEP-0062TEP-0085Was this page helpful?YesNoSuggest editsRaise issuePreviousMetadataNext⌘IgithubxtelegramPowered by MintlifyOn this pageComparison table",
    "category": "tokens",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:25:30.945Z"
  },
  {
    "id": "docs-ton-org--standard-tokens-jettons-overview",
    "title": "Overview",
    "url": "https://docs.ton.org/standard/tokens/jettons/overview",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensOverviewMetadataJettonsOverviewHow it worksComparisonMintless JettonMinting jettonsBurnHow to find Jetton walletHow to transfer JettonsGet Jetton wallet dataGet supply dataDeploy mintless JettonAPINFTAirdropVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationJettonsOverviewStandard contractsTokensJettonsOverviewCopy pageCopy pageJettons (TEP-74 standard) serve as TON’s counterpart to Ethereum’s ERC-20 tokens, functioning as the primary means of representing monetary value and fungible assets within the TON ecosystem. These tokens embody the principle of fungibility, where each unit holds identical value and can be seamlessly exchanged with any other unit of the same token type. Use cases: To represent currency on-chain, like USDT. Each Jetton can be arbitrary fraction (1 Jetton = 10-6 USD) To empower governance-like voting systems. Each Jetton equals a vote To represent deposit size in Decentralized Finance The technical architecture of Jettons reflects TON’s distributed design principles. Rather than storing all token information in a single contract, the system employs a distributed approach where each user maintains their own Jetton wallet contract. The main Jetton contract functions as a central registry, storing essential metadata and tracking total supply, while individual wallet contracts handle user-specific balances and execute transfer operations. This architecture enhances scalability and reduces congestion compared to centralized token models. Read more: Jetton standard comparison TEP-74 Was this page helpful?YesNoSuggest editsRaise issuePreviousHow it worksNext⌘IgithubxtelegramPowered by Mintlify",
    "category": "tokens",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:25:33.411Z"
  },
  {
    "id": "docs-ton-org--standard-tokens-nft-overview",
    "title": "NFT: Non-fungible token",
    "url": "https://docs.ton.org/standard/tokens/nft/overview",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensOverviewMetadataJettonsNFTOverviewHow it worksDeploy an NFT itemHow to transferHow to get metadata of an NFT itemHow to verify NFT itemComparisonSBT: How it worksReference implementationNFT 2.0APIAirdropVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationNFTNFT: Non-fungible tokenStandard contractsTokensNFTNFT: Non-fungible tokenCopy pageCopy pageNon‑Fungible Tokens (TEP‑62) represent the digital embodiment of uniqueness within the TON ecosystem. Unlike their fungible counterparts, each NFT possesses distinct characteristics that make it irreplaceable and non‑interchangeable. This fundamental property of uniqueness enables NFTs to serve as digital certificates of authenticity for a wide array of digital and physical assets. The power of NFTs lies in their ability to prove verifiable ownership of digital assets through blockchain technology. Each token carries a unique identifier and associated metadata that distinguish it from every other token in existence. This uniqueness makes NFTs particularly valuable for representing assets where individual characteristics matter significantly. Use cases: Digital art Real-world assets Access rights The technical implementation of NFTs in TON mirrors the distributed architecture philosophy found in Jettons. Individual item contracts represent each NFT, while collection contracts manage overall collection metadata and coordinate minting processes. This distributed approach ensures that NFT operations remain efficient and scalable even as collections grow to encompass thousands or even millions of individual tokens. ​Architecture and smart contracts NFTs in TON are built using a distributed smart contract architecture consisting of: NFT collection contracts — serve as the source of truth for items, providing addresses, collection metadata, and coordinating the overall collection NFT item contracts — each NFT is represented by its own smart contract account, storing the collection address, index, current owner, and individual metadata This architecture ensures that each NFT operates independently while maintaining a connection to its collection, enabling efficient and scalable operations. ​Transfer mechanism The current owner sends a transfer message to the NFT item contract, which updates the owner field and optionally sends notifications to the new owner along with any excess Toncoin. This transfer flow ensures atomicity while maintaining flexibility for ownership notifications and handling remaining funds. Read more: NFTs explained TEP-62 Was this page helpful?YesNoSuggest editsRaise issuePreviousHow it worksNext⌘IgithubxtelegramPowered by MintlifyOn this pageArchitecture and smart contractsTransfer mechanism",
    "category": "tokens",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:25:34.808Z"
  },
  {
    "id": "docs-ton-org--standard-tokens-nft-sbt",
    "title": "SBT: How it works",
    "url": "https://docs.ton.org/standard/tokens/nft/sbt",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensOverviewMetadataJettonsNFTOverviewHow it worksDeploy an NFT itemHow to transferHow to get metadata of an NFT itemHow to verify NFT itemComparisonSBT: How it worksReference implementationNFT 2.0APIAirdropVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationNFTSBT: How it worksStandard contractsTokensNFTSBT: How it worksCopy pageCopy pageSoul-Bound Tokens (SBTs) represent non-transferable digital credentials in the TON ecosystem. Unlike standard NFTs, SBTs are permanently bound to their owner and cannot be transferred to another address after minting. The canonical specification is defined in TEP-85. The SBT standard provides a general interaction scheme while leaving the specific implementation of related contracts to developers. ​Contract data storage The SBT standard defines what data must be stored in the contract. Each SBT contract must store the following fields: FieldTypeDescriptionindexuint256SBT identifiercollection_addressMsgAddressCollection addressownerMsgAddressOwner addresscontentCellSBT content/metadataauthorityMsgAddressAuthority address that can revoke the SBTrevoked_atuint64Revocation time in Unix format, or 0 if not revoked The standard defines what must be stored in the contract, but does not specify how exactly this data should be structured in storage. Developers are free to choose their own implementation. ​Message layouts Interactions with SBT contracts, which are most often encountered by users and developers, are: prove ownership: sending proof of SBT ownership to a destination contract. request current owner: requesting current owner information from SBT. destroy SBT: destroying the SBT contract and returning remaining balance. revoke SBT: marking the SBT as revoked by authority. All message schemes include the query_id field. This field is primarily used for off-chain parsing and linking request-response pairs. The protocol itself does not require it for on-chain logic. ​Bound to single owner The owner field is set during minting and remains immutable. The following sections describe the key operations and their message flows. ​Prove ownership This message flow allows the owner to ask the SBT to send a proof to a destination contract confirming that they own this SBT. May include arbitrary forward_payload and optionally attach content. ​Prove ownership message (inbound to SBT) TL-BCopyAsk AI;; Inbound message to SBT prove_ownership#04ded148 query_id:uint64 destination:MsgAddress forward_payload:^Cell with_content:Bool = InternalMsgBody; NameTypeDescriptionquery_iduint64Arbitrary identifier to link request and response.destinationMsgAddressAddress of the destination contract to receive the proof.forward_payloadCellArbitrary data forwarded to the destination contract.with_contentBoolIf true, attach SBT content to the proof. ​Ownership proof message (SBT -> destination contract) TL-BCopyAsk AI;; SBT response to the destination contract (if checks pass) ownership_proof#0524c7ae query_id:uint64 item_id:uint256 owner:MsgAddress data:^Cell revoked_at:uint64 content:(Maybe ^Cell) = InternalMsgBody; NameTypeDescriptionquery_iduint64Matches the query_id from the request.item_iduint256Identifier of the SBT item.ownerMsgAddressCurrent owner address.dataCellEquals forward_payload from the request.revoked_atuint64Revoke time if SBT is revoked, 0 otherwise.contentMaybe CellSBT content if requested with with_content=true. The transaction is rejected if the sender is not the owner. ​Request current owner This message flow allows any initiator to ask the SBT to send the current owner (and optionally the content) to a destination contract. ​Request owner message (inbound to SBT) TL-BCopyAsk AI;; Inbound message to SBT request_owner#d0c3bfea query_id:uint64 destination:MsgAddress forward_payload:^Cell with_content:Bool = InternalMsgBody; NameTypeDescriptionquery_iduint64Arbitrary identifier to link request and response.destinationMsgAddressAddress of the destination contract to receive the info.forward_payloadCellArbitrary data forwarded to the destination contract.with_contentBoolIf true, attach SBT content in the response. ​Owner info message (SBT -> destination contract) TL-BCopyAsk AI;; SBT response to the destination contract owner_info#0dd607e3 query_id:uint64 item_id:uint256 initiator:MsgAddress owner:MsgAddress data:^Cell revoked_at:uint64 content:(Maybe ^Cell) = InternalMsgBody; NameTypeDescriptionquery_iduint64Matches the query_id from the request.item_iduint256Identifier of the SBT item.initiatorMsgAddressAddress of the requester.ownerMsgAddressCurrent owner address.dataCellEquals forward_payload from the request.revoked_atuint64Revoke time if revoked, 0 otherwise.contentMaybe CellSBT content if requested. ​Destroy This message flow allows the owner to destroy the SBT contract. This clears the owner and authority fields, and sends remaining balance back to the sender via an excesses message. ​Destroy message (inbound to SBT) TL-BCopyAsk AI;; Internal message to SBT destroy#1f04537a query_id:uint64 = InternalMsgBody; NameTypeDescriptionquery_iduint64Arbitrary identifier to link request and response. ​Excesses message (SBT -> sender) TL-BCopyAsk AI;; Excess returned to the sender excesses#d53276db query_id:uint64 = InternalMsgBody; NameTypeDescriptionquery_iduint64Matches the query_id from the request. The transaction is rejected if the sender is not the owner. ​Revoke SBT This message flow allows the authority to mark the SBT as revoked. Revoking twice is disallowed. ​Revoke message (inbound to SBT) TL-BCopyAsk AI;; Inbound message to SBT revoke#6f89f5e3 query_id:uint64 = InternalMsgBody; NameTypeDescriptionquery_iduint64Arbitrary identifier for off-chain parsing. The transaction is rejected if: the sender is not the authority; the SBT was already revoked. Was this page helpful?YesNoSuggest editsRaise issuePreviousReference implementationNext⌘IgithubxtelegramPowered by MintlifyOn this pageContract data storageMessage layoutsBound to single ownerProve ownershipProve ownership message (inbound to SBT)Ownership proof message (SBT -> destination contract)Request current ownerRequest owner message (inbound to SBT)Owner info message (SBT -> destination contract)DestroyDestroy message (inbound to SBT)Excesses message (SBT -> sender)Revoke SBTRevoke message (inbound to SBT)",
    "category": "tokens",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:25:37.313Z"
  },
  {
    "id": "docs-ton-org--ecosystem-ton-connect-overview",
    "title": "TON Connect overview",
    "url": "https://docs.ton.org/ecosystem/ton-connect/overview",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectOverviewIntegrate a dAppIntegrate a walletManifestsMessage lookupWalletKitTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationTON ConnectTON Connect overviewEcosystemTON ConnectTON Connect overviewCopy pageCopy pageTo integrate with TON, the standard wallet connection protocol is used — TON Connect. It is similar to WalletConnect on Ethereum, but made specifically for TON and covers basic integration aspects. For deeper integrations, it’s common to utilize various supplementary SDKs and APIs. ​About TON Connect Your browser does not support the <video> tag. TON Connect enables secure communication between wallets and decentralized applications, allowing users to authorize transactions while maintaining control of their private keys. Currently, TON Connect supports over 30 wallets and connects to hundreds of major applications across the TON ecosystem. As the mandatory connection protocol for all Telegram Mini Apps, it serves as the gateway to TON’s entire ecosystem of applications and services. Think of it as the essential infrastructure that your institutional clients will need to access any TON-based services — from DeFi protocols to gaming applications to payment systems. For technical architecture details: TON Connect protocol specification on GitHub. ​Are you building a web3 app? Explore the demo apps made with React. Demo TON dApp with ReactDemo TON dApp GitHub repository Proceed with integration and usage recipes. How to integrate a dApp with TONCommon usage examples Skim the related reference pages. App manifest@tonconnect/sdk@tonconnect/ui@tonconnect/ui-react ​Are you building a web3 wallet? Follow the step-by-step guide. How to make a wallet on TON Or skim the related reference pages. Wallet manifestWalletKit reference@tonconnect/protocol For more, see the TON Connect articles from Google Docs. QA GuideNative or web walletsIn-app or browser extension wallets ​Join the community If you have questions about integrating TON into your project, need help troubleshooting issues, or want to discuss best practices with other developers, join our community channels. Telegram folder with many developer chatsList of skilled professionals and agencies ​See also Technical specification of the TON Connect protocol (GitHub) Official list of wallets that support TON Connect (GitHub) HTTP bridge for TON Connect Was this page helpful?YesNoSuggest editsRaise issuePreviousIntegrate a dAppNext⌘IgithubxtelegramPowered by MintlifyOn this pageAbout TON ConnectAre you building a web3 app?Are you building a web3 wallet?Join the communitySee also",
    "category": "integration",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "dapp",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "react",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:25:38.186Z"
  },
  {
    "id": "docs-ton-org--foundations-serialization-cells",
    "title": "Cells",
    "url": "https://docs.ton.org/foundations/serialization/cells",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationCellsLibrary referencesMerkle proofsMerkle updatesPruned branchesBag of cellsAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationSerializationCellsBlockchain foundationsSerializationCellsCopy pageCopy page​Basic structure The TON Virtual Machine (TVM) memory, persistent storage, and smart contract code consist of cells. In turn, each cell consists of up to 1023 bits; up to 4 references to other cells. Circular references are forbidden and cannot be created, because computing cryptographic hash function of data that contains the same hash is impossible. In this way, all cells are kept in TVM memory and persistent storage constitute a directed acyclic graph (DAG). From the perspective of low-level cell operations, these data bits and cell references are not intermixed. In other words, a cell essentially is a couple consisting of a list of up to 1023 bits and a list of up to four cell references, without prescribing an order in which the references and the data bits should be deserialized, even though TL-B schemes appear to suggest such an order. ​Kinds of cells There are two kinds of cells: ordinary and exotic. The former are the simplest and most commonly used flavor of cells, which can only contain data and references, while the latter are used for special purposes only. They sometimes appear in actual representations of blocks and other data structures on TON Blockchain. Their memory layouts and purposes differ significantly from ordinary cells. From the low-level perspective, ordinary and exotic cells can be distinguished by a special 1-bit flag stored outside the main 1,023 bits and read by TVM at runtime. Users cannot read this flag directly. TVM can support up to 256 different types of exotic cells, each identified by a special 8-bit type identifier stored in the first byte of the cell data. TVM supports four types of exotic cells: Type IDDescription0x01Pruned branch0x02Library reference0x03Merkle proof0x04Merkle update ​Level of a cell Every cell c has an attribute Lvl(c)Lvl(c)Lvl(c) called its level, which takes integer values in the range 0…3. A cell’s level affects the number of higher hashes it has. The level of an ordinary cell ccc is equal to the maximum of the levels of all its children cic_ici​: Lvl(c)=max⁡iLvl(ci).Lvl(c) = \\max_i Lvl(c_i).Lvl(c)=imax​Lvl(ci​). For instance, each cell in a tree of cells that does not contain any exotic cell has level 0. Exotic cells may have different rules for setting their level. ​Standard cell representation and its hash Before a cell can be transferred over the network or stored on disk, it must be serialized. A common way to do this is to use the so-called standard cell representation, CellRepr(c). The standard representation of a cell c is a byte sequence that is constructed as follows: Two descriptor bytes d1d_1d1​ and d2d_2d2​ are serialized first. Byte d1d_1d1​ equals r+8s+32l, where 0 ≤ r ≤ 4 is the quantity of cell references contained in the cell, 0 ≤ l ≤ 3 is the level of the cell, and 0 ≤ s ≤ 1 is 1 for exotic cells and 0 for ordinary cells. Byte d2d_2d2​ equals ⌊b8⌋+⌈b8⌉\\lfloor\\frac{b}{8}\\rfloor + \\lceil\\frac{b}{8}\\rceil⌊8b​⌋+⌈8b​⌉, where 0 ≤ b ≤ 1023 is the quantity of data bits in c. Then the data bits are serialized as ⌈b8⌉\\lceil\\frac{b}{8}\\rceil⌈8b​⌉ bytes. If b is not a multiple of eight, a binary 1 and up to six binary 0s are appended to the data bits. After that, the data is split into ⌈b8⌉\\lceil\\frac{b}{8}\\rceil⌈8b​⌉ 8-bit groups, and each group is interpreted as an unsigned big-endian integer 0 … 255 and stored into a byte. Next, for every referenced cell, 2 bytes in big-endian format store the depth of the refs, i.e. the number of cells between the root of the cell tree (the current cell) and the deepest reference, including it. For example, a cell containing only one reference and no further references would have a depth of 1, while the referenced cell would have a depth of 0. Finally, for every referenced cell, the SHA-256 hash of its standard representation is stored, occupying 32 bytes per referenced cell, recursively repeating the said algorithm. Note that cyclic cell references are not allowed, so this algorithm always terminates. If there are no referenced cells, neither depths nor hashes are stored. In this way, 2+⌈b8⌉+2r+32r2 + \\lceil\\frac{b}{8}\\rceil + 2r + 32r2+⌈8b​⌉+2r+32r bytes of CellRepr(c) are obtained. Thus, we got the serialization of c. However, the serialization of graphs formed by cells is arranged differently; see bag of cells for details. ​Cell manipulation Cells are read-only and immutable, but there are two major sets of ordinary cell manipulation instructions in TVM: Cell creation (or serialization) instructions, which are used to construct new cells from previously stored values and cells. Cell parsing (or deserialization) instructions, which are used to extract or load data previously stored into cells via serialization instructions. All cell manipulation instructions require transforming values of Cell type into either builder or slice types before such cells can be modified or inspected. Libraries like @ton/core and @ton-community/assets-sdk provide efficient cell handling. Below are examples of sequential cell creation, populating it with data, and then parsing. ​Create a cell and store data To build a cell, you use the beginCell() function. While the cell is open, you can store various data types with store...() functions. When you’re done, you close the cell with the endCell() function. CopyAsk AIimport { Address, beginCell } from \"@ton/core\"; const cell = beginCell() .storeUint(99, 64) // Stores uint 99 in 64 bits .storeAddress(Address.parse(\"EQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM9c\")) // Stores an address .storeCoins(123) // Stores 123 as coins .endCell(); // Closes the cell Each cell has a 1023-bit limit. If you exceed this, an error occurs: CopyAsk AI// This will fail due to overflow const cell = beginCell() .storeUint(1, 256) .storeUint(2, 256) .storeUint(3, 256) .storeUint(4, 256) // Exceeds 1023-bit limit (256 + 256 + 256 + 256 = 1024) .endCell(); To store more data, cells can reference up to four other cells. You can use the storeRef() function to create nested cells: CopyAsk AIconst cell = beginCell() .storeUint(1, 256) .storeUint(2, 256) .storeRef(beginCell().storeUint(3, 256).storeUint(4, 256).endCell()) .endCell(); You can store optional (nullable) values in cells by using the storeMaybe...() helpers: CopyAsk AIconst cell = beginCell() .storeMaybeInt(null, 64) // Optionally stores an int .storeMaybeInt(1, 64) .storeMaybeRef(null) // Optionally stores a reference .storeMaybeRef(beginCell().storeCoins(123).endCell()) .endCell(); ​Load data from a cell To read data from a cell, you first convert it into a slice using the beginParse() function. Then, you can extract various data types with load...() functions. You read data in the same order it was stored. CopyAsk AIconst slice = cell.beginParse(); const uint = slice.loadUint(64); const address = slice.loadAddress(); const coins = slice.loadCoins(); To load a referenced (nested) cell, use loadRef(): CopyAsk AIconst slice = cell.beginParse(); const uint1 = slice.loadUint(256); const uint2 = slice.loadUint(256); const innerSlice = slice.loadRef().beginParse(); // Load and parse nested cell const uint3 = innerSlice.loadUint(256); const uint4 = innerSlice.loadUint(256); You can parse optional values using the corresponding loadMaybe...() functions. Returned values are nullable, so do not forget to check them for null. CopyAsk AIconst slice = cell.beginParse(); const maybeInt = slice.loadMaybeInt(64); const maybeInt1 = slice.loadMaybeInt(64); const maybeRef = slice.loadMaybeRef(); const maybeRef1 = slice.loadMaybeRef(); if (maybeRef1) { const coins = maybeRef1.beginParse().loadCoins(); } ​References Parse and view TON smart contract cells in a human-readable format. Was this page helpful?YesNoSuggest editsRaise issuePreviousLibrary referencesNext⌘IgithubxtelegramPowered by MintlifyOn this pageBasic structureKinds of cellsLevel of a cellStandard cell representation and its hashCell manipulationCreate a cell and store dataLoad data from a cellReferences",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:25:40.048Z"
  },
  {
    "id": "docs-ton-org--foundations-serialization-boc",
    "title": "Bag of cells",
    "url": "https://docs.ton.org/foundations/serialization/boc",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationCellsLibrary referencesMerkle proofsMerkle updatesPruned branchesBag of cellsAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationSerializationBag of cellsBlockchain foundationsSerializationBag of cellsCopy pageCopy pageArbitrary data are represented in TON Blockchain by trees of cells. Such a tree of cells is transformed into a DAG of cells by identifying cells in the tree that have the same hash. After that, each of the references of each cell might be replaced by the 32-byte representation hash of the cell referred to. Thus a bag of cells (BoC) is obtained. CopyAsk AI🔵 Roots: [0x1111] 0x1111 Refs: [0x2222, 0x3333] 0x2222 Refs: [0x4444] 0x3333 Refs: [0x4444] 0x4444 Refs: [] In general, a BoC can be obtained from several trees of cells, thus forming a forest. By convention, the roots of the original trees of cells are marked elements of the resulting bag of cells, so that anybody receiving this bag of cells and knowing the marked elements can reconstruct the original forest. However, this BoC needs to be serialized into a file, suitable for disk storage or network transfer. CopyAsk AI🔵 Roots: [0x1111, 0x2222] 0x1111 Refs: [0x3333] 0x2222 Refs: [0x3333] 0x3333 Refs: [] There may be many different ways to serialize such a data structure, each of which has its own goals and is convenient for specific cases. This page provides a general serialization algorithm and specification of the corresponding TL-B schemes, followed by the example and specific implementation used in the TON Blockchain. Even though the syntax looks very much like TL-B, it cannot be used in most of the TL-B tooling. Unlike in real TL-B, these schemas serialize to a bitstring with no 1023 bit length limit, and without any refs. ​General scheme ​Internal references, absent cells, and complete BoCs For an arbitrary cell c in a given BoC, references to it can be either: internal if the cell corresponding to the reference is also represented in BoC, external if it’s not in BoC. Such cell c is called absent from this BoC. A BoC is called complete if it does not contain any external references. Most real-world BoCs are complete. ​Outline of serialization process This paragraphs provide a textual description of the BoC serialization process. The specific implementation of the serialization and TL-B schemes is left to the choice of developers.For a specific example of TL-B schema and pseudocode of related cell serialization, see TL-B schema. The serialization process of a BoC B consisting of n cells can be outlined as follows. List the cells from B in a topological order: c1, ..., cn(with c1, ..., ck as root cells, if B is a forest). Choose the smallest number of bytes s that can contain the binary representation of n. Serialize each cell ci in a way similar to standard representation algorithm, with exceptions: d1 = r + 8s + 16h + 32l where h = 1 if the cell’s hashes are explicitly included into the serialization; otherwise, h = 0 (when r = 7, h must be 1); if h = 1, after bytes b1 and b2 the serialization is continued by l + 1 32-byte higher hashes of c; unsigned big-endian s-bit integer j used instead of hash Hash(cj) to represent internal references to cell cj. Concatenate the representations of cells ci thus obtained in the increasing order of i. Optionally, an index can be constructed that consists of n t-bytes integer entries L1,…,LnL_{1}, \\ldots, L_{n}L1​,…,Ln​ where: LiL_{i}Li​ is the total length in bytes of the representations of cells cj with j ≤ i; t is the smallest number of bytes that can contain the binary representation of LnL_{n}Ln​. An optional CRC32C may be appended to the serialization for integrity verification purposes. If the index is included, any cell ci the serialized bag of cells may be easily accessed by its index i without deserializing all other cells, or even without loading the entire serialized bag of cells in memory. A final serialization of the bag of cells must include a magic number indicating the precise format of the serialization, followed by integers s, t, n, an optional index consisting of n * t bytes, LnL_nLn​ bytes with the cell representations, and an optional CRC32C checksum. Each specific implementation of the serialization process must comply with these fields and their order but, for example, may take into account number of roots, number of absent cells, and so one. ​Serialization Beware this is not an actual TL-B schema. TL-B describes serialization to cells, i.e. bits and refs, with the limit of 1023 bits per cell. This serialization describes serialization into a bitstring of arbitrary length without any refs, even though it uses syntax similar to TL-B. Only one serialization scheme of BoCs is used in TON Blockchain (there are also two outdated BoC serialization schemes in the file): PseudoTL-BCopyAsk AIserialized_boc#b5ee9c72 has_idx:(## 1) has_crc32c:(## 1) has_cache_bits:(## 1) flags:(## 2) { flags = 0 } size:(## 3) { size <= 4 } off_bytes:(## 8) { off_bytes <= 8 } cells:(##(size * 8)) roots:(##(size * 8)) { roots >= 1 } absent:(##(size * 8)) { roots + absent <= cells } tot_cells_size:(##(off_bytes * 8)) root_list:(roots * ##(size * 8)) index:has_idx?(cells * ##(off_bytes * 8)) cell_data:(tot_cells_size * [ uint8 ]) crc32c:has_crc32c?uint32 = BagOfCells; Fields size is s, off_bytes is t, cells is n, tot_cells_size is LnL_nLn​ (the total size of the serialization of all cells in bytes), index is the optional index L1,…,LnL_{1}, \\ldots, L_{n}L1​,…,Ln​, cell_data is the concatenation of the cells representations, and crc32c is the optional 4-bytes CRC32C checksum. This schema additionally includes: the 1-bit has_idx flag that indicates whether the index is included in the serialization; the 1-bit has_crc32c flag that indicates whether the CRC32C checksum is included in the serialization; the 1-bit has_cache_bits and 2-bit flags fields that are reserved for future use (flags must be zero); the roots field that indicates the number of root cells in the BoC; the absent field that indicates the number of absent cells in the BoC; the root_list field that is an indices sequence of the root cells in the BoC. ​Example: manual Consider the following example of a tree of cells: CopyAsk AI01 0aaaaa fe 0aaaaa So, there is a 2-bit root cell that references two other cells: The first is a 24-bit cell. The second is a 8-bit cell that itself references a 24-bit cell. After identifying of unique cells, we have the following: CopyAsk AI01 0aaaaa fe Next, the unique cells are arranged in a topological order: CopyAsk AI01 -> index 0 (root cell) fe -> index 1 0aaaaa -> index 2 Now, let’s calculate the descriptor bytes b1 and b2 for each of the three unique cells. So, we obtain: CopyAsk AI01 -> 0201 fe -> 0102 0aaaaa -> 0006 Then the data bits are serialized as ⌈b8⌉\\lceil\\frac{b}{8}\\rceil⌈8b​⌉ bytes. Remember, if b is not a multiple of eight, a binary 1 and up to six binary 0s are appended to the data bits. After that, the data is split into ⌈b8⌉\\lceil\\frac{b}{8}\\rceil⌈8b​⌉ 8-bit groups. CopyAsk AI01 -> 01100000 = 0x60 fe -> do not change (full groups) 0aaaaa -> do not change (full groups) Next come the depths for the refs in two bytes: CopyAsk AI01 -> 0002 fe -> 0001 0aaaaa -> 0000 Now specify which cells each one references: CopyAsk AI0: 01 -> 0201: refers to 2 cells with such indexes 1: fe -> 02: refers to cells with index 2 2: 0aaaaa -> no refs For each cell we have its hexadecimal representation: CopyAsk AI01 -> 02016000020201 fe -> 0102fe000102 0aaaaa -> 00060aaaaa0000 Finally, we concatenate all parts into a single hexadecimal array: 0x020160000202010102fe00010200060aaaaa0000. Now that we’ve serialized our cells into a flat 20-byte array, it’s time to pack them into a complete BoC format. CopyAsk AI0xb5ee9c72 -> TL-B id of the BoC structure 0b1 -> has indexes 0b0 -> does not have CRC32C 0b0 -> does not have cache bits 0b00 -> flags are 0 0b001 -> the number of bytes needed to store the number of cells is 1 0b00000001 -> the number of bytes used to represent offset of a serialization is 1 0b00000011 -> the number of cells is 3 0b00000001 -> the number of roots is 1 0b00000000 -> the number of absent cells is 0 0b00010100 -> tot_cells_size is 20 bytes 0b00000000 -> the root list; we have one root with number 0 after the topological sort 0b000001110000111000010100 -> the three 8-bits group of indexes for cells accorging to the topological sort 0x020160000202010102fe00010200060aaaaa0000 -> the cells data _ -> CRC32C is not serialized By combining everything into a single bit string, we get the result of serialization. ​Example: TypeScript According to the TL-B scheme above there is the SDK for serialization and parsing BoC. Only serialization of BoCs with one root and no absent cells is supported. There are two main functions: serializeBoc for serialization. It has two parameters: root and options object with two boo",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:25:41.516Z"
  },
  {
    "id": "docs-ton-org--languages-tl-b-overview",
    "title": "Overview",
    "url": "https://docs.ton.org/languages/tl-b/overview",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BOverviewSyntax and SemanticsSimple examplesComplex and non-trivial examplesTEP examplesToolingFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationTL-BOverviewLanguagesTL-BOverviewCopy pageCopy pageThe Type Language Binary (TL-B) for TON Blockchain is a domain-specific language designed to describe the structure of data in the TON Blockchain. It is used to define how data is serialized and deserialized, ensuring consistency and interoperability across different components of the TON ecosystem. Special TL-B parsers can read schemes to deserialize binary data into different objects. In fact, TL-B is a variant of the original Type Language (TL) developed for the Telegram Messenger and adapted to the specific needs of the TON Blockchain. It is recommended to start by studying the syntax and semantics of TL-B, simultaneously exploring each example through a convenient TL-B online editor. To further your understanding, we recommend referring to the page that describes the most complex examples of TL-B schemes.Was this page helpful?YesNoSuggest editsRaise issuePreviousSyntax and SemanticsNext⌘IgithubxtelegramPowered by Mintlify",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:25:43.587Z"
  },
  {
    "id": "docs-ton-org--ecosystem-explorers-overview",
    "title": "Overview",
    "url": "https://docs.ton.org/ecosystem/explorers/overview",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersOverviewUsing TonviewerSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationExplorersOverviewEcosystemExplorersOverviewCopy pageCopy pageExplorers are web tools for reading blockchain data. They let you look up accounts, transactions, blocks, and smart contracts, making it easy to verify activity and debug issues. ​Explorer A blockchain explorer is a website that indexes on‑chain data and presents it in a searchable user interface (UI). In TON, explorers commonly show account balances, recent transactions, jettons and non‑fungible tokens (NFTs), contract code and state, and links to related blocks and messages. ​What explorers show Balances and assets: TON, jettons, and NFTs held by an address Transactions and messages: history, fees, phases, and traces Blocks and validators: block contents, masterchain and shardchain details Smart contracts: code, state, disassembly, and known contract type Analytics: top entities, volumes, gas, fees, and network health ​Indexers Indexers continuously read blocks from nodes, parse messages and transactions, and store them in a database optimized for queries. Explorers rely on these indexers to provide fast search, traces, higher‑level events, and historical views beyond what a single node exposes by default. ​Explorers comparison ExplorerTypeMainnetTestnetOfficial TonviewerGeneral‑purposetonviewer.comTestnetNoTonscan.orgGeneral‑purposetonscan.orgTestnetNoTonscan.comGeneral‑purposetonscan.com-NoTON ExplorerLow‑level/coreexplorer.toncoin.orgTestnetYes Official: maintained by the TON Foundation or an affiliated team The verifier tool powers contract code verification.Was this page helpful?YesNoSuggest editsRaise issuePreviousUsing TonviewerNext⌘IgithubxtelegramPowered by MintlifyOn this pageExplorerWhat explorers showIndexersExplorers comparison",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "testnet",
      "mainnet",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:25:44.710Z"
  },
  {
    "id": "docs-ton-org--languages-tolk",
    "title": "Tolk — the language for TON",
    "url": "https://docs.ton.org/languages/tolk",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedOverviewBasic syntaxIdioms and conventionsType systemSyntax detailsLanguage featuresMigrating from FunCChangelogTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationTolkTolk — the language for TONLanguagesTolkTolk — the language for TONCopy pageCopy pageTolk is a statically typed language designed for TON smart contracts. It provides declarative structures, automatic cell serialization, first-class message handling, and a modern development experience. The language compiles to TVM (TON virtual machine) with zero overhead and full control over execution. CopyAsk AItype AllowedMessage = CounterIncrement | CounterReset fun onInternalMessage(in: InMessage) { val msg = lazy AllowedMessage.fromSlice(in.body); match (msg) { CounterIncrement => { ... } CounterReset => { ... } } } get fun currentCounter() { val storage = lazy Storage.load(); return storage.counter; } ​Key features Tolk offers high-level readability while remaining low-level in nature: a robust type system to express any cell layout in TON lazy loading: unused fields are skipped automatically unified message composition and deployment a gas-efficient compiler targeting the Fift assembler friendly tooling and IDE integration Tolk is fully compatible with existing TON standards and contracts. ​Tolk is a replacement for FunC Tolk started as an evolution of FunC and is now the recommended language for TON smart contracts. If you are migrating from FunC: Look through benchmarks: notice 30–50% lower gas fees. Scan the page Tolk vs FunC to get the overall picture. Use the FunC-to-Tolk converter to migrate existing projects. ​Quick start Run the command: CopyAsk AInpm create ton@latest Enter a project name and choose “simple counter contract”. Follow the “Your first smart contract” article to get explanations. ​IDE support All major IDEs support syntax highlighting and code completion: JetBrains IDEs (WebStorm, CLion, etc.) — via the plugin => install “TON” from Marketplace, read more VS Code — via the TON extension => install “TON” from Marketplace, read more Cursor and Windsurf — via the OpenVSX registry => install from the website, read more Neovim, Vim, Zed, etc. — via the language server => download an archive, consult the link above ​Where to go next Recommended starting points: Basic syntax Idioms and conventions Type system Message handling Was this page helpful?YesNoSuggest editsRaise issuePreviousBasic syntaxNext⌘IgithubxtelegramPowered by MintlifyOn this pageKey featuresTolk is a replacement for FunCQuick startIDE supportWhere to go next",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "deployment",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:25:46.917Z"
  },
  {
    "id": "docs-ton-org--standard-tokens-metadata",
    "title": "Metadata",
    "url": "https://docs.ton.org/standard/tokens/metadata",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensOverviewMetadataJettonsNFTAirdropVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationTokensMetadataStandard contractsTokensMetadataCopy pageCopy pageThe metadata standard covering NFTs, NFT collections, and jettons is outlined in TEP-64 (TON Enhancement Proposal 64). On TON, entities can have three types of metadata: on-chain, semi-chain, and off-chain. On-chain metadata: stored on the blockchain, including name, attributes, and image. Off-chain metadata: stored via a link to a metadata file hosted off-chain. Semi-chain metadata: a hybrid approach that stores small fields (e.g., name or attributes) on-chain, while hosting the image off-chain and storing only a link to it. ​Snake data encoding The Snake encoding allows a portion of data to be stored in a standardized cell, with the remainder stored recursively in child cells. In this scheme, Snake-encoded data is typically prefixed with the 0x00 byte (see the note below for exceptions). TL-B schema: TL-BCopyAsk AItail#_ {bn:#} b:(bits bn) = SnakeData ~0; cons#_ {bn:#} {n:#} b:(bits bn) next:^(SnakeData ~n) = SnakeData ~(n + 1); Read more about similar examples. When the payload exceeds the maximum size of a single cell, Snake stores the remaining data in child cells. Part of the data is placed in the root cell, and the rest in the first child cell, continuing recursively until all data is stored. Below is an example of Snake encoding and decoding in TypeScript: bufferToChunks, BitBuilder, and BitReader are provided by the surrounding tooling and helper utilities. TypeScriptCopyAsk AIexport function makeSnakeCell(data: Buffer): Cell { const chunks = bufferToChunks(data, 127) if (chunks.length === 0) { return beginCell().endCell() } if (chunks.length === 1) { return beginCell().storeBuffer(chunks[0]).endCell() } let curCell = beginCell() for (let i = chunks.length - 1; i >= 0; i--) { const chunk = chunks[i] curCell.storeBuffer(chunk) if (i - 1 >= 0) { const nextCell = beginCell() nextCell.storeRef(curCell) curCell = nextCell } } return curCell.endCell() } export function flattenSnakeCell(cell: Cell): Buffer { let c: Cell | null = cell; const bitResult = new BitBuilder(); while (c) { const cs = c.beginParse(); if (cs.remainingBits === 0) { break; } const data = cs.loadBits(cs.remainingBits); bitResult.writeBits(data); c = c.refs && c.refs[0]; } const endBits = bitResult.build(); const reader = new BitReader(endBits); return reader.loadBuffer(reader.remaining / 8); } The 0x00 byte prefix is not always required in the root cell when using Snake, for example, with off-chain NFT content. Also, cells are filled with bytes rather than bits to simplify parsing. To avoid issues when adding a reference in a child cell after it has already been written to its parent, the Snake cell is constructed in reverse order. ​Chunked encoding The chunked encoding stores data in a dictionary that maps chunk_index to a chunk. Chunked encoding must be prefixed with the 0x01 byte. This in-structure marker is distinct from the top-level content marker 0x01 that indicates off-chain content. TL-B schema: TL-BCopyAsk AIchunked_data#_ data:(HashMapE 32 ^(SnakeData ~0)) = ChunkedData; Below is an example of chunked data decoding in TypeScript: TypeScriptCopyAsk AIinterface ChunkDictValue { content: Buffer; } export const ChunkDictValueSerializer = { serialize(src: ChunkDictValue, builder: Builder) {}, parse(src: Slice): ChunkDictValue { const snake = flattenSnakeCell(src.loadRef()); return { content: snake }; }, }; export function ParseChunkDict(cell: Slice): Buffer { const dict = cell.loadDict( Dictionary.Keys.Uint(32), ChunkDictValueSerializer ); let buf = Buffer.alloc(0); for (const [_, v] of dict) { buf = Buffer.concat([buf, v.content]); } return buf; } ​NFT metadata attributes AttributeTypeRequirementDescription uriASCII stringoptionalA URI pointing to a JSON document with metadata used by the semi-chain content layout.nameUTF-8 stringoptionalIdentifies the asset.descriptionUTF-8 stringoptionalDescribes the asset.imageASCII stringoptionalA URI pointing to a resource with an image MIME type.image_databinaryoptionalEither a binary representation of the image for the on-chain layout or base64 for the off-chain layout. ​Jetton metadata attributes AttributeTypeRequirementDescription uriASCII stringoptionalA URI pointing to a JSON document with metadata used by the semi-chain content layout.nameUTF-8 stringoptionalIdentifies the asset.descriptionUTF-8 stringoptionalDescribes the asset.imageASCII stringoptionalA URI pointing to a resource with an image MIME type.image_databinaryoptionalEither a binary representation of the image for the on-chain layout or base64 for the off-chain layout.symbolUTF-8 stringoptionalToken symbol — for example, “XMPL” — used in the form “You have received 99 XMPL”.decimalsUTF-8 stringoptionalThe number of decimal places used by the token. If not specified, the default is 9. A UTF-8–encoded string containing a number from 0 to 255; for example, 8 means the on-chain amount must be divided by 100000000 to get the user-facing representation.amount_stylestringoptionalDefines how token amounts should be displayed for external applications. One of n, n-of-total, %.render_typestringoptionalIndicates how external applications should categorize and render the token. currency — display as a currency (default). game — game-style display: renders like an NFT, also shows the number of tokens, and respects amount_style. ​amount_style n — number of jettons (default). If the user has 100 tokens with 0 decimals, display 100. n-of-total — the number of jettons out of the total issued. For example, if the totalSupply is 1000 and the user has 100, display “100 of 1000” (or an equivalent representation of the ratio). % — the percentage of total issued jettons. For example, with a total of 1000 and a user balance of 100, display 10% (100 ÷ 1000 = 0.1). ​render_type currency — display as a currency (default). game — game-style display that appears as an NFT, shows the number of tokens, and respects amount_style. ​decimals Funds at riskEach jetton stores a decimals parameter in its metadata that determines how amounts are displayed. Transferring without accounting for decimals can result in sending drastically more tokens than expected.Mitigation: Always retrieve and apply the correct decimals value before calculating transfer amounts. Test transfers with small amounts on testnet first. The decimals parameter defines the number of decimal places for displaying token amounts. The on-chain balance is stored as an integer in the smallest unit (nano-tokens), and must be divided by 10^decimals to get the user-facing value. Common values: Most jettons use decimals: 9 (default when not specified) USDT uses decimals: 6 Example: If the on-chain balance is 1000000000 nano-tokens: With decimals: 9 → displayed as 1.0 token With decimals: 6 → displayed as 1000.0 tokens When transferring jettons programmatically, the amount must be calculated as: on_chain_amount = display_amount × 10^decimals. For example, to transfer 1 USDT (decimals: 6): Correct on-chain amount: 1 × 10^6 = 1000000 Incorrect (using default 9): 1 × 10^9 = 1000000000 (transfers 1000 USDT instead of 1) ​Parsing metadata To parse metadata, first retrieve the NFT data from the blockchain. For details, see retrieving NFT data. After the on-chain NFT data is retrieved, determine the content type by reading the first byte of the content, then parse accordingly. ​Off-chain If the metadata byte string starts with 0x01, the content is off-chain. Decode the remainder using Snake as an ASCII string to obtain the URL. Once you fetch the off-chain metadata and identification data, the process is complete. Example URL for off-chain NFT metadata: https://s.getgems.io/nft/b/c/62fba50217c3fe3cbaad9e7f/95/meta.json Contents of the referenced URL: jsonCopyAsk AI{ \"name\": \"TON Smart Challenge #2 Winners Trophy\", \"description\": \"TON Smart Challenge #2 Winners Trophy 1 place out of 181\", \"image\": \"https://s.getgems.io/nft/b/c/62fba50217c3fe3cbaad9e7f/images/943e994f91227c3fdbccbc6d8635bfaab256fbb4\", \"content_url\": \"https://s.getgems.io/nft/b/c/62fba50217c3fe3cbaad9e7f/content/84f7f698b337de3bfd1bc4a8118cdfd8226bbadf\", \"attributes\": [] } ​On-chain and semi-chain If the metadata byte string starts with 0x00, it indicates on-chain or semi-chain NFT metadata. The metadata is stored in a dictionary where the key is the SHA-256 hash of the attribute name, and the value is data stored using the Snake or chunked format. Read known attributes such as uri, name, image, description, and image_data. If the uri field is present, the layout is semi-chain: download the off-chain content specified by uri and merge it with the dictionary values. Examples: On-chain NFT: EQBq5z4N_GeJyBdvNh4tPjMpSkA08p8vWyiAX6LNbr3aLjI0 Semi-chain NFT: EQB2NJFK0H5OxJTgyQbej0fy5zuicZAXk2vFZEDrqbQ_n",
    "category": "tokens",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "testnet",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:25:49.154Z"
  },
  {
    "id": "docs-ton-org--standard-tokens-nft-comparison",
    "title": "NFT comparison",
    "url": "https://docs.ton.org/standard/tokens/nft/comparison",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensOverviewMetadataJettonsNFTOverviewHow it worksDeploy an NFT itemHow to transferHow to get metadata of an NFT itemHow to verify NFT itemComparisonSBT: How it worksReference implementationNFT 2.0APIAirdropVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationNFTNFT comparisonStandard contractsTokensNFTNFT comparisonCopy pageCopy pageThis page compares the available standards for each layer of the NFT protocol on TON. The protocol has two layers — Collection and Item — and you can mix standards between layers since they are independent of each other. ScopeThis page focuses on high‑level capabilities and typical trade‑offs. For low‑level details, see How it Works. ​Collection Short overview: Default Collection: canonical implementation. cNFT (compressed NFT): optimized for mass distribution. CapabilityDefault CollectioncNFT CollectionDeployment & minting flowItems are minted by the creatorAny user with a valid proof can deploy their itemWho pays for item deploymentCreator in most flowsCosts shifted to the audienceEligibility/allowlistCustom off‑chain/on‑chain logic, usually controlled by creatorOn‑chain Merkle allowlist, root readable via get_merkle_rootMinting permissionsTypically restricted to the creatorOpen to any user who provides a valid Merkle proofTypical use casesCurated drops, controlled mintingMass airdrops, growth campaigns, very large audiencesKey trade‑offsCreator bears mint costs; tighter controlLower creator cost; proof UX and distribution setup required ​cNFT A cNFT (compressed NFT) combines a standard NFT with an airdrop‑style distribution, optimized for large distributions and for shifting minting costs from the creator to end users via Merkle‑proof‑based self‑deployment. NFT items are self‑deployed by users using Merkle proofs instead of airdrop markers. ​Additional: Royalty Royalty is defined at the collection level and exposed via get_royalty_params (TEP‑66). Any collection implementation can follow this model. Marketplaces can rely on this model and pay royalties to the collection creator regardless of how the collection was deployed. ​Item Short overview: Default Item: fully transferable NFT item that implements the standard transfer operation. SBT (Soulbound Token): a non‑transferable NFT bound to a specific owner by design. CapabilityDefault ItemSBT (Soulbound Token)Transferability✅ Yes❌ NoTypical use casesArt, collectibles, tickets, gaming assetsIdentity, credentials, achievements, non‑transferable badges ​SBT An SBT inherits the uniqueness and metadata model of NFTs but disables transfer operations, binding the token permanently to the recipient’s address after mint. This makes SBTs well‑suited for identity and credentials: attendance records, participation proofs, and non‑transferable achievements. It also has an on‑chain API to prove ownership of an SBT item. ​Core functionality SBTs provide several key operations that enable secure credential management: Ownership binding - the owner is set at mint time and never changes, ensuring permanent association with the recipient. Ownership proof - allows the owner to request the SBT to send a proof to a target contract confirming ownership, with optional content attachment. Owner information requests - any party can request current owner information and optional content from the SBT. SBT destruction - the owner can destroy the SBT contract, clearing ownership and authority fields. Revocation mechanism - the authority can mark the SBT as revoked, preventing further use while maintaining historical records. ​Single NFT (no collection) A Single NFT is an item contract deployed without an associated collection. It keeps the same ownership semantics but omits shared collection metadata and indexing. When to use: one‑off assets, experimental pieces, or cases where collection‑level coordination is unnecessary. Metadata: stored entirely on the item. Discoverability: there is no collection index; external indexers or explicit links are used to surface the item. Trade‑offs: simpler setup but fewer shared features (no collection‑wide royalty/config, no batch queries by index). Was this page helpful?YesNoSuggest editsRaise issuePreviousSBT: How it worksNext⌘IgithubxtelegramPowered by MintlifyOn this pageCollectioncNFTAdditional: RoyaltyItemSBTCore functionalitySingle NFT (no collection)",
    "category": "tokens",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "deployment",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:25:51.902Z"
  },
  {
    "id": "docs-ton-org--old",
    "title": "Welcome to TON  Blockchain documentation  Welcome to  TON Blockchain  documentation",
    "url": "https://docs.ton.org/old",
    "content": "Skip to main contentDeprecated! Please, visit the new documentation at docs.ton.org Deprecated, go to new docs!Welcome to TON Blockchain documentation Welcome to TON Blockchain documentationChoose your path to start your journeyConceptsLearn TON fundamentals.GuidelinesBuild apps using TON.DocumentsLearn technical aspects of TON.Tip: search everywhere with Ctrl+K (or Cmd+K on macOS) hotkeyUseGet a WalletGet ToncoinStakeAccept PaymentsApps & ServicesDomainsUSDT on TONCross-Chain BridgesLearnTON ConceptDecentralized NetworkRoadmapTonStatHistory of MiningToncoinValidatorsWhite PaperBrand AssetsSustainabilityFor BuildersTON Builders PortalGetting StartedDocumentationTelegram Mini AppsDev ChatsBug BountyFind a JobFind a TalentUse CasesGameFiMemecoins & TokensCommunity ToolsTON SitesCommunityCommunitiesBlogCareers",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "wallet",
      "telegram",
      "mini app",
      "guide",
      "builder",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:25:53.914Z"
  },
  {
    "id": "docs-ton-org--ecosystem-explorers-tonviewer",
    "title": "Using Tonviewer",
    "url": "https://docs.ton.org/ecosystem/explorers/tonviewer",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersOverviewUsing TonviewerSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationExplorersUsing TonviewerEcosystemExplorersUsing TonviewerCopy pageCopy pageTonviewer is a TON Blockchain explorer that allows you to inspect blocks, transactions, contracts, and tokens, as well as analyze activity. ​High-level entities High-level entities provide the foundation for exploring TON Blockchain, understanding and tracking operations. They are essential for identifying transactions and tracing data flow across the network. Accounts — the primary entities representing actors on the blockchain. Addresses — unique identifiers for accounts, showing balances and activity in Tonviewer. Messages — instructions sent between addresses. In explorers, they reveal what actions are initiated and how they lead to transactions. Transactions — records of executed messages. Explorers display their details linked to a specific address. Blocks — containers of transactions. In explorers, they expose block metadata and configuration parameters, allowing you to trace activity and understand how the blockchain operates. ​Reading traces ​Traces In Tonviewer, operations are visualized through traces. A trace is a directed acyclic graph (DAG) where: transactions are nodes on an account’s address messages are edges between addresses ​Using the UI Tonviewer provides a visual interface for exploring traces: Hover over a “node” to see details about the account where a transaction succeeded or failed. Hover over an “edge” to inspect the message contents. Use “Show details” to examine full transaction and message information. The UI may change, but the approach to reading traces remains consistent. ​Steps to read a trace Determine the operation The external-in message initiates the trace and defines the operation, such as a transfer, swap, or staking action. Clarify accounts’ roles Examine the accounts involved — wallet addresses, jetton wallets, jetton master wallets, and DEX contracts. It clarifies the role of each account in the operation flow. Read messages Examine each message (edge in the trace). Its payload defines the intended actions and the transferred value: value — amount of TON or jettons transferred opcode — instruction type payload — instructions Check transaction phases Each transaction executes in phases. In the compute and action phases, an exit code of 0 indicates success; a non-zero code signals an error. This identifies which action succeeded and which failed. Find the failure point Some failures can occur even if all transactions are successful. Examine messages and payloads to identify where an operation was constrained or prevented from proceeding. ​Failed use cases The following examples illustrate traces where operations did not complete as intended, even when transactions appear successful. They demonstrate a general approach to reading traces and identifying the point of failure. ​Jetton transfer Analyze a jetton transfer attempt. Determine the operation At point A (mintmachine.ton), an external-in message initiates the operation, instructing a jetton transfer. Clarify accounts’ roles A — sender’s wallet contract (mintmachine.ton), initiates the transfer. B — jetton wallet contract governed by the jetton master, holds the tokens and executes the transfer. Read messages A → B: jetton transfer message with 0.2 TON attached to cover execution fees. Check transaction phases The transaction at B failed during execution, with a non-zero exit code. Find the failure point Exit code 48 per jetton contract logic indicates that there isn’t enough gas to complete the transfer. The attached TON was insufficient to cover execution and forwarding, so the contract aborted the transfer. ​NFT transfer Analyze an NFT transfer attempt. Determine the operation At point A (address UQDj…D0lN), the user’s wallet sends an external-in message to transfer an NFT. Clarify accounts’ roles A — the user’s wallet, initiates the transfer. B — the NFT contract at address EQCo…gJdV, validates ownership and executes the transfer. Read messages A → B: NFT transfer message with 0.04 TON attached. B → A: bounce returning 0.036514 TON. Check transaction phases The transaction at B failed in the compute phase, with an exit code of 401. Find the failure point According to the NFT standard, exit code 401 means that the sender is not the owner of the NFT. Because the ownership check failed, the contract rejected the transfer and returned the unused funds to A. ​DEX swap Analyze a token swap attempt from DYX to pTON. Determine the operation The trace begins at point A (the user’s mintmachine.ton contract). An external-in message initiates the token swap attempt. Clarify accounts’ roles A — user’s mintmachine.ton account, sending the initial funds. B — user’s jetton wallet, holds the tokens. C — DEX jetton wallet, forwards tokens to the DEX. D — DEX smart contract executing the swap. E — jetton master (minter), authorizes token operations. Read messages A → B: 0.3 TON transferred via a jetton transfer. B → C: jetton internal transfer to the DEX wallet. C → D: swap request sent to the DEX contract. C → A: return of excess funds. D → E: request to the jetton master. E → D: reply with exit_code: 962605456 (0x39603190). Check transaction phases Transactions in A, B, C, D, and E all completed with exit code 0. No phase errors were reported. Find the failure point The issue appears in the payload of E → D. According to STON.fi docs, the exit_code: 962605456 corresponds to Swap out token amount is less than provided minimum value. This explains why, despite all transactions succeeding, the swap reverted: the output did not satisfy the minimum slippage tolerance. ​Successful use case Analyze a token swap from REDO to TON. Determine the operation An external-in message arrives at point A (mintmachine.ton), initiating the token swap. Clarify accounts’ roles A — mintmachine.ton account, provides initial funds for the swap. B — user’s jetton wallet, holds the tokens. C — DEX jetton wallet, forwards tokens to the DEX. D — DEX smart contract executing the swap. E — jetton master (minter), authorizes token operations. F — DEX payout account (mergesort.t.me), receives the swapped tokens. Read messages A → B: 0.2 TON transferred via a jetton transfer. B → C: internal jetton transfer to the DEX wallet. C → D: valid amount forwarded to the DEX contract for swap execution. C → A: return of excess funds. D → E: request to the jetton master (minter) to mint/settle token movements. E → external-out: issues an external-out message — confirmation that the operation succeeded. E → F: sends an internal message to the payout pool account. F → A: forwards the swap result to the initiator (mintmachine.ton). Check transaction phases All transactions along the trace completed their phases without error, no warning markers; exit codes are 0. There are no bounces, failed compute or action phases reported in the nodes. Find the failure point No failure point — the operation completed successfully. ​Debugging with retracer Sometimes, reading messages and transaction phases is not enough. A transaction may show successful compute and action phases, exit codes of 0, and no errors in messages — yet still produce no effect on-chain. In such cases, you need to trace the TVM execution path. Retracer lets you replay the transaction and inspect what happened inside the virtual machine. See Debugging with TVM Retracer for details.Was this page helpful?YesNoSuggest editsRaise issuePreviousSDKsNext⌘IgithubxtelegramPowered by MintlifyOn this pageHigh-level entitiesReading tracesTracesUsing the UISteps to read a traceFailed use casesJetton transferNFT transferDEX swapSuccessful use caseDebugging with retracer",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:25:56.077Z"
  },
  {
    "id": "docs-ton-org--ecosystem-oracles-overview",
    "title": "Oracles overview",
    "url": "https://docs.ton.org/ecosystem/oracles/overview",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesOverviewRedStone oraclePyth oracleBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationOraclesOracles overviewEcosystemOraclesOracles overviewCopy pageCopy pageBlockchain oracles are entities that connect the blockchain to external systems, allowing smart contracts to be executed based on real-world inputs. ​How blockchain oracles work Blockchain oracles are specialized services that act as bridges between the real world and blockchain technology. They provide smart contracts with relevant and necessary information from the outside world, such as exchange rates, payment statuses, or even weather conditions. This data helps to automate and fulfill the terms of contracts without direct human intervention. The basic principle behind oracles is their ability to function outside of the blockchain by connecting to various online sources to collect data. Although oracles are not part of the blockchain itself, they play a key role in making it functional by acting as a trusted intermediary that reliably feeds external data into the system. Most oracles tend to be decentralized, avoiding the risks associated with dependence on a single source of data. This provides greater security and reliability to the system as data is verified and validated through a network of nodes before it is used in smart contracts. This approach minimizes the risk of manipulation and errors, ensuring that the information provided is accurate and up-to-date. ​Varieties of blockchain oracles Blockchain oracles are categorized according to various aspects: mechanism of operation, data sources, data direction, and governance structure. Let’s take a look at the most common types of oracles. ​Push and pull oracles Push and pull oracles differ in how they deliver data to an on-chain smart contract. For push oracle, the data provider constantly updates info, pushing the newest data to the centralized trusted contract. Read more about oracle model differences: ChainLink - Pull vs Push oracles. For pull oracle, users should retrieve the latest data from the off-chain data provider themselves, then verify it using the oracle contract. Learn more about data verification flow with pull model oracles. Given TON actor-model, pull oracles prove to be more suited for real world applications. ​Centralized and decentralized oracles Centralized oracles are controlled by a single party, which creates security and reliability risks. Decentralized oracles use multiple nodes to verify data, making them more secure and reliable. ​Cross-chain oracles These oracles are used to transfer data between different blockchains and are a critical component of bridges. They are used for decentralized applications that use cross-chain transactions, such as cross-chain transfer of crypto assets from one network to another. ​Application of blockchain oracles Blockchain oracles build bridges between the digital world of blockchains and real life, opening up a wide range of applications. Let’s take a look at some of the most popular uses of oracles. ​DeFi (decentralized finance) Oracles play a critical role in the DeFi ecosystem by providing market price and cryptocurrency data. Price oracles allow DeFi platforms to link token values to real assets, which is essential for controlling liquidity and securing users’ positions. Additionally, oracles are vital for lending platforms, where accurate price data ensures proper collateral valuation and risk management, safeguarding both lenders and borrowers. This makes transactions more transparent and secure, contributing to the stability and reliability of financial transactions. ​Prediction markets Oracles can automatically read and analyze data from a variety of sources to determine the occurrence of real-life events. This enables prediction and insurance contracts to automatically pay claims, reducing the need for manual processing of each case and speeding up response times to events. ​Random number generation It is difficult to generate random numbers in smart contracts because all operations must be reproducible and predictable, which contradicts the concept of randomness. Computational oracles solve this problem by bringing data from the outside world into contracts. They can generate verifiable random numbers for games and lotteries, ensuring fairness and transparency of results. Read more: Randomness in TON ​Oracles in TON Since the TON execution model is asynchronous, the classic ways to interact with oracles (get methods during transaction) can’t be applied here. You can learn about the differences in “Coming from Ethereum” article. The best pattern to retrieve data from an oracle is the Request-Response pattern - you send an internal message to the oracle contract and verify the response, getting the needed data. This model works well with pull oracles, since you can always guarantee the lowest possible latency for real-world data. If you use push oracle, you will still need to process two internal messages (request and response) to retrieve data. However, data relevance is limited by the data provider’s up-time and pushing intervals: if the data provider pushes updated data every 10 minutes, you will commonly receive information that is outdated by 5 minutes. But using pull oracle, you can ensure pushes as often as your service needs by updating the data yourself. ​Push oracle flow Data provider pushes the latest data on-chain The user contract, which needs prices on-chain, sends a request message to the trusted oracle contract Oracle contract replies to the sender address with a response internal message, containing the requested data User contract receives oracle response, verifies sender address, and then is ready to use the provided data ​Pull oracle flow Users’ off-chain backend calls the API method on the data provider Provider responds with signed price data (including timestamp till this data is valid) 3-4. User sends a message to his on-chain contract that will need prices (and the rest of the business logic) User contract sends “Verify that this price is correctly signed and valid” internal message to the oracle contract Oracle contract verifies signature, timestamp, and price feed ID. If everything is okay, it sends a response with the prices back User contract receives a response from the oracle contract, checks if the sender is really the oracle, and then can use the provided data ​List of oracles in TON RedStone Pyth Was this page helpful?YesNoSuggest editsRaise issuePreviousRedStone oracleNext⌘IgithubxtelegramPowered by MintlifyOn this pageHow blockchain oracles workVarieties of blockchain oraclesPush and pull oraclesCentralized and decentralized oraclesCross-chain oraclesApplication of blockchain oraclesDeFi (decentralized finance)Prediction marketsRandom number generationOracles in TONPush oracle flowPull oracle flowList of oracles in TON",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "backend",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:25:57.670Z"
  },
  {
    "id": "docs-ton-org--ecosystem-oracles-pyth",
    "title": "Pyth oracle",
    "url": "https://docs.ton.org/ecosystem/oracles/pyth",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesOverviewRedStone oraclePyth oracleBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationOraclesPyth oracleEcosystemOraclesPyth oracleCopy pageCopy page​How to use real-time data in TON contracts Pyth is a pull oracle. Pyth price feeds on TON are managed through the main TON Pyth smart contract, enabling seamless interaction with on-chain data. In TON, these interactions are facilitated by specific functions within the Pyth TON contract. This contract acts as an interface to Pyth price feeds, handling the retrieval and updating of price data. ​Install the Pyth SDK Install the Pyth TON SDK and other necessary dependencies using npm or yarn: CopyAsk AInpm install @pythnetwork/pyth-ton-js @pythnetwork/hermes-client @ton/core @ton/ton @ton/crypto ​Write code to interact with oracle ​Off-chain data fetch and update The following code snippet demonstrates how to fetch price updates, interact with the Pyth contract on TON, and update price feeds: TON Mainnet: EQA5NPyjfZztDm8jcTBwTAU9NGsgJEkw19z61yecX0TlseSB TON Testnet: EQBeydTZBuv4nkqN8jkScqZbWcyx7TsmOtxsEDbFann0IRtD The following example uses the testnet contract. For mainnet usage, change the PYTH_CONTRACT_ADDRESS_TESTNET to PYTH_CONTRACT_ADDRESS_MAINNET accordingly. CopyAsk AIimport { TonClient, Address, WalletContractV4 } from \"@ton/ton\"; import { mnemonicToPrivateKey } from \"@ton/crypto\"; import { HermesClient } from \"@pythnetwork/hermes-client\"; import { PythContract, PYTH_CONTRACT_ADDRESS_TESTNET, PYTH_CONTRACT_ADDRESS_MAINNET, calculateUpdatePriceFeedsFee, } from \"@pythnetwork/pyth-ton-js\"; const BTC_PRICE_FEED_ID = \"0xe62df6c8b4a85fe1a67db44dc12de5db330f7ac66b72dc658afedf0f4a415b43\"; async function main() { // Initialize TonClient const client = new TonClient({ endpoint: \"https://testnet.toncenter.com/api/v2/jsonRPC\", apiKey: \"your-api-key-here\", // Get your TON Center API key via @tonapibot or https://t.me/toncenter (optional) }); // Create PythContract instance const contractAddress = Address.parse(PYTH_CONTRACT_ADDRESS_TESTNET); const contract = client.open(PythContract.createFromAddress(contractAddress)); // Get current guardian set index const guardianSetIndex = await contract.getCurrentGuardianSetIndex(); console.log(\"Guardian Set Index:\", guardianSetIndex); // Get BTC price from TON contract const price = await contract.getPriceUnsafe(BTC_PRICE_FEED_ID); console.log(\"BTC Price from TON contract:\", price); // Fetch latest price updates from Hermes const hermesEndpoint = \"https://hermes.pyth.network\"; const hermesClient = new HermesClient(hermesEndpoint); const priceIds = [BTC_PRICE_FEED_ID]; const latestPriceUpdates = await hermesClient.getLatestPriceUpdates( priceIds, { encoding: \"hex\" } ); console.log(\"Hermes BTC price:\", latestPriceUpdates.parsed?.[0].price); // Prepare update data const updateData = Buffer.from(latestPriceUpdates.binary.data[0], \"hex\"); console.log(\"Update data:\", updateData); // Get update fee const updateFee = await contract.getUpdateFee(updateData); console.log(\"Update fee:\", updateFee); const totalFee = calculateUpdatePriceFeedsFee(BigInt(updateFee)) + BigInt(updateFee); // Update price feeds const mnemonic = \"your mnemonic here\"; const key = await mnemonicToPrivateKey(mnemonic.split(\" \")); const wallet = WalletContractV4.create({ publicKey: key.publicKey, workchain: 0, }); const provider = client.open(wallet); await contract.sendUpdatePriceFeeds( provider.sender(key.secretKey), updateData, totalFee ); console.log(\"Price feeds updated successfully.\"); } main().catch(console.error); See all 71 lines ​Additional resources You may find these additional resources helpful for developing your TON application: Pyth price feed IDs Pyth TON contract Pyth TON SDK Pyth TON example Was this page helpful?YesNoSuggest editsRaise issuePreviousBridgesNext⌘IgithubxtelegramPowered by MintlifyOn this pageHow to use real-time data in TON contractsInstall the Pyth SDKWrite code to interact with oracleOff-chain data fetch and updateAdditional resources",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "testnet",
      "mainnet",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:25:58.782Z"
  },
  {
    "id": "docs-ton-org--standard-tokens-jettons-how-it-works",
    "title": "How it works",
    "url": "https://docs.ton.org/standard/tokens/jettons/how-it-works",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensOverviewMetadataJettonsOverviewHow it worksComparisonMintless JettonMinting jettonsBurnHow to find Jetton walletHow to transfer JettonsGet Jetton wallet dataGet supply dataDeploy mintless JettonAPINFTAirdropVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationJettonsHow it worksStandard contractsTokensJettonsHow it worksCopy pageCopy pageThis article describes the basic ideas and processes behind the implementation of Jettons (aka tokens in Ethereum) in the TON Blockchain. ​Related smart contracts Standardized tokens on TON (see TEPs 0074 and 0089) are implemented using a set of smart contracts, including: Jetton master (that is also called Jetton minter) smart contract; Jetton wallet smart contract. It is important to keep in mind that Jetton standards provide only a general scheme of interaction, leaving the specific implementation of related contracts to developers. ​Jetton master Jetton master smart contracts store general information about a particular jetton, such as total supply (the total number of tokens of this type), a metadata link (or the metadata itself), and the code of the standard jetton-wallet smart contract for this jetton. They also have an owner (admin) who, by sending suitable messages to them, mints new tokens, closes the minting, changes metadata, or transfers the admin rights to another contract. Jetton master contracts also receive notifications about the burning of tokens. When they receive such a notification, they must adjust the total supply accordingly. ​Jetton wallet Jetton wallet smart contracts are used to transfer, receive, and burn jettons. Each jetton wallet contract stores the wallet balance information for a specific user (owner), the address of the Jetton master contract (for appropriate minting), and some additional information. In certain cases, Jetton wallets are used for individual token holders for each token type. ​Difference between Jetton wallets and regular ones Although both regular wallets and Jetton wallets are smart contracts, there are some significant differences between them. The regular wallets’ smart contracts are designed for off-chain interaction with their owner. In most implementations, their main purpose is to receive external messages and perform the operations requested in them. It is through a regular wallet that the user sends requests for the transfer of tokens or their burning to the Jetton wallet smart contract. They are designed to store only the native TON Blockchain currency: Toncoin (or TON). On the other hand, Jetton wallet smart contracts are designed only for storing and processing tokens. They ignore any external messages and accept only special internal ones. They execute commands received only from the Jetton master, another Jetton wallet, or their owner’s regular wallet smart contracts. ​Message layouts Interactions with Jetton contracts, which users and developers most often encounter, are: tokens transfer: sending tokens from one Jetton wallet to another; tokens minting: minting new tokens and transferring them to the Jetton wallet; tokens burning: burn a certain number of tokens on the Jetton wallet contract; wallet address providing: find the address of the Jetton wallet corresponding to a regular wallet. In all schemes below, you will see the query id field. Nowadays, the field is almost deprecated, and the protocol itself doesn’t need it. It is mostly used for easier off-chain parsing and other web2 processing. ​Token transfer Actor A regular wallet -> actor A Jetton wallet. Transfer message contains the following data: NameTypeDescription query_iduint64Links the three messaging types—transfer, transfer notification, and excesses—to each other. To ensure this process works correctly, always use a unique query ID.amountVarUInteger 16The total jetton amount to transfer.destinationMsgAddressThe address of the actor B’s regular wallet.response_destinationMsgAddressThe wallet address used to return remaining Toncoin through the excesses message.custom_payloadMaybe ^CellThe optional custom data used by either the sender or receiver jetton wallet for internal logic.forward_ton_amountVarUInteger 16Toncoin to forward to the recipient. Must > 0 to send a transfer notification with forward_payload and must be less than the amount attached to this message.forward_payloadEither Cell ^CellOptional data. If the first 32 bits equal 0x00000000, it is a text comment. that meet the TL-B scheme specified in TEP 0074: CopyAsk AItransfer#0f8a7ea5 query_id:uint64 amount:(VarUInteger 16) destination:MsgAddress response_destination:MsgAddress custom_payload:(Maybe ^Cell) forward_ton_amount:(VarUInteger 16) forward_payload:(Either Cell ^Cell) = InternalMsgBody; Actor A Jetton wallet -> actor B Jetton wallet. Internal transfer message contains the following data: NameTypeDescription query_iduint64Links the three messaging types—transfer, transfer notification, and excesses—to each other. To ensure this process works correctly, always use a unique query ID.amountVarUInteger 16The total jetton amount to transfer.senderMsgAddressThe address of the actor A regular wallet.response_destinationMaybe MsgAddressThe optional wallet address used to return remaining Toncoin through the excesses message.forward_ton_amountVarUInteger 16Toncoin to forward to the recipient. Must > 0 to send a transfer notification with forward_payload and must be less than the amount attached to this message.forward_payloadEither Cell ^CellOptional data. If the first 32 bits equal 0x00000000, it is a text comment. that is not specified, but has a recommended TL-B scheme in TEP 0074: CopyAsk AIinternal_transfer#178d4519 query_id:uint64 amount:(VarUInteger 16) from:MsgAddress response_address:MsgAddress forward_ton_amount:(VarUInteger 16) forward_payload:(Either Cell ^Cell) = InternalMsgBody; Actor B Jetton wallet → actor B regular wallet. The transfer notification message. This is sent only if forward_ton_amount is not zero and contains the following data: NameTypeDescription query_iduint64Links the three messaging types—transfer, transfer notification, and excesses—to each other. To ensure this process works correctly, always use a unique query ID.amountVarUInteger 16The total jetton amount were transferred.senderMsgAddressThe address of the actor A regular wallet.forward_payloadEither Cell ^CellSome data. that meet the TL-B scheme specified in TEP 0074: CopyAsk AItransfer_notification#7362d09c query_id:uint64 amount:(VarUInteger 16) sender:MsgAddress forward_payload:(Either Cell ^Cell) = InternalMsgBody; Actor B Jetton wallet -> actor C smart contract. Excess message body. This is sent only if there are remaining Toncoin after paying the fees. Contains the following data: NameType query_iduint64 that meet the TL-B scheme specified in TEP 0074: CopyAsk AIexcesses#d53276db query_id:uint64 = InternalMsgBody; ​Token minting Admin regular wallet -> Jetton master contract. Mint message contains the following data: The following data layout is just a possible example. The structure of the Mint message is not specified in any TEPs and is left to the choice of the developer. NameTypeDescription query_iduint64To ensure this process works correctly, always use a unique query ID.receiverMsgAddressThe address of the actor A regular wallet.mintMessageCellThe rest of the data as in an internal transfer message, except the query_id field. The rest of the messages have already been described above when analyzing the transfer process. ​Token burning Actor A regular wallet -> actor A Jetton wallet. Burn message contains the following data: NameTypeDescription query_iduint64To ensure this process works correctly, always use a unique query ID.amountVarUInteger 16The total jetton amount to burn.response_destinationMsgAddressThe wallet address used to return remaining Toncoin through the excesses message.custom_payloadMaybe ^CellThe optional custom data used by the receiver jetton wallet for internal logic. that meet a TL-B scheme in TEP 0074: CopyAsk AIburn#595f07bc query_id:uint64 amount:(VarUInteger 16) response_destination:MsgAddress custom_payload:(Maybe ^Cell) = InternalMsgBody; Actor A Jetton wallet -> Jetton master contract. Burn notification message contains the following data: NameTypeDescription query_iduint64To ensure this process works correctly, always use a unique query ID.amountVarUInteger 16The total jetton amount was burned.senderMsgAddressThe address of the actor A regular wallet.response_destinationMsgAddressThe wallet address used to return remaining Toncoin through the excesses message. that is not specified but has a recommended TL-B scheme in TEP 0074: CopyAsk AIburn_notification#7bdd97de query_id:uint64 amount:(VarUInteger 16) sender:MsgAddress response_destination:MsgAddress = InternalMsgBody; ​Wallet address providing This process is straightforward. Some actor sends to the Jett",
    "category": "tokens",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:26:01.089Z"
  },
  {
    "id": "docs-ton-org--standard-wallets-highload-overview",
    "title": "Highload wallets",
    "url": "https://docs.ton.org/standard/wallets/highload/overview",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsHow they workMnemonicsComparisonPerformance benchmarkHow to interactHistoryV4V5Highload WalletsOverviewHighload Wallet v3Highload Wallet v2Lockup walletPreprocessed Wallet V2Restricted walletTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationHighload WalletsHighload walletsStandard contractsWalletsHighload WalletsHighload walletsCopy pageCopy pageHighload Wallets are specialized wallet contracts designed for services that need to send hundreds of transactions per second, such as cryptocurrency exchanges, payment processors, and high-volume trading platforms. ​What makes them different Unlike standard wallets (v3, v4, v5) that use sequential processing with a seqno counter, Highload Wallets (v2 and v3) store processed request identifiers in a dictionary, enabling parallel transaction submission without blocking. seqno (sequence number) is a counter that increments with each transaction. Standard wallets use it for replay protection — each transaction must match the current seqno value. Standard wallet limitation: Each transaction must wait for the previous one to complete. If you send 100 transactions, they must process sequentially: transaction 2 waits for transaction 1, transaction 3 waits for transaction 2, and so on. Highload Wallet advantage: You can send 100, 1,000, or 100,000 transactions simultaneously. Each transaction uses a unique query_id instead of a sequential seqno, allowing parallel processing without conflicts. ​Version history ​Highload Wallet v1 The first highload wallet, using a simple seqno counter: Simple seqno-based: Sequential processing like standard wallets Batch support: Could send up to 255 messages per transaction Replay protection rollback: If the action phase failed, replay protection would roll back (learn about) Legacy contracts: Highload Wallet v1 and v2 are deprecated. Use Highload Wallet v3 for all new deployments. ​Highload Wallet v2 Improved version with dictionary-based replay protection: Fund locking risk: Under certain conditions, the contract could enter a state where funds become inaccessible High gas costs: Storage updates and cleanup operations consumed excessive gas Replay protection rollback: If the action phase failed, replay protection would roll back (learn about) Legacy contracts: Highload Wallet v1 and v2 are deprecated. Use Highload Wallet v3 for all new deployments. ​Highload Wallet v3 The current recommended version, redesigned to solve all previous architectural problems: More requests: Up to 8,380,416 unique query IDs with efficient rotation Lower gas costs: Optimized cleanup and storage operations Maximum safety: Architectural design prevents fund locking; bulletproof Guaranteed replay protection: Unlike v1, v2, and standard wallets v1-v4, replay protection never rolls back even if the action phase fails. The two-transaction pattern ensures the query_id is always committed before attempting to send messages. ​Highload Wallet version comparison Featurev1v2v3Replay rollback on action failure⚠️ Yes⚠️ Yes✅ No (two-transaction pattern)Fund locking risk✅ No⚠️ Yes✅ NoGas efficiencyNot optimized⚠️ High cleanup costs✅ OptimizedMax batch size255 messages255 messages254 messagesReplay protectionSimple seqnoQuery ID dictionaryDual dictionary + timestampTransaction patternSingle transactionSingle transactionTwo-transaction patternQuery ID spaceSequential seqno~32,0008,380,416 unique IDsParallel submissions❌ Sequential only✅ Supported✅ SupportedStatus⚠️ Deprecated⚠️ Deprecated✅ Recommended ​Replay protection rollback Standard wallets (v1-v4) and Highload wallets (v1-v2) share a fundamental problem: if the action phase fails (e.g., insufficient funds), the entire transaction rolls back, including replay protection marks. This causes lite-servers to retry the same message repeatedly, burning gas for a long time. Highload v3’s solution: Uses a two-transaction pattern where replay protection is committed in the first transaction, and actions are performed in a separate internal transaction. This guarantees replay protection never rolls back, even if sending messages fails. ​See also Highload Wallet v3 — complete technical reference and how-to guides Highload Wallet v2 — legacy version (deprecated) Highload Wallet v1 — legacy version (deprecated) Was this page helpful?YesNoSuggest editsRaise issuePreviousHow to create Highload Wallet v3Next⌘IgithubxtelegramPowered by MintlifyOn this pageWhat makes them differentVersion historyHighload Wallet v1Highload Wallet v2Highload Wallet v3Highload Wallet version comparisonReplay protection rollbackSee also",
    "category": "wallets",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "deployment",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:26:02.432Z"
  },
  {
    "id": "docs-ton-org--standard-tokens-jettons-api",
    "title": "API",
    "url": "https://docs.ton.org/standard/tokens/jettons/api",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensOverviewMetadataJettonsOverviewHow it worksComparisonMintless JettonMinting jettonsBurnHow to find Jetton walletHow to transfer JettonsGet Jetton wallet dataGet supply dataDeploy mintless JettonAPINFTAirdropVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationJettonsAPIStandard contractsTokensJettonsAPICopy pageCopy pageThis page describes all messages and methods related to Jetton processing that are specified in TEPs. ​TEP 0074 ​Transfer message layout FieldTypeDescription transfer0x0f8a7ea5tagquery_iduint64arbitrary request numberamountVarUInteger 16amount of transferred jettons in elementary unitsdestinationMsgAddressaddress of the new owner of the jettonsresponse_destinationMsgAddressaddress where to send a response with confirmation of a successful transfer and the rest of the incoming message Toncoincustom_payloadMaybe ^Celloptional custom data (which is used by either sender or receiver jetton wallet for inner logic)forward_ton_amountVarUInteger 16the amount of nanotons to be sent to the destination addressforward_payloadEither Cell ^Celloptional custom data that should be sent to the destination address ​Forward payload formats If you want to send a simple comment in the forward_payload, then the forward_payload must start with 0x00000000 (32-bit unsigned integer equals to zero) and the comment is contained in the remainder of the forward_payload. If the comment does not begin with the byte 0xff, the comment is a text one; it can be displayed “as is” to the end user of a wallet (after filtering invalid and control characters and checking that it is a valid UTF-8 string). For instance, users may indicate the purpose (“for coffee”) of a simple transfer from their wallet to the wallet of another user in this text field. On the other hand, if the comment begins with the byte 0xff, the remainder is a “binary comment”, which should not be displayed to the end user as text (only as a hex dump if necessary). The intended use of “binary comments” is, e.g., to contain a purchase identifier for payments in a store, to be automatically generated and processed by the store’s software. If the forward_payload contains a binary message for interacting with the destination smart contract (for example, with DEX), then there are no prefixes. ​Transfer notification message layout FieldTypeDescription transfer_notification0x7362d09ctagquery_iduint64should be equal with request’s query_idamountVarUInteger 16amount of transferred jettonssenderMsgAddressan address of the previous owner of transferred jettonsforward_payloadEither Cell ^Cellshould be equal with request’s forward_payload ​Excesses message layout FieldTypeDescription excesses0xd53276dbtagquery_iduint64should be equal with request’s query_id ​Burn message layout FieldTypeDescription burn0x595f07bctagquery_iduint64arbitrary request numberamountVarUInteger 16amount of burned jettonsresponse_destinationMsgAddressan address where to send a response with confirmation of a successful burn and the rest of the incoming message coinscustom_payloadMaybe ^Celloptional custom data ​get_wallet_data() No arguments. Outputs: FieldTypeDescription balanceVarUInteger 16amount of jettons on walletownerMsgAddressan address of wallet ownerjettonMsgAddressan address of Jetton master contractjetton_wallet_codeCellcode of this wallet ​get_jetton_data() No arguments. Outputs: FieldTypeDescription total_supplyVarUInteger 16the total number of issues jettonsmintableBool(-1/0) flag which indicates whether number of jettons can increaseadmin_addressMsgAddressan address of smart contract that controls Jettonjetton_contentCelldata in accordance to TEP 0064jetton_wallet_codeCellcode of wallet for that jetton ​get_wallet_address() Argument: owner_address as MsgAddress. Output: jetton_wallet_addressas MsgAddress. ​TEP 0089 ​Provide wallet address message layout FieldTypeDescription provide_wallet_address0x2c76b973tagquery_iduint64arbitrary request numberowner_addressMsgAddressowner’s address of Jetton wallet of interestinclude_addressBoolwhether to include the owner’s address in the outgoing message ​Take wallet address message layout FieldTypeDescription take_wallet_address0xd1735400tagquery_iduint64arbitrary request numberwallet_addressMsgAddressan address of Jetton wallet of interestowner_addressMaybe ^MsgAddressoptional: owner’s address of Jetton wallet of interest Was this page helpful?YesNoSuggest editsRaise issuePreviousOverviewNext⌘IgithubxtelegramPowered by MintlifyOn this pageTEP 0074Transfer message layoutForward payload formatsTransfer notification message layoutExcesses message layoutBurn message layoutget_wallet_data()get_jetton_data()get_wallet_address()TEP 0089Provide wallet address message layoutTake wallet address message layout",
    "category": "tokens",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:26:04.876Z"
  },
  {
    "id": "docs-ton-org--ecosystem-node-mytonctrl-wallet",
    "title": "Wallet",
    "url": "https://docs.ton.org/ecosystem/node/mytonctrl/wallet",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeOverviewRun a node with MyTonCtrlRun a validatorIntegrate MyTonCtrl with PrometheusSetting up a local blockchain using MyLocalTonMyTonCtrl referenceOverviewCoreInstallerWalletValidatorCollatorNominator poolsLiquid stakingCustom overlaysUtilitiesTelegram alertingBackupBTC TeleportStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationMyTonCtrl referenceWalletEcosystemBlockchain nodeMyTonCtrl referenceWalletCopy pageWallet mode provides convenience utilities for generating, activating, importing, exporting, and moving funds between TON wallets managed by MyTonCtrl.Copy page​Operational notes MyTonCtrl stores wallets under /var/ton-work/wallets. Back up .pk files securely before deleting or migrating wallets. Generated wallet names follow the wallet_### pattern. Use wl to find the correct name before funding or exporting. Bookmark support depends on entries configured via other modules (for example, utility commands that register shortcuts). Transfers rely on the validator console and may require the wallet to be active with sufficient rent balance (>0.1 TON). ​Wallet lifecycle ​nw Purpose: Create a new local wallet definition and show its deployment address. Syntax CopyAsk AInw [<workchain-id> <wallet-name> [<version> <subwallet>]] Behavior With no arguments, autogenerates a name (wallet_XXX), uses workchain 0, selects version v1, and derives subwallet 698983191 + workchain. When arguments are provided, you must supply the workchain and name; optional version (v1, v2, v3) and subwallet override defaults. Writes .addr/.pk files under the wallets directory and prints a table with the new wallet address (state-init form). Examples CopyAsk AInw nw 0 treasury v3 1001 ​aw Purpose: Deploy one wallet or all wallets that have unsigned deployment BoCs. Syntax CopyAsk AIaw [<wallet-name>|all] Behavior Without arguments, treats the request as all and scans every wallet for pending deployment BoCs, sending them if the target address still has a positive balance. With a wallet name, activates that specific wallet using the stored deployment message. Examples CopyAsk AIaw aw wallet_005 ​wl Purpose: List every wallet known to MyTonCtrl along with its on-chain status. Syntax CopyAsk AIwl Behavior Prints Name, Status, Balance, Version, Workchain, and Address (current or init address if inactive). Useful for auditing balances before elections or sweeping idle funds. ​dw Purpose: Delete a wallet’s local files after operator confirmation. Syntax CopyAsk AIdw <wallet-name> Behavior Prompts Are you sure you want to delete this wallet (yes/no): and only proceeds on yes. Removes the .addr, .pk, and cached query files for <wallet-name> but does not touch on-chain accounts. Example CopyAsk AIdw treasury ​Importing, exporting, and metadata ​iw Purpose: Import an existing wallet by address and secret key. Syntax CopyAsk AIiw <wallet-addr> <wallet-secret-key-base64> Behavior Writes the provided address bytes and base64-encoded private key into a new local wallet (name auto-generated). Prints the assigned wallet name for subsequent commands. Example CopyAsk AIiw EQDk...cQ KJ4Q... ​ew Purpose: Export a wallet’s address and secret key. Syntax CopyAsk AIew <wallet-name> Behavior Reads the .pk file, base64-encodes it, and prints the address/key pair along with the wallet name. Useful for backups or migration to hardware wallets. Example CopyAsk AIew treasury ​swv Purpose: Update the recorded wallet version (v1/v2/v3) for an imported wallet. Syntax CopyAsk AIswv <wallet-addr> <wallet-version> Behavior Updates metadata so MyTonCtrl selects the correct Fift script when sending transactions. Supply the wallet address exactly as stored (base64 or workchain:hex) and the version string. Example CopyAsk AIswv EQC0...FQ v3 ​Fund transfers ​mg Purpose: Send Toncoin from a local wallet to a destination address or bookmark. Syntax CopyAsk AImg <wallet-name> <account-addr|bookmark> <amount> [additional-flags...] Behavior <amount> accepts numeric TON values or the shortcuts all (sends balance minus fees) and alld (sends entire balance, including fees). Automatically checks the source balance, destination bounceability, and wallet version. Add -n to force non-bounceable mode or other validator-console flags as needed. Submits the signed transfer via the validator console; prints MoveCoins - OK on success. Examples CopyAsk AImg treasury EQDv...Qw 1500 mg treasury bookmark_main all -n ​mgtp Purpose: Relay a payment through two temporary proxy wallets before reaching the destination. Syntax CopyAsk AImgtp <wallet-name> <account-addr|bookmark> <amount> Behavior Creates two temporary wallets, hops the transfer through them (wallet -> proxy1 -> proxy2 -> destination), and cleans up afterward. Ensures the final leg includes -n (non-bounceable) to safely reach inactive recipients. Handy when the destination cannot accept a direct bounceable transfer. Example CopyAsk AImgtp treasury EQC6...rA alld Was this page helpful?YesNoSuggest editsRaise issuePreviousValidatorValidator mode automates governance voting, election participation, efficiency tracking, and the local collator registry.Next⌘IgithubxtelegramPowered by MintlifyOn this pageOperational notesWallet lifecyclenwawwldwImporting, exporting, and metadataiwewswvFund transfersmgmgtp",
    "category": "wallets",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "deployment",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:26:06.839Z"
  },
  {
    "id": "docs-ton-org--ecosystem-node-mytonctrl-pools",
    "title": "Nominator pools",
    "url": "https://docs.ton.org/ecosystem/node/mytonctrl/pools",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeOverviewRun a node with MyTonCtrlRun a validatorIntegrate MyTonCtrl with PrometheusSetting up a local blockchain using MyLocalTonMyTonCtrl referenceOverviewCoreInstallerWalletValidatorCollatorNominator poolsLiquid stakingCustom overlaysUtilitiesTelegram alertingBackupBTC TeleportStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationMyTonCtrl referenceNominator poolsEcosystemBlockchain nodeMyTonCtrl referenceNominator poolsCopy pagePool-focused commands help you manage validator-run nominator pools and Orbs single-nominator pools. The console exposes utilities that create local pool descriptors, deploy the contracts on-chain, and move stake in or out.Copy page​Shared pool utilities ​pools_list Purpose: Display every pool tracked locally along with its status on-chain. Syntax CopyAsk AIpools_list Behavior Queries the MyTonCtrl database for all pool descriptors stored under /var/ton-work/pools. Resolves each pool’s smart-contract account status and balance; if an account is inactive, it falls back to the deployment (init) address. Prints a table with columns Name, Status, Balance, Version, and Address so you can quickly audit which pools are deployed and funded. ​import_pool Purpose: Register an existing pool by saving its address inside the local pools directory. Syntax CopyAsk AIimport_pool <pool-name> <pool-addr> Behavior Accepts a local alias (<pool-name>) and the pool’s base64 (bounceable) smart-contract address. Creates <pool-name>.addr in the pools directory so other commands (activation, deposits, withdrawals) can reference it. Downloads the pool contract scripts on demand if they are not present yet. Example CopyAsk AIimport_pool my-pool EQC02...fa8 ​delete_pool Purpose: Remove the local metadata for a pool you no longer manage. Syntax CopyAsk AIdelete_pool <pool-name> Behavior Deletes the BoC/address files created for <pool-name> from the pools directory; on-chain contracts remain untouched. Useful when you migrate a pool to another host or retire a test deployment. Example CopyAsk AIdelete_pool my-pool ​Nominator pool operations (nominator-pool mode) ​new_pool Purpose: Generate deployment artifacts for a standard nominator pool before broadcasting it. Syntax CopyAsk AInew_pool <pool-name> <validator-reward-share-percent> <max-nominators-count> <min-validator-stake-ton> <min-nominator-stake-ton> Behavior Creates <pool-name>.addr and <pool-name>-query.boc using the official nominator pool Fift scripts. <validator-reward-share-percent> is the operator commission (e.g., 10.5 for 10.5%). <max-nominators-count> is the maximum number of nominators the pool will accept. <min-validator-stake-ton> and <min-nominator-stake-ton> define the minimum validator self-stake and delegator stake in TON (whole-ton values are expected; convert to nanoTON before use if you need fractional amounts). Validates that no other local pool shares the same derived address. Does not submit anything to the blockchain; run activate_pool afterward. Example CopyAsk AInew_pool mypool 12.5 100 300000 1000 ​activate_pool Purpose: Deploy the nominator pool contract created via new_pool or import_pool. Syntax CopyAsk AIactivate_pool <pool-name> Behavior Loads <pool-name>-query.boc and ensures the validator wallet is active. If the pool account is still empty, it signs and broadcasts the deployment message; if it is already active, it logs a warning and exits without changes. Leaves the deployment BoC in place so you can retry if the transaction fails. Example CopyAsk AIactivate_pool mypool ​update_validator_set Purpose: Refresh the validator address list stored in the pool contract after elections or operator changes. Syntax CopyAsk AIupdate_validator_set <pool-addr> Behavior Uses the validator wallet to call the pool’s update_validator_set method. <pool-addr> must be the pool’s bounceable address as reported by pools_list or status. Typically run after activating the pool or when the validator ADNL set changes. Example CopyAsk AIupdate_validator_set EQB1e...6g ​deposit_to_pool Purpose: Stake Toncoin from the validator wallet into the pool contract. Syntax CopyAsk AIdeposit_to_pool <pool-addr> <amount-ton> Behavior Builds a validator deposit query, signs it with the validator wallet, and sends it to <pool-addr>. <amount-ton> is a TON-denominated float or integer. Internally, the command converts it to the correct nanoTON amount. Useful for seeding the validator share or topping up the pool’s liquidity. Example CopyAsk AIdeposit_to_pool EQB1e...6g 1000 ​withdraw_from_pool Purpose: Withdraw Toncoin from a nominator pool back to the validator wallet. Syntax CopyAsk AIwithdraw_from_pool <pool-addr> <amount-ton> Behavior Checks the pool state; if withdrawals are currently unlocked, it performs an immediate withdrawal, otherwise it submits a pending withdrawal request that will execute once the pool cycle allows it. <amount-ton> is specified in TON. Requires that the validator wallet has the authority to trigger the withdrawal. Example CopyAsk AIwithdraw_from_pool EQB1e...6g 250 ​Single nominator pool operations (single-nominator mode) ​new_single_pool Purpose: Prepare deployment assets for an Orbs single-nominator pool. Syntax CopyAsk AInew_single_pool <pool-name> <owner-address> Behavior Generates <pool-name>.addr and <pool-name>-query.boc using the bundled Orbs single-nominator contract templates. <owner-address> is the delegator’s smart-contract or wallet address (bounceable base64 or workchain:hex format supported by TON tools). The validator wallet address is embedded automatically as the operator. Ensures no other local pool produces the same address. Example CopyAsk AInew_single_pool vip-client EQCrn...u3 ​activate_single_pool Purpose: Broadcast the state-init produced by new_single_pool to deploy the contract. Syntax CopyAsk AIactivate_single_pool <pool-name> Behavior Checks that <pool-name>-query.boc still exists (indicating the pool is not already active). Signs the deploy message with the validator wallet and posts it to the network. Warns and exits without changes if the BoC is missing because the pool was already activated. Example CopyAsk AIactivate_single_pool vip-client ​withdraw_from_single_pool Purpose: Withdraw Toncoin from a single-nominator pool back to the validator wallet or owner as configured. Syntax CopyAsk AIwithdraw_from_single_pool <pool-addr> <amount-ton> Behavior Issues an immediate withdrawal request against <pool-addr> for <amount-ton> TON. Uses WithdrawFromPoolProcess, which executes in the current cycle without creating a pending queue. Primarily used to return delegated funds or distribute rewards. Example CopyAsk AIwithdraw_from_single_pool EQCsd...9k 50 ​Activation and funding prerequisites Enable the appropriate mode (enable_mode nominator-pool or enable_mode single-nominator) before using these commands; each mode mounts its own command set. Ensure your validator wallet is active and funded because deployment, deposits, and withdrawals all originate from it. For new pools, review the generated .addr and -query.boc files and keep secure backups—deletion removes these local artifacts. Was this page helpful?YesNoSuggest editsRaise issuePreviousLiquid stakingLiquid staking mode orchestrates controller deployment and maintenance for jetton-based staking pools. The commands below cover controller lifecycle management, funding flows, validator-set updates, and diagnostic helpers.Next⌘IgithubxtelegramPowered by MintlifyOn this pageShared pool utilitiespools_listimport_pooldelete_poolNominator pool operations (nominator-pool mode)new_poolactivate_poolupdate_validator_setdeposit_to_poolwithdraw_from_poolSingle nominator pool operations (single-nominator mode)new_single_poolactivate_single_poolwithdraw_from_single_poolActivation and funding prerequisites",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "deployment",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:26:08.824Z"
  },
  {
    "id": "docs-ton-org--standard-wallets-history",
    "title": "Wallets history",
    "url": "https://docs.ton.org/standard/wallets/history",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsHow they workMnemonicsComparisonPerformance benchmarkHow to interactHistoryV4V5Highload WalletsLockup walletPreprocessed Wallet V2Restricted walletTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationWalletsWallets historyStandard contractsWalletsWallets historyCopy pageCopy pageYou may have heard about different versions of wallets on TON Blockchain. But what do these versions actually mean, and how do they differ? In this article, we will explore the various versions and modifications of TON wallets. ​Common concept We should first understand that wallets are not a specific entity in the TON ecosystem. They are still just smart contracts consisting of code and data, and in that sense, are equal to any other actor (i.e., smart contract) in TON. Read more about differences. Like your own custom smart contract, or any other one, wallets can receive external and internal messages, send internal messages and logs, and provide get methods. So the question is: what functionality do they provide, and how do they differ between versions? You can consider each wallet version as a smart contract implementation providing a standard external interface, allowing different external clients to interact with the wallets in the same way. You can find these implementations in FunC and Fift languages in the main TON monorepo: ton/crypto/smartcont/ ​Basic wallets ​Wallet contract hashes Here, you can find the current hashes of the wallet contract code versions. For detailed specifications of each wallet contract, please refer to the sections further down this page. Contract versionHash V1 R1a0cfc2c48aee16a271f2cfc0b7382d81756cecb1017d077faaab3bb602f6868cV1 R2d4902fcc9fad74698fa8e353220a68da0dcf72e32bcb2eb9ee04217c17d3062cV1 R3587cc789eff1c84f46ec3797e45fc809a14ff5ae24f1e0c7a6a99cc9dc9061ffV2 R15c9a5e68c108e18721a07c42f9956bfb39ad77ec6d624b60c576ec88eee65329V2 R2fe9530d3243853083ef2ef0b4c2908c0abf6fa1c31ea243aacaa5bf8c7d753f1V3 R1b61041a58a7980b946e8fb9e198e3c904d24799ffa36574ea4251c41a566f581V3 R284dafa449f98a6987789ba232358072bc0f76dc4524002a5d0918b9a75d2d599V4 R164dd54805522c5be8a9db59cea0105ccf0d08786ca79beb8cb79e880a8d7322dV4 R2feb5ff6820e2ff0d9483e7e0d62c817d846789fb4ae580c878866d959dabd5c0V5 R120834b7b72b112147e1b2fb457b84e74d1a30f04f737d4f62a668e9552d2b72f Note: These hashes can also be found in the explorers. ​Wallet V1 This is the simplest one. It only allows you to send four transactions at a time and doesn’t check anything besides your signature and seqno. Wallet source code: ton/crypto/smartcont/new-wallet.fif This version isn’t even used in regular apps because it has some major issues: No easy way to retrieve the seqno and public key from the contract. No valid_until check, so you can’t be sure that the transaction won’t be confirmed too late. The first issue was fixed in V1R2 and V1R3. The R stands for revision. Usually, revisions are just minor updates that only add get methods; you can find all of those in the changes history of new-wallet.fif. Hereinafter, we will consider only the latest revisions. Nevertheless, because each subsequent version inherits the functionality of the previous one, we should still stick to it, as this will help us with later versions. ​Official code hashes Contract versionHash V1 R1a0cfc2c48aee16a271f2cfc0b7382d81756cecb1017d077faaab3bb602f6868cV1 R2d4902fcc9fad74698fa8e353220a68da0dcf72e32bcb2eb9ee04217c17d3062cV1 R3587cc789eff1c84f46ec3797e45fc809a14ff5ae24f1e0c7a6a99cc9dc9061ff ​Persistent memory layout seqno: 32-bit long sequence number. public-key: 256-bit long public key. ​External message body layout Data: signature: 512-bit long Ed25519 signature. msg-seqno: 32-bit long sequence number. (0-4) mode: up to four 8-bit long integers defining sending mode for each message. Up to 4 references to cells containing messages. As you can see, the main functionality of the wallet is to provide a safe way to communicate with TON Blockchain from the outside world. The seqno mechanism protects against replay attacks, and the Ed25519 signature provides authorized access to wallet functionality. The payload data consists of up to 4 references to cells and the corresponding number of modes, which will be directly transferred to the send_raw_message method. Note that the wallet doesn’t provide any validation for internal messages you send through it. It is the programmer’s (i.e., the external client’s) responsibility to serialize the data according to the internal message layout. ​Exit codes Exit codeDescription 33seqno check failed, replay protection occurred34Ed25519 signature check failed0Standard successful execution exit code. ​Get methods int seqno() returns current stored seqno. int get_public_key() returns the current stored public key. ​Wallet V2 Wallet source code: ton/crypto/smartcont/wallet-code.fc Originally in FunC; compiled to Fift assembly; later optimized get methods. Final Fift source: ton/crypto/smartcont/new-wallet-v2.fif. This version introduces the valid_until parameter, which is used to set a time limit for a transaction in case you don’t want it to be confirmed too late. This version also does not have a get method for the public key, which was added in V2R2. All differences compared to the previous version are a consequence of adding the valid_until functionality. A new exit code was added: 35, marking the failure of the valid_until check. Additionally, a new Unix time field has been added to the external message body layout, setting the time limit for the transaction. All get methods remain the same. ​Official code hashes Contract versionHash V2 R15c9a5e68c108e18721a07c42f9956bfb39ad77ec6d624b60c576ec88eee65329V2 R2fe9530d3243853083ef2ef0b4c2908c0abf6fa1c31ea243aacaa5bf8c7d753f1 ​External message body layout Data: signature: 512-bit long Ed25519 signature. msg-seqno: 32-bit long sequence number. valid-until: 32-bit long Unix time integer. (0-4) mode: up to four 8-bit integers defining the sending mode for each message. Up to 4 references to cells containing messages. ​Wallet V3 This version introduces the subwallet_id parameter, which allows you to create multiple wallets using the same public key (so you can have only one seed phrase and multiple wallets). As before, V3R2 only adds the get method for the public key. Wallet source code: ton/crypto/smartcont/wallet3-code.fc Originally in FunC; compiled to Fift assembly; later optimized get methods. Final Fift source: ton/crypto/smartcont/wallet-v3-code.fif. Essentially, subwallet_id is just a number added to the contract state when it’s deployed. Since the contract address in TON is a hash of its state and code, the wallet address will change with a different subwallet_id. This version is the most widely used right now. It covers most use cases and remains clean, simple, and mostly the same as previous versions. All get methods remain the same. ​Official code hashes Contract versionHash V3 R1b61041a58a7980b946e8fb9e198e3c904d24799ffa36574ea4251c41a566f581V3 R284dafa449f98a6987789ba232358072bc0f76dc4524002a5d0918b9a75d2d599 ​Persistent memory layout seqno: 32-bit sequence number. subwallet_id: 32-bit subwallet ID. public_key: 256-bit public key. ​External message body layout Data: signature: 512-bit Ed25519 signature. subwallet_id: 32-bit subwallet ID. msg-seqno: 32-bit sequence number. valid-until: 32-bit Unix time integer. (0-4) mode: up to four 8-bit integers defining the sending mode for each message. Up to 4 references to cells containing messages. ​Exit codes Exit codeDescription 33seqno check failed; replay protection triggered34subwallet_id does not match the stored one35valid_until check failed; transaction confirmation attempted too late35Ed25519 signature check failed0Standard successful execution exit code. In V3, exit code 35 is intentionally re-used for two checks. This is not a typo. In V4 they are split: 35 = signature check failed; 36 = valid_until check failed. ​Wallet V4 Why V4 was created: V4 was developed to introduce plugin functionality, allowing third-party smart contracts to interact with wallets in a controlled manner. This enabled features like automated payments, subscriptions, and complex DApp integrations while maintaining security through an allowlist system. Read about this standard iteration on its dedicated page: V4 wallet standard. ​Wallet V5 Why V5 was created: V5 was developed by the Tonkeeper team to address the growing need for gasless transactions, improved extensibility, and better user experience. It adds support for owner-signed internal messages, enabling gasless transactions where users can pay fees in tokens like USDt instead of Toncoin. It is the most modern wallet version at the moment, aimed at replacing V4 and allowing arbitrary extensions. Read more: V5 wallet standard How to interact with V5 wallet ​Special wallets Sometimes the functionality of basic wallets isn’t enoug",
    "category": "wallets",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "dapp",
      "api",
      "sdk",
      "transaction",
      "deployment",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:26:10.579Z"
  },
  {
    "id": "docs-ton-org--standard-tokens-airdrop",
    "title": "Airdrop",
    "url": "https://docs.ton.org/standard/tokens/airdrop",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensOverviewMetadataJettonsNFTAirdropVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationTokensAirdropStandard contractsTokensAirdropCopy pageCopy page​The problem: distributing at scale Rewarding thousands (or millions) of users by sending assets to each address proactively looks simple until the network fees add up. Network fees scale fast when the sender pays for every transfer. ​The twist: let users claim An airdrop flips the model. Instead of the distributor paying all fees, each eligible user claims their allocation and covers the network fees themselves. The straightforward approach is to keep a precomputed mapping of recipient → allocation in the contract. When a user sends a claim message, the contract releases the preassigned drop for that user. ​The naive approach and its limit Keep a precomputed mapping of recipient → allocation in the contract. When a user sends a claim message, the contract releases the preassigned amount. This works until the list becomes too large. Starting at roughly 3,000 entries, problems begin to surface with the external limit (see more in limits). ​Scalable airdrop architecture A scalable airdrop consists of two independent modules: Double-claim prevention ensures each user can claim only once Eligibility verification proves the user is entitled to claim a specific drop These modules are independent and can be combined in different ways. ​Double-claim prevention ​Markers The airdrop has a small per-user marker contract that records whether the user has already claimed. This marker blocks any subsequent attempts. ​Eligibility verification ​Merkle proof The airdrop contract stores a root hash of a dictionary (see hashmap) containing all allocations. Users present a Merkle proof to verify their allocation against this root. On-chain state: Root hash (256 bits) How to prepare: Prepare a list of eligible recipients and their allocations, and construct a dictionary. Store the root hash in the airdrop contract. Provide each user with their Merkle proof. ​Signed proof The airdrop contract stores a backend public key. The backend signs authorization messages for eligible users. Users present the signature to claim. On-chain state: Backend public key (256 bits) How to prepare: Deploy airdrop contract with backend public key. Backend validates eligibility criteria on demand. Backend signs authorization messages for eligible users. For signature implementation details and security considerations, see signing messages. ​Claim flow The claim process combines both modules. User sends a message that deploys their marker contract along with proof. Marker contract checks it has not been deployed before (double-claim prevention). Airdrop contract verifies proof (eligibility verification). Airdrop contract transfers assets to recipient. ​Choosing an approach Merkle proof fits when: Trustless, verifiable distribution is required. Eligibility list is static or changes infrequently. Backend control over claims is not desired. Signed authorization fits when: Eligibility rules change frequently or depend on external data. Trust in the backend is acceptable (centralized projects, known organizations). Lower gas costs per claim are a priority. ​Examples cNFT Mintless Jetton Was this page helpful?YesNoSuggest editsRaise issuePreviousVestingNext⌘IgithubxtelegramPowered by MintlifyOn this pageThe problem: distributing at scaleThe twist: let users claimThe naive approach and its limitScalable airdrop architectureDouble-claim preventionMarkersEligibility verificationMerkle proofSigned proofClaim flowChoosing an approachExamples",
    "category": "tokens",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "backend",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:26:13.745Z"
  },
  {
    "id": "docs-ton-org--contract-dev-ide-overview",
    "title": "IDEs and editor plugins for smart contract development",
    "url": "https://docs.ton.org/contract-dev/ide/overview",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsOverviewVSCode and forksJetBrains IDEsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationIDEs and editor pluginsIDEs and editor plugins for smart contract developmentContract developmentIDEs and editor pluginsIDEs and editor plugins for smart contract developmentCopy pageCopy pageA table of plugins and extensions is organized by the editors and IDEs they are made for: EditorPluginTolkTL-BFiftFunCTact⭐VSCodeTON✅✅✅✅⭐VSCodium and forksTON✅✅✅✅⭐JetBrains IDEsTON✅✅✅✅⭐All LSP-compatible editorsTON Language Server✅✅✅✅VSCodeTact Language✅✅✅VSCodium and forksTact Language✅✅✅JetBrains IDEsTact✅✅✅All LSP-compatible editorsTact Language Server✅✅✅Vim 8+ and Neovimtact.vim✅Sublime Text 4tact-sublime✅ For minor testing and quick experiments, use the Web IDE as an online playground for smart contracts written in FunC and Tact languages.Was this page helpful?YesNoSuggest editsRaise issuePreviousVSCode and forksNext⌘IgithubxtelegramPowered by Mintlify",
    "category": "smart-contracts",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:26:15.200Z"
  },
  {
    "id": "docs-ton-org--contract-dev-blueprint-deploy",
    "title": "Deployment and interaction",
    "url": "https://docs.ton.org/contract-dev/blueprint/deploy",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentOverviewSmart contract developmentDeployment and interactionCollecting test coverageBenchmarking performanceConfiguring BlueprintBlueprint CLIBlueprint TypeScript APITestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationDevelopment environmentDeployment and interactionContract developmentDevelopment environmentDeployment and interactionCopy pageCopy pageFollowing development and testing, contracts can be deployed and interacted with. This section outlines deployment scripts, provider configuration, and interaction workflows. ​Running scripts Blueprint allows you to run scripts directly from the project. Place your script in the scripts/ folder. Each script file must export a run function: CopyAsk AIexport async function run(provider: NetworkProvider, args: string[]) { // } Run the script with: npx blueprint run <SCRIPT> [arg1, arg2, ...] command. ​Deploying contracts To deploy a smart contract, create a deployment script in scripts/deploy<Contract>.ts with the following content. ./scripts/deploy<Contract>.tsCopyAsk AIimport { toNano } from '@ton/core'; import { MyContract } from '../wrappers/MyContract'; import { compile, NetworkProvider } from '@ton/blueprint'; export async function run(provider: NetworkProvider) { const myContract = provider.open(MyContract.createFromConfig({}, await compile('MyContract'))); await myContract.sendDeploy(provider.sender(), toNano('0.05')); await provider.waitForDeploy(myContract.address); // run methods on `myContract` } See all 13 lines ​Interactive mode To launch a guided prompt to create a contract step by step, use: CopyAsk AInpx blueprint run ​Non-interactive mode To create a contract without prompts, provide the contract name and template type: CopyAsk AInpx blueprint run deploy<CONTRACT> --<NETWORK> --<DEPLOY_METHOD> Example: CopyAsk AInpx blueprint run deployCounter --mainnet --tonconnect ​Deploying methods ​Mnemonic provider Run scripts with a wallet using mnemonic authentication by configuring environment variables and specifying the --mnemonic for a non-interactive method. Required variables: Set the following variables in the .env file: WALLET_MNEMONIC — wallet mnemonic phrase (space-separated words). WALLET_VERSION — wallet contract version. Supported versions: v1r1, v1r2, v1r3, v2r1, v2r2, v3r1, v3r2, v4r1, v4r2 (or v4), v5r1. CopyAsk AIWALLET_MNEMONIC=\"word1 word2 ... word24\" # Your wallet's mnemonic phrase WALLET_VERSION=\"v4r2\" # Wallet contract version Optional variables: WALLET_ID — wallet ID for versions earlier than v5r1, excluding v5r1. SUBWALLET_NUMBER — subwallet number for v5r1 wallets. See the wallet v5 reference for WALLET_ID construction. Once your environment is set up, you can use the mnemonic wallet for deployment with the appropriate configuration. ​TON Connect Run scripts with a wallet using TON Connect by specifying the --tonconnect option. Steps: After running the command, select a wallet from the available options. Scan the generated QR code in your wallet app or open the provided link. Confirm the transaction in the wallet’s interface. Once confirmed, the contract is deployed. ​Interaction After deploying your contracts, you can interact with them using Blueprint scripts. These scripts use the wrappers you’ve created to send messages and call get methods on your deployed contracts. To run the following scripts, refer to the Running scripts section. ​Sending messages To send messages to your deployed contracts, create a script that calls the send methods defined in your wrapper. These methods trigger contract execution and modify the contract’s state. ./scripts/sendIncrease.tsCopyAsk AIimport { Address, toNano } from '@ton/core'; import { MyContract } from '../wrappers/MyContract'; import { NetworkProvider } from '@ton/blueprint'; const contractAddress = Address.parse('<CONTRACT_ADDRESS>'); export async function run(provider: NetworkProvider) { const myContract = provider.open(MyContract.createFromAddress(contractAddress)); await myContract.sendIncrease(provider.sender(), { value: toNano('0.05'), increaseBy: 42 }); await provider.waitForLastTransaction(); console.log('Message sent successfully!'); } ​Executing get methods Get methods allow you to read data from your deployed contracts without creating transactions. These methods are free to call and don’t modify the contract’s state. ./scripts/getCounter.tsCopyAsk AIimport { Address } from '@ton/core'; import { MyContract } from '../wrappers/MyContract'; import { NetworkProvider } from '@ton/blueprint'; const contractAddress = Address.parse('<CONTRACT_ADDRESS>'); export async function run(provider: NetworkProvider) { const myContract = provider.open(MyContract.createFromAddress(contractAddress)); const counter = await myContract.getCounter(); const id = await myContract.getId(); console.log('Counter:', counter); console.log('ID:', id); } Was this page helpful?YesNoSuggest editsRaise issuePreviousCollecting test coverageNext⌘IgithubxtelegramPowered by MintlifyOn this pageRunning scriptsDeploying contractsInteractive modeNon-interactive modeDeploying methodsMnemonic providerTON ConnectInteractionSending messagesExecuting get methods",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "mainnet",
      "transaction",
      "deployment",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:26:17.224Z"
  },
  {
    "id": "docs-ton-org--contract-dev-testing-reference",
    "title": "Reference",
    "url": "https://docs.ton.org/contract-dev/testing/reference",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingOverviewReferenceDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationTestingReferenceContract developmentTestingReferenceCopy pageCopy pageBlueprint provides comprehensive testing capabilities for TON smart contracts using the TON Sandbox emulator and test utilities. This reference covers all available testing APIs, methods, and utilities. ​Quick Navigation Main Sections: Environment setup — installation and basic test structure Core Testing Classes — Blockchain, Treasury, RemoteBlockchainStorage Type Definitions — SandboxContract, SendMessageResult, FlatTransaction, FlatTransactionComparable Utility functions — helper functions for testing Test utilities and matchers — Jest/Chai assertion extensions and testing utilities Network configuration — custom blockchain configs ​Environment setup Blueprint testing environment requires proper setup of the TON Sandbox and test utilities. ​Installation CopyAsk AInpm install --save-dev @ton/sandbox @ton/test-utils ​Basic test structure ./tests/Sample.spec.tsCopyAsk AIimport { Blockchain, SandboxContract, TreasuryContract } from '@ton/sandbox'; import { Cell, toNano } from '@ton/core'; import { Sample } from '../wrappers/Sample'; import '@ton/test-utils'; import { compile } from '@ton/blueprint'; describe('Sample', () => { let code: Cell; beforeAll(async () => { code = await compile('Sample'); }); let blockchain: Blockchain; let deployer: SandboxContract<TreasuryContract>; let sample: SandboxContract<Sample>; beforeEach(async () => { blockchain = await Blockchain.create(); sample = blockchain.openContract(Sample.createFromConfig({}, code)); deployer = await blockchain.treasury('deployer'); const deployResult = await sample.sendDeploy(deployer.getSender(), toNano('0.05')); expect(deployResult.transactions).toHaveTransaction({ from: deployer.address, to: sample.address, deploy: true, success: true, }); }); it('should deploy', async () => { // the check is done inside beforeEach // blockchain and sample are ready to use }); }); See all 39 lines ​Core Testing Classes ​Blockchain The main blockchain emulator class provides an isolated testing environment. CopyAsk AIclass Blockchain { static create(opts?: { executor?: IExecutor; config?: BlockchainConfig; storage?: BlockchainStorage; meta?: ContractsMeta; autoDeployLibs?: boolean; }): Promise<Blockchain> // Contract and states management treasury(seed: string, params?: TreasuryParams): Promise<SandboxContract<TreasuryContract>> createWallets(n: number, params?: TreasuryParams): Promise<SandboxContract<TreasuryContract>[]> openContract<T extends Contract>(contract: T): SandboxContract<T> provider(address: Address, init?: StateInit | null): ContractProvider sender(address: Address): Sender getContract(address: Address): Promise<SmartContract> setShardAccount(address: Address, account: ShardAccount): Promise<void> getTransactions(address: Address, opts?: { limit?: number; lt?: string | bigint; hash?: string | Buffer }): Promise<BlockchainTransaction[]> // Core messaging methods sendMessage(message: Message | Cell, params?: MessageParams): Promise<SendMessageResult> sendMessageIter(message: Message | Cell, params?: SendMessageIterParams): Promise<AsyncIterator<BlockchainTransaction> & AsyncIterable<BlockchainTransaction>> runGetMethod(address: Address, method: number | string, stack?: TupleItem[], params?: GetMethodParams): Promise<GetMethodResult> runTickTock(on: Address | Address[], which: TickOrTock, params?: MessageParams): Promise<SendMessageResult> // Snapshotting snapshot(): BlockchainSnapshot loadFrom(snapshot: BlockchainSnapshot): Promise<void> // Coverage enableCoverage(enable?: boolean): void coverage(contract: Contract): Coverage | undefined coverageForCell(code: Cell, address?: Address): Coverage | undefined // Debugging getDebuggerExecutor(): Promise<Executor> get debug(): boolean set debug(value: boolean) // Configuration methods setVerbosityForAddress(address: Address, verbosity: Partial<LogsVerbosity> | Verbosity | undefined): Promise<void> setConfig(config: BlockchainConfig): void randomize(): Promise<Buffer> // Configuration properties get now(): number | undefined set now(now: number | undefined) get lt(): bigint get config(): Cell get configBase64(): string get verbosity(): LogsVerbosity set verbosity(value: LogsVerbosity) get libs(): Cell | undefined set libs(value: Cell | undefined) get random(): Buffer | undefined set random(value: Buffer | undefined) get recordStorage(): boolean set recordStorage(v: boolean) get autoDeployLibraries(): boolean set autoDeployLibraries(value: boolean) get prevBlocks(): PrevBlocksInfo | undefined set prevBlocks(value: PrevBlocksInfo | undefined) } ​Blockchain.create() CopyAsk AIstatic create(opts?: { executor?: IExecutor; config?: BlockchainConfig; storage?: BlockchainStorage; meta?: ContractsMeta; autoDeployLibs?: boolean; }): Promise<Blockchain> Creates a new blockchain instance for testing. Parameters: opts — optional blockchain configuration executor — custom contract executor (default: Executor) config — blockchain configuration (Cell, 'default', or 'slim') storage — contracts storage (default: LocalBlockchainStorage) meta — optional contracts metadata provider autoDeployLibs — automatically collect and deploy libraries Returns: promise resolving to blockchain instance Usage example: CopyAsk AI// Basic blockchain const blockchain = await Blockchain.create(); // With slim config for faster execution const blockchain = await Blockchain.create({ config: 'slim' }); // With remote storage const blockchain = await Blockchain.create({ storage: new RemoteBlockchainStorage(client) }); // With auto-deploy libraries const blockchain = await Blockchain.create({ autoDeployLibs: true }); ​treasury() CopyAsk AItreasury(seed: string, params?: TreasuryParams): Promise<SandboxContract<TreasuryContract>> Creates a treasury wallet contract. This wallet is used as an alternative to the wallet smart contract. Parameters: seed — initial seed for the treasury. If the same seed is used to create a treasury, then these treasuries will be identical params — optional treasury parameters workchain — the workchain ID of the treasury (default: 0) predeploy — if set, the treasury will be deployed at the moment of creation balance — initial balance of the treasury (default: 1_000_000 TON if omitted) resetBalanceIfZero — if set and the treasury balance is zero at the moment of calling the method, it resets the balance to balance Returns: promise resolving to treasury contract wrapper Usage example: CopyAsk AIconst deployer = await blockchain.treasury('deployer'); const user = await blockchain.treasury('user', { balance: toNano('100') }); // Same seed creates identical treasury const wallet1 = await blockchain.treasury('same-seed'); const wallet2 = await blockchain.treasury('same-seed'); // wallet1.address equals wallet2.address ​createWallets() CopyAsk AIcreateWallets(n: number, params?: TreasuryParams): Promise<SandboxContract<TreasuryContract>[]> Bulk variant of treasury() method. Parameters: n — number of wallets to create params — params for treasury creation Returns: array of opened treasury contracts Usage example: CopyAsk AIconst [wallet1, wallet2, wallet3] = await blockchain.createWallets(3); ​openContract() CopyAsk AIopenContract<T extends Contract>(contract: T): SandboxContract<T> Wraps a contract for testing with additional methods and state tracking. Parameters: contract — contract instance to wrap Returns: SandboxContract wrapper with testing capabilities Usage example: CopyAsk AIconst myContract = blockchain.openContract(MyContract.createFromConfig(config, code)); ​provider() CopyAsk AIprovider(address: Address, init?: StateInit | null): ContractProvider Creates a new ContractProvider for the contract address. Parameters: address — address to create contract provider for init — initial state of contract Returns: ContractProvider instance Usage example: CopyAsk AIconst contractProvider = blockchain.provider(address, init); ​sender() CopyAsk AIsender(address: Address): Sender Creates a Sender for the address. Note that this sender pushes internal messages to the Blockchain directly. No value is deducted from the sender address; all the values are set to defaults. Use for test purposes only. Parameters: address — address to create sender for Returns: Sender instance Usage example: CopyAsk AIconst sender = blockchain.sender(address); await contract.send(sender, ...); ​getContract() CopyAsk AIgetContract(address: Address): Promise<SmartContract> Retrieves SmartContract from BlockchainStorage. Parameters: address — address of the contract to get Returns: a promise resolving to a SmartContract instance ​setShardAccount() CopyAsk AIsetShardAccount(address: Address, account: ShardAccount): Promise<void> Sets the account state directly for a contract address. Parameters: address — contract Address acc",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "testnet",
      "mainnet",
      "transaction",
      "deployment",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "reference",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:26:19.922Z"
  },
  {
    "id": "docs-ton-org--tvm-tools-txtracer",
    "title": "TxTracer",
    "url": "https://docs.ton.org/tvm/tools/txtracer",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsTxTracerRetracerTVM ExplorerTON DecompilerInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationToolsTxTracerTVM: TON Virtual MachineToolsTxTracerCopy pageCopy pageTxTracer is a multipurpose debugging tool for TVM, Tolk, and FunC. Tools from a screenshot are described below in their separate sections. Its source code can be found on GitHub. ​1. TxTracer TxTracer’s main tool allows stepping over TVM execution by transaction hash. Put a transaction hash into the input. Use playback controls on the right to step through execution of the TVM bitcode that happened when this transaction was executed. Below those controls, the UI displays a current TVM stack. ​2. Playground Playground is for stepping over arbitrary TVM Assembly (TASM) or FunC code. Put the code into the code editor on the left. Use playback controls on the right to step through execution of the TVM bitcode that happened when this transaction was executed. Below those controls, the UI displays a current TVM stack. ​3. Code Explorer Explorer converts FunC/Tolk code to TVM Assembly (TASM). Put the code into the code editor on the left. The corresponding assembly code is on the right. ​4. TVM Specification A modern version of TVM Specification. Put instruction name into the search field. Read about description, stack signature, and other effects of the instruction. ​5. Sandbox Web interface that displays a trace from local @ton/sandbox. Follow instructions on the main page of the tool on how to set it up. The tool displays a trace of what happened during execution of the code in a local @ton/sandbox. ​6. Emulate Web interface that displays a trace from its BoC. Was this page helpful?YesNoSuggest editsRaise issuePreviousRetracerNext⌘IgithubxtelegramPowered by MintlifyOn this page1. TxTracer2. Playground3. Code Explorer4. TVM Specification5. Sandbox6. Emulate",
    "category": "infrastructure",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:26:21.914Z"
  },
  {
    "id": "docs-ton-org--tvm-tools-retracer",
    "title": "Retracer",
    "url": "https://docs.ton.org/tvm/tools/retracer",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsTxTracerRetracerTVM ExplorerTON DecompilerInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationToolsRetracerTVM: TON Virtual MachineToolsRetracerCopy pageCopy pageRetracer is a classic TVM transaction tracing tool that provides detailed inspection of transaction execution. It’s useful for: Understanding complex transaction flows; Debugging smart contract behavior; Analyzing gas usage and performance. Some explorers display links to Retracer on their transaction pages. Otherwise it’s recommended to use a more modern TxTracer tool. Its source code can be found on GitHub. On this screenshot, key elements of its interface are visible: Transaction details — Sender, contract, amounts, time, LT, fees, and balances; C5 button — Display action list: complete details of all actions performed during the transaction; Logs button — Detailed logs for deeper debugging; List of instructions (on the left) — Steps taken by execution of the contract on TVM; Stack (on the right) — Stack during execution of current instruction. Was this page helpful?YesNoSuggest editsRaise issuePreviousTVM ExplorerNext⌘IgithubxtelegramPowered by Mintlify",
    "category": "infrastructure",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:26:24.837Z"
  },
  {
    "id": "docs-ton-org--foundations-whitepapers-tblkch",
    "title": "Telegram Open Network (TON) Blockchain Specification",
    "url": "https://docs.ton.org/foundations/whitepapers/tblkch",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersOverviewTVMTON BlockchainThe Open NetworkCatchain consensusGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationWhitepapersTelegram Open Network (TON) Blockchain SpecificationBlockchain foundationsWhitepapersTelegram Open Network (TON) Blockchain SpecificationCopy pageWhitepaper by Dr. Nikolai DurovCopy pageAuthors: Nikolai Durov Date: February 8, 2020 : Original whitepaper, PDF ​Abstract The aim of this text is to provide a detailed description of the Telegram Open Network (TON) Blockchain. ​Introduction This document provides a detailed description of the TON Blockchain, including its precise block format, validity conditions, TON Virtual Machine (TVM) invocation details, smart-contract creation process, and cryptographic signatures. In this respect it is a continuation of the TON whitepaper, so we freely use the terminology introduced in that document. Chapter 1 provides a general overview of the TON Blockchain and its design principles, with particular attention to the introduction of compatibility and validity conditions and the implementation of message delivery guarantees. More detailed information, such as the TL-B schemes that describe the serialization of all required data structures into trees or collections (“bags”) of cells, is provided in subsequent chapters, culminating in a complete description of the TON Blockchain (shardchain and masterchain) block layout in Chapter 5. A detailed description of the elliptic curve cryptography used for signing blocks and messages, also accessible through TVM primitives, is provided in Appendix A. TVM itself is described in a separate document. Some subjects have intentionally been left out of this document. One is the Byzantine Fault Tolerant(BFT) protocol used by the validators to determine the next block of the masterchain or a shardchain; that subject is left for a forthcoming document dedicated to the TON Network. And although this document describes the precise format of TON Blockchain blocks, and discusses the blockchain’s validity conditions and serialized invalidity proofs,1 it provides no details about the network protocols used to propagate these blocks, block candidates, collated blocks, and invalidity proofs. Similarly, this document does not provide the complete source code of the masterchain smart contracts used to elect the validators, change the configurable parameters or get their current values, or punish the validators for their misbehavior, even though these smart contracts form an important part of the total blockchain state and of the masterchain block zero. Instead, this document describes the location of these smart contracts and their formal interfaces.2 The source code of these smart contracts will be provided separately as downloadable files with comments. Please note that the current version of this document describes a preliminary test version of the TON Blockchain; some minor details are likely to change prior to launch during the development, testing, and deployment phases. ​1 Overview This chapter provides an overview of the main features and design principles of the TON Blockchain. More detail on each topic is provided in subsequent chapters. ​1.1 Everything is a bag of cells All data in the blocks and state of the TON Blockchain is represented as a collection of cells. Therefore, this chapter begins with a general discussion of cells. ​1.1.1. TVM cells Recall that the TON Blockchain, as well as the TON Virtual Machine (TVM), represents all permanently stored data as a collection or bag of so-called cells. Each cell consists of up to 1023 data bits and up to four references to other cells. Cyclic cell references are not allowed, so the cells are usually organized into trees of cells, or rather directed acyclic graphs (DAGs) of cells.3 Any value of an abstract algebraic (dependent) data type may be represented (serialized) as a tree of cells. The precise way of representing values of an abstract data type as a tree of cells is expressed by means of a TL-B scheme.4 A more thorough discussion of different kinds of cells may be found in Generalities on cells. ​1.1.2. Application to TON Blockchain blocks and state The above is particularly applicable to the blocks and state of the TON Blockchain, which also are values of certain (quite convoluted) dependent algebraic data types. Therefore, they are serialized according to various TL-B schemes (which are gradually presented throughout this document), and are represented as a collection or bag of cells. ​1.1.3. The layout of a single cell Each single cell consists of up to 1023 data bits and up to four references to other cells. When a cell is kept in memory, its exact representation is implementation-dependent. However, there is a standard representation of cells, useful for instance, for serializing cells for file storage or network transmission. This “standard representation” or “standard layout” CellRepr(c)\\text{CellRepr}(c)CellRepr(c) of a cell ccc consists of the following: Two descriptor bytes come first, sometimes denoted by d1d_1d1​ and d2d_2d2​. The first of these bytes d1d_1d1​ equals (in the simplest case) the number of references 0≤r≤40\\leq r\\leq 40≤r≤4 in the cell. The second descriptor byte d2d_2d2​ encodes the bit length lll of the data part of the cell as follows: the first seven bits of d2d_2d2​ equal ⌊l/8⌋\\lfloor l/8\\rfloor⌊l/8⌋, the number of complete data bytes present in the cell, while the last bit of d2d_2d2​ is the completion tag, equal to one if lll is not divisible by eight. Therefore, d2=2⌊l/8⌋+[l mod 8≠0]=⌊l/8⌋+⌈l/8⌉(1)d_2=2\\lfloor l/8\\rfloor+[l\\bmod 8\\neq0]=\\lfloor l/8\\rfloor+\\lceil l/8\\rceil \\tag{1}d2​=2⌊l/8⌋+[lmod8=0]=⌊l/8⌋+⌈l/8⌉(1) where [A][A][A] equals one when condition AAA is true, and zero otherwise. Next, ⌈l/8⌉\\lceil l/8\\rceil⌈l/8⌉ data bytes follow. This means that the lll data bits of the cell are split into groups of eight, and each group is interpreted as a big-endian 8-bit integer and stored into a byte. If lll is not divisible by eight, a single binary one and a suitable number of binary zeroes (up to six) are appended to the data bits, and the completion tag (the least significant bit of the descriptor byte d2d_2d2​) is set. Finally, rrr references to other cells follow. Each reference is normally represented by 32 bytes containing the SHA-256 hash of the referenced cell computed. In this way, the standard representation CellRepr(c)\\text{CellRepr}(c)CellRepr(c) of a cell ccc with lll data bits and rrr references is 2+⌈l/8⌉+32r2+\\lceil l/8\\rceil+32r2+⌈l/8⌉+32r bytes long. ​1.1.4. The SHA-256 hash of a cell The SHA-256 hash of a cell ccc is recursively defined as the SHA-256 of the standard representation CellRepr(c)\\text{CellRepr}(c)CellRepr(c) of the cell in question: Hash(c):=Sha256(c):=Sha256(CellRepr(c))(2)\\text{Hash}(c):=\\text{Sha256}(c):=\\text{Sha256}\\bigl(\\text{CellRepr}(c)\\bigr) \\tag{2}Hash(c):=Sha256(c):=Sha256(CellRepr(c))(2) Because cyclic cell references are not allowed (the relationships among all cells must constitute a directed acyclic graph, or DAG), the SHA-256 hash of a cell is always well-defined. Furthermore, because SHA-256 is tacitly assumed to be collision-resistant, we assume that all the cells that we encounter are completely determined by their hashes. In particular, the cell references of a cell ccc are completely determined by the hashes of the referenced cells, contained in the standard representation CellRepr(c)\\text{CellRepr}(c)CellRepr(c). ​1.1.5. Exotic cells Apart from the ordinary cells (also called simple or data cells) considered so far, cells of other types, called exotic cells, sometimes appear in the actual representations of TON Blockchain blocks and other data structures. Their representation is somewhat different; they are distinguished by having the first descriptor byte d1≥5d_1\\geq 5d1​≥5. ​1.1.6. External reference cells (External) reference cells, which contain the 32-byte Sha256(c)\\text{Sha256}(c)Sha256(c) of a “true” data cell ccc instead of the data cell itself, are one example of exotic cells. These cells can be used in the serialization of a bag of cells corresponding to a TON Blockchain block in order to refer to data cells absent in the serialization of the block itself, but assumed to be present somewhere else (e.g., in the previous state of the blockchain). ​1.1.7. Transparency of reference cells with respect to most operations Most cell operations do not observe any reference cells or other “exotic” kinds of cells; they see only data cells, with any reference cell transparently replaced by the cell referred to. For example, when the transparent cell hash Hash♭(c)\\text{Hash}^\\flat(c)Hash♭(c) is recursively computed, the hash of a reference cell is set to be equal to the hash of the cell referred to, not the hash of the standard representation of the reference cell. ​1.1.8. Transparent",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "deployment",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:26:27.381Z"
  },
  {
    "id": "docs-ton-org--foundations-actions-reserve",
    "title": "Reserve coins",
    "url": "https://docs.ton.org/foundations/actions/reserve",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsOverviewSend messageReserve coinsSet codeChange libraryConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationActionsReserve coinsBlockchain foundationsActionsReserve coinsCopy pageCopy pageReserving coins is one of the actions that a smart contract can perform during the action phase. In TVM it is implemented via the RAWRESERVE instruction that takes from the stack an amount of Toncoin (in nanotoncoins) to reserve and an integer mode specifying a way of the reservation. The reservation action is queued to the output action list of a smart contract, which contains other actions such as message sends. The RAWRESERVE instruction is equivalent to creating an outbound message carrying the specified amount of nanotoncoin to oneself. But unlike regular sending of a message, the reservation action does not create a new message and does not incur any forward fees. Its primary goal is to limit the amount of Toncoin that can be spent by subsequent actions. ​Modes The mode parameter is a bitmask that specifies how a reserved amount is calculated. The resulting mode value can have the following base modes: Mode valueConvenient nameDescription0ReserveExactReserves exactly the specified amount of nanotoncoin.1ReserveAllExceptReserves all but the specified amount of nanotoncoin.2ReserveAtMostReserves at most the specified amount of nanotoncoin. Additionally, the resulting mode can have the following optional flags added: Flag valueConvenient nameDescription+4ReserveAddOriginalBalanceIncreases the amount by the original balance (i.e. without incoming message value) of the current account before the compute phase.+8ReserveInvertSignNegates the amount value before performing the reservation.+16ReserveBounceIfActionFailBounces the transaction if the reservation fails. ​Behavior Notation: amount – the amount of Toncoin passed to the RAWRESERVE instruction. mode – the integer mode passed to the RAWRESERVE instruction. original_balance: if after the storage phase, account’s balance is less than the value of incoming message with bounce flag set to false, then original_balance is set to 000; otherwise, original_balance equals account’s balance before the compute phase minus incoming message value. remaining_balance – account’s balance before the reservation action. reserve – the final amount to be reserved. The algorithm is as follows: Check that mode has flag ReserveBounceIfActionFail: if so, then in case of any failure the action phase will be interrupted and the bounce phase will be initiated; if not, then in case of any failure the reservation action will be skipped. Set reserve to amount. Check that mode has flag ReserveAddOriginalBalance: If so, then check that mode has flag ReserveInvertSign: if so, then set reserve to original_balance - reserve; otherwise, increase reserve by original_balance. Otherwise, if mode has flag ReserveInvertSign, throw the error “invalid reserve mode”. Check that mode has flag ReserveAtMost: if so, then set reserve to min(reserve, remaining_balance). Check that mode has flag ReserveAllExcept: if so, then set reserve to remaining_balance - reserve. Set remaining_balance to remaining_balance - reserve. If there were no errors, then the reservation action was successful, and the subsequent actions can spend only at most the new remaining_balance. For example, suppose that: amount = 0.1 Ton; mode = 1 + 4 + 8 (ReserveAllExcept, ReserveAddOriginalBalance, ReserveInvertSign); original_balance = 2 Ton; remaining_balance = 3 Ton. Then the reservation proceeds as follows: mode has flag ReserveBounceIfActionFail? No. reserve = 0.1 Ton. mode has flag ReserveAddOriginalBalance? Yes. mode has flag ReserveInvertSign? Yes. Thus, reserve = original_balance - reserve = 2 - 0.1 = 1.9 Ton. mode has flag ReserveAtMost? No. mode has flag ReserveAllExcept? Yes. Thus, reserve = remaining_balance - reserve = 3 - 1.9 = 1.1 Ton. remaining_balance = remaining_balance - reserve = 3 - 1.1 = 1.9 Ton. ​Errors The following errors can occur during the reservation flow: If the mode bitmask has more than first five ones positive bits, then the error 34 is thrown. If mode has flag 8 but not flag 4, then the error 34 is thrown. If after step 3, reserve is negative, then the error 34 is thrown. Passing a negative amount also results in the same error. If after step 4, reserve is greater than remaining_balance, then the error 37 (“Not enough Toncoin”) is thrown. Some problems with unpacking the reserve action cell. A problem related to extra-currency. If the action had flag 16, then in case of any of the above errors a bounce message is sent back to a sender.Was this page helpful?YesNoSuggest editsRaise issuePreviousSet codeNext⌘IgithubxtelegramPowered by MintlifyOn this pageModesBehaviorErrors",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:26:29.081Z"
  },
  {
    "id": "docs-ton-org--standard-tokens-jettons-find",
    "title": "How to find Jetton wallet",
    "url": "https://docs.ton.org/standard/tokens/jettons/find",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensOverviewMetadataJettonsOverviewHow it worksComparisonMintless JettonMinting jettonsBurnHow to find Jetton walletHow to transfer JettonsGet Jetton wallet dataGet supply dataDeploy mintless JettonAPINFTAirdropVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationJettonsHow to find Jetton walletStandard contractsTokensJettonsHow to find Jetton walletCopy pageCopy pageSome applications may want to be able to discover their own or other contract wallets for a specific Jetton Master. For instance, some contracts may want to obtain and store their Jetton wallet for Jetton to handle transfer notifications from it in a specific way. To compute the address of a Jetton wallet from the address of its owner (a regular user wallet), the Jetton master contract provides the get_wallet_address (slice owner_address) method. CopyAsk AIimport { TonClient, Address, beginCell, TupleItemSlice } from \"@ton/ton\"; async function main() { const client = new TonClient({ endpoint: \"https://toncenter.com/api/v2/jsonRPC\", }); const jettonMasterAddress = Address.parse( \"put the Jetton master address in any format\", ); const walletAddress = Address.parse(\"put owner's address in any format\"); const walletAddressCell = beginCell().storeAddress(walletAddress).endCell(); // forming the required type for the stack const el: TupleItemSlice = { type: \"slice\", cell: walletAddressCell, }; // call the get method with a non-empty stack const data = await client.runMethod( jettonMasterAddress, \"get_wallet_address\", [el], ); // get the Jetton wallet address console.log(data.stack.readAddress()); } void main(); Or if you are sure about the structure of Jetton wallet’s initial persistent storage and know its code, you can also manually create StateInit of the Jetton wallet and thus calculate its address. Use this method with great care, as the c4 of Jetton wallet contracts is not specified. CopyAsk AIimport { Address, Cell, beginCell, contractAddress, StateInit, } from \"@ton/core\"; // let's choose Tether USDT as an example const jettonwalletcode = Cell.fromHex( \"b5ee9c72010101010023000842028f452d7a4dfd74066b682365177259ed05734435be76b5fd4bd5d8af2b7c3d68\", ); const masterAddress = Address.parse( \"0:b113a994b5024a16719f69139328eb759596c38a25f59028b146fecdc3621dfe\", ); const ownerAddress = Address.parse(\"an address in any format\"); const jettonwalletdata = beginCell() .storeAddress(ownerAddress) .storeAddress(masterAddress) .storeVarUint(0, 16) // the initial value is always zero .endCell(); const jettonWalletStateInit: StateInit = { code: jettonwalletcode, data: jettonwalletdata, }; const BASECHAIN = 0; // All Jetton wallet contracts are located in Basechain by default const jettonWalletAddress = contractAddress(BASECHAIN, jettonWalletStateInit); console.log(jettonWalletAddress.toString()); There are also various web services that allow you to call contract’s get methods without writing any code. For example, let’s inspect the Tether USD master contract page on Tonviewer. Inserting the owner’s address in any format and executing the get method, you obtain the Jetton wallet address. Finally, you can use built-in APIs.Was this page helpful?YesNoSuggest editsRaise issuePreviousHow to transfer JettonsNext⌘IgithubxtelegramPowered by Mintlify",
    "category": "tokens",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:26:30.852Z"
  },
  {
    "id": "docs-ton-org--foundations-proofs-overview",
    "title": "Overview",
    "url": "https://docs.ton.org/foundations/proofs/overview",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsOverviewLiteserver proof verificationSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationMerkle proofsOverviewBlockchain foundationsMerkle proofsOverviewCopy pageCopy pageA proof is a tree-based structure that contains the necessary data and can be verified by a proof requester. To prove something means to construct such a structure. The exact structure may differ depending on the use case. For example, suppose a proof is to be validated off-chain and requires multiple cell trees; the native TON approach is to construct a Bag of Cells (BoC) containing all the necessary cells. This is precisely what a liteserver does when data is requested from the blockchain. It is highly recommended to familiarize yourself with Exotic cells first. This article primarily covers situations where you want to verify a proof in a smart contract. However, the same techniques can be used to validate proofs off-chain. There are several key points to consider when proving anything on-chain. The only trusted information available in a smart contract is a few recent masterchain blocks. Some data is stored directly within blocks. Additional information is maintained within the workchain state. Blocks serve as diffs that reflect changes to the state over time. Think of blocks as Git commits and the state as your repository. Latest TL-B schemas can be found in the TON Monorepo. They may evolve, typically in backward-compatible ways. ​More about blocks We need to examine the block layout to determine what we can prove and how to do it. Each block (shardchain block, masterchain block) has a unique block ID: CopyAsk AIblock_id_ext$_ shard_id:ShardIdent seq_no:uint32 root_hash:bits256 file_hash:bits256 = BlockIdExt; ShardIdent contains information about the workchain and the shard the block belongs to. seq_no is the sequence number of the current block. root_hash is the hash of the block data (block header). file_hash helps validators optimize processes; typically, you don’t need it. A full block structure is as follows: CopyAsk AIblock#11ef55aa global_id:int32 info:^BlockInfo value_flow:^ValueFlow state_update:^(MERKLE_UPDATE ShardState) extra:^BlockExtra = Block; The most relevant field here is state_update. This MERKLE_UPDATE cell stores the old and new hashes of the shardchain state. Note that the masterchain always consists of a single shard, so inspecting a masterchain block reveals the masterchain state hash. Another relevant field is extra: CopyAsk AIblock_extra in_msg_descr:^InMsgDescr out_msg_descr:^OutMsgDescr account_blocks:^ShardAccountBlocks rand_seed:bits256 created_by:bits256 custom:(Maybe ^McBlockExtra) = BlockExtra; Inspecting a masterchain block reveals the McBlockExtra field: CopyAsk AImasterchain_block_extra#cca5 key_block:(## 1) shard_hashes:ShardHashes shard_fees:ShardFees ^[ prev_blk_signatures:(HashmapE 16 CryptoSignaturePair) recover_create_msg:(Maybe ^InMsg) mint_msg:(Maybe ^InMsg) ] config:key_block?ConfigParams = McBlockExtra; The shard_hashes field is essential, as it holds the latest known shardchain blocks, which are critical for basechain proofs. For detailed inspections, it is convenient to use the official explorer. ​High-level overview of proofs ​Prove a transaction in masterchain To prove a transaction’s existence in the masterchain: Obtain a trusted masterchain block root_hash using TVM instructions (PREVMCBLOCKS, PREVMCBLOCKS_100, PREVKEYBLOCKS). The user provides a complete masterchain block that should be validated against the trusted hash. Parse the block to extract the transaction. ​Prove a transaction in basechain For basechain transactions: Follow steps 1-2 above to get a trusted masterchain block. Extract the shard_hashes field from the masterchain block. User provides the full shardchain block that should be validated against the trusted hash. Parse the shardchain block to find the transaction. ​Prove account states Sometimes, data is not in block diffs but within the ShardState itself. To prove an account’s state in the basechain: Parse the shardchain block’s state_update field. This exotic cell contains two ShardState hashes (before and after the block). The user provides a ShardState that must be validated against the hash obtained in step 1. You can only prove the state at block boundaries (not intermediate states). ​Understanding pruned branch cells Familiarize yourself with pruned branch cells and the concept of hash0(cell). v1 is a regular cell tree; in v2, the cell c1 becomes a pruned branch, removing its content and references. However, if you only need c0, there’s no practical difference, as $hash_0(v1) == hash_0(v2)$. hash0(cell) ignores pruned branches, returning the original tree’s hash. reprHash(cell) accounts for everything. Matching reprHashes ensures cell path equivalency. Use HASHCU for representation hash and CHASHI/CHASHIX for different-level hashes. ​Composing proofs If you have two cell trees: Approaches: Parse v1 to get $hash_0(c1) = x$ and verify the provided v2. Concatenate v2 with v1 to reconstruct the original tree. Trusted data hashes may be separated from cells (e.g., PREVMCBLOCKS). Replacing pruned cells with actual cells changes the MERKLE_UPDATE cell hash. Always manually validate proofs against trusted hashes in these cases. ​Real-world example Let’s consider a scenario where we want to prove that a particular account has a specific state. This is useful because having a state allows you to call a get-method on it or even emulate a transaction. In this particular example, we want to prove the state of a JettonMaster and then call the get_wallet_address method on it. This way, even if a particular JettonMaster does not support TEP-89, it is still possible to obtain the wallet address for a specific account. The full example is too large for this article, but let’s cover some key points. This is an example of the proof composition technique described above. It is convenient because for getRawAccountState, the liteserver returns two items: the account state itself a BoC containing two proofs The first is a shardchain block proof, and the second is a shard state proof. We will save gas and improve parsing convenience by concatenating the AccountState with the ShardState proof, which is a cell tree where all branches are pruned except for the path from the root to the AccountState. The AccountState itself is also pruned so that we will substitute the pruned AccountState with the actual one. CopyAsk AIconst accountStateAndProof = await client.liteServer.getRawAccountState( jettonMinterToProofStateFor, { target_block: blockToProofToStrId, }, ) const proofs = Cell.fromBoc(Buffer.from(accountStateAndProof.proof, \"hex\")) const scBlockProof = proofs[0] const newShardStateProof = proofs[1] const newShardState = newShardStateProof.refs[0] const accountState = Cell.fromHex(accountStateAndProof.state) const {path} = walk(newShardState, 0, [], null) // Find the deepest pruned branch cell const patchedShardState = rebuild(newShardState, path, accountState) // And replace it with the actual account state Another interesting point is how we access the hash of the last known ShardBlock. TactCopyAsk AIinline fun findShardInBinTree(root: Cell, address: Address, shardBitLen: Int): ShardDescr { let curCs = root.beginParse(); // It's std address, but we parse it as VarAddress to get hash part as Slice, not as Int let accountId = myParseVarAddress(address.asSlice()).address; repeat (shardBitLen) { if (accountId.loadBool()) { // If the bit is 1, we go to the right child curCs = curCs.preloadIthRef(1).beginParse(); } else { // If the bit is 0, we go to the left child curCs = curCs.preloadIthRef(0).beginParse(); } } curCs.skipBits(1); // We need to skip 1 bit - leaf tag of the tree node return ShardDescr.fromSlice(curCs); } // ... let mcBlockExtra = McBlockExtra.fromCell(blockHeader.extra.loadRef().beginParse().preloadIthRef(3)); // shardHashes is a hashmap (workchain -> ShardDescr) // Therefore, we only need to retrieve the ShardDescr for workchain 0, as we are working in basechain. // We can use a non-null assertion, as we already proved that it is a valid block, and a valid masterchain block must have a ShardDescr for workchain 0. let binTreeWithShardDescr: Cell = mcBlockExtra.shardHashes.get(0)!!; let shardDescr = findShardInBinTree(binTreeWithShardDescr, jettonMaster, shardBitLen); CopyAsk AI_ (HashmapE 32 ^(BinTree ShardDescr)) = ShardHashes; A BinTree is a TL-B structure that operates straightforwardly. It stores a single bit to indicate whether the current cell is a leaf. If it is a leaf, it stores the ShardDescr. Otherwise, the cell holds two references: a left child and a right child. Since a shard identifier is a binary prefix of an address, we can traverse the tree by following the path of bits in the address.Was this page helpful?YesNoSuggest editsRaise issuePreviousLiteserver pr",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:26:32.104Z"
  },
  {
    "id": "docs-ton-org--foundations-serialization-library",
    "title": "Library references",
    "url": "https://docs.ton.org/foundations/serialization/library",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationCellsLibrary referencesMerkle proofsMerkle updatesPruned branchesBag of cellsAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationSerializationLibrary referencesBlockchain foundationsSerializationLibrary referencesCopy pageCopy pageWhile cells are deduplicated by hash within each data store on TON, there might be situations where cells with the same hash are required in several stores. For example, if there is a popular contract with a lot of instances, and there’s no need to duplicate and store separately part of its code for every instance. This is where libraries are needed: they store a single cell that is available to all the contracts. Library reference cells store a hash of such a library, and tell TVM to look up the content of such a library cell. This might reduce the size of serialized data and enable efficient storage of incrementally updated data. The library reference has level 0, so it does not contain any higher hashes. Each library cell is serialized as follows: The 1-byte tag that always equals 0x02. The 256-bit representation hash of the library cell being referred to. ​Introduction One of the native features of how TON stores data in cells is deduplication: duplicate cells are stored only once in storage, messages, blocks, transactions, and other elements. This significantly reduces the size of serialized data and enables efficient storage of incrementally updated data. The library allows extending the deduplication mechanism on-chain, enabling the incorporation of the same efficiency into custom smart contracts. You can think of a library cell as a const weak C++ pointer: a small cell that references a larger one, which may include many references. The referenced cell must exist and be registered publicly, i.e., “published”. ​Low-level details They always have level 0. They store a tag equal to 2 in the first 8 bits. Then 256 bits follow, which are the representation hash of the referenced cell. When a library cell is stored in account storage, the account pays storage for this cell equal to the cost of 1 cell and 256 + 8 bits. ​Hierarchical library cells Library cells can reference other library cells. However, they are not automatically dereferenced by the CTOS instruction (begin_parse in FunC). Attempting to do so results in exit code 9. Use XLOAD or XCTOS to dereference explicitly. Creating libraries that reference a cell whose tree contains other library cells is fine. ​Smart-contract library environment When a contract tries to load a library cell, the library is looked up in its library environment. The library environment of a smart contract is a hashmap mapping 256-bit cell (representation) hashes to the corresponding cells themselves. When an external cell reference is accessed during the execution of a smart contract, the referenced cell is looked up in the library environment, and the external cell reference is transparently replaced by the cell found. The library environment for an invocation of a smart contract is computed as follows: The global library environment for the workchain in question is taken from the current state of the Masterchain. Next, it is augmented by the local library environment of the smart contract, stored in the library field of the smart contract’s state. Only 256-bit keys equal to the hashes of the corresponding value cells are taken into account. If a key is present in both the global and local library environments, the local environment takes precedence while merging the two library environments. Finally, the message library stored in the library field of the init field of the inbound message is similarly taken into account. Note, however, that if the account is frozen or uninitialized, the library field of the message is part of the suggested state of the account and is used instead of the local library environment in the previous step. The message library has lower precedence than both the local and the global library environments. ​Hosting a library cell Libraries are hosted in the states of accounts. More specifically, they reside in the library field in the account. CopyAsk AI_ fixed_prefix_length:(Maybe (## 5)) special:(Maybe TickTock) code:(Maybe ^Cell) data:(Maybe ^Cell) library:(HashmapE 256 SimpleLib) = StateInitWithLibs; simple_lib$_ public:Bool root:^Cell = SimpleLib; One can see the public flag in SimpleLib. This flag allows making a library cell private (accessible only from the account hosting it), even if the account hosting it resides in the Masterchain. Also, if the account hosting the library becomes frozen, the library becomes inaccessible. So it is crucial to keep in mind that storage costs in the Masterchain are much higher than in the Basechain and to carefully control the balance of the account that hosts the library. ​Other articles Library cells are mainly used to minimize storage costs for accounts with identical code. Read more about this pattern.Was this page helpful?YesNoSuggest editsRaise issuePreviousMerkle proofsNext⌘IgithubxtelegramPowered by MintlifyOn this pageIntroductionLow-level detailsHierarchical library cellsSmart-contract library environmentHosting a library cellOther articles",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "reference",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:26:33.800Z"
  },
  {
    "id": "docs-ton-org--languages-func-stdlib",
    "title": "Standard library of FunC",
    "url": "https://docs.ton.org/languages/func/stdlib",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCOverviewCookbookLanguageLibrariesStandard libraryOther librariesChangelogKnown issuesTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationLibrariesStandard library of FunCLanguagesFunCLibrariesStandard library of FunCCopy pageCopy pageThis section covers the stdlib.fc library, which provides standard functions for FunC. The FunC standard library serves as a wrapper around the most commonly used TVM assembly commands that aren’t built-in. For detailed descriptions of these commands, refer to the TVM documentation. Some explanations in this document adapted from there. Some functions in the library are commented out, meaning they have already been optimized and integrated as built-in operations. However, their type signatures and behaviors remain unchanged. Additionally, some less frequently used TVM commands are not yet included in the standard library. These may be added in future updates. ​Tuple manipulation primitives Most function names and types in this section are self-explanatory. For more details on polymorphic functions, refer to the Polymorphism with forall section. Note: Currently, values of atomic type tuple cannot be converted into composite tuple types (e.g.,[int, cell]) and vice versa. ​Lisp-style lists Lists can be represented as nested 2-element tuples. Empty list is conventionally represented as TVM null value (it can be obtained by calling null()). For example, the tuple (1, (2, (3, null))) represents the list [1, 2, 3]. Elements of a list can be of different types. Lists in FunC are represented as nested two-element tuples. An empty list is conventionally represented by the TVM null value, which can be obtained using null(). For example, the tuple (1, (2, (3, null))) corresponds to the list [1, 2, 3]. Lists in FunC can contain elements of different types. ​cons CopyAsk AIforall X -> tuple cons(X head, tuple tail) asm \"CONS\"; Adds an element to the beginning of a lisp-style list. ​uncons CopyAsk AIforall X -> (X, tuple) uncons(tuple list) asm \"UNCONS\"; Extracts the head and tail of a lisp-style list. ​list_next CopyAsk AIforall X -> (tuple, X) list_next(tuple list) asm( -> 1 0) \"UNCONS\"; Extracts the head and tail of a lisp-style list. It can be used as a (non-)modifying method. Example CopyAsk AI() foo(tuple xs) { (_, int x) = xs.list_next(); ;; get the first element, `_` means do not use tail list int y = xs~list_next(); ;; pop the first element int z = xs~list_next(); ;; pop the second element } ​car CopyAsk AIforall X -> X car(tuple list) asm \"CAR\"; Returns the head of a lisp-style list. ​cdr CopyAsk AItuple cdr(tuple list) asm \"CDR\"; Returns the tail of a lisp-style list. ​Other tuple primitives ​empty_tuple CopyAsk AItuple empty_tuple() asm \"NIL\"; Creates an empty tuple (0 elements). ​tpush CopyAsk AIforall X -> tuple tpush(tuple t, X value) asm \"TPUSH\"; forall X -> (tuple, ()) ~tpush(tuple t, X value) asm \"TPUSH\"; Appends a value to the tuple (x1, ..., xn), forming (x1, ..., xn, x). The resulting tuple must not exceed 255 elements, or a type check exception is thrown. ​single CopyAsk AIforall X -> [X] single(X x) asm \"SINGLE\"; Creates a tuple with a single element — singleton ​unsingle CopyAsk AIforall X -> X unsingle([X] t) asm \"UNSINGLE\"; Unpacks a singleton. ​pair CopyAsk AIforall X, Y -> [X, Y] pair(X x, Y y) asm \"PAIR\"; Creates a two-element tuple (pair). ​unpair CopyAsk AIforall X, Y -> (X, Y) unpair([X, Y] t) asm \"UNPAIR\"; Unpacks a pair into two separate values. ​triple CopyAsk AIforall X, Y, Z -> [X, Y, Z] triple(X x, Y y, Z z) asm \"TRIPLE\"; Creates a three-element tuple (triple). ​untriple CopyAsk AIforall X, Y, Z -> (X, Y, Z) untriple([X, Y, Z] t) asm \"UNTRIPLE\"; Unpacks a triple into three separate values. ​tuple4 CopyAsk AIforall X, Y, Z, W -> [X, Y, Z, W] tuple4(X x, Y y, Z z, W w) asm \"4 TUPLE\"; Creates a four-element tuple. ​untuple4 CopyAsk AIforall X, Y, Z, W -> (X, Y, Z, W) untuple4([X, Y, Z, W] t) asm \"4 UNTUPLE\"; Unpacks a four-element tuple into four separate values. ​Tuple element access ​first CopyAsk AIforall X -> X first(tuple t) asm \"FIRST\"; Returns the first element of a tuple. ​second CopyAsk AIforall X -> X second(tuple t) asm \"SECOND\"; Returns the second element of a tuple. ​third CopyAsk AIforall X -> X third(tuple t) asm \"THIRD\"; Returns the third element of a tuple. ​fourth CopyAsk AIforall X -> X fourth(tuple t) asm \"3 INDEX\"; Returns the fourth element of a tuple. ​Pair and triple element access ​pair_first CopyAsk AIforall X, Y -> X pair_first([X, Y] p) asm \"FIRST\"; Returns the first element of a pair. ​pair_second CopyAsk AIforall X, Y -> Y pair_second([X, Y] p) asm \"SECOND\"; Returns the second element of a pair. ​triple_first CopyAsk AIforall X, Y, Z -> X triple_first([X, Y, Z] p) asm \"FIRST\"; Returns the first element of a triple. ​triple_second CopyAsk AIforall X, Y, Z -> Y triple_second([X, Y, Z] p) asm \"SECOND\"; Returns the second element of a triple. ​triple_third CopyAsk AIforall X, Y, Z -> Z triple_third([X, Y, Z] p) asm \"THIRD\"; Returns the third element of a triple. ​Domain specific primitives ​Extracting info from c7 The c7 special register holds useful data about smart contract execution. The following primitives facilitate easy retrieval of this information: ​now CopyAsk AIint now() asm \"NOW\"; Returns the current Unix timestamp as an integer. ​my_address CopyAsk AIslice my_address() asm \"MYADDR\"; Retrieves the smart contract’s internal address as a Slice containing MsgAddressInt. If needed, it can be further processed using functions like parse_std_addr. ​get_balance CopyAsk AI[int, cell] get_balance() asm \"BALANCE\"; Returns the smart contract’s balance as a tuple: int: The remaining balance in nanotoncoins. cell: A dictionary (with 32-bit keys) containing balances of extra currencies. Since this is retrieved during the compute phase, the balance reflects the incoming message value, with storage_fee and import_fee already subtracted. Raw primitives such as send_raw_message do not update this field. ​cur_lt CopyAsk AIint cur_lt() asm \"LTIME\"; Returns the logical time of the current transaction. ​block_lt CopyAsk AIint block_lt() asm \"BLOCKLT\"; Returns the logical time at the beginning of the current block. ​config_param CopyAsk AIcell config_param(int x) asm \"CONFIGOPTPARAM\"; Returns the value of the global configuration parameter with integer index i as cell or null value. ​my_code CopyAsk AIcell my_code() asm \"MYCODE\"; Retrieves the smart contract’s code from c7. This function is not included in the standard library, but is often sought by developers. You need to manually add initialization it to your contract system, with the asm word specified as shown in the snippet above. ​Hashes ​cell_hash CopyAsk AIint cell_hash(cell c) asm \"HASHCU\"; Calculates the representation hash of the given cell c and returns it as a 256-bit unsigned integer x. This function is handy for signing and verifying signatures of arbitrary entities structured as a tree of cells. ​slice_hash CopyAsk AIint slice_hash(slice s) asm \"HASHSU\"; Computes the hash of the given slice s and returns it as a 256-bit unsigned integer x. The result is equivalent to creating a standard cell containing only the data and references from s and then computing its hash using cell_hash. ​string_hash CopyAsk AIint string_hash(slice s) asm \"SHA256U\"; Calculates the SHA-256 hash of the data bits in the given slice s. A cell underflow exception is thrown if the bit length of s is not a multiple of eight. The hash is returned as a 256-bit unsigned integer x. ​Signature checks ​check_signature CopyAsk AIint check_signature(int hash, slice signature, int public_key) asm \"CHKSIGNU\"; Checks whether the given signature is a valid Ed25519 signature of the provided hash using the specified public key. The hash and public key are both 256-bit unsigned integers. The signature must be at least 512 bits long, and only the first 512 bits are used. If the signature is valid, the function returns -1; otherwise, it returns 0. Remember that CHKSIGNU converts the hash into a 256-bit slice and then calls CHKSIGNS. This means that if the hash was initially generated from some data, that data gets hashed twice — the first time when creating the hash and the second time within CHKSIGNS. ​check_data_signature CopyAsk AIint check_data_signature(slice data, slice signature, int public_key) asm \"CHKSIGNS\"; Verifies whether the given signature is a valid Ed25519 signature for the data contained in the slice data, using the specified public key, just like check_signature. A cell underflow exception is thrown if the data bit length is not a multiple of eight. The verification follows the standard Ed25519 process, where SHA-256 is used to derive a 256-bit number from data, which is then signed. ​Computation of BoC size The following functions help calculate storage fees for user-provided data. ​compute_data_size? Cop",
    "category": "languages",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:26:35.487Z"
  },
  {
    "id": "docs-ton-org--standard-tokens-nft-how-it-works",
    "title": "NFT: How it works",
    "url": "https://docs.ton.org/standard/tokens/nft/how-it-works",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensOverviewMetadataJettonsNFTOverviewHow it worksDeploy an NFT itemHow to transferHow to get metadata of an NFT itemHow to verify NFT itemComparisonSBT: How it worksReference implementationNFT 2.0APIAirdropVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationNFTNFT: How it worksStandard contractsTokensNFTNFT: How it worksCopy pageCopy pageCore concepts and processes behind Non‑Fungible Tokens (NFTs) in the TON Blockchain, aligned with TEP‑62. ​Related smart contracts Standardized NFTs on TON are implemented using a set of smart contracts, including: NFT collection smart contract NFT item smart contract The NFT standard provides only a general interaction scheme, leaving specific implementation details to developers. ​NFT collection The collection is the source of truth for items. It should provide each NFT item’s address, its own collection metadata, and, given an index and individual item metadata, can provide full item metadata. ​NFT item Following TON’s contract sharding approach, each NFT item is its own smart contract account. It provides the collection address, index, current owner, and individual metadata. On a valid transfer from the current owner, it updates the owner, optionally notifies the new owner, and returns excess Toncoin to the specified address. Not every NFT that stores a collection address actually belongs to that collection. Verify that the collection returns the item’s address for the item’s index. ​Transfer NFT item The current owner sends a transfer message to the NFT item contract. The item updates its owner field and, optionally, sends a notification and/or excess Toncoin to the specified addresses. Transfer message body contains the following data: FieldTypeDescriptiontransferuint32tag equal to 0x5fcc3d14query_iduint64arbitrary request numbernew_ownerMsgAddressaddress of the new owner of the NFT itemresponse_destinationMsgAddressoptional address to receive excess Toncoin, usually the sender’s addresscustom_payloadMaybe ^Celloptional custom dataforward_amountVarUInteger 16the amount of Toncoin to be sent to the new ownerforward_payloadEither Cell ^Celloptional data that should be forwarded to the new owner TL-BCopyAsk AItransfer#5fcc3d14 query_id:uint64 new_owner:MsgAddress response_destination:MsgAddress custom_payload:(Maybe ^Cell) forward_amount:(VarUInteger 16) forward_payload:(Either Cell ^Cell) = InternalMsgBody; Ownership notification message body (ownership_assigned) contains the following data: FieldTypeDescriptionownership_assigneduint32tag equal to 0x05138d91query_iduint64should be equal to request’s query_idprev_ownerMsgAddressaddress of the previous owner of this NFT itemforward_payloadEither Cell ^Cellshould be equal to request’s forward_payload TL-BCopyAsk AIownership_assigned query_id:uint64 prev_owner:MsgAddress forward_payload:(Either Cell ^Cell) = InternalMsgBody; Excess message body (excesses) contains the following data: FieldTypeDescriptionexcessesuint32tag equal to 0xd53276dbquery_iduint64should be equal to request’s query_id TL-BCopyAsk AIexcesses query_id:uint64 = InternalMsgBody; The transfer must be rejected if: The inbound message is not from the current owner. There are not enough coins (considering storage fee guidelines) to process the operation and send forward_amount. ​Get static data Anyone can send a get_static_data message to an NFT item to request its static data (index and collection address). The item responds with report_static_data message using send mode 64 (return message amount except gas fees). Get static data message body contains the following data: FieldTypeDescriptionget_static_datauint32tag equal to 0x2fcb26a2query_iduint64arbitrary request number TL-BCopyAsk AIget_static_data#2fcb26a2 query_id:uint64 = InternalMsgBody; Report static data message body contains the following data: FieldTypeDescriptionreport_static_datauint32tag equal to 0x8b771735query_iduint64should be equal to request’s query_idindexuint256numerical index of this NFT in the collectioncollectionMsgAddressaddress of the smart contract of the collection to which this NFT belongs TL-BCopyAsk AIreport_static_data#8b771735 query_id:uint64 index:uint256 collection:MsgAddress = InternalMsgBody; ​Best practices Metadata referenced by each link should be permanent. If you need to change it, send a transaction that updates the reference. Be mindful of TON’s asynchronous nature: on‑chain “current owner” reads may become stale by the time you act on them. Was this page helpful?YesNoSuggest editsRaise issuePreviousDeploy an NFT itemNext⌘IgithubxtelegramPowered by MintlifyOn this pageRelated smart contractsNFT collectionNFT itemTransfer NFT itemGet static dataBest practices",
    "category": "tokens",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:26:38.020Z"
  },
  {
    "id": "docs-ton-org--languages-func-known-issues",
    "title": "Known issues",
    "url": "https://docs.ton.org/languages/func/known-issues",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCOverviewCookbookLanguageLibrariesChangelogKnown issuesTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationFunCKnown issuesLanguagesFunCKnown issuesCopy pageCopy page​Constant evaluation breaks function argument substitution ​Removes division by zero exception For the following operators and arithmetic functions, the compiler carries out optimizations during constant evaluation that removes the expected division by zero exception. ​Multiplication/division built-ins Issue page: #1678 For functions muldiv, muldivc and muldivr, if any of their first two arguments is zero at compilation time, the compiler replaces the function call with 0, irrespective of the function’s third argument, i.e., the divisor. This means that the function calls get replaced by 0 even when the divisor is 0, effectively removing the expected division by zero exception. Examples: CopyAsk AI;; All these produce 0, irrespective of divisor z, ;; even when z is 0. muldiv(0, 1, z); muldivc(1, 0, z); muldivr(0, 1, z); ​Operators /, % combined with comparison operators Issue pages: #1659, #1660, #1661, #1662. The compiler simplifies the division / and modulo % operators when their left argument is 0, but only when / and % are used in tandem with comparison operators like >=, >, ==, etc. For example, the following expressions are not simplified to 0 at compile-time, which is the correct behavior: CopyAsk AI0 / z; ;; NOT replaced by 0 0 % z; ;; NOT replaced by 0 However, when comparison operators are used, the following expressions get simplified, irrespective of the value of z: CopyAsk AI(0 % z) >= 0; ;; Replaced by true (0 / z) >= 0; ;; Replaced by true (0 % z) != 1; ;; Replaced by true This means that the FunC compiler removes the expected division by zero exception in the above examples when z = 0. The following are further examples where the left operand of / and % is simplified to 0 by FunC, resulting in a final expression that the compiler simplifies to true, irrespective of the value of z: CopyAsk AI(~(-1) / z) >= 0; ((1 & (~ 1)) / z) >= 0; ((z & 0) / z) >= 0; ((z * 0) / z) >= 0; (~(-1) % z) >= 0; ((1 & (~ 1)) % z) >= 0; ((z & 0) % z) >= 0; ((z * 0) % z) >= 0; ((x & 0) % z) == 1; ((x * 0) % z) == 1; ((-1 % z) % 1) <= 0; ​Removes integer overflow exception Issue pages: #1656, #1657, #1658. The following expressions should produce overflows for particular values of z, but the FunC compiler simplifies them irrespective of z: CopyAsk AI(0 & (- z)) <= 0; ;; Should overflow for z = -115792089237316195423570985008687907853269984665640564039457584007913129639936, ;; but simplified to true (0 * (- z)) <= 0; ;; Should overflow for z = -115792089237316195423570985008687907853269984665640564039457584007913129639936, ;; but simplified to true ((z / -1) % 2) > -2; ;; Should overflow for z = -115792089237316195423570985008687907853269984665640564039457584007913129639936, ;; but simplified to true The following are further examples of expressions that should produce integer overflows at the indicated values, but the FunC compiler simplifies them to true irrespective of the value of z: CopyAsk AI(~(-1) & (-1 * z)) <= 0; ;; for z = MIN_INT. ((1 & (~ 1)) & (z / -1)) <= 0; ;; for z = MIN_INT. ((z & 0) & (z * 2)) <= 0; ;; for z = MAX_INT ((z * 0) & (z + 1)) <= 0; ;; for z = MAX_INT. (~(-1) * (-1 * z)) <= 0; ;; for z = MIN_INT ((1 & (~ 1)) * (z / -1)) <= 0; ;; for z = MIN_INT ((z & 0) * (z * 2)) <= 0; ;; for z = MAX_INT ((z * 0) * (z + 1)) <= 0; ;; for z = MAX_INT ((-1 * z) % 2) > -2; ;; for z = MIN_INT ((- z) % 2) > -2; ;; for z = MIN_INT ((z * 2) % 2) > -2; ;; for z = MAX_INT ((z + 1) % 2) > -2; ;; for z = MAX_INT where MIN_INT = -115792089237316195423570985008687907853269984665640564039457584007913129639936 and MAX_INT = 115792089237316195423570985008687907853269984665640564039457584007913129639935. ​Incorrect results ​Involving operator ~% Issue Page: #1670 In the following code: CopyAsk AIint calc(int x) { return ((x ~% -3) <= 0); } int calc3(int x, int y, int z) { return ((x ~% y) <= z); } calling calc(1) produces -1. But calling calc3(1,-3,0) produces 0. But the expected behavior is calc(1) = calc3(1,-3,0), since calc is just a specialization of calc3. The same happens with comparison operators: <=>, !=, and ==, i.e., the following expressions also produce differing results: ((x ~% -3) <=> 1) in calc function, and ((x ~% y) <=> z) in cal3 function. Produces calc(1) = -1, and calc3(1,-3,1) = 0. ((x ~% -3) != 1) in calc function, and ((x ~% y) != z) in cal3 function. Produces calc(1) = -1, and calc3(1,-3,1) = 0. ((x ~% -3) == 1) in calc function, and ((x ~% y) == z) in cal3 function. Produces calc(1) = 0, and calc3(1,-3,1) = -1. ​Involving operator ^% Issue Page: #1669 In the following code: CopyAsk AIint calc(int x) { return ((x ^% -2) <= 0); } int calc3(int x, int y, int z) { return ((x ^% y) <= z); } calling calc(1) produces -1. But calling calc3(1,-2,0) produces 0. But the expected behavior is calc(1) = calc3(1,-2,0), since calc is just a specialization of calc3. The same happens with comparison operators: <=>, !=, and ==. The following expressions also produce differing results: ((x ^% -2) <=> 1) in calc function, and ((x ^% y) <=> z) in cal3 function. Produces calc(1) = -1, and calc3(1,-2,1) = 0. ((x ^% -2) != 1) in calc function, and ((x ^% y) != z) in cal3 function. Produces calc(1) = -1, and calc3(1,-2,1) = 0. ((x ^% -2) == 1) in calc function, and ((x ^% y) == z) in cal3 function. Produces calc(1) = 0, and calc3(1,-2,1) = -1. ​Stack underflow in run_methodX functions Issue Page: #1883. The following code produces a stack underflow when run_method3 executes: CopyAsk AI() test(int a, int b, int c) impure method_id(16384) { ~dump(a); ~dump(b); ~dump(c); } () recv_internal() impure { run_method3(16384, 100, 200, 300); } The expected behavior is that test function prints 100, 200, and 300 in the debug logs when run_method3 executes. The functions run_method0, run_method1, and run_method2 have similar problems with stack underflow. ​FunC does not throw on 1024 bits long slice constant creation with s literal Issue page: #1153. The following is successfully compiled: CopyAsk AIconst slice s = \"abcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcd\"s; () main () { ~dump(s); } But the compiler should have thrown a compilation error due to the string being too long. ​FunC ignores argument order when calling built-ins or asm functions via variables Page issue: #1681. CopyAsk AI;; Correct: directly calls built-in, respects ret_order (int, int) correctBuiltin(int a, int b) { return moddiv(a, b); } ;; Incorrect: calling built-in via variable, ignores ret_order (int, int) incorrectBuiltin(int a, int b) { var f = moddiv; return f(a, b); } ;; Define the asm function with explicit ret_order (int, int) myAsm(int a, int b) asm(-> 1 0) \"SWAP\"; ;; Correct: directly calls asm function with explicit ret_order (int, int) correctAsm(int a, int b) { return myAsm(a, b); } ;; Incorrect: calls asm function via variable, ignores ret_order (int, int) incorrectAsm(int a, int b) { var f = myAsm; return f(a, b); } () main () { ~dump([correctBuiltin(5, 1)]); ;; [0 5] Correct ~dump([incorrectBuiltin(5, 1)]); ;; [5 0] Incorrect ~dump([correctAsm(5, 1)]); ;; [5 1] Correct ~dump([incorrectAsm(5, 1)]); ;; [1 5] Incorrect } ​FunC crashes with fatal assertion when tensor exceeds 254 elements Issue Page: 1682 The compiler crashes with a fatal internal assertion if a tensor exceeds 254 elements, instead of a proper user-facing error. Example: CopyAsk AI() main() { var x = ( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ); } which crashes with message: CopyAsk AIfatal: Assertion failed at analyzer.cpp:46: k <= 254 && n <= 0x7fff00 Was this page helpful?YesNoSuggest editsRaise issuePreviousTactNext⌘IgithubxtelegramPowered by MintlifyOn this pageConstant evaluation breaks function argument substitutionRemoves division by zero exceptionMultiplication/division built-insOperators /, % combine",
    "category": "languages",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:26:39.389Z"
  },
  {
    "id": "docs-ton-org--tvm-tools-ton-decompiler",
    "title": "TON Decompiler",
    "url": "https://docs.ton.org/tvm/tools/ton-decompiler",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsTxTracerRetracerTVM ExplorerTON DecompilerInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationToolsTON DecompilerTVM: TON Virtual MachineToolsTON DecompilerCopy pageCopy pageTON Decompiler is an utility for converting BoC of the contract into a Fift-like pseudocode. Decompiled code cannot match match the original source. At the very least, variable names and high-level structure is removed during compilation. Variables and methods will get some generated names, for example, ?fun_ref_12345678. The resulting pseudocode might not compile back to the same BoC either. ​CLI usage Install Tact language tool suite. CopyAsk AInpm install -g @tact-lang/compiler Then run it on a BoC file: CopyAsk AIunboc example.boc ​API usage Add it to the project CopyAsk AInpm install @tact-lang/ton-decompiler Then call a disassembler to decompile it, and a writer to put the result back into Fift-like pseudocode. CopyAsk AIimport { Cell } from \"@ton/core\"; import { disassembleRoot } from \"./decompiler/disasm\"; import { AssemblyWriter } from \"./printer/assembly-writer\"; const cell: Cell = ...; // your TVM contract bytecode const program = disassembleRoot(cell); const writer = new AssemblyWriter(); const code = writer.write(program); console.log(code); Was this page helpful?YesNoSuggest editsRaise issuePreviousInstructionsInteractive reference for TVM instructionsNext⌘IgithubxtelegramPowered by MintlifyOn this pageCLI usageAPI usage",
    "category": "infrastructure",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:26:41.384Z"
  },
  {
    "id": "docs-ton-org--languages-fift-fift-and-tvm-assembly",
    "title": "Fift and TVM assembly",
    "url": "https://docs.ton.org/languages/fift/fift-and-tvm-assembly",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftOverviewFift and TVM assemblyDeep diveSimple multisig contractWhitepaperFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationFiftFift and TVM assemblyLanguagesFiftFift and TVM assemblyCopy pageCopy pageFift is a stack-based programming language with TON-specific features that can work with cells. TVM assembly is another stack-based language designed for TON that also handles cells. What’s the difference between them? ​Key differences Fift executes at compile-time - when your compiler builds the smart contract code BoC after processing FunC code. Fift can appear in different forms: TVM opcode definitions in Asm.fif: CopyAsk AI// Tuple primitives x{6F0} @Defop(4u) TUPLE x{6F00} @Defop NIL x{6F01} @Defop SINGLE x{6F02} dup @Defop PAIR @Defop CONS wallet_v3_r2.fif: CopyAsk AI\"Asm.fif\" include <{ SETCP0 DUP IFNOTRET // Return if recv_internal DUP 85143 INT EQUAL OVER 78748 INT EQUAL OR IFJMP:<{ // \"seqno\" and \"get_public_key\" get-methods 1 INT AND c4 PUSHCTR CTOS 32 LDU 32 LDU NIP 256 PLDU CONDSEL // cnt or pubk }> INC 32 THROWIF // Fail unless recv_external 9 PUSHPOW2 LDSLICEX DUP 32 LDU 32 LDU 32 LDU // signature in_msg subwallet_id valid_until msg_seqno cs NOW s1 s3 XCHG LEQ 35 THROWIF // signature in_msg subwallet_id cs msg_seqno c4 PUSH CTOS 32 LDU 32 LDU 256 LDU ENDS // signature in_msg subwallet_id cs msg_seqno stored_seqno stored_subwallet public_key s3 s2 XCPU EQUAL 33 THROWIFNOT // signature in_msg subwallet_id cs public_key stored_seqno stored_subwallet s4 s4 XCPU EQUAL 34 THROWIFNOT // signature in_msg stored_subwallet cs public_key stored_seqno s0 s4 XCHG HASHSU // signature stored_seqno stored_subwallet cs public_key msg_hash s0 s5 s5 XC2PU // public_key stored_seqno stored_subwallet cs msg_hash signature public_key CHKSIGNU 35 THROWIFNOT // public_key stored_seqno stored_subwallet cs ACCEPT WHILE:<{ DUP SREFS // public_key stored_seqno stored_subwallet cs _51 }>DO<{ // public_key stored_seqno stored_subwallet cs 8 LDU LDREF s0 s2 XCHG // public_key stored_seqno stored_subwallet cs _56 mode SENDRAWMSG }> // public_key stored_seqno stored_subwallet cs ENDS SWAP INC // public_key stored_subwallet seqno' NEWC 32 STU 32 STU 256 STU ENDC c4 POP }>c The last code fragment resembles TVM assembly because most of it actually is TVM assembly. Here’s why: Imagine explaining programming concepts to a trainee. Your instructions become part of their program, processed twice - similar to how opcodes in capital letters (SETCP0, DUP, etc.) are processed by both Fift and TVM. Think of Fift as a teaching language where you can introduce high-level concepts to a learner. Just as a trainee programmer gradually absorbs and applies new concepts, Fift allows you to define custom commands and abstractions. The Asm.fif file demonstrates this perfectly - it’s essentially a collection of TVM opcode definitions. TVM assembly, in contrast, is like the trainee’s final working program. While it operates with fewer built-in features (it can’t perform cryptographic signing, for instance), it has direct access to the blockchain environment during contract execution. Where Fift works at compile-time to shape the contract’s code, TVM assembly runs that code on the actual blockchain. ​Smart contract usage ​(Fift) Including large BoCs in contracts When using toncli, you can include large BoCs by: Editing project.yaml to include fift/blob.fif: CopyAsk AIcontract: fift: - fift/blob.fif func: - func/code.fc Adding the BoC to fift/blob.boc Including this code in fift/blob.fif: CopyAsk AI<b 8 4 u, 8 4 u, \"fift/blob.boc\" file>B B>boc ref, b> <s @Defop LDBLOB Now you can access the blob in your contract: CopyAsk AIcell load_blob() asm \"LDBLOB\"; () recv_internal() { send_raw_message(load_blob(), 160); } ​(TVM assembly) Converting integers to strings Fift primitives can’t convert integers to strings at runtime because Fift operates at compile-time. For runtime conversion, use TVM assembly like this solution from TON Smart Challenge 3: CopyAsk AItuple digitize_number(int value) asm \"NIL WHILE:<{ OVER }>DO<{ SWAP TEN DIVMOD s1 s2 XCHG TPUSH }> NIP\"; builder store_number(builder msg, tuple t) asm \"WHILE:<{ DUP TLEN }>DO<{ TPOP 48 ADDCONST ROT 8 STU SWAP }> DROP\"; builder store_signed(builder msg, int v) inline_ref { if (v < 0) { return msg.store_uint(45, 8).store_number(digitize_number(-v)); } elseif (v == 0) { return msg.store_uint(48, 8); } else { return msg.store_number(digitize_number(v)); } } ​(TVM assembly) Efficient modulo multiplication Compare these implementations: CopyAsk AIint mul_mod(int a, int b, int m) inline_ref { ;; 1232 gas units (_, int r) = muldivmod(a % m, b % m, m); return r; } int mul_mod_better(int a, int b, int m) inline_ref { ;; 1110 gas units (_, int r) = muldivmod(a, b, m); return r; } int mul_mod_best(int a, int b, int m) asm \"x{A988} s,\"; ;; 65 gas units The x{A988} opcode implements an optimized division operation with built-in multiplication (as specified in section 5.2 Division). This specialized instruction directly computes just the modulo remainder of the operation, skipping unnecessary computation steps. The s, suffix then handles the result storage - it takes the resulting slice from the stack’s top and efficiently writes it into the target builder. Together, this combination delivers substantial gas savings compared to conventional approaches.Was this page helpful?YesNoSuggest editsRaise issuePreviousDeep diveNext⌘IgithubxtelegramPowered by MintlifyOn this pageKey differencesSmart contract usage(Fift) Including large BoCs in contracts(TVM assembly) Converting integers to strings(TVM assembly) Efficient modulo multiplication",
    "category": "infrastructure",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:26:44.046Z"
  },
  {
    "id": "docs-ton-org--languages-func-dictionaries",
    "title": "FunC dictionaries",
    "url": "https://docs.ton.org/languages/func/dictionaries",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCOverviewCookbookLanguageCommentsTypesLiteralsOperatorsExpressionsStatementsProgram declarationsReserved words and built-insDictionariesLibrariesChangelogKnown issuesTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationLanguageFunC dictionariesLanguagesFunCLanguageFunC dictionariesCopy pageCopy pageSmart contracts in TON can utilize dictionaries structured as ordered key-value mappings. Internally, these dictionaries are represented as tree-like structures composed of cells. Handling potentially large trees of cells in TON introduces several important considerations: Gas consumption for updates Every update operation generates many new cells, costing 500 gas, as detailed on the TVM instructions page. Careless updates can lead to excessive gas usage, potentially causing operations to fail due to gas exhaustion. Example: This issue occurred with the Wallet bot using the highload-v2 wallet. Each iteration’s unbounded loop and expensive dictionary updates led to gas depletion. As a result, the bot triggered repeated transactions, eventually draining its balance (see transaction details). Storage limitation A binary tree containing NNN key-value pairs requires N−1N-1N−1 forks, resulting in at least 2N−12N-12N−1 cells. Since smart contract storage in TON is capped at 65,536 unique cells, the maximum number of dictionary entries is approximately 32,768. This limit may be slightly higher if some cells are reused within the structure. ​Dictionary kinds ​”Hash” map Hashmaps are the most widely used dictionary type in TON. They have a dedicated set of TVM opcodes for manipulation and are commonly used in smart contracts (see TVM instructions - Dictionary manipulation). Hashmaps map fixed-length keys, which are defined as an argument to all functions, to value slices. Despite the “hash” in its name, entries are ordered and allow efficient access to elements by key and retrieval of the previous or next key-value pair. Since values share space with internal node tags and possibly key fragments within the same cell, they cannot utilize the full 1023 bits. In such cases, the ~udict_set_ref function often helps. An empty hashmap is represented as null in TVM, meaning it is not stored as a cell. A single bit is first saved to store a dictionary in a cell (0 for empty, 1 otherwise), followed by a reference if the hashmap is not empty. This makes store_maybe_ref and store_dict interchangeable. Some smart contract developers use load_dict to load a Maybe ^Cell from an incoming message or storage. Available hashmap operations: Load from a slice, store to a builder; Get/Set/Delete a value by key; Replace a value (update an existing key) or add a new value (if the key is absent); Move to the next/previous key-value pair (entries are ordered by keys, enabling iteration if gas constraints allow); Retrieve the minimal or maximal key with its value; Fetch and execute a function (continuation) by key. To prevent gas exhaustion, smart contracts should limit the number of dictionary updates per transaction. If a contract’s balance is used to maintain the hashmap under specific conditions, it can send itself a message to continue processing in another transaction. TVM provides instructions for retrieving a sub-dictionary — a subset of entries within a given key range. These operations (SUBDICTGET and similar) are currently untested and can only be explored at the TVM assembly level. ​Hashmap examples To illustrate, let’s examine a hashmap that maps 257-bit integer keys to empty value slices. This type of hashmap serves as a presence indicator, storing only the existence of elements. You can quickly check this by running the following Python script. If needed, you can use a different SDK instead of pytoniq: CopyAsk AIimport pytoniq k = pytoniq.HashMap(257) em = pytoniq.begin_cell().to_slice() k.set(5, em) k.set(7, em) k.set(5 - 2**256, em) k.set(6 - 2**256, em) print(str(pytoniq.begin_cell().store_maybe_ref(k.serialize()).end_cell())) This structure forms a binary tree, which appears balanced except for the root cell: CopyAsk AI1[80] -> { 2[00] -> { 265[9FC00000000000000000000000000000000000000000000000000000000000000080] -> { 4[50], 4[50] }, 266[9FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF40] -> { 2[00], 2[00] } } } For further examples of hashmap parsing, refer to the official documentation. ​Augmented maps Augmented maps with additional data in each node are used internally by TON validators to calculate the total balance of all contracts in a shard. By storing the total subtree balance in each node, validators can quickly validate updates. There are no TVM primitives for working with these maps. ​Prefix dictionary Testing shows that documentation on prefix dictionaries is insufficient. Avoid using them in production contracts unless you fully understand how the relevant opcodes, such as PFXDICTSET, work.Was this page helpful?YesNoSuggest editsRaise issuePreviousStandard libraryNext⌘IgithubxtelegramPowered by MintlifyOn this pageDictionary kinds”Hash” mapHashmap examplesAugmented mapsPrefix dictionary",
    "category": "languages",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "python",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:26:45.399Z"
  },
  {
    "id": "docs-ton-org--standard-tokens-nft-reference",
    "title": "NFT: reference implementation",
    "url": "https://docs.ton.org/standard/tokens/nft/reference",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensOverviewMetadataJettonsNFTOverviewHow it worksDeploy an NFT itemHow to transferHow to get metadata of an NFT itemHow to verify NFT itemComparisonSBT: How it worksReference implementationNFT 2.0APIAirdropVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationNFTNFT: reference implementationStandard contractsTokensNFTNFT: reference implementationCopy pageCopy pageThe NFT standard (TEP-62) describes the required messages and get-methods. The NFT royalty standard (TEP-66) describes a standard way to implement royalty information for NFT sales. The token data standard (TEP-64) describes available formats for metadata of tokens. A widely used reference implementation follows these standards for simple NFTs with only the essential mechanics. This page explains the reference implementation, what you can extend, and what must remain unchanged. The implementation contains multiple smart contracts written in FunC language, including additional ones for NFT sales. This page describes the collection and item smart contracts, as they are the only necessary ones per standard. ​Collection The full source code is in nft-collection.fc file. The TEP-62 standard only requires the implementation of get‑methods: get_collection_data(), get_nft_address_by_index(int index), and get_nft_content(int index, cell individual_content). The TEP‑66 standard also adds the royalty_params() get‑method, a get_royalty_params message for requesting royalty parameters on‑chain, and a report_royalty_params message for the response containing these parameters. All other behavior is implementation‑specific. This includes any kind of modifications to the logic of minting new items, managing ownership of the collection, changing metadata, and other features. The reference implementation, for example, implements the ownership management feature and two ways of minting items: singular and batched. Both of these are outside the scope of the standards but are common and needed in most cases. These features are optional and can be removed or replaced. CapabilityRequirementget_collection_data (get-method)Required by TEP-62get_nft_address_by_index (get-method)Required by TEP-62get_nft_content (get-method)Required by TEP-62, data format follows TEP-64royalty_params (get-method)Required by TEP-66get_royalty_params (inbound internal message)Required by TEP-66report_royalty_params (outbound internal message)Required by TEP-66Deploy single item, op=1 (inbound internal message, owner-only)OptionalDeploy batch of items, op=2 (inbound internal message, owner-only)OptionalChange owner, op=3 (inbound internal message, owner-only)Optional Here, op means a 32‑bit operation code placed at the start of an internal message body. Contracts use it to dispatch messages to different handlers. The numeric values are local to this contract; they just need to be unique within its dispatcher. See the Messages overview for more background. ​Storage The storage scheme itself is not defined by these standards, so it can be arbitrary. The reference collection contract contains 5 fields: owner_address, next_item_index, content, nft_item_code, and royalty_params. Some of them are self‑explanatory, while content and royalty_params need additional explanation below. Storage loading and saving is implemented with simple functions load_data and save_data: CopyAsk AI(slice, int, cell, cell, cell) load_data() inline { var ds = get_data().begin_parse(); return (ds~load_msg_addr(), ;; owner_address ds~load_uint(64), ;; next_item_index ds~load_ref(), ;; content ds~load_ref(), ;; nft_item_code ds~load_ref() ;; royalty_params ); } () save_data(slice owner_address, int next_item_index, cell content, cell nft_item_code, cell royalty_params) impure inline { set_data(begin_cell() .store_slice(owner_address) .store_uint(next_item_index, 64) .store_ref(content) .store_ref(nft_item_code) .store_ref(royalty_params) .end_cell()); } The content cell in this contract contains 2 cells in references: collection_content containing metadata of the collection itself, and common_content containing the common prefix for individual items’ metadata. The royalty_params cell contains 3 values: royalty_factor which is a numerator, royalty_base which is a denominator, and royalty_address which is the address where royalties are sent. ​Child contracts The collection and item contracts implement a classic parent–child pattern, where the collection acts as the parent and items are children. Therefore, the collection implements functionality to deploy its children, and the contract keeps the nft_item_code field in storage. The contract uses helper functions to compose StateInit — roughly, the package that holds a contract’s initial code and data used to derive its address and deploy it — calculate addresses, and send deploy messages for NFT items. First, calculate_nft_item_state_init composes a StateInit cell of an NFT item with a given item_index. It composes a data cell following the expected storage schema of the item contract. Then the data and code cells are placed in a final StateInit cell following the format required by the TON blockchain. It uses the store_dict builder to encode optional references; it does not store dictionaries. This can be replaced with a more self‑explanatory store_maybe_ref builder which does the same thing. It stores a single bit 0 in a builder if the cell is null, otherwise bit 1 and a cell as a reference. CopyAsk AIcell calculate_nft_item_state_init(int item_index, cell nft_item_code) { cell data = begin_cell().store_uint(item_index, 64).store_slice(my_address()).end_cell(); return begin_cell().store_uint(0, 2).store_dict(nft_item_code).store_dict(data).store_uint(0, 1).end_cell(); } The calculate_nft_item_address function takes state_init composed by calculate_nft_item_state_init, along with wc (the workchain for the resulting address). It calculates the address by hashing the StateInit and composing a MsgAddressInt slice according to the format required by the TON blockchain. CopyAsk AIslice calculate_nft_item_address(int wc, cell state_init) { return begin_cell().store_uint(4, 3) .store_int(wc, 8) .store_uint(cell_hash(state_init), 256) .end_cell() .begin_parse(); } deploy_nft_item builds the StateInit, derives the address, and sends the deploy message. It calls calculate_nft_item_state_init to compose the StateInit, then calculate_nft_item_address with workchain() to derive the contract’s workchain (reference implementation uses 0 for basechain), and finally composes and sends the deploy message with the StateInit and content (using send_raw_message). CopyAsk AI() deploy_nft_item(int item_index, cell nft_item_code, int amount, cell nft_content) impure { cell state_init = calculate_nft_item_state_init(item_index, nft_item_code); slice nft_address = calculate_nft_item_address(workchain(), state_init); var msg = begin_cell() .store_uint(0x18, 6) .store_slice(nft_address) .store_coins(amount) .store_uint(4 + 2 + 1, 1 + 4 + 4 + 64 + 32 + 1 + 1 + 1) .store_ref(state_init) .store_ref(nft_content); send_raw_message(msg.end_cell(), 1); ;; pay transfer fees separately, revert on errors } Note on .store_uint(0x18, 6) and .store_uint(0x10, 6): These 6 leading bits encode the start of CommonMsgInfo for an internal message: int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress … (see message layout). Concretely, the 6 bits are: tag = 0 — selects int_msg_info$0 (internal message info). ihr_disabled — set to 1 to disable IHR (Instant Hypercube Routing). IHR is a legacy delivery mode and is not used in TON; contracts should always keep it disabled. See Hypercube routing. bounce — if 1, the message will bounce back on errors during compute/action phases; if 0, it will not bounce. We use bounce=1 (0x18) for deploys to child items so the collection gets its funds back on failure, and bounce=0 (0x10) for royalty replies to avoid bounces and ensure crediting wallets/uninitialized addresses. See Bounce phase. bounced — set to 0 in outbound messages you build. This bit is meaningful only for inbound messages: when the blockchain generates a bounce, the inbound copy has bounced=1. Validators construct such bounce messages themselves; your outbound value does not make a message “bounced”. In normal sends, keep it 0. src — we serialize addr_none (the 00 tag). Validators replace it with the current contract address during the action phase, so you don’t need to spend bits storing the full source address. See send_raw_message. Therefore: .store_uint(0x18, 6) → 011000: ihr_disabled=1, bounce=1 (bounceable), bounced=0, src=addr_none. Used for deploy messages to child items. .store_uint(0x10, 6) → 010000: ihr_disabled=1, bounce=0 (non‑bounceable), bounced=0, src=addr_none. Used for replies like report_royalty_params to avoid bounces. The destination comes next (.store_slice(nft_address)), followed by value",
    "category": "tokens",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "deployment",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "reference",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:26:46.811Z"
  },
  {
    "id": "docs-ton-org--foundations-consensus-catchain-visualizer",
    "title": "Catchain & BCP visualizer",
    "url": "https://docs.ton.org/foundations/consensus/catchain-visualizer",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusCatchain & BCP visualizerAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationConsensusCatchain & BCP visualizerBlockchain foundationsConsensusCatchain & BCP visualizerCopy pageInteractive visual simulation of Catchain + BCP roundsCopy pageTo understand this simulation, read Catchain whitepaper first. ​Interact with the simulation Click nodes to view status (locks/commits) and toggle behavior (good, crash, lagging). Click Adjust simulation config at the top to change consensus simulation parameters. Hover over the Event types at the bottom to read short description. Click moving messages to inspect sender/receiver, timings, and embedded actions; drop a message from the overlay with Drop message button. Click Candidates in the sidebar to see proposer, priority, and per-node approvals/votes/pre-commits/commits observed. Use the speed slider to slow down/accelerate the sim; use Restart round to begin a new round. ​Simulation notes This is a teaching simulation, not the exact C++ validator-session implementation of the whitepaper. It contains certain simplifications. Timing is approximate; actions are driven by the sim loop and simplified delays, not the precise check_all/process_blocks cadence. Catchain dependency handling is simplified: if a node sees a message but lacks one of its parents, it asks peers for that missing block (no vector-time sync). Quorums use equal weights (counts), not stake weights. Submits are auto-scheduled per priority window; retries and network sync differ from the real catchain/validator logic. Null candidate is assumed after its delay; VoteFor/slow-mode handling is simplified. Was this page helpful?YesNoSuggest editsRaise issuePreviousAccount statusNext⌘IgithubxtelegramPowered by Mintlify",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:26:48.111Z"
  },
  {
    "id": "docs-ton-org--foundations-actions-send",
    "title": "Send message",
    "url": "https://docs.ton.org/foundations/actions/send",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsOverviewSend messageReserve coinsSet codeChange libraryConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationActionsSend messageBlockchain foundationsActionsSend messageCopy pageCopy pageSending a message is the most frequent action that a smart contract performs during the action phase. It can get into the out action list by: The SENDRAWMSG instruction. The SENDMSG instruction. The POPCTR instruction. The sending message action consists of: an 8-bit bitmask mode specifying the way of sending; a cell containing the message to send, which is serialized as MessageRelaxed type. ​Message normalization During the process of sending, the original message is normalized. In the final message that is sent to the destination address, the following changes are applied to the fields of the CommonMsgInfoRelaxed type: ihr_disabled is set to true; bounced is set to false; fwd_fee is set to actual forward fee dedicated to the validators of the destination address shard; src address is set to address of the sender smart contract; created_at is set to the current Unix timestamp; created_lt is set to the logical time of that action. As a result, when composing a message cell, it is acceptable to: fill the ihr_disabled, bounced, fwd_fee, created_at, and created_lt fields with any values; fill the src field with addr_none. If the message cell does not fit into the maximum allowed size (1023 bits) after the normalization, the process is repeated with different ways to pack it: with init packed in a separate cell, referred from the root cell; with init and body packed in separate cells. If after the second attempt the message is still too large, the exception is thrown in the action phase. This can lead to rejecting the whole action phase, sending a bounce message, or skipping this action. The exact behavior depends on the mode bitmask of the action. ​Serialization CopyAsk AIaction_send_msg#0ec3c86d mode:(## 8) out_msg:^(MessageRelaxed Any) = OutAction; out_list_node$_ prev:^Cell action:OutAction = OutListNode; message$_ {X:Type} info:CommonMsgInfoRelaxed init:(Maybe (Either StateInit ^StateInit)) body:(Either X ^X) = MessageRelaxed X; int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress dest:MsgAddressInt value:CurrencyCollection extra_flags:(VarUInteger 16) fwd_fee:Grams created_lt:uint64 created_at:uint32 = CommonMsgInfoRelaxed; ext_out_msg_info$11 src:MsgAddress dest:MsgAddressExt created_lt:uint64 created_at:uint32 = CommonMsgInfoRelaxed; Was this page helpful?YesNoSuggest editsRaise issuePreviousReserve coinsNext⌘IgithubxtelegramPowered by MintlifyOn this pageMessage normalizationSerialization",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:26:50.129Z"
  },
  {
    "id": "docs-ton-org--foundations-proofs-verifying-liteserver-proofs",
    "title": "Liteserver proof verification",
    "url": "https://docs.ton.org/foundations/proofs/verifying-liteserver-proofs",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsOverviewLiteserver proof verificationSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationMerkle proofsLiteserver proof verificationBlockchain foundationsMerkle proofsLiteserver proof verificationCopy pageCopy pageThis article assumes you are familiar with Merkle proof cells. This article presents advanced examples of proof verification using liteservers. Verifying any data received from a node is essential for trustless interaction with the blockchain. However, this article covers only a portion of the trustless communication process with a liteserver. It assumes you have verified the block hash received from a liteserver or any other source. Block hash verification is a more advanced topic. It requires syncing key blocks, validating block signatures, or both. This topic will be covered in a future article. Nonetheless, even using only the examples provided here can significantly reduce the probability of accepting incorrect data from a liteserver. ​Block header Suppose we have a known block ID: not runnableCopyAsk AI<TL BlockIdExt [wc=-1, shard=-9223372036854775808, seqno=31220993, root_hash=51ed3b9e728e7c548b15a5e5ce988b4a74984c3f8374f3f1a52c7b1f46c26406, file_hash=d4fcdc692de1a252deb379cd25774842b733e6a96525adf82b8ffc41da667bf5] > Request the corresponding block header from a liteserver. The liteserver’s response includes a header_proof BoC. After deserializing the BoC, we obtain the following cell: not runnableCopyAsk AI280[0351ED3B9E728E7C548B15A5E5CE988B4A74984C3F8374F3F1A52C7B1F46C264060016] -> { 64[11EF55AAFFFFFF11] -> { 640[9BC7A98700000000040101DC65010000000100FFFFFFFF000000000000000064B6C356000023D38BA64000000023D38BA64004886D00960007028101DC64FD01DC42BEC400000003000000000000002E] -> { 608[000023D38B96FDC401DC650048A3971C46472B85C8D761060A6E7AE9F13A90CDDA815915A89597CFECB393A6B568807ADFB3C1C5EFC920907225175DB61CA384E4F8B313799E3CBB8B7B4085] }, 288[01018C6053C1185700C0FE4311D5CF8FA533EA0382E361A7B76D0CF299B75AC0356C0003], 288[0101741100D622B0D5264BCDB86A14E36FC8C349B82AE49E037002EB07079EAD8B060015], 288[01015720B6AEFCBF406209522895FAA6C0D10CC3315D90BCAF09791B19F595E86F8F0007] } } Deserialize the cell according to the block TL-B schema: CopyAsk AI_ = { 'global_id': -239, 'info': { 'version': 0, 'not_master': 0, 'after_merge': 0, 'before_split': 0, 'after_split': 0, 'want_split': False, 'want_merge': True, 'key_block': False, 'vert_seqno_incr': 0, 'flags': 1, 'seqno': 31220993, 'vert_seqno': 1, 'shard': {'shard_pfx_bits': 0, 'workchain_id': -1, 'shard_prefix': 0}, 'gen_utime': 1689699158, 'start_lt': 39391488000000, 'end_lt': 39391488000004, 'gen_validator_list_hash_short': 2288844950, 'gen_catchain_seqno': 459393, 'min_ref_mc_seqno': 31220989, 'prev_key_block_seqno': 31212222, 'gen_software': {'version': 3, 'capabilities': 46}, 'master_ref': None, 'prev_ref': {'type_': 'prev_blk_info', 'prev': {'end_lt': 39391487000004, 'seqno': 31220992, 'root_hash': b'H\\xa3\\x97\\x1cFG+\\x85\\xc8\\xd7a\\x06\\nnz\\xe9\\xf1:\\x90\\xcd\\xda\\x81Y\\x15\\xa8\\x95\\x97\\xcf\\xec\\xb3\\x93\\xa6', 'file_hash': b'\\xb5h\\x80z\\xdf\\xb3\\xc1\\xc5\\xef\\xc9 \\x90r%\\x17]\\xb6\\x1c\\xa3\\x84\\xe4\\xf8\\xb3\\x13y\\x9e<\\xbb\\x8b{@\\x85'}}, 'prev_vert_ref': None }, 'value_flow': None, 'state_update': None, 'extra': None } Next, we need to verify that the seqno in the deserialized block matches the seqno of the block we know. After that, we compute hash_1 for the single Merkle proof reference and compare it to our block hash. CopyAsk AIassert h_proof.refs[0].get_hash(0) == block_id.root_hash Now, we can trust all other data in the cell. Checking proof examples: Python, Kotlin, C++ ​Full block In the liteserver.getBlock method, proof verification is performed in Block header. However, it includes full cells instead of pruned branches for the value flow, state update, and block extra schemas. ​Shard block Shard proofs verify that a shard reference is stored in the masterchain block provided to the liteserver. These proofs are necessary when calling the following methods: liteServer.getShardInfo liteServer.getAccountState liteServer.runSmcMethod To request shard info from the liteserver for the masterchain block mentioned above, we can execute the following code: CopyAsk AIawait client.raw_get_shard_info(master, wc=0) The liteserver response contains the BlockIdExt of the shard block: not runnableCopyAsk AI<TL BlockIdExt [wc=0, shard=-9223372036854775808, seqno=36908135, root_hash=39e5cbca5bf69750b5d9897872c3a0d7a3e614e521c53e4de728fafed38dce27, file_hash=f1f0e5cdc4b8a12cf2438dcab60f4712d1dc04f3792b1d72f2500cbf640948b7] > Shard proof BoC: The shard_descr BoC can be used if the liteserver is trusted. After deserializing the shard proof BoC, two root cells are obtained: not runnableCopyAsk AI[<Cell 280[0351ED3B9E728E7C548B15A5E5CE988B4A74984C3F8374F3F1A52C7B1F46C264060016] -> 1 refs>, <Cell 280[0332BF3592969931CA4FBC7715494B50597F1884C0D847456029D8CF0E526E6046016F] -> 1 refs>] The first root is a masterchain block Merkle proof, which must be verified using the check_block_header function: not runnableCopyAsk AI280[0351ED3B9E728E7C548B15A5E5CE988B4A74984C3F8374F3F1A52C7B1F46C264060016] -> { 64[11EF55AAFFFFFF11] -> { 640[9BC7A98700000000040101DC65010000000100FFFFFFFF000000000000000064B6C356000023D38BA64000000023D38BA64004886D00960007028101DC64FD01DC42BEC400000003000000000000002E] -> { 608[000023D38B96FDC401DC650048A3971C46472B85C8D761060A6E7AE9F13A90CDDA815915A89597CFECB393A6B568807ADFB3C1C5EFC920907225175DB61CA384E4F8B313799E3CBB8B7B4085] }, 288[01018C6053C1185700C0FE4311D5CF8FA533EA0382E361A7B76D0CF299B75AC0356C0003], 552[0478E0F0E601BA1161ECC1395E9A0475C4F80AADBD6C483F210E96E29CF36789E432BF3592969931CA4FBC7715494B50597F1884C0D847456029D8CF0E526E6046016F016F] -> { 560[010378E0F0E601BA1161ECC1395E9A0475C4F80AADBD6C483F210E96E29CF36789E46492304DFB6EF9149781871464AF686056A9627F882F60E3B24F8C944A75EBAF016F0014], 560[010332BF3592969931CA4FBC7715494B50597F1884C0D847456029D8CF0E526E6046DA58493CCB5DA3876129B0190F3C375E69E59C3AD9FF550BE708999DAD1F6F39016F0014] }, 288[01015720B6AEFCBF406209522895FAA6C0D10CC3315D90BCAF09791B19F595E86F8F0007] } } The cell not runnableCopyAsk AI552[0478E0F0E601BA1161ECC1395E9A0475C4F80AADBD6C483F210E96E29CF36789E432BF3592969931CA4FBC7715494B50597F1884C0D847456029D8CF0E526E6046016F016F] -> { 560[010378E0F0E601BA1161ECC1395E9A0475C4F80AADBD6C483F210E96E29CF36789E46492304DFB6EF9149781871464AF686056A9627F882F60E3B24F8C944A75EBAF016F0014], 560[010332BF3592969931CA4FBC7715494B50597F1884C0D847456029D8CF0E526E6046DA58493CCB5DA3876129B0190F3C375E69E59C3AD9FF550BE708999DAD1F6F39016F0014] } It is a Merkle update of the ShardState TL-B schema. The resulting new hash should be stored. After verifying that the only Merkle proof cell reference Hash_1 matches the known block hash and storing the new ShardState hash, proceed to validate the second shard proof cell: not runnableCopyAsk AI280[0332BF3592969931CA4FBC7715494B50597F1884C0D847456029D8CF0E526E6046016F] -> { 362[9023AFE2FFFFFF1100FFFFFFFF000000000000000001DC65010000000164B6C356000023D38BA6400401DC64FD40] -> { 288[0101AFFE84CDD73951BCE07EEAAD120D00400295220D6F66F1163B5FA8668202D72B0001], 288[0101FAED0DD3CA110ADA3D22980E3795D2BDF15450E9159892BBF330CDFD13A3B880016E], 204[0000000000000000FFFFFFFFFFFFFFFF820CE9D9C3929379C820] -> { 288[0101A5A7D24057D8643B2527709D986CDA3846ADCB3EDDC32D28EC21F69E17DBAAEF0001], 288[0101DEAB5A5AAF79C5E24F8DCBBE51747D6804104F75F58ED5BED4702C353545C6AC0011] }, 342[CC26AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC23519B11EDDC69B7C] -> { 9[D000] -> { 878[50119963380EE3280800011E9C5CB7EE0000011E9C5CB7EE29CF2E5E52DFB4BA85AECC4BC3961D06BD1F30A7290E29F26F3947D7F69C6E713F8F872E6E25C50967921C6E55B07A38968EE0279BC958EB97928065FB204A45B88000381ABC00000000000000000EE327EB25B61A88] -> { 74[43C9B67A721DCD650000] } }, 288[01015394592E3A3F1E3BC2D4249E993D0EC1E33CA18F49533991274EBC65276CD9A50011], 766[0001AAA0161D000702816000047A7172DFB88800011E8B625908200EE215F71061846393A08C682E87BC3A12AFF2D246EB97A09164F5657F96F9A252EF71580FE5309A823F73F3C4C3F8AB73F5A85BBF204BFD22E68D36D0EFAB1818E7B428BC] -> { 288[010150FCC05BD9723571B83316A5F650BE31EDB131D05FDC78D271486E5D4EF077E10019], 288[0101E5BE728200B172CF7E2356CBA2AE1C6E2C790BE7C03CD7814C6E6FE3080B944B0011] }, 288[0101B20E36A3B36A4CDEE601106C642E90718B0A58DAF200753DBB3189F956B494B60001] } } } The Merkle proof reference in this cell has the prefix 9023AFE2, corresponding to the ShardStateUnsplit TL-B schema. This reference’s Hash_1 must match the hash stored in the previous step: CopyAsk AI\"\"\" Here, mc_block_cell is the first shard proof root, and mc_state_root is the second one. The check_block_header_proof function returns a new hash of the ShardState Merkle Update. \"\"\" mc_state_hash = mc_state_root[0].get_hash(0) state_hash = check_block_header_proof(mc_block_cell[0], blk.root_hash, True) if mc_state_hash != state_hash: raise ProofError('mc sta",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "python",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:26:53.056Z"
  },
  {
    "id": "docs-ton-org--foundations-whitepapers-overview",
    "title": "Overview",
    "url": "https://docs.ton.org/foundations/whitepapers/overview",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersOverviewTVMTON BlockchainThe Open NetworkCatchain consensusGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationWhitepapersOverviewBlockchain foundationsWhitepapersOverviewCopy pageCopy pageThe original TON documentation was written by Dr. Nikolai Durov and comprises a series of whitepapers. They provided a comprehensive overview of all aspects of TON. While most of the information described in the original PDFs holds some truth, those whitepapers are considered legacy due to a lack of updates and gradual integration of their contents into actual documentation pages. Notice that “legacy” here does not mean “outdated”, but rather less kept up to date compared to the regular pages. Only an English PDF version of whitepapers is considered “official.” English HTML version is provided by documentation team. The rest are community translations. The code, comments, and documentation may reference “gram” and “nanogram”. These are remnants of the original TON code developed by Telegram. Gram cryptocurrency was never issued. The official currency of TON is Toncoin. WhitepaperPDFHTMLThe Open Network (TON)EN RU ZH ZHEN RUTON Virtual Machine (TVM)EN RU ZHEN RUTON BlockchainEN RU ZHEN RUCatchain consensusEN RU ZHEN RUFift language specificationEN RU ZHENWas this page helpful?YesNoSuggest editsRaise issuePreviousTVMWhitepaper by Dr. Nikolai DurovNext⌘IgithubxtelegramPowered by Mintlify",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:26:55.713Z"
  },
  {
    "id": "docs-ton-org--foundations-whitepapers-catchain",
    "title": "Catchain consensus: an outline",
    "url": "https://docs.ton.org/foundations/whitepapers/catchain",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersOverviewTVMTON BlockchainThe Open NetworkCatchain consensusGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationWhitepapersCatchain consensus: an outlineBlockchain foundationsWhitepapersCatchain consensus: an outlineCopy pageWhitepaper by Dr. Nikolai DurovCopy pageAuthors: Nikolai Durov Date: February 19, 2020 : Original whitepaper, PDF ​Abstract The aim of this text is to provide an outline of the Catchain Consensus Protocol, a Byzantine Fault Tolerant (BFT) protocol specifically crafted for block generation and validation in the TON Blockchain. This protocol can potentially be used for purposes other than block generation in a proof-of-stake (PoS) blockchain; however, the current implementation uses some optimizations valid only for this specific problem. ​1 Overview The Catchain Consensus protocol builds upon the overlay network construction protocol and the overlay network broadcast protocol of TON Network. The Catchain Consensus protocol itself can be decomposed into two separate protocols, one more low-level and general-purpose (the Catchain protocol1), and the other the high-level Block Consensus Protocol (BCP), which makes use of the Catchain protocol. Higher levels in the TON protocol stack are occupied by the block generation and validation levels; however, all of them are executed essentially locally on one (logical) machine, with the problem of achieving consensus on the newly-generated block delegated to the Catchain protocol level. Here is an approximate diagram of the protocol stack employed by TON for block generation and distribution, showing the correct place of the Catchain Consensus protocol (or rather its two component protocols): Top-level: Block generation and block validation software, logically running on a stand-alone logical machine, with all the inputs provided and outputs handled by the lower-level protocols. The job of this software is to either generate a new valid block for a blockchain (a shardchain or the masterchain of the TON Blockchain), or to check the validity of a block generated by somebody else. (TON) Block consensus protocol: Achieves (byzantine fault tolerant) consensus on the block to be accepted as the next one in the current validator group for the masterchain or a shardchain. This level makes use of (the abstract interface of) the block generation and validation software, and builds upon the lower-level Catchain protocol. This protocol is explained in more detail in Block Consensus Protocol. Catchain protocol: Provides secure persistent broadcasts in an overlay network (e.g., the task group of validators for a specific shardchain or the masterchain dedicated to generation, validation, and propagation of new blocks in this shardchain or masterchain), and detects attempts of “cheating” (protocol violation) on the part of some participants. This protocol is explained in more detail in Catchain Protocol. (TON Network) overlay broadcast protocol: A simple best-effort broadcast protocol for overlay networks in the TON Network. Simply broadcasts received broadcast messages to all neighbors in the same overlay network that did not receive a copy of these messages before, with minimal effort dedicated to keeping copies of undelivered broadcast messages for a short period of time. (TON Network) overlay protocol: Creates overlay networks inside the ADNL protocol network, manages neighbor lists for these overlay networks. Each participant of an overlay network tracks several neighbors in the same overlay network and keeps dedicated ADNL connections (called “channels”) to them, so that incoming messages can be efficiently broadcast to all neighbors with minimal overhead. Abstract Datagram Network Layer (ADNL) protocol: The basic protocol of the TON Network, that delivers packets (datagrams) between network nodes identified only by 256-bit abstract (ADNL) addresses, which effectively are cryptographic keys (or their hashes). This text aims to describe only the second and the third protocol in this suite, namely, the (TON) block consensus protocol and the (TON) Catchain protocol. We would like to point out here that the author of this text, while providing the general guidelines of how this protocol should be designed (on the lines of “let’s create a BFT-hardened group broadcast message system, and run a suitably adapted simple two-phase or three-phase commit protocol on top of this system”) and participating in several discussions during the development and implementation of the protocol, is definitely not the only designer of this protocol and especially of its current implementation. This is the work of several people. A few words on the efficiency of the combined Catchain Consensus protocol. Firstly, it is a true Byzantine Fault Tolerant (BFT) protocol, in the sense that it eventually achieves consensus on a valid next block of the blockchain even if some participants (validators) exhibit arbitrarily malicious behavior, provided these malicious participants are less than one third of the total number of the validators. It is well-known that achieving BFT consensus is impossible if at least one third of participants are malicious [5], so the Catchain Consensus protocol is as good as theoretically possible in this respect. Secondly, when the Catchain Consensus was first implemented (in December 2018) and tested on up to 300 nodes distributed all over the world, it achieved consensus on a new block in 6 seconds for 300 nodes and in 4–5 seconds for 100 nodes (and in 3 seconds for 10 nodes), even if some of these nodes fail to participate or exhibit incorrect behavior.2 Since the TON Blockchain task groups are not expected to consist of more than a hundred validators (even if a total of a thousand or ten thousand validators are running, only a hundred of them with the largest stakes will generate new masterchain blocks, and the others will participate only in the creation of new shardchain blocks, each shardchain block generated and validated by 10–30 validators; of course, all numbers given here are configuration parameters (TON whitepaper and TON Blockchain specification) and can be adjusted later by a consensus vote of validators if necessary), this means that the TON Blockchain is able to generate new blocks once every 4–5 seconds, as originally planned. This promise has been further tested and found out to be fulfilled with the launch of the Test Network of the TON Blockchain a couple of months later (in March 2019). Therefore, we see that the Catchain Consensus protocol is a new member of the ever-growing family of practical BFT protocols [2], even though it is based on slightly different principles. ​2 Catchain Protocol We have already explained in the Overview that the BFT consensus protocol used by the TON Blockchain for achieving consensus on new blockchain blocks consists of two protocols. We provide here a brief description of the Catchain protocol, the lower-level of these two protocols that could be potentially used for purposes other than BFT consensus for blocks. The source code for the Catchain protocol resides in subdirectory catchain\\texttt{catchain}catchain of the source tree. ​2.1. Prerequisites for running the Catchain protocol The main prerequisite for running (an instance of) the Catchain protocol is the ordered list of all nodes that are participating (or allowed to participate) in this specific instance of the protocol. This list consists of public keys and ADNL addresses of all participating nodes. It has to be provided from the outside when an instance of the Catchain protocol is created. ​2.2. Nodes participating in the block consensus protocol For the specific task of creating new blocks for one of the blockchains (i.e., the masterchain or one of the active shardchains) of the TON Blockchain, a special task group consisting of several validators is created. The list of members of this task group is used both to create a private overlay network inside ADNL (this means that the only nodes that can join this overlay network are those explicitly listed during its creation) and to run the corresponding instance of the Catchain protocol. The construction of this list of members is the responsibility of the higher levels of the overall protocol stack (the block creation and validation software) and therefore is not the topic of this text (Examples of configurable parameters would be a more appropriate reference). It is sufficient to know at this point that this list is a deterministic function of the current (most recent) masterchain state (and especially of the current value of the configuration parameters, such as the active list of all validators elected for creating new blocks along with their respective weights). Since the list is computed deterministically, all validators compute the same lists and in particular each validator knows in which task gro",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "react",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:26:58.536Z"
  },
  {
    "id": "docs-ton-org--contribute-snippets-overview",
    "title": "Using components and snippets",
    "url": "https://docs.ton.org/contribute/snippets/overview",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsOverviewAsideImageFileTreeTON Docs home pageSearch...⌘KAsk AISearch...NavigationComponents and snippetsUsing components and snippetsContributeComponents and snippetsUsing components and snippetsCopy pageCopy pageSnippets allow to conveniently keep the same content in sync, while components let you easily reuse a piece of UI or styling consistently. Examples might include a link card or a YouTube embed. Mintlify supports the use of MDX snippets and JSX (React) components in MDX files and provides some built-in components for you to use. In addition to those, this documentation provides a number of custom components in the snippets/ folder. ​Using a snippet One of the core principles of software development is DRY (Don’t Repeat Yourself), which applies to documentation as well. If you find yourself repeating the same content in multiple places, consider creating a custom snippet to keep your content in sync. All snippets are placed in the root snippets/ folder. For more info on their creation and usage, refer to the reusable snippets page in the Mintlify documentation. ​Using a component You can use a component by importing it into your MDX file and then rendering it as a JSX tag. These look like HTML tags but start with an uppercase letter matching the name in your import statement: some/page.mdxCopyAsk AI--- title: \"Frontmatter goes first, as usual\" --- {/* Right after the formatter go the imports of snippets... */} import MyMdxSnippet from '/snippets/my-mdx-snippet.mdx'; {/* ...and components */} import { Aside } from '/snippets/aside.jsx'; And now, some text and usage! <Aside>Here we go, some **nested content and formatting**!</Aside> Learn more in the Mintlify documentation: JSX snippets React components ​Built-in components Mintlify provides built-in components for common documentation use cases. These components are available globally without needing to import anything. See items on the left navigation panel near that page, such as: Accordion, Cards, Columns, Code groups, etc. ​Custom components TON documentation has a number of components built for various needs. See items on the left navigation panel within the “Components and snippets” group under the “Contribute” section, such as: Aside, Image, etc. ​Styling Mintlify supports Tailwind CSS v3 style HTML elements and any components or snippets from the snippets/ folder. Read more: Styling with Tailwind CSS in the Mintlify documentation. Tailwind CSS v3 Documentation Unofficial Tailwind CSS v3 Cheatsheet ​See also Learn how to format text, create headers, and style content with Mintlify Was this page helpful?YesNoSuggest editsRaise issuePreviousAsideNext⌘IgithubxtelegramPowered by MintlifyOn this pageUsing a snippetUsing a componentBuilt-in componentsCustom componentsStylingSee also",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "react",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:27:00.441Z"
  },
  {
    "id": "docs-ton-org--contract-dev-blueprint-develop",
    "title": "Smart contract development",
    "url": "https://docs.ton.org/contract-dev/blueprint/develop",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentOverviewSmart contract developmentDeployment and interactionCollecting test coverageBenchmarking performanceConfiguring BlueprintBlueprint CLIBlueprint TypeScript APITestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationDevelopment environmentSmart contract developmentContract developmentDevelopment environmentSmart contract developmentCopy pageCopy pageEnsure your current directory is the root of the project initialized with npm create ton@latest. ​Contract creation Use Blueprint to create a new contract. ​Interactive mode To launch a guided prompt to create a contract step by step, use: CopyAsk AInpx blueprint create ​Non-interactive mode To create a contract without prompts, provide the contract name and template type: CopyAsk AInpx blueprint create <CONTRACT> --type <TYPE> <CONTRACT>- contract name <TYPE>- template type, e.g., tolk-empty, func-empty, tact-empty, tolk-counter, func-counter, tact-counter Example: CopyAsk AInpx blueprint create MyNewContract --type tolk-empty ​Contract code writing After creation, contracts are placed in the contracts/ folder. Each file uses the extension that matches its language. For example, creating a Tolk contract MyNewContract results in contracts/my_new_contract.tolk. ​Building Blueprint compiles your contracts into build artifacts. ​Interactive mode Run without arguments to select contracts from a prompt: CopyAsk AInpx blueprint build ​Non-interactive mode Specify a contract name or use flags to skip prompts: CopyAsk AInpx blueprint build <CONTRACT> Example: CopyAsk AInpx blueprint build MyNewContract npx blueprint build --all # build all contracts ​Compiled artifacts Compiled outputs are stored in the build/ directory. build/<CONTRACT>.compiled.json- serialized contract representation used for deployment and testing. Each file contains three fields: hash — hash of the compiled contract code in hexadecimal format. hashBase64 — the same hash encoded in Base64. hex — the compiled contract code in hexadecimal form. Example: <CONTRACT>.compiled.jsonCopyAsk AI{ \"hash\":\"21eabd3331276c532778ad3fdcb5b78e5cf2ffefbc0a6dc...\", \"hashBase64\":\"Ieq9MzEnbFMneK0/3LW3jlzy/++8Cm3Dxkt+I3yRe...\", \"hex\":\"b5ee9c72410106010082000114ff00f4a413f4bcf2c80b01...\" } build/<CONTRACT>/<CONTRACT>.fif — Fift code derived from the contract. ​Wrappers Wrappers are TypeScript classes that you write to interact with your smart contracts. They act as a bridge between your application code and the blockchain, encapsulating contract deployment, message sending, and data retrieval logic. Each wrapper implements the Contract interface from @ton/core. When you create a new contract with Blueprint, you need to write your own wrapper class in the wrappers/ folder to define how your application will interact with the contract. Naming ConventionMethods that send messages should start with send (e.g., sendDeploy, sendIncrement), and methods that read data should start with get (e.g., getCounter).This convention works seamlessly with the open() method, which automatically provides the ContractProvider as the first argument to your wrapper methods. ​Static creating methods Wrappers typically include two main static methods for creating contract instances: ​createFromAddress(address: Address) Creates a wrapper instance for an already deployed contract using its address. This method is used when you want to interact with an existing contract on the blockchain. ./wrappers/Counter.tsCopyAsk AIimport { Address, Cell, Contract } from '@ton/core'; export class Counter implements Contract { constructor(readonly address: Address, readonly init?: { code: Cell; data: Cell }) {} static createFromAddress(address: Address) { return new Counter(address); } } ​createFromConfig(config, code, workchain) Creates a wrapper instance for a new contract that hasn’t been deployed yet. This method calculates the contract’s future address based on its initial state and code. ./wrappers/Counter.tsCopyAsk AIimport { Address, beginCell, Cell, Contract, contractAddress } from '@ton/core'; export type CounterConfig = { id: number; counter: number; }; export function counterConfigToCell(config: CounterConfig): Cell { return beginCell().storeUint(config.id, 32).storeUint(config.counter, 32).endCell(); } export class Counter implements Contract { constructor(readonly address: Address, readonly init?: { code: Cell; data: Cell }) {} static createFromConfig(config: CounterConfig, code: Cell, workchain = 0) { const data = counterConfigToCell(config); const init = { code, data }; return new Counter(contractAddress(workchain, init), init); } } Parameters: config - Initial configuration data for your contract code - Compiled contract code (usually loaded from build artifacts) workchain - workchain ID (0 for basechain, -1 for masterchain) Contracts created with createFromAddress() cannot be deployed since they lack the init data required for deployment. Use createFromConfig() for new contracts that need to be deployed. ​Sending messages Message sending methods allow your application to trigger contract execution by sending internal or external messages. These methods handle the construction of message bodies and transaction parameters. All sending methods follow a similar pattern and should start with send: ./wrappers/Counter.tsCopyAsk AIimport { ContractProvider, Sender, SendMode, beginCell, Cell } from '@ton/core'; export class Counter implements Contract { async sendDeploy(provider: ContractProvider, via: Sender, value: bigint) { await provider.internal(via, { value, sendMode: SendMode.PAY_GAS_SEPARATELY, body: beginCell().endCell(), // empty body for deployment }); } async sendIncrement(provider: ContractProvider, via: Sender, opts: { value: bigint; queryId?: number }) { await provider.internal(via, { value: opts.value, sendMode: SendMode.PAY_GAS_SEPARATELY, body: beginCell() .storeUint(0x7e8764ef, 32) // opcode for increment .storeUint(opts.queryId ?? 0, 64) // queryId .endCell(), }); } async sendExternal(provider: ContractProvider, body: Cell) { await provider.external(body); } } Parameters: provider - ContractProvider instance that handles blockchain communication via - Sender object representing the transaction sender opts - Options object containing transaction value and method-specific parameters ​Calling get methods Get methods allow you to read data from smart contracts without creating transactions. These methods are read-only operations that query the contract’s current state. All get methods should start with get and return a Promise: ./wrappers/Counter.tsCopyAsk AIimport { Contract, ContractProvider } from '@ton/core'; export class Counter implements Contract { async getCounter(provider: ContractProvider): Promise<number> { const result = await provider.get('currentCounter', []); return result.stack.readNumber(); } async getItemById(provider: ContractProvider, id: number): Promise<number> { const result = await provider.get('itemById', [ { type: 'int', value: BigInt(id) } ]); return result.stack.readNumber(); } async getContractData(provider: ContractProvider): Promise<{ counter: number; id: number }> { const result = await provider.get('contractData', []); return { counter: result.stack.readNumber(), id: result.stack.readNumber(), }; } } ​Complete example ./wrappers/Counter.tsCopyAsk AIimport { Address, beginCell, Cell, Contract, contractAddress, ContractProvider, Sender, SendMode } from '@ton/core'; export type NewContractConfig = { id: number; counter: number; }; export function newContractConfigToCell(config: NewContractConfig): Cell { return beginCell().storeUint(config.id, 32).storeUint(config.counter, 32).endCell(); } export const Opcodes = { OP_INCREASE: 0x7e8764ef, OP_RESET: 0x3a752f06, }; export class NewContract implements Contract { constructor(readonly address: Address, readonly init?: { code: Cell; data: Cell }) {} static createFromAddress(address: Address) { return new NewContract(address); } static createFromConfig(config: NewContractConfig, code: Cell, workchain = 0) { const data = newContractConfigToCell(config); const init = { code, data }; return new NewContract(contractAddress(workchain, init), init); } async sendDeploy(provider: ContractProvider, via: Sender, value: bigint) { await provider.internal(via, { value, sendMode: SendMode.PAY_GAS_SEPARATELY, body: beginCell().endCell(), }); } async sendIncrease( provider: ContractProvider, via: Sender, opts: { increaseBy: number; value: bigint; queryID?: number; } ) { await provider.internal(via, { value: opts.value, sendMode: SendMode.PAY_GAS_SEPARATELY, body: beginCell() .storeUint(Opcodes.OP_INCREASE, 32) .storeUint(opts.queryID ?? 0, 64) .storeUint(opts.increaseBy, 32) .endCell(), }); } async sendReset( provider: ContractProvider, via: Sender, opts: { value: bigint; queryID?: number; } ) { await provider.internal(via, { value: opts.value, sendMode: SendMode.PAY_GAS_SEPARATELY",
    "category": "development",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "deployment",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:27:02.550Z"
  },
  {
    "id": "docs-ton-org--contract-dev-blueprint-coverage",
    "title": "Collecting test coverage",
    "url": "https://docs.ton.org/contract-dev/blueprint/coverage",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentOverviewSmart contract developmentDeployment and interactionCollecting test coverageBenchmarking performanceConfiguring BlueprintBlueprint CLIBlueprint TypeScript APITestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationDevelopment environmentCollecting test coverageContract developmentDevelopment environmentCollecting test coverageCopy pageCopy pageThis page covers coverage calculated on TVM assembly instructions. Path- and source-line coverage is not implemented. There are two main ways to calculate coverage of your @ton/sandbox tests. ​Easy way Library compatibilityFor this way to work correctly, a version of @ton/sandbox >= 0.37.2 and @ton/blueprint >= 0.41.0 is needed. When using Blueprint, the only thing you need to collect coverage is to run the following command: CopyAsk AIblueprint test --coverage Results will appear in the coverage/ directory as HTML files with reports for each of your contracts. ​Customizable way There might be some reasons why you don’t want to simply use --coverage. You don’t want to collect coverage for all contracts. You use @ton/sandbox but don’t use @ton/blueprint. Not all contracts have source code. (For example, for each transaction, you deploy a new contract, and you don’t have wrappers for it.) You want to get the raw data and customize the output. ​1. Enable coverage collection Before running tests, add blockchain.enableCoverage() to collect coverage data: CopyAsk AIimport {Blockchain} from '@ton/sandbox'; describe('Contract Tests', () => { let blockchain: Blockchain; let contract: SandboxContract<MyContract>; beforeEach(async () => { blockchain = await Blockchain.create(); blockchain.enableCoverage(); // or for COVERAGE=true mode only // blockchain.enableCoverage(process.env[\"COVERAGE\"] === \"true\"); // Deploy your contract contract = blockchain.openContract(MyContract.fromInit()); // ... deployment logic }); // Your tests here... }); ​2. Collect coverage after tests CopyAsk AIafterAll(() => { const coverage = blockchain.coverage(contract); console.log(coverage?.summary()); }) ​3. Generate reports CopyAsk AIimport {writeFileSync} from 'fs'; afterAll(() => { const coverage = blockchain.coverage(contract); if (!coverage) return; // Generate HTML report for detailed analysis const htmlReport = coverage.report(\"html\"); writeFileSync(\"coverage.html\", htmlReport); // Print text report to console const textReport = coverage.report(\"text\"); console.log(textReport); }); ​Understanding coverage data ​Coverage summary The coverage summary provides key metrics about your test coverage: CopyAsk AIconst summary = coverage.summary(); console.log(`Total lines: ${summary.totalLines}`); console.log(`Covered lines: ${summary.coveredLines}`); console.log(`Coverage percentage: ${summary.coveragePercentage.toFixed(2)}%`); console.log(`Total gas consumed: ${summary.totalGas}`); console.log(`Total hits: ${summary.totalHits}`); // Instruction-level statistics summary.instructionStats.forEach(stat => { console.log(`${stat.name}: ${stat.totalHits} hits, ${stat.totalGas} gas, avg ${stat.avgGas}`); }); ​Coverage reports HTML Report: Interactive report with highlighting and line-by-line coverage details Text Report: Console-friendly report with coverage information and marked code ​Advanced usage patterns ​Multiple test suites When running multiple test files, you might want to merge coverage data: CopyAsk AI// In first test file const coverage1 = blockchain.coverage(contract); if (!coverage1) return; const coverage1Json = coverage1.toJson(); writeFileSync(\"coverage1.json\", coverage1Json); // In second test file const coverage2 = blockchain.coverage(contract); if (!coverage2) return; const coverage2Json = coverage2.toJson(); writeFileSync(\"coverage2.json\", coverage2Json); // Merge coverage data in separate script after tests const savedCoverage1 = Coverage.fromJson(readFileSync(\"coverage1.json\", \"utf-8\")); const savedCoverage2 = Coverage.fromJson(readFileSync(\"coverage2.json\", \"utf-8\")); const totalCoverage = savedCoverage1.mergeWith(savedCoverage2); console.log(`Combined coverage: ${totalCoverage.summary().coveragePercentage}%`); ​Coverage for multiple contracts When testing systems with multiple contracts: not runnableCopyAsk AIdescribe('Multi-Contract System', () => { let blockchain: Blockchain; let contract1: SandboxContract<Contract1>; let contract2: SandboxContract<Contract2>; beforeEach(async () => { blockchain = await Blockchain.create(); blockchain.enableCoverage(); // Deploy multiple contracts contract1 = blockchain.openContract(Contract1.fromInit()); contract2 = blockchain.openContract(Contract2.fromInit()); }); afterAll(() => { // Get coverage for each contract separately const coverage1 = blockchain.coverage(contract1); const coverage2 = blockchain.coverage(contract2); if (!coverage1 || !coverage2) return; console.log('Contract 1 Coverage:', coverage1.summary().coveragePercentage); console.log('Contract 2 Coverage:', coverage2.summary().coveragePercentage); // Generate separate reports writeFileSync(\"contract1-coverage.html\", coverage1.report(\"html\")); writeFileSync(\"contract2-coverage.html\", coverage2.report(\"html\")); }); }); ​Interpret results The usual report looks like this: Apart from the header statistics, the line-by-line coverage report is the most informative. Most fields are self‑explanatory; the code section shows per‑instruction hit counts (blue) and gas cost (red). This helps you analyze both coverage and gas efficiency. To understand the TVM assembly output, read TVM. ​Limitations Note that when code of other contracts is stored directly in the code of the contract (Tact does that automatically if a contract system does not contain circular dependencies), that affects the overall code coverage percentage. To mitigate this effect in coverage estimation, add a circular dependency. For example, import a file with the following content. TactCopyAsk AIcontract A { receive() { let x = initOf B(); drop2(x); } } contract B() { receive() { let x = initOf A(); drop2(x); } } asm fun drop2(x: StateInit) { DROP2 } Was this page helpful?YesNoSuggest editsRaise issuePreviousBenchmarking performanceNext⌘IgithubxtelegramPowered by MintlifyOn this pageEasy wayCustomizable way1. Enable coverage collection2. Collect coverage after tests3. Generate reportsUnderstanding coverage dataCoverage summaryCoverage reportsAdvanced usage patternsMultiple test suitesCoverage for multiple contractsInterpret resultsLimitations",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "deployment",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:27:04.398Z"
  },
  {
    "id": "docs-ton-org--contract-dev-blueprint-benchmarks",
    "title": "Benchmarking performance",
    "url": "https://docs.ton.org/contract-dev/blueprint/benchmarks",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentOverviewSmart contract developmentDeployment and interactionCollecting test coverageBenchmarking performanceConfiguring BlueprintBlueprint CLIBlueprint TypeScript APITestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationDevelopment environmentBenchmarking performanceContract developmentDevelopment environmentBenchmarking performanceCopy pageCopy pageIn TON, a contract’s performance is defined by its gas consumption, so it’s important to design your logic efficiently. Unlike many other blockchains, TON also requires you to pay for storing contract data and forwarding messages between contracts. ​Gas consumption As you develop and iterate on a contract, even small changes to its logic can affect both gas usage and data size. Monitoring these changes helps ensure that your contract remains efficient and cost-effective. For a deeper breakdown of how fees work in TON, refer to Transaction fees ​Gas metrics reporting To simplify tracking changes in gas usage and data size, we’ve introduced a reporting system that lets you collect and compare metrics across different versions of a contract. To enable this, write test scenarios that cover the contract’s primary usage patterns and verify expected behavior. This approach is sufficient to gather relevant metrics, which you can later use to compare performance changes after updating the implementation. Before running the tests, a store is created to collect metrics from all transactions generated during the tests. After test execution, the collected metrics are supplemented with ABI information from the snapshot, and a report is generated based on this data. While more metrics are collected, the current report format includes gasUsed, cells, and bits, which correspond to the internal metrics compute.phase, state.code, and state.data. ​Metrics comparison example To see how gas metrics can be collected and compared in practice, let’s walk through a complete example. Start by creating a new project using npm create ton@latest: CopyAsk AInpm create ton@latest -y -- sample --type func-counter --contractName Sample cd sample Note: The -y flag skips prompts and accepts defaults. --type specifies the template (e.g., func-counter). --contractName sets the contract name. Alternatively, you can run: CopyAsk AInpm create ton@latest sample This command scaffolds a project with a basic counter contract at contracts/sample.fc. It defines a simple stateful contract that stores an id and a counter and supports an increase operation. sample.fcCopyAsk AI#include \"imports/stdlib.fc\"; const op::increase = \"op::increase\"c; global int ctx_id; global int ctx_counter; () load_data() impure { var ds = get_data().begin_parse(); ctx_id = ds~load_uint(32); ctx_counter = ds~load_uint(32); ds.end_parse(); } () save_data() impure { set_data( begin_cell() .store_uint(ctx_id, 32) .store_uint(ctx_counter, 32) .end_cell() ); } () recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure { if (in_msg_body.slice_empty?()) { ;; ignore all empty messages return (); } slice cs = in_msg_full.begin_parse(); int flags = cs~load_uint(4); if (flags & 1) { ;; ignore all bounced messages return (); } load_data(); int op = in_msg_body~load_uint(32); int query_id = in_msg_body~load_uint(64); if (op == op::increase) { int increase_by = in_msg_body~load_uint(32); ctx_counter += increase_by; save_data(); return (); } throw(0xffff); } int get_counter() method_id { load_data(); return ctx_counter; } int get_id() method_id { load_data(); return ctx_id; } ​Generate a gas report Let’s now generate a gas usage report for the contract. Run the following command: CopyAsk AInpx blueprint test --gas-report This runs your tests with gas tracking enabled and outputs a gas-report.json with transaction metrics. … PASS Comparison metric mode: gas depth: 1 Gas report write in ‘gas-report.json’ ┌───────────┬──────────────┬───────────────────────────┐ │ │ │ current │ │ Contract │ Method ├──────────┬────────┬───────┤ │ │ │ gasUsed │ cells │ bits │ ├───────────┼──────────────┼──────────┼────────┼───────┤ │ │ sendDeploy │ 1937 │ 11 │ 900 │ │ ├──────────────┼──────────┼────────┼───────┤ │ │ send │ 515 │ 11 │ 900 │ │ Sample ├──────────────┼──────────┼────────┼───────┤ │ │ sendIncrease │ 1937 │ 11 │ 900 │ │ ├──────────────┼──────────┼────────┼───────┤ │ │ 0x7e8764ef │ 2681 │ 11 │ 900 │ └───────────┴──────────────┴──────────┴────────┴───────┘ ​Storage fee calculation You can use the cells and bits values from the report to estimate the storage fee for your contract. Here’s the formula: CopyAsk AIstorage_fee = ceil( (account.bits * bit_price + account.cells * cell_price) * time_delta / 2 ** 16) To try this in practice, use the calculator example. ​Regenerate the gas report Note that the op::increase method appears in the report as the raw opcode 0x7e8764ef. To display a human-readable name in the report, update the generated contract.abi.json by replacing the raw opcode with the name increase in both the messages and types sections: CopyAsk AI--- a/contract.abi.json +++ b/contract.abi.json @@ -6,13 +6,13 @@ \"receiver\": \"internal\", \"message\": { \"kind\": \"typed\", - \"type\": \"0x7e8764ef\" + \"type\": \"increase\" } } ], \"types\": [ { - \"name\": \"0x7e8764ef\", + \"name\": \"increase\", \"header\": 2122802415 } ], Once you’ve updated the contract.abi.json file, rerun the command to regenerate the gas report: CopyAsk AInpx blueprint test --gas-report Now the method name appears in the report as increase, making it easier to read: … │ ├──────────────┼──────────┼────────┼───────┤ │ │ increase │ 2681 │ 11 │ 900 │ └───────────┴──────────────┴──────────┴────────┴───────┘ ​Save a snapshot for future comparison To track how gas usage evolves, you can create a named snapshot of the current metrics. This allows you to compare future versions of the contract against this baseline: CopyAsk AInpx blueprint snapshot --label \"v1\" This creates a snapshot file in .snapshot/: CopyAsk AI... PASS Collect metric mode: \"gas\" Report write in '.snapshot/1749821319408.json' ​Optimize the contract and compare the metrics Let’s try a simple optimization — adding the inline specifier to some functions. An inline specifier is directly substituted into the code wherever it’s called, which can help reduce gas usage by eliminating the overhead of a function call. Update your contract like this: CopyAsk AI--- a/contracts/sample.fc +++ b/contracts/sample.fc -() load_data() impure { +() load_data() impure inline { -() save_data() impure { +() save_data() impure inline { -() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure { +() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure inline { Now regenerate the gas report. Since we already created a snapshot labeled v1, this report will include a comparison with the previous version: CopyAsk AInpx blueprint test --gas-report You see a side-by-side comparison of gas usage before and after the change: PASS Comparison metric mode: gas depth: 2 Gas report write in ‘gas-report.json’ ┌───────────┬──────────────┬─────────────────────────────────────────┬───────────────────────────┐ │ │ │ current │ v1 │ │ Contract │ Method ├──────────────┬───────────┬──────────────┼──────────┬────────┬───────┤ │ │ │ gasUsed │ cells │ bits │ gasUsed │ cells │ bits │ ├───────────┼──────────────┼──────────────┼───────────┼──────────────┼──────────┼────────┼───────┤ │ │ sendDeploy │ 1937 same │ 7 -36.36% │ 1066 +18.44% │ 1937 │ 11 │ 900 │ │ ├──────────────┼──────────────┼───────────┼──────────────┼──────────┼────────┼───────┤ │ │ send │ 446 -13.40% │ 7 -36.36% │ 1066 +18.44% │ 515 │ 11 │ 900 │ │ Sample ├──────────────┼──────────────┼───────────┼──────────────┼──────────┼────────┼───────┤ │ │ sendIncrease │ 1937 same │ 7 -36.36% │ 1066 +18.44% │ 1937 │ 11 │ 900 │ │ ├──────────────┼──────────────┼───────────┼──────────────┼──────────┼────────┼───────┤ │ │ increase │ 1961 -26.86% │ 7 -36.36% │ 1066 +18.44% │ 2681 │ 11 │ 900 │ └───────────┴──────────────┴──────────────┴───────────┴──────────────┴──────────┴────────┴───────┘ ​Project setup instructions If your project already exists, you need to configure jest to collect gas metrics. You can do this in one of two ways: ​Option 1: update the existing jest.config.ts Add the necessary environment and reporter settings: jest.config.tsCopyAsk AIimport type { Config } from 'jest'; const config: Config = { preset: 'ts-jest', + testEnvironment: '@ton/sandbox/jest-environment', testPathIgnorePatterns: ['/node_modules/', '/dist/'], + reporters: [ + 'default', + ['@ton/sandbox/jest-reporter', {}], + ] }; export default config; See the full list of options in the Sandbox jest config docs. ​Option 2: create a separate config gas-report.config.ts If you prefer not to modify your main jest.config.ts, you can create a dedicated config file: gas-report.c",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "deployment",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:27:06.264Z"
  },
  {
    "id": "docs-ton-org--contract-dev-blueprint-config",
    "title": "Configuring Blueprint",
    "url": "https://docs.ton.org/contract-dev/blueprint/config",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentOverviewSmart contract developmentDeployment and interactionCollecting test coverageBenchmarking performanceConfiguring BlueprintBlueprint CLIBlueprint TypeScript APITestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationDevelopment environmentConfiguring BlueprintContract developmentDevelopment environmentConfiguring BlueprintCopy pageCopy pageA configuration file allows you to customize certain blueprint features. Create a blueprint.config.ts file in the root of your project, and export the configuration as a named config; do not use a default export: CopyAsk AIimport { Config } from '@ton/blueprint'; export const config: Config = { // configuration options }; The configuration supports the following options: FieldType/ValuesDescriptionpluginsPlugin[]Extend or customize the behavior.network'mainnet' 'testnet' CustomNetworkSpecifies the target network for deployment or interaction.separateCompilablesbooleanIf true, *.compile.ts files go to compilables/. If false, to wrappers/.requestTimeoutnumberHTTP request timeout in milliseconds.recursiveWrappersbooleanIf true, searches wrappers/ or compilables/ recursively for contracts.manifestUrlstringOverrides the default TON Connect manifest URL. ​Plugins Blueprint includes a plugin system, allowing the community to extend its functionality without modifying Blueprint’s core code. To use plugins, add a plugins array to your config: CopyAsk AIimport { Config } from '@ton/blueprint'; import { ScaffoldPlugin } from 'blueprint-scaffold'; export const config: Config = { plugins: [new ScaffoldPlugin()], }; This example adds the scaffold plugin. Some community-developed plugins include: scaffold – creates a simple DApp using the wrappers’ code. misti – simplifies workflow with the Misti static analyzer. ​Custom network A custom network can be set as the default by adding a network object to your configuration: CopyAsk AIimport { Config } from '@ton/blueprint'; export const config: Config = { network: { endpoint: 'https://toncenter.com/api/v2/jsonRPC', type: 'mainnet', version: 'v2', key: <YOUR_API_KEY>, }, }; Using the --custom flags achieves the same result, but it can be tiresome to provide them every time. The above configuration is equivalent to running: CopyAsk AInpx blueprint run \\ --custom https://toncenter.com/api/v2/jsonRPC \\ --custom-version v2 \\ --custom-type mainnet \\ --custom-key <YOUR_API_KEY> Each property of the network object has the same meaning as its corresponding --custom flag. See the blueprint help run for details. ​Liteclient support Liteclient can be configured using the network object in your configuration: CopyAsk AIimport { Config } from '@ton/blueprint'; export const config: Config = { network: { endpoint: 'https://ton.org/testnet-global.config.json', // Use https://ton.org/global.config.json for Mainnet or any custom configuration version: 'liteclient', type: 'testnet', } }; You can also specify these parameters using CLI: CopyAsk AInpx blueprint run \\ --custom https://ton.org/testnet-global.config.json \\ --custom-version liteclient \\ --custom-type testnet ​Request timeouts You can configure how long HTTP requests should wait before timing out using the requestTimeout field. This is useful when working with unstable or slow networks. CopyAsk AIimport { Config } from '@ton/blueprint'; export const config: Config = { requestTimeout: 10000, // 10 seconds }; ​Recursive wrappers The recursiveWrappers field controls whether the wrappers directory is searched recursively for contract configurations. CopyAsk AIimport { Config } from '@ton/blueprint'; export const config: Config = { recursiveWrappers: true, }; By default, it’s set to false. ​TON Connect manifest If you’re using a TON Connect provider, you can override the default manifest URL by setting the manifestUrl field: CopyAsk AIimport { Config } from '@ton/blueprint'; export const config: Config = { manifestUrl: 'https://yourdomain.com/custom-manifest.json', }; By default, the manifest URL is: CopyAsk AIhttps://raw.githubusercontent.com/ton-org/blueprint/main/tonconnect/manifest.json Was this page helpful?YesNoSuggest editsRaise issuePreviousBlueprint CLINext⌘IgithubxtelegramPowered by MintlifyOn this pagePluginsCustom networkLiteclient supportRequest timeoutsRecursive wrappersTON Connect manifest",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "dapp",
      "api",
      "sdk",
      "testnet",
      "mainnet",
      "transaction",
      "deployment",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:27:08.668Z"
  },
  {
    "id": "docs-ton-org--contract-dev-blueprint-cli",
    "title": "Blueprint CLI",
    "url": "https://docs.ton.org/contract-dev/blueprint/cli",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentOverviewSmart contract developmentDeployment and interactionCollecting test coverageBenchmarking performanceConfiguring BlueprintBlueprint CLIBlueprint TypeScript APITestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationDevelopment environmentBlueprint CLIContract developmentDevelopment environmentBlueprint CLICopy pageCopy pageBlueprint is a CLI tool for TON smart contract development. This reference covers all available commands, options, configuration, and API methods. ​CLI commands Blueprint provides a comprehensive set of CLI commands for smart contract development, testing, and deployment. Commands support both interactive and non-interactive modes. ​create CopyAsk AInpx blueprint create <CONTRACT> --type <TYPE> Creates a new smart contract with all necessary files, including the contract source, TypeScript wrapper, test file, and deployment script. ​Interactive mode CopyAsk AInpx blueprint create Launches an interactive wizard that guides you through: Contract name selection (validates CamelCase format) Programming language choice (Tolk, FunC, or Tact) Template type selection (empty or counter example) ​Non-interactive mode CopyAsk AInpx blueprint create <CONTRACT> --type <TYPE> Parameters: <CONTRACT> — contract name in CamelCase format (e.g., MyAwesomeContract) <TYPE> — template type from available options Available template types: tolk-empty — an empty contract (Tolk) func-empty — an empty contract (FunC) tact-empty — an empty contract (Tact) tolk-counter — a simple counter contract (Tolk) func-counter — a simple counter contract (FunC) tact-counter — a simple counter contract (Tact) Usage examples: CopyAsk AI# Create empty Tolk contract npx blueprint create MyToken --type tolk-empty # Create Tolk counter example npx blueprint create SimpleCounter --type tolk-counter # Create contract interactively npx blueprint create Generated files: contracts/MyContract.{tolk|fc|tact} — contract source code wrappers/MyContract.ts — TypeScript wrapper for contract interaction tests/MyContract.spec.ts — Jest test suite with basic test cases scripts/deployMyContract.ts — deployment script with network configuration ​build CopyAsk AInpx blueprint build <CONTRACT> --all Compiles smart contracts using their corresponding .compile.ts configuration files. ​Interactive mode CopyAsk AInpx blueprint build Displays a list of all available contracts with .compile.ts files for selection. Shows compilation status and allows building individual contracts or all at once. ​Non-interactive mode CopyAsk AInpx blueprint build <CONTRACT> npx blueprint build --all Parameters: <CONTRACT> — specific contract name to build (matches the .compile.ts filename) --all — build all contracts in the project that have compilation configurations Usage examples: CopyAsk AI# Build specific contract npx blueprint build MyToken # Build all contracts npx blueprint build --all # Interactive selection npx blueprint build For detailed information about build artifacts, see Compiled Artifacts. ​run CopyAsk AInpx blueprint run <SCRIPT> <ARGS...> <OPTIONS> Executes TypeScript scripts from the scripts/ directory with full network provider access. Commonly used for contract deployment, interaction, and maintenance tasks. ​Interactive mode CopyAsk AInpx blueprint run Displays a list of all available scripts in the scripts/ directory to select from. ​Non-interactive mode CopyAsk AInpx blueprint run <SCRIPT> <ARGS...> Parameters: <SCRIPT> — script name (without .ts extension) <ARGS...> — optional arguments passed to the script --<NETWORK> — network selection (mainnet, testnet) --<DEPLOY_METHOD> — deployment method (tonconnect, mnemonic) Network options: --mainnet — use TON Mainnet --testnet — use TON Testnet --custom <URL> — use custom network endpoint --custom-version <VERSION> — API version (v2, v4) --custom-type <TYPE> — network type (custom, mainnet, testnet) --custom-key <KEY> — API key (v2 only) Deploy options: --tonconnect — use TON Connect for deployment --deeplink — use deep link for deployment --mnemonic — use mnemonic for deployment Explorer options: --tonscan — use Tonscan explorer --tonviewer — use Tonviewer explorer (default) --toncx — use TON.cx explorer --dton — use dTON explorer Usage examples: CopyAsk AI# Deploy contract to testnet with TON Connect npx blueprint run deployCounter --testnet --tonconnect # Deploy to testnet with mnemonic npx blueprint run deployCounter --testnet --mnemonic # Run script with custom arguments npx blueprint run updateConfig arg1 arg2 --testnet # Use custom network configuration npx blueprint run deployContract \\ --custom https://toncenter.com/api/v2/jsonRPC \\ --custom-version v2 \\ --custom-type mainnet \\ --custom-key <YOUR_API_KEY> <YOUR_API_KEY> — API key for the selected provider (v2 only). Requirements: Scripts must be located in the scripts/ directory Script files must export a run function: CopyAsk AIimport { NetworkProvider } from '@ton/blueprint'; export async function run(provider: NetworkProvider, args: string[]) { } Environment variables: For mnemonic-based deployments, configure these environment variables. ​test Run the full project test suite with all .spec.ts files. ​Basic usage CopyAsk AInpx blueprint test Run all test files in the tests/ directory. ​Collecting coverage CopyAsk AInpx blueprint test --coverage Run tests and collect coverage into the coverage/ directory. ​Gas reporting CopyAsk AInpx blueprint test --gas-report # or npx blueprint test -g Run tests and compare with the last snapshot’s metrics. ​Specific test file CopyAsk AInpx blueprint test <CONTRACT_NAME> Examples: CopyAsk AInpx blueprint test npx blueprint test MyContract Test file requirements: Test files should be located in the tests/ directory Use .spec.ts extension Supports standard Jest syntax and matchers ​verify Verify a deployed contract using TON Contract Verifier. ​Basic usage CopyAsk AInpx blueprint verify Interactive mode to select the contract and network. ​Non-interactive mode CopyAsk AInpx blueprint verify <CONTRACT> --network <NETWORK> Parameters: <CONTRACT> — contract name to verify --network <NETWORK> — network (mainnet, testnet) --compiler-version <VERSION> — compiler version used for building --custom <URL> — custom network endpoint --custom-version <VERSION> — API version (v2 default) --custom-type <TYPE> — network type (mainnet, testnet) --custom-key <KEY> — API key (v2 only) Examples: CopyAsk AInpx blueprint verify MyContract --network mainnet npx blueprint verify MyContract --network testnet --compiler-version 0.4.4-newops.1 Custom network verification: CopyAsk AInpx blueprint verify MyContract \\ --custom https://toncenter.com/api/v2/jsonRPC \\ --custom-version v2 \\ --custom-type mainnet \\ --custom-key <YOUR_API_KEY> \\ --compiler-version 0.4.4-newops.1 ​help Show detailed help. CopyAsk AInpx blueprint help npx blueprint help <COMMAND> Examples: CopyAsk AInpx blueprint help npx blueprint help create npx blueprint help run ​set Sets language versions. CopyAsk AInpx blueprint set <KEY> <VALUE> Available keys: func — overrides @ton-community/func-js-bin version ​convert Converts legacy bash build scripts to Blueprint wrappers. CopyAsk AInpx blueprint convert <PATH_TO_BUILD_SCRIPT> ​rename Renames a contract by matching in wrappers, scripts, and tests. CopyAsk AInpx blueprint rename <OLD_NAME> <NEW_NAME> ​pack Builds and prepares a publish-ready package of wrappers. CopyAsk AInpx blueprint pack Flags: --no-warn, -n — ignore warnings about modifying tsconfig.json and package.json, and about removing the dist directory Output: Creates a deployment-ready package Includes compiled artifacts Bundles dependencies ​snapshot Creates snapshots with gas usage and cell sizes. CopyAsk AInpx blueprint snapshot Flags: --label=<COMMENT>, -l=<COMMENT> — add a comment label to the snapshot Features: Run with gas usage and cell sizes collected Write a new snapshot Useful for regression testing ​Environment variables Blueprint supports environment variables for wallet configuration when using the mnemonic provider: WALLET_MNEMONIC — wallet mnemonic phrase (space-separated words). WALLET_VERSION — wallet contract version (v1r1, v1r2, v1r3, v2r1, v2r2, v3r1, v3r2, v4r1, v4r2, v4, v5r1). WALLET_ID — wallet ID for versions earlier than v5r1. SUBWALLET_NUMBER — subwallet number for v5r1 wallets. ​Example .env file CopyAsk AIWALLET_MNEMONIC=\"<MNEMONIC_24_WORDS>\" WALLET_VERSION=v4 WALLET_ID=698983191 SUBWALLET_NUMBER=0 <MNEMONIC_24_WORDS> — 24-word wallet mnemonic (space-separated). Was this page helpful?YesNoSuggest editsRaise issuePreviousBlueprint TypeScript APINext⌘IgithubxtelegramPowered by MintlifyOn this pageCLI commandscreateInteractive modeNon-interactive modebuildInteractive modeNon-interactive moderunInteractive modeNon-interactive modetestBasic usageCollecting coverageGas reportingSpecific test fileverifyBasic usageNon-interactive mode",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "testnet",
      "mainnet",
      "transaction",
      "deployment",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:27:11.113Z"
  },
  {
    "id": "docs-ton-org--contract-dev-blueprint-api",
    "title": "Blueprint TypeScript API",
    "url": "https://docs.ton.org/contract-dev/blueprint/api",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentOverviewSmart contract developmentDeployment and interactionCollecting test coverageBenchmarking performanceConfiguring BlueprintBlueprint CLIBlueprint TypeScript APITestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationDevelopment environmentBlueprint TypeScript APIContract developmentDevelopment environmentBlueprint TypeScript APICopy pageCopy pageBlueprint exports functions and classes for programmatic interaction with TON smart contracts. ​tonDeepLink Generates a TON deep-link for transfer. CopyAsk AIfunction tonDeepLink( address: Address, amount: bigint, body?: Cell, stateInit?: Cell, testOnly?: boolean ): string; Parameters: address — the recipient’s TON address amount — the amount of nanoTON to send body — optional message body as a Cell stateInit — optional StateInit cell for deploying a contract testOnly — optional flag to determine output address format Returns: a URL deep link that can be opened in TON wallets Example: CopyAsk AIconst link = tonDeepLink(myAddress, 10_000_000n); // 0.01 TON // \"ton://transfer/...\" ​getExplorerLink Generates a link to view a TON address in a selected blockchain explorer. CopyAsk AIfunction getExplorerLink( address: string, network: string, explorer: 'tonscan' | 'tonviewer' | 'toncx' | 'dton' ): string; Parameters: address — the TON address to view in explorer network — the target network (mainnet or testnet) explorer — the desired explorer (tonscan, tonviewer, toncx, dton) Returns: a full URL pointing to the address in the selected explorer Example: CopyAsk AIconst link = getExplorerLink(\"<ADDR>\", \"testnet\", \"tonscan\"); // \"https://testnet.tonscan.org/address/EQC...9gA\" // <ADDR> — TON address to view. ​getNormalizedExtMessageHash Generates a normalized hash of an external-in message for comparison. CopyAsk AIfunction getNormalizedExtMessageHash(message: Message): Buffer; This function ensures consistent hashing of external-in messages by following TEP-467. Parameters: message — the message to be normalized and hashed (must be of type external-in) Returns: the hash of the normalized message as Buffer Throws: error if the message type is not external-in ​compile Compiles a contract using the specified configuration for tact, func, or tolk languages. CopyAsk AIasync function compile(name: string, opts?: CompileOpts): Promise<Cell> Parameters: name — the name of the contract to compile (should correspond to a file named <name>.compile.ts) opts — optional CompileOpts, including user data passed to hooks Returns: a promise that resolves to the compiled contract code as a Cell Example: CopyAsk AIimport { compile } from '@ton/blueprint'; async function main() { const codeCell = await compile('Contract'); console.log('Compiled code BoC:', codeCell.toBoc().toString('base64')); } ​libraryCellFromCode Packs the resulting code hash into a library cell. CopyAsk AIfunction libraryCellFromCode(code: Cell): Cell Parameters: code — the contract code cell Returns: a library cell containing the code hash ​NetworkProvider Interface representing a network provider for interacting with the TON Blockchain. CopyAsk AIinterface NetworkProvider { network(): 'mainnet' | 'testnet' | 'custom'; explorer(): Explorer; sender(): SenderWithSendResult; api(): BlueprintTonClient; provider(address: Address, init?: { code?: Cell; data?: Cell }): ContractProvider; isContractDeployed(address: Address): Promise<boolean>; waitForDeploy(address: Address, attempts?: number, sleepDuration?: number): Promise<void>; waitForLastTransaction(attempts?: number, sleepDuration?: number): Promise<void>; getContractState(address: Address): Promise<ContractState>; getConfig(configAddress?: Address): Promise<BlockchainConfig>; open<T extends Contract>(contract: T): OpenedContract<T>; ui(): UIProvider; } ​network() CopyAsk AInetwork(): 'mainnet' | 'testnet' | 'custom'; Returns: current network type that the provider is connected to ​explorer() CopyAsk AIexplorer(): Explorer; Returns: Explorer name for the current network ​sender() CopyAsk AIsender(): SenderWithSendResult Returns: the SenderWithSendResult instance used for sending transactions ​api() CopyAsk AIapi(): BlueprintTonClient Returns: the underlying BlueprintTonClient API for direct blockchain interactions ​provider() CopyAsk AIprovider(address: Address, init?: { code?: Cell; data?: Cell }): ContractProvider Creates a contract provider for interacting with a contract at the specified address. Parameters: address — the contract address to interact with init — optional contract initialization data code — Contract code cell data — Contract initial data cell Returns: contractProvider instance for the specified address ​isContractDeployed() CopyAsk AIisContractDeployed(address: Address): Promise<boolean> Checks whether a contract is deployed at the specified address. Parameters: address — the contract address to check Returns: promise resolving to true if contract is deployed, false otherwise Usage example: CopyAsk AIexport async function run(provider: NetworkProvider) { const isDeployed = await provider.isContractDeployed(contractAddress); if (!isDeployed) { console.log('Contract not yet deployed'); } } ​waitForDeploy() CopyAsk AIwaitForDeploy(address: Address, attempts?: number, sleepDuration?: number): Promise<void> Waits for a contract to be deployed by polling the address until the contract appears on-chain. Parameters: address — the contract address to monitor attempts — maximum number of polling attempts (default: 20) sleepDuration — delay between attempts in milliseconds (default: 2000) Returns: a promise that resolves when the contract is deployed Throws: error if the contract is not deployed within the specified attempts Usage example: CopyAsk AIexport async function run(provider: NetworkProvider) { // Send deployment transaction await contract.sendDeploy(provider.sender(), { value: toNano('0.01') }); // Wait for deployment to complete await provider.waitForDeploy(contract.address); console.log('Contract deployed successfully'); } ​waitForLastTransaction() CopyAsk AIwaitForLastTransaction(attempts?: number, sleepDuration?: number): Promise<void> Waits for the last sent transaction to be processed and confirmed on the blockchain. Parameters: attempts — maximum number of polling attempts (default: 20) sleepDuration — delay between attempts in milliseconds (default: 2000) Returns: promise that resolves when the last transaction is confirmed Usage example: CopyAsk AIexport async function run(provider: NetworkProvider) { await contract.sendIncrement(provider.sender(), { value: toNano('0.01') }); await provider.waitForLastTransaction(); } ​getContractState() CopyAsk AIgetContractState(address: Address): Promise<ContractState> Retrieves the current state of a contract, including its balance, code, and data. Parameters: address — the contract address to query Returns: promise resolving to ContractState. Usage example: CopyAsk AIexport async function run(provider: NetworkProvider) { const state = await provider.getContractState(contractAddress); console.log(`Contract balance: ${fromNano(state.balance)} TON`); } ​getConfig() CopyAsk AIgetConfig(configAddress?: Address): Promise<BlockchainConfig> Fetches the current blockchain configuration parameters. Parameters: configAddress — optional config contract address (uses default if not provided) Returns: promise resolving to BlockchainConfig ​open() CopyAsk AIopen<T extends Contract>(contract: T): OpenedContract<T> Opens a contract instance for interaction, binding it to the current provider. Parameters: contract — the contract instance to open Returns: openedContract wrapper that enables direct method calls Usage example: CopyAsk AIexport async function run(provider: NetworkProvider) { const counter = provider.open(Counter.fromAddress(contractAddress)); const currentValue = await counter.getCounter(); console.log('Current counter value:', currentValue); } ​ui() CopyAsk AIui(): UIProvider Returns: UIProvider instance for console interactions Usage example: CopyAsk AIexport async function run(provider: NetworkProvider) { const ui = provider.ui(); ui.write('Deployment starting...'); const confirmed = await ui.prompt('Deploy to mainnet?'); } ​UIProvider Interface for handling user interactions, such as displaying messages, prompting for input, and managing action prompts. This interface abstracts console interactions and can be used in both interactive and automated scenarios. CopyAsk AIinterface UIProvider { write(message: string): void; prompt(message: string): Promise<boolean>; inputAddress(message: string, fallback?: Address): Promise<Address>; input(message: string): Promise<string>; choose<T>(message: string, choices: T[], display: (v: T) => string): Promise<T>; setActionPrompt(message: string): void; clearActionPrompt(): void; } ​write() CopyAsk AIwrite(message: string): void Displays a message to the user console. Parame",
    "category": "api",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "testnet",
      "mainnet",
      "transaction",
      "deployment",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:27:12.595Z"
  },
  {
    "id": "docs-ton-org--contract-dev-ide-jetbrains",
    "title": "TON plugin for IDEs from JetBrains",
    "url": "https://docs.ton.org/contract-dev/ide/jetbrains",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsOverviewVSCode and forksJetBrains IDEsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationIDEs and editor pluginsTON plugin for IDEs from JetBrainsContract developmentIDEs and editor pluginsTON plugin for IDEs from JetBrainsCopy pageCopy pageTON plugin for IntelliJ IDEA (Ultimate and Community), WebStorm, CLion, GoLand, PyCharm, RustRover, and all other JetBrains IDEs. InstallationFeaturesCommunity ​Installation ​From marketplace In the IDE, open Settings Skip this step if you do not have open projects and are in the Start menu Go to Plugins Select the Marketplace tab (default) Search for TON Select the official plugin from TON Core and click Install The plugin would be fetched and installed in your current JetBrains IDE. You might need to restart it for changes to take effect. Here is how the plugin installation page may look in the start menu of WebStorm, before pressing the Install button: Alternatively, you can press Get on the plugin homepage in the JetBrains Marketplace and then follow subsequent instructions. ​From disk To manually install the plugin: Download the plugin archive from the latest GitHub release or from the exact version on the marketplace In the IDE, open Settings Skip this step if you do not have open projects and are in the Start menu Go to Plugins Click the gear icon on top and then select Install Plugin from Disk... Select the plugin archive in the pop-up and complete the installation See also: Installing a plugin from the command line in IntelliJ IDEA. ​Features and language support This plugin provides first-class support for TON-specific languages, schemas, and data formats in IntelliJ-based IDEs. Everything you need to develop, test, debug, and deploy TON smart contracts is made available right from your favorite JetBrains-made editor. TolkRecommended language for TON smart contract developmentFunCLegacy TON smart contract programming languageFiftLow-level stack-based language with deep TVM integrationTL-BCell-based data serialization and markup languageTON Assembly (TASM)Textual TVM bitcode assembly language and corresponding (dis)assemblerIntegrationsWork with Blueprint projects, Sandbox TON emulator, and other popular tools for TON development ​Tolk File extension: .tolk The plugin provides the following features for Tolk files: Syntax and error highlighting Code completion — context-specific suggestions as you type Parameter info — names of parameters in function calls, with option to enable complete function signatures info Quick documentation — pop-up and hover documentation for any symbol right from the editor Declarations — go to declarations, implementations, and types Usages — search for references and usages of a code element throughout the codebase Inlay hints — special in-editor markers, like parameter name blobs next to the corresponding argument values Inspections — detects, finds, and highlights various problems and abnormal code Intention actions — contextual code edits and quick fixes Formatting — rearrangements and code cleanup Rename refactorings — change names of symbols and files Code fragment surrounding — templates for wrapping code fragments in various constructs, such as try...catch blocks. File structure — view and navigate the code structure of the open file. Navigation bar — structure of the project from directories down to code elements, usually located at the bottom of the status bar. ​FunC File extensions: .fc, .func The plugin provides the following features for FunC files: Syntax and error highlighting Code completion Quick documentation Declarations Usages Inlay hints Inspections ​Fift File extensions: .fif, .fift The plugin provides the following features for Fift: Syntax and error highlighting, with better support for Fift assembly Code completion Declarations Usages Inspections ​TL-B File extension: .tlb The plugin provides the following features for TL-B files: Syntax and error highlighting Code completion Declarations Usages Inspections ​TASM File extensions: .tasm — textual bitcode assembly .boc — serialized binary smart contract code The plugin provides the following features for TON Assembly (TASM): Syntax and error highlighting of .tasm files Code completion Declarations Usages Inspections ​Integrations The plugin integrates with: Blueprint — all-in-one development environment for TON smart contract development Sandbox — local TON emulator ​Community Follow news of TON plugin development in the @intellijton Telegram channel.Was this page helpful?YesNoSuggest editsRaise issuePreviousOverviewNext⌘IgithubxtelegramPowered by MintlifyOn this pageInstallationFrom marketplaceFrom diskFeatures and language supportTolkFunCFiftTL-BTASMIntegrationsCommunity",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:27:14.831Z"
  },
  {
    "id": "docs-ton-org--contract-dev-ide-vscode",
    "title": "TON extension for Visual Studio Code (VS Code) and VSCode-based editors",
    "url": "https://docs.ton.org/contract-dev/ide/vscode",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsOverviewVSCode and forksJetBrains IDEsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationIDEs and editor pluginsTON extension for Visual Studio Code (VS Code) and VSCode-based editorsContract developmentIDEs and editor pluginsTON extension for Visual Studio Code (VS Code) and VSCode-based editorsCopy pageCopy pageTON extension for Visual Studio Code (VS Code) and VSCode-based editors, such as VSCodium, Cursor, Windsurf, and others. InstallationFeaturesUsage ​Installation ​From Visual Studio Marketplace Applicable for: VSCode Extension on: Marketplace In the editor, open the Command Palette with Ctrl+Shift+P (or ⌘+⇧+P on macOS) Type and select Extensions: Install Extensions Search for TON Select the official extension from TON Core and click Install The editor fetches and installs the extension. Restart the editor to apply changes if prompted. Here is how the extension page may look in VSCode, before pressing the Install button: ​From Open VSX Registry Applicable for: VSCodium, Cursor, Windsurf, and other VSCodium-based editors Extension in: Registry Installation steps are identical to the VSCode setup. Additionally, one can download the exact extension version from the Open VSX Registry and then proceed with installation from disk. ​From disk Applicable for: any VSCodium-based editor VSIX file: latest GitHub release To manually install the extension: Download the .vsix-packaged plugin archive from the latest GitHub release or from the exact version in the registry In the editor, open the Command Palette with Ctrl+Shift+P (or ⌘+⇧+P on macOS) Type and select Extensions: Install from VSIX... Browse and select the downloaded .vsix file The editor installs the extension. Restart the editor to apply changes if prompted. To install the extension using CLI, specify the editor executable and the --install-extension command-line switch, followed by the path to a .vsix file:CopyAsk AI# Command for VSCode code --install-extension <PATH_TO_EXTENSION.vsix> # Command for VSCodium codium --install-extension <PATH_TO_EXTENSION.vsix> # Other VSCodium-based editors have similar commands Visual Studio Code’s “Installing an extension from a VSIX” guide explains the process. ​Features and language support Extension provides support for TON Blockchain languages and tools in VSCode and VSCode-based editors: from syntax highlighting to on-the-fly inspections and toolchain management. TolkRecommended language for TON smart contract developmentFunCLegacy TON smart contract programming languageFiftLow-level stack-based language with deep TVM integrationTL-BCell-based data serialization and markup languageTON Assembly (TASM)Textual TVM bitcode assembly language and corresponding (dis)assemblerIntegrationsWork with Blueprint projects, Sandbox TON emulator, and other popular tools for TON development ​Tolk File extension: .tolk Tolk support includes: Semantic syntax highlighting Code completion with auto import, postfix completion, snippets, imports completion Go to definition, type definition Find all references, workspace symbol search, symbol renaming Automatic import updates when renaming and moving files Types and documentation on hover Various inlay hints, including hints for types and parameter names. On-the-fly inspections with quick fixes Signature help inside calls Build, test, and debug Blueprint-based projects Flexible toolchain management ​FunC File extensions: .fc, .func FunC support includes: Semantic syntax highlighting Code completion, imports completion Go to definition Find all references, workspace symbol search, symbol renaming Automatic import updates when renaming and moving files Types and documentation on hover Inlay hints for method IDs On-the-fly inspections Build, test, and debug Blueprint-based projects ​Fift File extensions: .fif, .fift Fift support includes: Basic and semantic syntax highlighting Go-to definition Inlay hints with instruction gas consumption Hover documentation for instructions ​TL-B File extension: .tlb TL-B support includes: Basic and semantic syntax highlighting Go-to definition Completion for fields, parameters, and types Go-to references for types Hover documentation for declarations ​TASM File extensions: .tasm — textual bitcode assembly .boc — serialized binary smart contract code TON Assembly (TASM) support includes: Basic syntax highlighting Go-to definition Inlay hints with instruction gas consumption Hover documentation for instructions Code completion for instructions Additionally, BoC support includes: Automatic BoC disassembly with syntax highlighting Automatic updates on changes in BoC ​Integrations The extension integrates with: Sandbox — Local TON emulator used to test smart contracts Blueprint — a popular development environment for TON smart contract development ​Sandbox There is a graphical interface for local TON Blockchain emulation testing. By using it in Blueprint-based projects or any projects that use Sandbox (@ton/sandbox) for contract emulation, one can: Deploy contracts directly from source code Send internal and external messages Execute get-methods Inspect all transactions and messages Inspect storage and balances in real time Rollback to previous states and export or import various scenarios It is suited for prototyping, interactive debugging, and educational purposes. To start, open the “TON Sandbox” panel in the primary sidebar after installing the extension, then follow instructions on top. The Sandbox wiki page provides more detail. ​Usage Customize the default config by setting various options Utilize commands from the Command Palette ​Configuration options This extension provides a wide range of options configurable in the settings editor. ​General ​ton.tolk.stdlib.pathstringdefault:\"auto\"Path to Tolk standard library. If empty, will try to find in node_modules. ​Toolchain ​ton.tolk.toolchain.toolchainsobjectConfigured Tolk toolchains. Each key serves as a unique identifier for the toolchain, which is an object with the following properties: \"name\" (required) — Display name for the toolchain \"path\" (required) — Path to the Tolk compiler executable \"description\" — Optional description for the toolchain Default configuration:CopyAsk AI\"ton.tolk.toolchain.toolchains\": { \"auto\": { \"name\": \"Auto-detected\", \"path\": \"\", \"description\": \"Automatically detect Tolk compiler in node_modules\" } } ​ton.tolk.toolchain.activeToolchainstringdefault:\"auto\"Name of the active Tolk toolchain to use. The \"auto\" is a default toolchain that is automatically detected in node_modules/. ​ton.tolk.toolchain.showShortCommitInStatusBarbooleandefault:falseWhether to add a short commit hash after Tolk version in the status bar. ​Editor → Hints ​ton.tolk.hints.disablebooleandefault:falseTolk: Disable all inlay hints. ​ton.tolk.hints.typesbooleandefault:trueTolk: Show type hints for variables and expressions. ​ton.tolk.hints.parametersbooleandefault:trueTolk: Show parameter name hints in function calls. ​ton.tolk.hints.showMethodIdbooleandefault:trueTolk: Show method ID hints for get methods. ​ton.tolk.hints.constantValuesbooleandefault:trueTolk: Show computed values for constants. ​ton.func.hints.disablebooleandefault:falseFunC: Disable all inlay hints. ​ton.func.hints.showMethodIdbooleandefault:trueFunC: Show method ID hints for functions with method_id. ​ton.func.hints.implicitConstantTypebooleandefault:trueFunC: Show type hints for constants without explicit type. ​Editor → Completion ​ton.tolk.completion.typeAwarebooleandefault:trueTolk: Sort completion items by relevance to the current context type. ​ton.tolk.completion.addImportsbooleandefault:trueTolk: Automatically add necessary imports for symbols from other files. ​Editor → Inspections ​ton.tolk.inspections.disabledstring[]Tolk: List of disabled code inspections. All available inspections are enabled by default: \"unused-parameter\" \"unused-type-parameter\" \"unused-variable\" \"unused-top-level-declaration\" \"unused-import\" \"deprecated-symbol-usage\" \"struct-initialization\" \"cannot-reassign\" \"need-not-null-unwrapping\" \"missed-semicolon\" \"call-arguments-count-mismatch\" ​ton.func.inspections.disabledstring[]FunC: List of disabled code inspections. All available inspections are enabled by default: \"unused-parameter\" \"unused-type-parameter\" \"unused-variable\" \"unused-import\" ​Editor → Find Usages ​ton.tolk.findUsages.scopestringdefault:\"workspace\"Tolk: Where to search when using “Find Usages”. Allowed values: \"workspace\" (default) — Search only in workspace files \"everywhere\" — Search everywhere, including the standard library ​Fift ​ton.fift.hints.showGasConsumptionbooleandefault:trueShow gas consumption hints for Fift instructions. ​ton.fift.semanticHighlighting.enabledbooleandefault:trueEnable/disable semantic highlighting for Fift files. ​BoC ​ton.boc.openDecompiledOnOpenbooleandefault:trueAutomatically open decompiled Fift assembly wh",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:27:17.342Z"
  },
  {
    "id": "docs-ton-org--ecosystem-ton-connect-dapp",
    "title": "How to integrate a decentralized application (dApp)",
    "url": "https://docs.ton.org/ecosystem/ton-connect/dapp",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectOverviewIntegrate a dAppIntegrate a walletManifestsMessage lookupWalletKitTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationTON ConnectHow to integrate a decentralized application (dApp)EcosystemTON ConnectHow to integrate a decentralized application (dApp)Copy pageCopy pageThis guide helps you integrate your dApp with TON or build one from scratch using TON Connect and auxiliary libraries. TON Connect is a standard wallet connection protocol in TON. It consists of supplementary SDKs and supervises two major use cases: dApps integrations with TON and custom wallet integrations. To proceed with a dApp integration, select your framework or environment: ReactNext.jsVanilla JS ​Integration ​React 1Install necessary librariesInstall the @tonconnect/ui-react package:CopyAsk AInpm i @tonconnect/ui-react That is enough for the most basic usage. However, to allow for more complex examples, install the following packages as well:CopyAsk AInpm i @ton-community/assets-sdk @ton/ton @ton/core 2Create a TON Connect manifestTON Connect manifest is a small JSON file that lets wallets discover information about your dApp. It should be named tonconnect-manifest.json, placed at https://<YOUR_APP_URL>/tonconnect-manifest.json, and be accessible with a direct GET request.Notice that CORS should be disabled, and there should be no authorization or intermediate proxies like CloudFlare or similar services. The connection also won’t work when using a VPN.Here’s an example of such a file:tonconnect-manifest.jsonCopyAsk AI{ \"url\": \"https://tonconnect-sdk-demo-dapp.vercel.app/\", \"name\": \"Demo Dapp with React UI\", \"iconUrl\": \"https://tonconnect-sdk-demo-dapp.vercel.app/apple-touch-icon.png\", \"termsOfUseUrl\": \"https://tonconnect-sdk-demo-dapp.vercel.app/terms-of-use.txt\", \"privacyPolicyUrl\": \"https://tonconnect-sdk-demo-dapp.vercel.app/privacy-policy.txt\" } After creating the manifest file, import TonConnectUIProvider to the root of your dApp and pass the manifest URL:CopyAsk AIimport { TonConnectUIProvider } from '@tonconnect/ui-react'; export function App() { return ( <TonConnectUIProvider manifestUrl=\"https://<YOUR_APP_URL>/tonconnect-manifest.json\" > { /* Your app */ } </TonConnectUIProvider> ); } See more detailed information here: TON Connect manifest.3Add a button in the UIUsers need a clear way of connecting their wallets to your app, so you must give a clear UI element to do so. Usually, that is a Connect wallet button.Some in-wallet browsers automatically open a wallet connection modal when your dApp loads. Still, always provide a button alternative in case the user dismissed the modal window or wants to connect a wallet after doing their research.Adding TonConnectButton is straightforward:CopyAsk AIimport { TonConnectButton } from '@tonconnect/ui-react'; export const Header = () => { return ( <header> <span>My App with React UI</span> <TonConnectButton /> </header> ); }; The TonConnectButton is a universal UI component for initializing a connection. After the wallet is connected, it transforms into a wallet menu. Prefer to place the Connect wallet button in the top right corner of your app.You can add the className and style props to the button:CopyAsk AI<TonConnectButton className=\"my-button-class\" style={{ float: \"right\" }}/> You cannot pass a child element to the TonConnectButton.4Utilize TON Connect in your dAppCommon usage recipes ​Manual connection initiation You can always initiate the connection manually using the useTonConnectUI hook and openModal method. CopyAsk AIimport { useTonConnectUI } from '@tonconnect/ui-react'; export const Header = () => { const [tonConnectUI, setOptions] = useTonConnectUI(); return ( <header> <span>My App with React UI</span> <button onClick={() => tonConnectUI.openModal()}> Connect Wallet </button> </header> ); }; To open a modal window for a specific wallet, use the openSingleWalletModal() method. It takes the wallet’s app_name and opens the corresponding wallet modal, returning a promise that resolves once the modal window opens. To find the correct app_name of the target wallet, refer to the wallets-list.json file. CopyAsk AI<button onClick={() => tonConnectUI.openSingleWalletModal('tonwallet')}> Connect Wallet </button> ​UI customization To customize the UI of the modal, use the tonConnectUI object provided by the useTonConnectUI() hook, and then assign designated values as an object to the uiOptions property. CopyAsk AI// Somewhere early in the component: const [tonConnectUI] = useTonConnectUI(); // ... // Somewhere later in the same component: tonConnectUI.uiOptions = { language: 'ru', // sets the target language uiPreferences: { theme: THEME.DARK, // dark theme of the modal } }; In the object assigned, you should only pass options that you want to change — they will be merged with the current UI options. UI element will be re-rendered after such assignment. Note that you have to pass an object and never set individual sub-properties under uiOptions. That is, DO NOT do this:CopyAsk AI/* WRONG, WILL NOT WORK */ tonConnectUI.uiOptions.language = 'ru'; See all available uiOptions in the external reference: TonConnectUiOptions Interface. ​Minimal React setup Putting all the above together, here’s a most minimal React dApp integration example. First, start by creating a new project with React and Vite: CopyAsk AInpm create vite@latest demo-react-dapp -- --template react-ts Then, go into the project and add the @tonconnect/ui-react dependency: CopyAsk AIcd demo-react-dapp npm i @tonconnect/ui-react # this will also install other missing dependencies Edit your App.tsx to have the following imports present: src/App.tsxCopyAsk AIimport { TonConnectUIProvider, TonConnectButton, useTonConnectUI, useTonWallet, CHAIN, } from '@tonconnect/ui-react'; Finally, in the same App.tsx file, replace your App() function with the following: src/App.tsxCopyAsk AIfunction App() { const [tonConnectUI] = useTonConnectUI(); const wallet = useTonWallet(); const sendToncoin = async (amount: string) => { if (!wallet) return; // Once the user has connected, // you can prepare and send a message from the wallet: try { await tonConnectUI.sendTransaction({ validUntil: Math.floor(Date.now() / 1000) + 300, network: CHAIN.TESTNET, messages: [{ address: wallet.account.address, amount }], }); } }; return ( <TonConnectUIProvider {/* We re-use an existing manifest here. To specify your own while developing locally, setup a tunnel and an https domain with the help of ngrok or similar tools. */} manifestUrl=\"https://tonconnect-sdk-demo-dapp.vercel.app/tonconnect-manifest.json\" > <TonConnectButton /> <button {/* Notice that it's important to specify Toncoin in nanoToncoin format, where 1 Toncoin is equal to 10⁹ nanoToncoin: */} onClick={() => sendToncoin(String(100_000_000))} > Send 0.1 TON </button> </TonConnectUIProvider> ); } See all 39 lines Now, execute npm run dev to launch and preview your app in the browser at http://localhost:5173. All changes in code will be reflected live. Connect a wallet and try using the Send 0.1 TON button. Notice that the exact sum of Toncoin shown in your wallet will be different, because there are certain fees required for such a transfer by the blockchain itself. When building apps, make sure to always take fees into consideration and show them to the end-user. This example sends real TON from the connected wallet. Try it with a testnet wallet first or send less Toncoin, e.g., 0.001 TON instead of 1 TON, to avoid surprises. ​Next.js TonConnectUIProvider relies on browser APIs and should be rendered only on the client side, i.e., on the frontend. As such, in a Next.js application, you should mark the component that wraps the provider with 'use client' directive. Alternatively, dynamically import the provider to disable server-side rendering. Both approaches ensure that the provider is invoked only in the browser and works correctly there. Example for the app router: app/providers.tsxCopyAsk AI'use client'; import { TonConnectUIProvider } from '@tonconnect/ui-react'; export function Providers({ children }: { children: React.ReactNode }) { return ( <TonConnectUIProvider manifestUrl=\"https://<YOUR_APP_URL>/tonconnect-manifest.json\" > {children} </TonConnectUIProvider> ); } For the pages router, you can dynamically import the provider: CopyAsk AIimport dynamic from 'next/dynamic'; const TonConnectUIProvider = dynamic( () => import('@tonconnect/ui-react').then(m => m.TonConnectUIProvider), { ssr: false } ); function MyApp({ Component, pageProps }) { return ( <TonConnectUIProvider manifestUrl=\"https://<YOUR_APP_URL>/tonconnect-manifest.json\" > <Component {...pageProps} /> </TonConnectUIProvider> ); } ​Vanilla JS For quick testing, use the following single-file HTML example. This example sends real Toncoin from the connected wallet. Try it with a testnet wallet first or send less Toncoin, e.g., 0.001 ",
    "category": "integration",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "dapp",
      "frontend",
      "api",
      "sdk",
      "testnet",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "react",
      "nextjs",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:27:19.995Z"
  },
  {
    "id": "docs-ton-org--ecosystem-ton-connect-wallet",
    "title": "How to integrate a wallet with TON",
    "url": "https://docs.ton.org/ecosystem/ton-connect/wallet",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectOverviewIntegrate a dAppIntegrate a walletManifestsMessage lookupWalletKitTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationTON ConnectHow to integrate a wallet with TONEcosystemTON ConnectHow to integrate a wallet with TONCopy pageCopy pageThis guide helps you integrate your custodial or non-custodial wallet with TON or partially build a basic, fresh one from scratch with the help of TON Connect and WalletKit. TON Connect is a standard wallet connection protocol used on TON. It consists of many supplementary SDKs and supervises two major use-cases: dApp integrations with TON and custom wallet integrations. The latter are done via the WalletKit. To proceed with a WalletKit integration, select your framework or environment: (Stub) Additionally, explore the complete demo wallets: Demo wallet with WalletKit integrationDemo wallet, GitHub repository ​Usage Once the wallet is integrated, follow one of these common usage recipes: WebInitialize the kit ​See also Read more about the TON Connect and WalletKit themselves: TON Connect overviewWalletKit overview Skim the reference pages with more in-depth information: TON Connect manifestsWalletKit integration QA guideNative and web walletsBrowser extensions and in-wallet browsersWas this page helpful?YesNoSuggest editsRaise issuePreviousManifestsNext⌘IgithubxtelegramPowered by MintlifyOn this pageUsageSee also",
    "category": "integration",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "dapp",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:27:22.228Z"
  },
  {
    "id": "docs-ton-org--ecosystem-ton-connect-manifest",
    "title": "TON Connect manifests",
    "url": "https://docs.ton.org/ecosystem/ton-connect/manifest",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectOverviewIntegrate a dAppIntegrate a walletManifestsMessage lookupWalletKitTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationTON ConnectTON Connect manifestsEcosystemTON ConnectTON Connect manifestsCopy pageCopy pageTON Connect manifests are specially formatted JSON files that define meta information to either pass it from your dApp to the wallet (app manifest) or to set up subsequent wallet interactions with the TON Connect protocol (wallet manifest). ​App manifest App manifest is a small JSON file that lets wallets discover information about your dApp. It should be named tonconnect-manifest.json and correspond to the following definition. FieldRequirementDescription urlrequiredDefines the app URL. It will be used to open the dApp after clicking its icon in the wallet. It is recommended to pass the URL without closing the slash, e.g., https://mydapp.com instead of https://mydapp.com/.namerequiredDefines the app name. Typically, a simple word. Shouldn’t be used as an identifier.iconUrlrequiredDefines the URL to the app icon. It must be in PNG or ICO format. SVG icons are not supported. An 180x180 px PNG icon is optimal.termsOfUseUrloptionalOnly needed for apps to be featured in the wallet’s recommendation lists.privacyPolicyUrloptionalOnly needed for apps to be featured in the wallet’s recommendation lists. Here is a generic example of an app manifest: CopyAsk AI{ \"url\": \"<app-url>\", // required \"name\": \"<app-name>\", // required \"iconUrl\": \"<app-icon-url>\", // required \"termsOfUseUrl\": \"<terms-of-use-url>\", // optional \"privacyPolicyUrl\": \"<privacy-policy-url>\" // optional } For a web dApp, place its manifest at https://[myapp.com]/tonconnect-manifest.json so that wallets can fetch it with a simple GET request. Application manifest must be publicly available with CORS disabled, without any authorization required, and without a CloudFlare or similar service proxying them. If hosting that way is troublesome on your own, consider using a trusted CDN. ​Wallet manifest Wallet manifest is a JSON configuration that defines how your wallet interacts with the TON Connect. Here is an example of a custodian manifest: CopyAsk AI{ \"app_name\": \"[custodian]\", \"name\": \"[Custodian]\", \"image\": \"https://cdn.[custodian].com/ton-connect-icon.png\", \"about_url\": \"https://[custodian].com\", \"universal_url\": \"https://wallet.[custodian].com/ton-connect\", \"bridge\": [ { \"type\": \"sse\", \"url\": \"https://bridge.[custodian].com/bridge\" } ], \"platforms\": [\"ios\", \"android\", \"web\", \"windows\", \"macos\", \"linux\"], \"features\": [ { \"name\": \"SendTransaction\", \"maxMessages\": 4, \"extraCurrencySupported\": false } ] } There, the bridge refers to the way connectivity between the wallet and dApp is achieved. It can either be a JavaScript one, extending the window object, or an HTTP one, requiring a separate service to be running.For more details, see the respective reference section: WalletKit reference. ​Primary properties app_name: A unique identifier for the wallet. This string should be lowercase, without spaces or special characters. It will be used as an identifier in connection events and must match the ConnectEventSuccess.device.appName value. name: The display name of the wallet that will be shown to users in dApp interfaces. For your custodian, simply use “[Custodian]” or “[Custodian] Wallet” as appropriate. image: A URL pointing to the wallet’s icon. This should be a high-quality image with the following specifications: Resolution: 288×288 pixels Background: Non-transparent Corners: Non-rounded Format: PNG Examples: https://wallet.tg/images/logo-288.png https://tonkeeper.com/assets/tonconnect-icon.png ​Connection properties about_url: A URL to the wallet information or landing page. This helps new TON users learn about your wallet. universal_url: The base part of the wallet’s universal URL that will handle TON Connect parameters. This is a critical component for enabling connections via universal links. For your custodian, this could be something like https://wallet.[custodian].com/ton-connect. bridge: An array specifying connectivity options between dApps and the wallet. HTTP bridge setups should include: CopyAsk AI\"bridge\": [ { \"type\": \"sse\", \"url\": \"https://bridge.[custodian].com/bridge\" } ] There, url points to the publicly exposed bridge. JavaScript bridge setups should include: CopyAsk AI\"bridge\": [ { \"type\": \"js\", \"key\": \"[custodian]\" } ] In the above, key points to the property name within the window object on the same web page. ​Platform and feature support platforms: An array listing all platforms where the wallet is available. This can include any of the following values: \"ios\", \"android\", \"chrome\", \"firefox\", \"safari\", \"windows\", \"macos\", \"linux\", \"web\". Include only the platforms that you actually support. features: This section defines the capabilities of the wallet: CopyAsk AI\"features\": [ { \"name\": \"SendTransaction\", \"maxMessages\": 4, \"extraCurrencySupported\": false } ] name: Currently, only “SendTransaction” is defined in the protocol. maxMessages: The maximum number of messages the wallet can sign in a single transaction (4 is standard for many wallets). extraCurrencySupported: Whether the wallet supports additional currencies beyond TON. Set to false initially; you can update this later if you add support. Was this page helpful?YesNoSuggest editsRaise issuePreviousMessage lookupNext⌘IgithubxtelegramPowered by MintlifyOn this pageApp manifestWallet manifestPrimary propertiesConnection propertiesPlatform and feature support",
    "category": "integration",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "dapp",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:27:23.392Z"
  },
  {
    "id": "docs-ton-org--ecosystem-ton-connect-message-lookup",
    "title": "Message lookup",
    "url": "https://docs.ton.org/ecosystem/ton-connect/message-lookup",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectOverviewIntegrate a dAppIntegrate a walletManifestsMessage lookupWalletKitTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationTON ConnectMessage lookupEcosystemTON ConnectMessage lookupCopy pageCopy pageYou should never use external message tracking for payment processing purposes. Check out payment processing for more details. ​Introduction The process of seeking a transaction associated with an external-in message is called message lookup. It should only be used for better UX to display, for example, the progress of the operation and its result. ​Message normalization Normalization is a standardization process that converts different external-in message representations into a consistent format. This needs to be done because the structure of external-in messages allows the same message to be constructed in different forms, which results in different possible hashes for the same external message. To address this, the ecosystem defines a standard that ensures consistent hash calculation. The normalization rules are specified in detail in the TEP-467 proposal. Message lookup by its normalized hash is already implemented in most TON RPC providers. How normalization works: The normalized hash is computed by applying the following standardization rules to an external-in message: Source Address (src): set to addr_none$00 Import Fee (import_fee): set to 0 InitState (init): set to an empty value Body: always stored as a reference ​Transaction lookup using external message from TON Connect CopyAsk AI/** * Generates a normalized hash of an \"external-in\" message for comparison. * * This function ensures consistent hashing of external-in messages by following [TEP-467](https://github.com/ton-blockchain/TEPs/blob/8b3beda2d8611c90ec02a18bec946f5e33a80091/text/0467-normalized-message-hash.md): * * @param {Message} message - The message to be normalized and hashed. Must be of type `\"external-in\"`. * @returns {Buffer} The hash of the normalized message. * @throws {Error} if the message type is not `\"external-in\"`. */ export function getNormalizedExtMessageHash(message: Message) { if (message.info.type !== 'external-in') { throw new Error(`Message must be \"external-in\", got ${message.info.type}`); } const info = { ...message.info, src: undefined, importFee: 0n }; const normalizedMessage = { ...message, init: null, info: info, }; return beginCell() .store(storeMessage(normalizedMessage, { forceRef: true })) .endCell() .hash(); } ​Retrying API calls Sometimes API requests may fail due to rate limits or network issues. Use the retry function presented below to deal with api failures: CopyAsk AIexport async function retry<T>(fn: () => Promise<T>, options: { retries: number; delay: number }): Promise<T> { let lastError: Error | undefined; for (let i = 0; i < options.retries; i++) { try { return await fn(); } catch (e) { if (e instanceof Error) { lastError = e; } await new Promise((resolve) => setTimeout(resolve, options.delay)); } } throw lastError; } ​Find the transaction by incoming message The getTransactionByInMessage function searches the account’s transaction history for a match by normalized external message hash: CopyAsk AI/** * Tries to find transaction by ExternalInMessage */ async function getTransactionByInMessage( inMessageBoc: string, client: TonClient, ): Promise<Transaction | undefined> { // Step 1. Convert Base64 BoC to Message if input is a string const inMessage = loadMessage(Cell.fromBase64(inMessageBoc).beginParse()); // Step 2. Ensure the message is an external-in message if (inMessage.info.type !== 'external-in') { throw new Error(`Message must be \"external-in\", got ${inMessage.info.type}`); } const account = inMessage.info.dest; // Step 3. Compute the normalized hash of the input message const targetInMessageHash = getNormalizedExtMessageHash(inMessage); let lt: string | undefined = undefined; let hash: string | undefined = undefined; // Step 4. Paginate through the transaction history of the account while (true) { const transactions = await retry( () => client.getTransactions(account, { hash, lt, limit: 10, archival: true, }), { delay: 1000, retries: 3 }, ); if (transactions.length === 0) { // No more transactions found - message may not be processed yet return undefined; } // Step 5. Search for a transaction whose input message matches the normalized hash for (const transaction of transactions) { if (transaction.inMessage?.info.type !== 'external-in') { continue; } const inMessageHash = getNormalizedExtMessageHash(transaction.inMessage); if (inMessageHash.equals(targetInMessageHash)) { return transaction; } } const last = transactions.at(-1)!; lt = last.lt.toString(); hash = last.hash().toString('base64'); } } If found, it returns a Transaction object. Otherwise, it returns undefined. ​Example CopyAsk AIimport { TonClient } from '@ton/ton'; const client = new TonClient({ endpoint: 'https://toncenter.com/api/v2/jsonRPC' }); const tx = await getTransactionByInMessage( 'te6ccgEBAQEA...your-base64-message...', client ); if (tx) { console.log('Found transaction:', tx); } else { console.log('Transaction not found'); } ​Waiting for transaction confirmation If you’ve just sent a message, it may take a few seconds before it appears on-chain. The function waitForTransaction to poll the blockchain and wait for the corresponding transaction should be used in this case: CopyAsk AI/** * Waits for a transaction to appear on-chain by incoming external message. * * Useful when the message has just been sent. */ async function waitForTransaction( inMessageBoc: string, client: TonClient, retries: number = 10, timeout: number = 1000, ): Promise<Transaction | undefined> { const inMessage = loadMessage(Cell.fromBase64(inMessageBoc).beginParse()); if (inMessage.info.type !== 'external-in') { throw new Error(`Message must be \"external-in\", got ${inMessage.info.type}`); } const account = inMessage.info.dest; const targetInMessageHash = getNormalizedExtMessageHash(inMessage); let attempt = 0; while (attempt < retries) { console.log(`Waiting for transaction to appear in network. Attempt: ${attempt}`); const transactions = await retry( () => client.getTransactions(account, { limit: 10, archival: true, }), { delay: 1000, retries: 3 }, ); for (const transaction of transactions) { if (transaction.inMessage?.info.type !== 'external-in') { continue; } const inMessageHash = getNormalizedExtMessageHash(transaction.inMessage); if (inMessageHash.equals(targetInMessageHash)) { return transaction; } } await new Promise((resolve) => setTimeout(resolve, timeout)); } // Transaction was not found - message may not be processed return undefined; } ​Example CopyAsk AIimport { TonClient } from '@ton/ton'; const client = new TonClient({ endpoint: 'https://toncenter.com/api/v2/jsonRPC' }); const [tonConnectUI, setOptions] = useTonConnectUI(); // Obtain ExternalInMessage BoC const { boc } = await tonConnectUI.sendTransaction({ messages: [ { address: \"UQBSzBN6cnxDwDjn_IQXqgU8OJXUMcol9pxyL-yLkpKzYpKR\", amount: \"20000000\" } ] }); const tx = await waitForTransaction( boc, client, 10, // retries 1000, // timeout before each retry ); if (tx) { console.log('Found transaction:', tx); } else { console.log('Transaction not found'); } ​See also TEP-467: Normalized Message Hash Messages and transactions TON Connect: Sending messages Was this page helpful?YesNoSuggest editsRaise issuePreviousOverviewNext⌘IgithubxtelegramPowered by MintlifyOn this pageIntroductionMessage normalizationTransaction lookup using external message from TON ConnectRetrying API callsFind the transaction by incoming messageExampleWaiting for transaction confirmationExampleSee also",
    "category": "integration",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "dapp",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:27:25.376Z"
  },
  {
    "id": "docs-ton-org--ecosystem-ton-connect-walletkit-overview",
    "title": "WalletKit: TON Connect for custodial and non-custodial wallets",
    "url": "https://docs.ton.org/ecosystem/ton-connect/walletkit/overview",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectOverviewIntegrate a dAppIntegrate a walletManifestsMessage lookupWalletKitOverviewWebiOSAndroidIntegration QA guideNative and web walletsBrowser extensions and in-wallet browsersTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationWalletKitWalletKit: TON Connect for custodial and non-custodial walletsEcosystemTON ConnectWalletKitWalletKit: TON Connect for custodial and non-custodial walletsCopy pageCopy pageTON Connect WalletKit is an open-source SDK that helps integrate your custodial or non-custodial wallet with TON in a secure and streamlined fashion. It’s designed for institutions, non-custodians, and custodians that need full control over key management, signing, and access without compromising UX or compliance. ​Features Awaits a partial or full release of the WalletKit ​Use cases Awaits a partial or full release of the WalletKit ​Quick start First, follow this step-by-step guide: How to integrate a wallet with TON. Then, follow relevant usage recipes: WebInitialize the kitManage TON walletsHandle connectionsHandle other events ​See also Read more about the TON Connect itself: TON Connect overview. Skim the reference pages with more in-depth information: TON Connect manifests @tonconnect/protocol, external API reference Was this page helpful?YesNoSuggest editsRaise issuePreviousInitialize the kitNext⌘IgithubxtelegramPowered by MintlifyOn this pageFeaturesUse casesQuick startSee also",
    "category": "integration",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "dapp",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:27:27.580Z"
  },
  {
    "id": "docs-ton-org--ecosystem-ton-connect-walletkit-qa-guide",
    "title": "Integration QA guide",
    "url": "https://docs.ton.org/ecosystem/ton-connect/walletkit/qa-guide",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectOverviewIntegrate a dAppIntegrate a walletManifestsMessage lookupWalletKitOverviewWebiOSAndroidIntegration QA guideNative and web walletsBrowser extensions and in-wallet browsersTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationWalletKitIntegration QA guideEcosystemTON ConnectWalletKitIntegration QA guideCopy pageCopy pageThis document provides a complete guide for custodians integrating TON Connect - from understanding what to build to verifying your implementation works correctly. Understanding user experience standardsLearn what good integration looks likeDemo environment and testing platformusing TON Foundation’s testing infrastructureTesting your implementationverify your basic integration worksGo-live procedurewhat’s needed for production integrationsSupportget helpFAQfrequently asked questions ​Understanding user experience standards Before building your integration, experience TON Connect as a user to understand what good integration looks like and what your users will expect. ​Try these wallets first Use Tonkeeper or MyTonWallet to experience TON Connect. Both support mobile, desktop, and browser extensions. Wallet in Telegram demonstrates the UX for wallets implemented as Telegram Mini Apps. ​Basic flow experience Open the React Demo dApp and connect one of these wallets. Notice how the connection works — desktop to mobile uses QR codes, mobile browser to wallet clicks directly, browser extensions connect instantly, and in-wallet browsers connect with one click. After connecting, try sending a basic transaction and test signing features like “Sign Text”. Pay attention to how transaction details are displayed, how approval works, and how errors are handled. This is the standard your users will expect from your wallet. ​Demo environment and testing platform TON Foundation provides demo dApps and a comprehensive testing platform with all necessary test scenarios. You don’t need to create your own test cases — everything is already prepared. ​Demo dApps We have a dApp for TON Connect testing, which is used in most test cases. In our testing platform, it is called GENERAL. Additionally, there are several demo dApps used for testing specific scenarios. In our testing platform, it is called CUSTOM. Keep in mind that each test case has a Description field indicating which dApp to use: GENERAL or CUSTOM. ​Testing platform Our testing platform, Allure TestOps, contains manual test scenarios you execute yourself. Navigate to test suites matching your wallet’s platforms and run each test case manually. Observe all test scenarios via this link with these credentials: Login: guest Password: Test123! #Test suiteCoverage1Common ChecksPR formatting, manifest validation, platform installation2Connection and Transaction SendingCore functionality across platforms and dApps3Disconnection TestingSession termination scenarios4Transaction Data ValidationWallet-side security checks5Max MessagesBatch transaction handling6App Domain ValidationSecurity testing for TON Proof wallets7Extra Currency SupportAdvanced currency features8Merkle Proof/UpdateAdvanced cryptographic operations9Sign dataCustom payload signing Each test case shows: Description: Which dApp to use GENERAL or CUSTOM along with its URL. Preconditions: What setup is needed before starting. Scenario: Manual actions to perform. Expected results: What should happen if your integration works correctly. For transaction tests, use the provided JSON configurations in the demo dApp’s editable transaction interface. Execute all test cases in sequence and fix any issues found in your integration. ​Testing your implementation After building your integration, verify that it works with a basic connection test. ​Basic connection test Open the React Demo dApp Click “Connect Wallet” to see the connection modal Choose connection method: Scan universal QR code: Use your mobile wallet to scan the QR code (works with any TON Connect wallet) Find your wallet in the testing wallets list and click it for direct connection Complete the connection based on your wallet type (extension, mobile app, or web wallet) Try sending a simple transaction to confirm full functionality If this works, your basic integration is successful, and you can start using our testing platform suites. If your wallet doesn’t appear in the list or the connection fails, revisit the technical implementation guides. ​Go-live procedure ​Wallet submission Submit a pull request to the wallet-list repository with your wallet manifest, which was tested with the testing platform. ​Audit process Once your team has opened a pull request to add the wallet to the official wallets-list repository on GitHub, please advise your BizDev liaison so an audit slot can be scheduled. A typical review cycle lasts three to five business days. During this period, TON Foundation engineers verify the TON Connect integration, assessing connection flows, transaction signing, security controls, error handling, and overall user experience across every supported platform. At the end of each iteration, you will receive a written report that summarizes the test results. After you supply an updated build and a brief changelog, the engineering team performs a re-test under the same three-to-five-day service level. ​Release When the audit is approved, the pull request moves to the maintainers’ queue for a final repository review. This check — focused on completeness of metadata and technical compliance — normally takes one business day. Once the pull request is merged, your wallet becomes discoverable to TON ecosystem dApps. Please keep the manifest endpoint continuously available and update the repository entry whenever you release significant changes to the wallet. ​Support TON Foundation’s engineering team is available throughout the entire integration lifecycle – from design review to pre-production validation – to surface issues early and help you reach production smoothly. When you request support, please include the following information so we can diagnose and resolve issues quickly: Wallet platform and version: e.g., macOS 15.3.2, Chrome 137.0.7151.69, wallet version 1.2.3 Issue summary: Brief description of the problem or the attached URL to the corresponding Allure scenario, if available, along with any questions related to it. Reproduction steps: Clear, step-by-step instructions (or sample requests/transactions) that consistently trigger the issue. Providing this information up front enables faster triage, targeted guidance, and efficient re-testing once fixes are applied. ​FAQ ​How long does the process take? With collaborative development and continuous testing support, we expect 1-2 weeks for wallet listing. (General self-submitted wallets typically take 4-8 weeks.) ​What platforms should we support? Any platforms that fit your business needs — mobile, desktop, browser extensions, or web. ​Is TON Proof required? Yes — TON Proof is a required feature for wallet integration. ​What if we fail test scenarios? Work with TON Foundation during the audit to determine if issues are critical or acceptable. ​Can we update during the audit? Yes, notify the audit team of significant changes.Was this page helpful?YesNoSuggest editsRaise issuePreviousNative and web walletsNext⌘IgithubxtelegramPowered by MintlifyOn this pageUnderstanding user experience standardsTry these wallets firstBasic flow experienceDemo environment and testing platformDemo dAppsTesting platformTesting your implementationBasic connection testGo-live procedureWallet submissionAudit processReleaseSupportFAQHow long does the process take?What platforms should we support?Is TON Proof required?What if we fail test scenarios?Can we update during the audit?",
    "category": "integration",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "dapp",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "react",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:27:29.727Z"
  },
  {
    "id": "docs-ton-org--ecosystem-ton-connect-walletkit-native-web",
    "title": "Custodian integration for native and web wallets",
    "url": "https://docs.ton.org/ecosystem/ton-connect/walletkit/native-web",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectOverviewIntegrate a dAppIntegrate a walletManifestsMessage lookupWalletKitOverviewWebiOSAndroidIntegration QA guideNative and web walletsBrowser extensions and in-wallet browsersTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationWalletKitCustodian integration for native and web walletsEcosystemTON ConnectWalletKitCustodian integration for native and web walletsCopy pageCopy pageThis document provides instructions for integrating TON Connect into wallets and other custodian services for iOS, Android, macOS, Windows, Linux, and Web platforms. TON Connect is the standard wallet connection protocol for The Open Network (TON) blockchain, similar to WalletConnect on Ethereum. It enables secure communication between wallets and decentralized applications, allowing users to authorize transactions while maintaining control of their private keys. More about TON Connectoverview of the protocol and its role in the TON ecosystemWallet manifestwhat is the manifest and how to prepare itBridgewhat is the bridge service and how to set it upProtocolwhat is the protocol and how to implement itSigningsigning processes and reference implementationsSupporthow to get help and schedule technical consultationsFAQfrequently asked questions about TON Connect implementationSee alsoadditional links and references ​TON Connect bridge The TON Connect bridge serves as a transport mechanism for delivering messages between applications (dApps) and wallets. It enables end-to-end encrypted communication where neither party needs to be online simultaneously. ​Setup options ​Option 1: On-premise solution Custodians can run the TON Connect Bridge themselves. This approach provides full control over the infrastructure and data. For this option, you can deploy the official TON Connect Bridge implementation. You will need to: Set up a dedicated bridge instance following the repository documentation Create a DNS entry pointing to your bridge Configure your infrastructure (load balancers, SSL certificates, etc.) Maintain the bridge and provide updates ​Option 2: SaaS solution TON Foundation can provide a Software-as-a-Service (SaaS) solution for custodians who prefer not to maintain on-premise infrastructure. To request access to the SaaS solution, contact the TON Foundation business development team. This managed service includes: Hosted bridge infrastructure Maintenance and updates Technical support Service level agreements ​Bridge endpoints and protocol The TON Connect Bridge protocol uses these main endpoints: SSE Events Channel — For receiving messages: CopyAsk AIGET /events?client_id=<to_hex_str(A1)>,<to_hex_str(A2)>,<to_hex_str(A3)>&last_event_id=<lastEventId> Accept: text/event-stream Message Sending — For sending messages: CopyAsk AIPOST /message?client_id=<sender_id>&to=<recipient_id>&ttl=300 body: <base64_encoded_message> There, client_id and sender_id are the public keys of the wallet’s session in hex. To read more about the bridge protocol, please refer to the TON Connect Bridge documentation. ​TON Connect protocol TON Connect enables communication between wallets and dApps. For custodian wallets, the integration has these core components: Establishing secure sessions with dApps Handling universal links in the browser Managing wallet connections Listening for messages from connected dApps Disconnecting from dApps ​Setting up the protocol We recommend using the @tonconnect/protocol package to handle the TON Connect protocol. But you can also implement the protocol manually. CopyAsk AInpm install @tonconnect/protocol Refer to the @tonconnect/protocol documentation for more details. ​Session management and encryption The foundation of TON Connect is secure communication using the SessionCrypto class: CopyAsk AIimport { SessionCrypto, KeyPair, AppRequest, Base64 } from '@tonconnect/protocol'; // Receive dApp public key from the connection link 'id' parameter // This value is decoded from hex to Uint8Array const dAppPublicKey: Uint8Array = hexToByteArray(dAppClientId); // Create a new session - this generates a keypair for the session internally const sessionCrypto: SessionCrypto = new SessionCrypto(); // Encrypt a message to send to the dApp // Parameters: // - message: The string message to encrypt // - dAppPublicKey: The dApp's public key as Uint8Array const message: string = JSON.stringify({ event: 'connect', payload: { /* connection details */ } }); const encryptedMessage: string = sessionCrypto.encrypt( message, dAppPublicKey ); // Decrypt a message from the dApp // Parameters: // - encrypted: The encrypted message string from the dApp // - dAppPublicKey: The dApp's public key as Uint8Array const encrypted: string = 'encrypted_message_from_dapp'; const decryptedMessage: string = sessionCrypto.decrypt( Base64.decode(encrypted).toUint8Array(), dAppPublicKey ); const parsedMessage: AppRequest = JSON.parse(decryptedMessage); // Get session keys for storage // Returns an object with `publicKey` and `secretKey` as hex strings const keyPair: KeyPair = sessionCrypto.stringifyKeypair(); // Store these securely in your persistent storage const storedData = { secretKey: keyPair.secretKey, publicKey: keyPair.publicKey, dAppClientId: dAppClientId }; // Later - restore the session using stored keys // Parameters: // - secretKey: Hex string of the secret key // - publicKey: Hex string of the public key const restoredSessionCrypto: SessionCrypto = new SessionCrypto({ secretKey: storedData.secretKey, publicKey: storedData.publicKey }); See all 52 lines Refer to the SessionCrypto implementation and Session documentation for more details. ​Bridge communication TON Connect uses a bridge service as a relay for messages between dApps and wallets: CopyAsk AI// Bridge URL for your wallet const bridgeUrl = 'https://bridge.[custodian].com/bridge'; // Sending messages to the bridge // Parameters: // - fromClientId: Your wallet's client ID (public key of the wallet's session in hex) // - toClientId: The dApp's client ID (public key of the dApp's session in hex) // - encryptedMessage: The encrypted message to send // - ttl: Time to live in seconds (optional, default is 300 seconds) async function sendToBridge(fromClientId: string, toClientId: string, encryptedMessage: string) { await fetch(`${bridgeUrl}/message`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ client_id: fromClientId, to: toClientId, message: encryptedMessage, ttl: 300 }) }); } // Listening for messages from the bridge // Parameters: // - clientId: Your wallet's client ID (public key of the wallet's session in hex) // - lastEventId: The last event ID received from the bridge (optional, but should be used if you want to resume listening for messages from the same point) function listenFromBridge(clientId: string, lastEventId?: string) { const url = lastEventId ? `${bridgeUrl}/events?client_id=${clientId}&last_event_id=${lastEventId}` : `${bridgeUrl}/events?client_id=${clientId}`; return new EventSource(url); } See all 33 lines Refer to the bridge API documentation for more details. ​Handling TON Connect links for new connections When a user opens a connection link in your browser wallet, this flow begins: CopyAsk AI// This code runs when a URL like this is opened: // https://wallet.[custodian].com/ton-connect?v=2&id=<client_id>&r=<connect_request>&ret=<return_strategy> // Parameters in the URL: // - v: Protocol version (2) // - id: The dApp's client ID (hex-encoded public key of the dApp's session) // - r: URL-encoded connect request object // - ret: Return strategy for the dApp (may be ignored for custodian) import { ConnectRequest, ConnectEventSuccess, SessionCrypto, KeyPair, ConnectManifest, TonAddressItem, TonProofItem, CHAIN, Base64 } from '@tonconnect/protocol'; window.addEventListener('load', async () => { if (window.location.pathname === '/ton-connect') { try { // 1. Parse the connection parameters from the URL const parsedUrl: URL = new URL(window.location.href); const searchParams: URLSearchParams = parsedUrl.searchParams; const version: string | null = searchParams.get('v'); const dAppClientId: string | null = searchParams.get('id'); const requestEncoded: string | null = searchParams.get('r'); if (!version || !dAppClientId || !requestEncoded) { console.error('Invalid TON Connect URL: missing required parameters'); return; } // Decode and parse the request const request: ConnectRequest = JSON.parse(decodeURIComponent(requestEncoded)); // Check if the ton_addr is requested in the connection request, if not, throw an error const tonAddrItemRequest: TonAddressItem | null = request.items.find(p => p.name === 'ton_addr') ?? null; if (!tonAddrItemRequest) { console.error(\"`ton_addr` item is required in the connection request\"); return; } // Check if the ton_proof is requested in the connection request, optional const tonProofItemRequest: TonProofItem | nu",
    "category": "integration",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "dapp",
      "api",
      "sdk",
      "testnet",
      "mainnet",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:27:32.290Z"
  },
  {
    "id": "docs-ton-org--ecosystem-ton-connect-walletkit-browser-extension",
    "title": "Custodian integration for in-wallet browsers and browser extensions",
    "url": "https://docs.ton.org/ecosystem/ton-connect/walletkit/browser-extension",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectOverviewIntegrate a dAppIntegrate a walletManifestsMessage lookupWalletKitOverviewWebiOSAndroidIntegration QA guideNative and web walletsBrowser extensions and in-wallet browsersTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationWalletKitCustodian integration for in-wallet browsers and browser extensionsEcosystemTON ConnectWalletKitCustodian integration for in-wallet browsers and browser extensionsCopy pageCopy pageThis document provides instructions for integrating TON Connect into wallets and other custodian services in browser extensions and in-wallet browsers. TON Connect is the standard wallet connection protocol for The Open Network (TON) blockchain, similar to WalletConnect on Ethereum. It enables secure communication between wallets and decentralized applications, allowing users to authorize transactions while maintaining control of their private keys. More about TON Connectoverview of the protocol and its role in the TON ecosystemWallet manifestwhat is the manifest and how to prepare itBridgewhat is the JavaScript bridge and how to use itProtocolwhat is the protocol and how to implement itSigningsigning processes and reference implementationsSupporthow to get help and schedule technical consultationsFAQfrequently asked questions about TON Connect implementationSee alsoadditional links and references ​TON Connect bridge A TON Connect bridge acts as a communication layer between decentralized applications (dApps) and wallets. The wallet extension should expose the bridge using the window.[custodian].tonconnect property. This bridge must implement a defined interface, allowing dApps to call its methods and receive appropriate responses from the wallet. CopyAsk AIinterface TonConnectBridge { deviceInfo: DeviceInfo; // see Requests/Responses spec walletInfo?: WalletInfo; protocolVersion: number; // max supported Ton Connect version (e.g. 2) isWalletBrowser: boolean; // if the page is opened into wallet's browser connect(protocolVersion: number, message: ConnectRequest): Promise<ConnectEvent>; restoreConnection(): Promise<ConnectEvent>; send(message: AppRequest): Promise<WalletResponse>; listen(callback: (event: WalletEvent) => void): () => void; } To read more about the bridge protocol, please refer to the TON Connect Bridge documentation. ​TON Connect protocol TON Connect enables communication between wallets and dApps. For custodian wallets, the integration has these core components: Managing wallet connections Listening for messages from connected dApps Disconnecting from dApps ​Setting up the protocol We recommend using the @tonconnect/protocol package to handle the TON Connect protocol. But you can also implement the protocol manually. CopyAsk AInpm install @tonconnect/protocol Refer to the @tonconnect/protocol documentation for more details. ​Interacting with the dApp To interact with the dApp wallet, implement the TonConnectBridge interface and inject it into the window.[custodian].tonconnect property. Below is the sample implementation of the protocol: CopyAsk AIimport { AppRequest, CHAIN, CONNECT_EVENT_ERROR_CODES, ConnectEvent, ConnectEventSuccess, ConnectManifest, ConnectRequest, DeviceInfo, RpcMethod, SendTransactionRpcRequest, SendTransactionRpcResponseError, SendTransactionRpcResponseSuccess, TonAddressItem, TonProofItem, WalletEvent, WalletResponse, } from '@tonconnect/protocol'; export type TonConnectCallback = (event: WalletEvent | DisconnectEvent) => void; // https://github.com/ton-connect/sdk/blob/main/packages/sdk/src/provider/injected/models/injected-wallet-api.ts export interface TonConnectBridge { deviceInfo: DeviceInfo; // see Requests/Responses spec walletInfo?: WalletInfo; protocolVersion: number; // max supported Ton Connect version (e.g. 2) isWalletBrowser: boolean; // if the page is opened into the wallet's browser connect( protocolVersion: number, message: ConnectRequest, ): Promise<ConnectEvent>; restoreConnection(): Promise<ConnectEvent>; send<T extends RpcMethod>(message: AppRequest<T>): Promise<WalletResponse<T>>; listen(callback: TonConnectCallback): () => void; } export interface DisconnectEvent { event: 'disconnect'; id: number | string; payload: Record<string, never>; } export interface WalletInfo { name: string; image: string; // <png image url> tondns?: string; about_url: string; } // Instance of this class should be injected into the window.[custodian].tonconnect property. export class JsBridge implements TonConnectBridge { deviceInfo: DeviceInfo = { platform: 'browser', appName: '[custodian]', // Must match your manifest app_name appVersion: '1.0.0', // Your wallet version maxProtocolVersion: 2, // TON Connect protocol version, currently 2 features: [ 'SendTransaction', // Keep 'SendTransaction' as string for backward compatibility { // And pass the object of 'SendTransaction' feature name: 'SendTransaction', maxMessages: 4, extraCurrencySupported: false } ] }; isWalletBrowser: boolean = true; protocolVersion: number = 2; walletInfo: WalletInfo = { name: 'walletName', about_url: 'about.com', image: 'image.png', }; // Refer to https://github.com/ton-blockchain/ton-connect/blob/main/requests-responses.md#initiating-connection documentation for more details. async connect(protocolVersion: number, request: ConnectRequest): Promise<ConnectEvent> { if (protocolVersion > this.protocolVersion) { throw new Error('Invalid TON Connect URL'); } // Check if the ton_addr is requested in the connection request, if not, throw an error const tonAddrItemRequest: TonAddressItem | null = request.items.find(p => p.name === 'ton_addr') ?? null; if (!tonAddrItemRequest) { throw new Error(\"`ton_addr` item is required in the connection request\"); } // Check if the ton_proof is requested in the connection request, optional const tonProofItemRequest: TonProofItem | null = request.items.find(p => p.name === 'ton_proof') ?? null; // Load app manifest const manifestUrl: string = request.manifestUrl; // app manifest url const manifest: ConnectManifest = await fetch(manifestUrl).then(res => res.json()); if (!manifest) { throw new Error(\"Failed to load app manifest\"); } // 2. Show the connection approval dialog to the user const userApproved = await confirm(`Allow ${request.manifestUrl} to connect to your wallet?`); if (!userApproved) { // User rejected the connection throw new Error('User rejected connection'); // } // 3. Get the user's wallet data from the custodian API const walletAddress = '0:9C60B85...57805AC'; // Replace with actual address from custodian API const walletPublicKey = 'ADA60BC...1B56B86'; // Replace with actual wallet's public key from custodian API const walletStateInit = 'te6cckEBBAEA...PsAlxCarA=='; // Replace with actual wallet's `StateInit` from custodian API // 4. Create the connect event return { event: 'connect', id: 0, // The id field is 0 for connect events payload: { items: [ { name: 'ton_addr', address: walletAddress, network: CHAIN.MAINNET, publicKey: walletPublicKey, walletStateInit: walletStateInit } // If ton_proof was requested in the connection request, include it here: // Note: how to get the proof is described in a separate section // { // name: 'ton_proof', // proof: { // // Signed proof data // } // } ], device: this.deviceInfo } }; } private listeners: TonConnectCallback[] = []; listen(callback: TonConnectCallback): () => void { this.listeners.push(callback); return () => { this.listeners = this.listeners.filter(listener => listener !== callback); } } // Function to disconnect from a dApp // Refer to the https://github.com/ton-blockchain/ton-connect/blob/main/requests-responses.md#wallet-events documentation for more details. async disconnectFromDApp() { // Create a disconnect event // The id field should be incremented for each sent message const disconnectEvent = { event: 'disconnect', id: nextEventId++, payload: { reason: 'user_disconnected' } } as const; this.listeners.map(listener => listener(disconnectEvent)); } async restoreConnection(): Promise<ConnectEvent> { // 1. Get the user's wallet data from custodian API const walletAddress = '0:9C60B85...57805AC'; // Replace with actual address from custodian API const walletPublicKey = 'ADA60BC...1B56B86'; // Replace with actual wallet's public key from custodian API const walletStateInit = 'te6cckEBBAEA...PsAlxCarA=='; // Replace with actual wallet's `StateInit` from custodian API // 2. Create the connect event return { event: 'connect', id: 0, // The id field is 0 for connect events payload: { items: [ { name: 'ton_addr', address: walletAddress, network: CHAIN.MAINNET, publicKey: walletPublicKey, walletStateInit: walletStateInit } // If ton_proof was requested in the connection request, include it here: // Note: how to get the proof is described in a separate section // { // name: 'ton_proof', // proof: { // // Signed proof data // } // } ], device: this.deviceInfo } }; } // Handle messages from dApp",
    "category": "integration",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "dapp",
      "api",
      "sdk",
      "testnet",
      "mainnet",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:27:35.618Z"
  },
  {
    "id": "docs-ton-org--ecosystem-node-setup-mytonctrl",
    "title": "Run a node with MyTonCtrl",
    "url": "https://docs.ton.org/ecosystem/node/setup-mytonctrl",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeOverviewRun a node with MyTonCtrlRun a validatorIntegrate MyTonCtrl with PrometheusSetting up a local blockchain using MyLocalTonMyTonCtrl referenceStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationBlockchain nodeRun a node with MyTonCtrlEcosystemBlockchain nodeRun a node with MyTonCtrlCopy pageProvision hardware, install MyTonCtrl, and follow runbooks for validator, liteserver, or archive roles.Copy pageHandle validator keys like production secrets.Keep recovery phrases offline, restrict shell access, and rehearse new procedures on testnet before touching wallets that hold real stake. ​Plan the environment ​Supported operating systems MyTonCtrl is tested on the following distributions (choose one and keep it up to date): Ubuntu 22.04 LTS or 24.04 LTS Debian 11 or 12 Always create and use a non-root operator with sudo access—running MyTonCtrl as root leads to subtle permission failures later on. ​Hardware sizing by role RoleCPURAMStorageNetworkTrafficNotesFull/validator node16 dedicated cores (32 threads preferred)128 GB≥1 TB NVMe SSD or provisioned 64k+ IOPS≥1 Gbps up/down64 TB/month typical (peaks ~100 TB)Leave headroom for elections and snapshots.Liteserver16 cores128 GB≥1 TB NVMe SSD≥1 Gbps~16 TB/month peaksHetzner/OVH are acceptable for liteservers (not for validators).Archive liteserver16 cores128 GB≥12 TB NVMe or ZFS pool with compression≥1 Gbps≥16 TB/monthPlan for continuous growth; monitor ZFS capacity. Disk latency is the common bottleneck. Benchmark storage before going live (MyTonCtrl> benchmark). ​Network and ports Obtain a static public IPv4 address for each node. Forward a single UDP port (default 30303) from the internet to the node and leave all outbound ports open. Verify exposure with netstat -tulpn and third-party scanners. Update cloud security groups or on-prem firewalls after installation—use MyTonCtrl> about validator / about liteserver to confirm the chosen port. ​Recommended providers The TON Foundation validates the following instances for validator-class workloads: Cloud ProviderInstance TypeCPURAMStorageNetworkPublic IPTrafficGCPn2-standard-1632 vCPUs128 GB1 TB NVMe SSD16 GbpsStatic external IP64 TB/monthAlibaba Cloudecs.g6.4xlarge32 vCPUs128 GB1 TB NVMe SSDUp to 10 GbpsElastic IP64 TB/monthTencent CloudM5.4XLARGE32 vCPUs128 GB1 TB NVMe SSDUp to 10 GbpsElastic IP64 TB/monthVultrBare metal Intel E-2388G16C/32T128 GB1.92 TB NVMe SSD10 GbpsFixed64 TB/monthDigitalOceanGeneral purpose premium Intel32 vCPUs128 GB1 TB NVMe SSD10 GbpsFixed64 TB/monthLatitudec3.medium.x8616C/32T128 GB1.9 TB NVMe SSD10 GbpsFixed64 TB/monthAWSi4i.8xlarge32 vCPUs256 GB2×3.75 TB Nitro SSDUp to 25 GbpsElastic IP64 TB/month ​Prepare the operator account If you still need a dedicated operator, create and switch to it before installing MyTonCtrl: CopyAsk AIsudo adduser <USERNAME> sudo usermod -aG sudo <USERNAME> # reconnect as the new user ssh <USERNAME>@<SERVER_IP> ​Install MyTonCtrl Run the installer from the operator account with sudo so it can create system users and services: CopyAsk AIsudo apt update sudo apt install -y curl wget git ca-certificates python3-pip wget https://raw.githubusercontent.com/ton-blockchain/mytonctrl/master/scripts/install.sh sudo bash install.sh -d The interactive wizard walks through: Selecting mainnet vs. testnet (or supplying a custom global.config.json). Choosing the initial mode (validator or liteserver). Optionally downloading blockchain dumps via TON Storage (recommended for archive builds). Whether to run post-download tasks in the background (useful when pulling large dumps). Refer to the MyTonCtrl overview for installer flags and environment variables when you need unattended deployments. ​Verify services and synchronization CopyAsk AImytonctrl MyTonCtrl> status MyTonCtrl> status_fast MyTonCtrl> status_modes status shows the long-form report, including Local validator initial sync status—wait for it to read synchronized before switching roles. status_fast prints live metrics such as timeDiff and Local validator out of sync; both should trend toward zero on a healthy node. status_modes confirms which modes are currently enabled. After installation, verify ownership so MyTonCtrl and validator processes can access state and keys: CopyAsk AIsudo chown -R validator:validator /var/ton-work/db sudo chown -R <install_user>:<install_user> /var/ton-work/keys ​Baseline maintenance tasks MyTonCtrl> create_backup and restore_backup safeguard your configs and keys—run before upgrades and after major changes. MyTonCtrl> set sendTelemetry true sends telemetry to the MyTonCtrl developers so they can surface TON status alerts and diagnose emerging issues. MyTonCtrl> update followed by upgrade applies MyTonCtrl and binary updates; schedule regular maintenance windows. MyTonCtrl> settings_status reviews every setting, its owner mode, and the current value. Use tail -F /var/ton-work/log* and journalctl -u validator -f during troubleshooting; reduce verbosity again if you temporarily ran installer set_node_argument --verbosity 3. ​Validator quickstart You need: a fully synchronized node, validator mode not active elsewhere, and at least the current minimum stake (approximately 300,000 TON; check tonscan.com/validation for live numbers). ​Prepare the validator wallet (one-time) List existing wallets: MyTonCtrl> wl. The installer usually creates validator_wallet_001. If you need a dedicated wallet, create one (example): CopyAsk AIMyTonCtrl> nw 0 validator_wallet v3 1001 Fund the wallet, inspect recent activity with vas <wallet_name>, then activate it: CopyAsk AIMyTonCtrl> aw validator_wallet Tell MyTonCtrl which wallet to use for elections: CopyAsk AIMyTonCtrl> set validatorWalletName \"validator_wallet\" MyTonCtrl> get validatorWalletName Export and store the private key offline: MyTonCtrl> ew validator_wallet. Need more wallet operations? See the wallet command reference. ​Enable validator mode Disable conflicting roles (liteserver cannot run alongside validator) and switch modes: CopyAsk AIMyTonCtrl> disable_mode liteserver MyTonCtrl> enable_mode validator MyTonCtrl> status_modes MyTonCtrl> about validator Confirm that validator shows as enabled and note the advertised ADNL port for firewall rules. ​Configure staking policy Assign either a fixed stake or a percentage of wallet balance: CopyAsk AIMyTonCtrl> set stake 500000 # or MyTonCtrl> set stakePercent 99 get stake / get stakePercent display the stored values; adjust before each election window if your balance changes. ​Election routine Use the same sequence every election cycle (automate with cron if desired): CopyAsk AIMyTonCtrl> status_fast MyTonCtrl> ve MyTonCtrl> check_ef Wait until Local validator out of sync is below 20 before running ve. ve submits election messages, check_ef reports the previous and current round efficiency. MyTonCtrl automatically splits balances into two stakes when the Elector accepts your bid; withdrawals become available in the following election per protocol rules. ​Operational discipline Track network announcements via @tonstatus and enable notifications. Keep hardware aligned with the minimum system requirements; upgrade storage promptly if metrics show saturation. Leave telemetry enabled (set sendTelemetry true) so telemetry continues reaching the MyTonCtrl developers and they can warn the community about issues. Monitor RAM, disk, CPU, and bandwidth dashboards. Contact @mytonctrl_help_bot if metrics or efficiency drop below target. Re-run check_ef or consult the efficiency API when diagnosing performance. ​Liteserver quickstart You need: a synchronized full node with validator mode disabled (liteserver cannot run alongside validator on the same machine). ​Activate liteserver services CopyAsk AIMyTonCtrl> enable_mode liteserver MyTonCtrl> status_modes ​Configure endpoints and proxies CopyAsk AIMyTonCtrl> installer Installer> enable LS Installer> plsc Installer> exit enable LS deploys the liteserver daemon. plsc prints the client bundle—share it with /var/ton-work/keys/liteserver.pub so lite-clients can connect. Regenerate configs at any time with installer clcf. ​Open the liteserver port Check the port in /var/ton-work/db/config.json (within the liteservers array). Update security groups or configure ufw on bare-metal hosts: CopyAsk AIsudo apt install -y ufw sudo ufw allow ssh sudo ufw allow <port> sudo ufw enable sudo ufw status Confirm connectivity by initializing a lite-client using the generated config. ​Ongoing care Monitor netLoadAvg and CPU via status_fast; scale hardware before saturation. Export create_backup after any config change so you can rapidly rebuild liteserver hosts. Keep ports private—front them with VPNs or proxies when exposing to public users. ​Archive liteserver quickstart You need: liteserver mode enabled, ≥12 TB of fast storage, and ZFS installed for handling compressed dumps. ​Pre",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "testnet",
      "mainnet",
      "transaction",
      "deployment",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "python",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:27:36.935Z"
  },
  {
    "id": "docs-ton-org--ecosystem-node-run-validator",
    "title": "Run a validator",
    "url": "https://docs.ton.org/ecosystem/node/run-validator",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeOverviewRun a node with MyTonCtrlRun a validatorIntegrate MyTonCtrl with PrometheusSetting up a local blockchain using MyLocalTonMyTonCtrl referenceStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationBlockchain nodeRun a validatorEcosystemBlockchain nodeRun a validatorCopy pageRun a validator node with MyTonCtrlCopy page​Overview This guide explains how to run a validator TON node with MyTonCtrl from scratch. ​Step 1: Prepare environment ​1.1 Maintain costs and expenses 200 TON per month on the validator hot wallet for its operational transactions. Validator deposit stake 700 000 TON ~ 4 000 000 TON. 100 TB/month traffic at a peak load. ​1.2 Minimal hardware requirements 16-core CPU 128 GB RAM 1 TB NVMe SSD or provisioned 64+k IOPS storage 1 Gbit/s network connectivity Public IP address (fixed IP address) A 1 Gbit/s network connection is recommended to ensure reliable performance during peak load conditions. The average expected bandwidth usage is approximately 100 Mbit/s. Validators must carefully consider IOPS disk requirements, as insufficient storage performance can severely impact validator stability and overall network health. ​1.3 Software requirements Ubuntu 22.04 LTS or 24.04 LTS Python 3.10 or higher Clang 16.0.0 or higher CopyAsk AI#check ubuntu version cat /etc/os-release CopyAsk AI#check python version python3 --version CopyAsk AI#check clang version clang --version Update Clang...CopyAsk AI# Check clang version clang --version # If version 16, skip the steps below. # Required for 22.04. Update current clang to clang-16 sudo apt install lsb-release wget software-properties-common gnupg sudo wget -O - https://apt.llvm.org/llvm-snapshot.gpg.key|sudo apt-key add - wget https://apt.llvm.org/llvm.sh chmod +x llvm.sh sudo ./llvm.sh 16 clang # change default clang sudo update-alternatives --install /usr/bin/clang clang /usr/bin/clang-16 100 sudo update-alternatives --install /usr/bin/clang++ clang++ /usr/bin/clang++-16 100 # Reqiured for Ubuntu 24.04. Install clang-16 sudo apt install clang-16 ​1.4 Port forwarding for validator Configure the network on the server according to the following: All outgoing connections are allowed. A static external IP address. One UDP port open for incoming connections. ​1.5 Follow network announcements Subscribe and follow the instructions provided for validators with Telegram channels. Do not ignore announcements for TON Testnet; validators that violate the maintenance rules are fined and excluded from the network. ChannelNetwork@tonstatusTON Mainnet@testnetstatusTON Testnet ​1.6 Prepare validator user Prepare and log in a user for the validator. Create a non-root user CopyAsk AI# Create a non-root validator user sudo adduser <USERNAME> sudo usermod -aG sudo <USERNAME> Switch to it by reconnecting to the server via ssh CopyAsk AI#reconnect as the new user exit ssh <USERNAME>@<SERVER_IP> ​Step 2: Validator node installation ​2.1 Download validator installer (MyTonCtrl) Run: CopyAsk AIwget https://raw.githubusercontent.com/ton-blockchain/mytonctrl/master/scripts/install.sh ​2.2 Run validator installation Run the validator installation. Installation takes approximately 20 minutes: CopyAsk AI#install validator for Mainnet sudo bash install.sh -m single-nominator -n mainnet Install validator for TestnetCopyAsk AI#install validator for Testnet sudo bash install.sh -m single-nominator -n testnet ​2.3 Verify status results Launch MyTonCtrl with the command mytonctrl. Then, check synchronization using the status command: CopyAsk AImytonctrl MyTonCtrl> status Initially, the status shows “Local validator initial sync status: downloading blockchain state x”, which indicates that the node has started synchronization. There are also other status messages in the very beginning of the synchronization, such as “starting”, “init block seqno”, “last key block is x”, “downloading all shard states”, “mc seqno” - all these statuses are fine. ​2.4 Verify validator’s port Print engine.addr port configuration config.json file: CopyAsk AIgrep -A5 '\"addrs\"' -n /var/ton-work/db/config.json | grep '\"port\"' | head -1 ​2.5 Check validator’s port Make sure UDP engine.addr port is allowed with the following command: CopyAsk AIsudo ufw status If the port is filtered (absent in allowed), open this port: CopyAsk AIsudo ufw allow <PORT_NUMBER>/udp Then make sure with sudo ufw status. ​2.6 Verify node synchronization Wait until the node is fully synchronized, which takes approximately 3 hours (depending on the network connection). Check the field Local validator initial sync status: x, the value x should become less than 20. Set up alert bot to receive a notification when the node is synchronized. ​Step 3: Configure validator When installing, MyTonCtrl automatically creates a validator wallet. Top up and activate (deploy) this wallet so MyTonCtrl can operate the single nominator pool smart contract with it. ​3.1 Get validator wallet address CopyAsk AIMyTonCtrl> wl Find the wallet named validator_wallet_001 and its address. ​3.2 Back-up validator wallet secret key This private key is required to restore access to the funds stored in the validator wallet. It is not involved in managing rewards or staking. Make a backup of the validator wallet secret key: CopyAsk AIMyTonCtrl> ew validator_wallet_001 Import this secret key with iw command. ​3.3 Explore validator wallet Explore validator wallet by address with Tonviewer: ​3.4 Credit validator wallet Funds at riskEnsure precise handling of operations, carefully verifying the addresses for single_nominator_pool, owner_address, and validator_wallet. Any incorrect deposit processing may result in the permanent and unrecoverable loss of funds. Credit the validator wallet. Ensure that at least 200 TON per month is available in the validator’s wallet to cover operational fees. ​3.5 Activate the wallet Activate (deploy on-chain) validator wallet, run: CopyAsk AIMyTonCtrl> aw validator_wallet_001 That also reflects in Tonviewer; the status will be displayed as Active ​3.6 Create a pool Create a single nominator pool for secure stake management. As the owner-address, specify the beneficiary wallet address that will stake the owner’s funds and receive rewards. Funds at riskUse a cold wallet (e.g., Ledger) for the owner-address and store its seed phrase securely to keep funds safe. If access to the owner’s wallet is lost, access to stake and rewards funds cannot be recovered. CopyAsk AIMyTonCtrl> new_single_pool <pool-name> <owner-address> If a single nominator pool already exists...If a single-nominator pool is already created, import it with:CopyAsk AIMyTonCtrl> import_pool <pool-name> <pool-addr> ​3.7 Print pool list Explore pool addresses using pools_list command: CopyAsk AIMyTonCtrl> pools_list At the moment, the pool hasn’t been deployed yet, and Explorer will display this as Nonexist status ​3.8 Activate pool Activate the single pool nominator contract: CopyAsk AIMyTonCtrl> activate_single_pool <pool-name> ​3.9 Verify activated pool Make sure the pool becomes activated with pools_list: CopyAsk AIMyTonCtrl> pools_list Blockchain explorer should also display the now-deployed contract with Active status. ​3.10 Test deposit to pool Funds at riskEnsure precise handling of operations, carefully verifying the addresses for single_nominator_pool, owner_address, and validator_wallet. Any incorrect deposit processing may result in the permanent and unrecoverable loss of funds. Test deposit to stake workflow. Any user can deposit to the pool via a standard direct TON transfer. Credit decent sum around 10 TON: ​3.11 Test withdrawal from pool Test withdrawal workflow. Only the owner’s cold wallet can request a withdrawal. Send a withdrawal request, a message with w comment from owner wallet to the single nominator pool address: Withdraw with script...Insert the single nominator pool address to SINGLE_NOMINATOR_ADDRESS and send this message from the owner’s wallet.Not runnableCopyAsk AIimport { Address, beginCell, internal, storeMessageRelaxed, toNano, } from \"@ton/core\"; async function main() { const single_nominator_address = Address.parse(\"SINGLE_NOMINATOR_ADDRESS\"); const WITHDRAW_OP = 0x1000; const amount = 50000; const messageBody = beginCell() .storeUint(WITHDRAW_OP, 32) .storeUint(0, 64) .storeCoins(amount) .endCell(); const internalMessage = internal({ to: single_nominator_address, value: toNano(\"1\"), bounce: true, body: messageBody, }); } Once the deposit is restored (except 1 TON reserve on the single nominator pool) to the owner’s wallet, that means validator are set securely and ready for real stake: ​Step 4: Set optimal stake for validator Top up the single nominator pool with the effective validation stake. In the next elections, MyTonCtrl will automatically use this pool for staking. If the pool’s balance is sufficient to participate in both rounds balance > min_sta",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "testnet",
      "mainnet",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "python",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:27:39.607Z"
  },
  {
    "id": "docs-ton-org--ecosystem-node-integrating-with-prometheus",
    "title": "Integrate MyTonCtrl with Prometheus",
    "url": "https://docs.ton.org/ecosystem/node/integrating-with-prometheus",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeOverviewRun a node with MyTonCtrlRun a validatorIntegrate MyTonCtrl with PrometheusSetting up a local blockchain using MyLocalTonMyTonCtrl referenceStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationBlockchain nodeIntegrate MyTonCtrl with PrometheusEcosystemBlockchain nodeIntegrate MyTonCtrl with PrometheusCopy pageCopy pageMyTonCtrl pushes metrics to a Prometheus Pushgateway so Prometheus (and Grafana, if used) can scrape them without exposing the node directly. ​Prerequisites Docker and Docker Compose are installed on the host that runs Prometheus. MyTonCtrl installed and running on the node that emits metrics. ​Deploy Prometheus and Pushgateway In an empty directory, create docker-compose.yml: CopyAsk AIservices: pushgateway: image: prom/pushgateway:v1.4.0 restart: unless-stopped ports: - \"9091:9091\" prometheus: image: prom/prometheus:v2.52.0 restart: unless-stopped volumes: - ./prometheus.yml:/etc/prometheus/prometheus.yml:ro command: - \"--config.file=/etc/prometheus/prometheus.yml\" ports: - \"9090:9090\" Create prometheus.yml alongside it: CopyAsk AIglobal: scrape_interval: 15s scrape_configs: - job_name: \"mytonctrl_pushgateway\" static_configs: - targets: [\"pushgateway:9091\"] Start the stack and confirm the container status: CopyAsk AIdocker compose up -d docker compose ps ​Configure MyTonCtrl to push metrics Open the MyTonCtrl console: CopyAsk AImytonctrl Enable Prometheus mode: CopyAsk AIMyTonCtrl> enable_mode prometheus Point MyTonCtrl to the Pushgateway (include a job name): CopyAsk AIMyTonCtrl> set prometheus_url http://<PUSHGATEWAY_HOST>:9091/metrics/job/<JOB_NAME> <PUSHGATEWAY_HOST> — host running the Pushgateway (use 127.0.0.1 when MyTonCtrl and Docker run on the same machine). <JOB_NAME> — unique label for this node, for example validator1. Use unique job namesDo not reuse the same JOB_NAME across nodes when scraped by one Prometheus instance, or metrics collide. ​Verify metrics Pushgateway: open http://<PUSHGATEWAY_HOST>:9091 and confirm metrics appear under <JOB_NAME>. Prometheus targets: open http://<PROMETHEUS_HOST>:9090/targets and check that mytonctrl_pushgateway shows UP. Prometheus graph: query mytonctrl_synced or other MyTonCtrl metrics at http://<PROMETHEUS_HOST>:9090/graph. Was this page helpful?YesNoSuggest editsRaise issuePreviousSetting up a local blockchain using MyLocalTonInstall MyLocalTon to spin up a self-contained TON network for development and testing.Next⌘IgithubxtelegramPowered by MintlifyOn this pagePrerequisitesDeploy Prometheus and PushgatewayConfigure MyTonCtrl to push metricsVerify metrics",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:27:42.155Z"
  },
  {
    "id": "docs-ton-org--ecosystem-node-setup-mylocalton",
    "title": "Setting up a local blockchain using MyLocalTon",
    "url": "https://docs.ton.org/ecosystem/node/setup-mylocalton",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeOverviewRun a node with MyTonCtrlRun a validatorIntegrate MyTonCtrl with PrometheusSetting up a local blockchain using MyLocalTonMyTonCtrl referenceStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationBlockchain nodeSetting up a local blockchain using MyLocalTonEcosystemBlockchain nodeSetting up a local blockchain using MyLocalTonCopy pageInstall MyLocalTon to spin up a self-contained TON network for development and testing.Copy pageMyLocalTon packages validator nodes, a lite-server, explorer, and optional HTTP API into a single JAR so you can prototype locally without touching mainnet. Use it for integration tests, smart-contract dry runs, and demos before deploying to public networks. ​Prerequisites Java Development Kit (JDK) 21 or newer in your PATH. Python 3.9-3.12 if you plan to enable the optional HTTP API bridge. On Windows, install the Microsoft Visual C++ 2015+ x64 Redistributable. Allocate at least 4 CPU cores, 16 GB RAM, and 20 GB of free disk space for smooth operation. ​Download and install ​Windows Install the Visual C++ Redistributable. Download the JAR that matches your architecture from the MyLocalTon releases. MyLocalTon-x86-64.jar for x86-64 systems. MyLocalTon-arm64.jar for ARM64 systems. ​macOS and Linux CopyAsk AI# x86-64 wget https://github.com/neodix42/MyLocalTon/releases/latest/download/MyLocalTon-x86-64.jar # ARM64 wget https://github.com/neodix42/MyLocalTon/releases/latest/download/MyLocalTon-arm64.jar ​Build from source CopyAsk AIsudo apt install openjdk-21-jdk ant maven git clone https://github.com/neodix42/MyLocalTon.git cd MyLocalTon mvn clean package assembly:single The JAR with all dependencies appears under target/ when the build finishes. ​Launch the local network CopyAsk AIjava -jar MyLocalTon-x86-64.jar Useful arguments: FlagDescriptionnoguiRun in headless mode without the Swing interface.with-validators=<N>Start N validator instances (default: 1).explorerLaunch the bundled block explorer.ton-http-apiStart the HTTP API bridge (requires Python + ton-http-api).custom-binaries=<PATH>Load TON binaries from a custom directory.ip.addr.X.XBind services to a specific local IP.debugIncrease log verbosity for troubleshooting. The first run creates the myLocalTon/ workspace alongside the JAR. Validators, liteserver certificates, and logs live in this directory. ​Connect CLI tools MyLocalTon prints the lite-server public key during startup and stores certificates in ./myLocalTon/genesis/bin/certs/. CopyAsk AIlite-client -a 127.0.0.1:4443 -b E7XwFSQzNkcRepUC23J2nRpASXpnsEKmyyHYV4u/FZY= -c last validator-engine-console \\ -a 127.0.0.1:4441 \\ -k $(pwd)/myLocalTon/genesis/bin/certs/client \\ -p $(pwd)/myLocalTon/genesis/bin/certs/server.pub ​Enable the HTTP API bridge On Windows, install OpenSSL v1.1.1 first Install Python dependencies on the host system, then restart MyLocalTon with the ton-http-api flag or enable the “Start TON Center” toggle in UI. CopyAsk AI# Linux sudo apt install -y python3 python3-pip pip3 install --user ton-http-api # macOS (Homebrew) brew install python3 python3 -m ensurepip --upgrade pip3 install --user ton-http-api # Windows py -3 -m ensurepip --upgrade py -3 -m pip install --user ton-http-api The bridge exposes REST endpoints that mirror the lite-server APIs for tooling that cannot speak the native ADNL protocol. ​Monitor and maintain Tail myLocalTon/MyLocalTon.log for application-level events. Validator logs reside in myLocalTon/genesis/db/log. Re-run with debug when reproducing issues. Upgrade by downloading the latest JAR, replacing the existing file, and deleting the myLocalTon directory so the genesis state regenerates. ​Troubleshooting tips SymptomResolutionJAR fails to startVerify Java 21+ is installed and the file is not quarantined by the OS (macOS: xattr -d com.apple.quarantine <JAR>).HTTP API errorsEnsure Python 3.9-3.12 and ton-http-api are installed.Need a clean resetStop the process, delete the myLocalTon folder, and restart the JAR to regenerate the network. ​Where to go next Graduate to production setups with Setting up a node using MyTonCtrl. Explore node roles and responsibilities in the node overview. Was this page helpful?YesNoSuggest editsRaise issuePreviousOverviewNext⌘IgithubxtelegramPowered by MintlifyOn this pagePrerequisitesDownload and installWindowsmacOS and LinuxBuild from sourceLaunch the local networkConnect CLI toolsEnable the HTTP API bridgeMonitor and maintainTroubleshooting tipsWhere to go next",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "mainnet",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "python",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:27:44.575Z"
  },
  {
    "id": "docs-ton-org--ecosystem-tma-analytics-faq",
    "title": "FAQ",
    "url": "https://docs.ton.org/ecosystem/tma/analytics/faq",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsOverviewTMA create CLITelegram UIMateAnalyticsTelegram analyticsSupported eventsPreparationsInstallation via script tagInstallation via NPM packageAPI EndpointsManaging integrationFAQBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationAnalyticsFAQEcosystemTMA: Telegram Mini AppsAnalyticsFAQCopy pageCopy page​How can I check the integration status of the SDK? ​Using a bot After completing the integration process, the bot @DataChief_bot will display the time of the last recorded event in our database. If it shows something like “one minute ago”, then everything is working correctly. ​Using DevTools ​Desktop version Go to Telegram settings, then to Advanced Settings, and then to Experimental Settings. Toggle on the “Enable webview inspecting” function. Next, open your application and right-click to open the developer console. In the Network section, you should see the SDK script (index.js) loading and sending events. If this is not observed, try refreshing the application without closing TMA. ​Web version Go to Telegram’s web version, open the developer tools, go to the network section, open your TMA, and filter queries by 'tganalytics.xyz'. You’ll see the SDK being loaded (index.js) and events being sent afterward.Was this page helpful?YesNoSuggest editsRaise issuePreviousOverviewPick the right TON node setup and understand the operational work it requires.Next⌘IgithubxtelegramPowered by MintlifyOn this pageHow can I check the integration status of the SDK?Using a botUsing DevToolsDesktop versionWeb version",
    "category": "tma",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:27:46.177Z"
  },
  {
    "id": "docs-ton-org--ecosystem-node-mytonctrl-liquid-staking",
    "title": "Liquid staking",
    "url": "https://docs.ton.org/ecosystem/node/mytonctrl/liquid-staking",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeOverviewRun a node with MyTonCtrlRun a validatorIntegrate MyTonCtrl with PrometheusSetting up a local blockchain using MyLocalTonMyTonCtrl referenceOverviewCoreInstallerWalletValidatorCollatorNominator poolsLiquid stakingCustom overlaysUtilitiesTelegram alertingBackupBTC TeleportStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationMyTonCtrl referenceLiquid stakingEcosystemBlockchain nodeMyTonCtrl referenceLiquid stakingCopy pageLiquid staking mode orchestrates controller deployment and maintenance for jetton-based staking pools. The commands below cover controller lifecycle management, funding flows, validator-set updates, and diagnostic helpers.Copy page​Operational notes Liquid staking controllers rely on the validator wallet and liquid pool contracts. Keep the wallet funded and the pool address (liquid_pool_addr) set via set liquid_pool_addr <address> before deploying controllers. Pending withdrawals are stored in the local database when a controller is busy (non-zero state). MyTonCtrl processes them automatically as soon as the controller returns to the ready state. The jetton pool contracts must be available under /usr/src/mytonctrl/contracts/jetton_pool/. The first run of create_controllers downloads them if necessary. Commands interacting with the TON HTTP API assume the service listens on 127.0.0.1:8801 (the default when this mode is enabled). ​Controller deployment and discovery ​create_controllers Purpose: Deploy the two standard controllers for the configured liquid staking pool if they are missing or outdated. Syntax CopyAsk AIcreate_controllers Behavior Compares the controller addresses returned by the pool (GetControllers) with the addresses stored in the local database. If they differ, downloads the jetton pool deployment scripts (on first run), signs the deployment BoCs with the validator wallet, and sends them to the liquid pool with a small attach value. Stores the newly active controllers under using_controllers so subsequent staking and voting commands target the fresh contracts. ​update_controllers Purpose: Re-run the controller deployment workflow to synchronize with changes on the pool side. Syntax CopyAsk AIupdate_controllers Behavior Alias for create_controllers; useful after pool upgrades or migration, forcing MyTonCtrl to redeploy controllers when the contract-address mapping changes. ​controllers_list Purpose: Inspect every controller list tracked locally. Syntax CopyAsk AIcontrollers_list Behavior Prints tables for the active (using), newly detected, previously used (old), and user-specified controller lists. Each entry includes address, on-chain status, balance, approval flag, and controller state as reported by get_validator_controller_data. Allows operators to verify whether a controller is approved, funded, or stopped. ​add_controller Purpose: Mark an additional controller address as user-managed so MyTonCtrl considers it for operations. Syntax CopyAsk AIadd_controller <controller-addr> Behavior Adds <controller-addr> to the user_controllers list and removes it from the stop list if present, enabling future staking or updates through MyTonCtrl. Accepts base64 controller addresses. Example CopyAsk AIadd_controller EQDf...9A ​Funding and withdrawals ​deposit_to_controller Purpose: Top up a controller contract with Toncoin from the validator wallet. Syntax CopyAsk AIdeposit_to_controller <controller-addr> <amount-ton> Behavior Signs the top-up.boc script with the validator wallet and sends <amount-ton> TON to <controller-addr>. Use decimal TON amounts; the command handles the nanoTON conversion internally. Example CopyAsk AIdeposit_to_controller EQDf...9A 2000 ​withdraw_from_controller Purpose: Withdraw funds from a controller back to the validator wallet. Syntax CopyAsk AIwithdraw_from_controller <controller-addr> [amount-ton] Behavior Requests an immediate withdrawal when the controller state permits it; otherwise, it queues a pending withdrawal that is handled automatically later. If [amount-ton] is omitted, MyTonCtrl withdraws nearly the entire balance (leaving ~10 TON to cover rent). Examples CopyAsk AIwithdraw_from_controller EQDf...9A withdraw_from_controller EQDf...9A 750 ​stop_controller Purpose: Flag a controller so MyTonCtrl stops using it for future staking operations. Syntax CopyAsk AIstop_controller <controller-addr> Behavior Adds <controller-addr> to the local stop list and removes it from the user or active lists. The contract remains on-chain but is ignored by automated workflows. Example CopyAsk AIstop_controller EQDf...9A ​stop_and_withdraw_controller Purpose: Stop a controller and withdraw its funds in a single step. Syntax CopyAsk AIstop_and_withdraw_controller <controller-addr> [amount-ton] Behavior Flags the controller as stopped (same as stop_controller). Triggers a withdrawal for [amount-ton] TON; when omitted, withdraws almost the full balance (balance minus ~10.1 TON to keep the contract alive). Example CopyAsk AIstop_and_withdraw_controller EQDf...9A ​Validator-set maintenance ​controller_update_validator_set Purpose: Refresh the validator set stored on a controller contract. Syntax CopyAsk AIcontroller_update_validator_set <controller-addr> Behavior Calls the controller’s update_validator_set method so it picks up the latest validator ADNL IDs from the pool. Use after elections or whenever the pool indicates mismatched validator sets. Example CopyAsk AIcontroller_update_validator_set EQDf...9A ​check_liquid_pool Purpose: Scan recent liquid pool transactions and update controller validator sets automatically. Syntax CopyAsk AIcheck_liquid_pool Behavior Looks through the liquid pool’s account history, detects controller addresses interacting with the pool, and calls controller_update_validator_set for each detected controller. Useful as a catch-up step after manual interventions or pool upgrades. ​Controller diagnostics ​get_controller_data Purpose: Dump the full controller status JSON for inspection. Syntax CopyAsk AIget_controller_data <controller-addr> Behavior Runs the controller’s get_validator_controller_data method and prints the resulting fields (for example: state, approval, borrowed amount, and stake timing). Ideal for debugging controllers stuck in a non-zero state or verifying approval. Example CopyAsk AIget_controller_data EQDf...9A ​calculate_annual_controller_percentage Purpose: Convert the per-round interest rate into an annualized percentage. Syntax CopyAsk AIcalculate_annual_controller_percentage [percent-per-round] Behavior Uses the validators’ election cycle length from config 15 to compute how many rounds fit into a year, and then scales the provided (or configured max_interest_percent) rate. Prints intermediate values and the final yearly percentage. Examples CopyAsk AIcalculate_annual_controller_percentage calculate_annual_controller_percentage 1.25 ​test_calculate_loan_amount Purpose: Test the on-chain helper that calculates controller loan amounts. Syntax CopyAsk AItest_calculate_loan_amount Behavior Sends a local HTTP request to the TON HTTP API (/runGetMethod) using the configured loan parameters (min_loan, max_loan, max_interest_percent). Prints the raw response (nanoTON value) used to size controller loans. Was this page helpful?YesNoSuggest editsRaise issuePreviousCustom overlaysSets up a custom overlay to speed up synchronization for a group of nodes.Next⌘IgithubxtelegramPowered by MintlifyOn this pageOperational notesController deployment and discoverycreate_controllersupdate_controllerscontrollers_listadd_controllerFunding and withdrawalsdeposit_to_controllerwithdraw_from_controllerstop_controllerstop_and_withdraw_controllerValidator-set maintenancecontroller_update_validator_setcheck_liquid_poolController diagnosticsget_controller_datacalculate_annual_controller_percentagetest_calculate_loan_amount",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "deployment",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:27:49.338Z"
  },
  {
    "id": "docs-ton-org--ecosystem-node-mytonctrl-validator",
    "title": "Validator",
    "url": "https://docs.ton.org/ecosystem/node/mytonctrl/validator",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeOverviewRun a node with MyTonCtrlRun a validatorIntegrate MyTonCtrl with PrometheusSetting up a local blockchain using MyLocalTonMyTonCtrl referenceOverviewCoreInstallerWalletValidatorCollatorNominator poolsLiquid stakingCustom overlaysUtilitiesTelegram alertingBackupBTC TeleportStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationMyTonCtrl referenceValidatorEcosystemBlockchain nodeMyTonCtrl referenceValidatorCopy pageValidator mode automates governance voting, election participation, efficiency tracking, and the local collator registry.Copy page​Operational notes These commands require validator mode to be enabled. They interact with the validator console and expect the validator wallet to be configured and funded. Offer hashes, complaint hashes, and election identifiers come from status, lite-client, or governance dashboards. Use the exact strings reported there to avoid signature failures. When managing collators, follow up with setup_collator (from collator mode) on the node that actually produces blocks. The validator-side registry maintained here determines which collators are accepted and how they behave during elections. ​Governance and elections ​vo Purpose: Vote for one or more governance offers (configuration proposals) using the validator wallet. Syntax CopyAsk AIvo <offer-hash> [additional_offer_hashes...] Behavior Accepts one or more offer hashes exactly as reported by commands like status or ol. Hashes are typically base64 strings. Fetches the full offer list, saves each voted offer locally for tracking, and submits signed votes through the validator wallet. Skips unknown hashes and raises an error if the vote submission fails. Example CopyAsk AIvo xKF+2Cj4wP6w2y... xKF+2Cj4wP6w2y... ​ve Purpose: Cast the validator election entry for the upcoming round. Syntax CopyAsk AIve Behavior Runs the Elections helper from mytoncore, which prepares and sends the election request using the validator wallet. Reuses configuration stored in the local database (stake amount, elector parameters, etc.). Prints VoteElectionEntry - OK when the elector accepts the query. ​vc Purpose: Vote on a validator complaint by pairing the election round with the complaint hash. Syntax CopyAsk AIvc <election-id> <complaint-hash> Behavior <election-id> is the integer identifier of the round (from status or elector logs). <complaint-hash> is usually base64 and matches the hash reported in complaint notifications. Delegates to VoteComplaint, which signs and broadcasts the vote via the validator wallet. Example CopyAsk AIvc 345678901234567890 xFFmZ...Y ​Performance diagnostics ​check_ef Purpose: Review validator efficiency for the previous and current validation rounds. Syntax CopyAsk AIcheck_ef Behavior Collects validator lists for the current and previous rounds, locates the local ADNL, and prints block production statistics. Highlights time ranges for each round, shows created versus expected masterchain blocks, and colorizes efficiency percentages (green when ≥90%). Warns when efficiency data is unavailable (e.g., when the validator joined as a shard-only participant or the round has just started). ​Local collator registry ​add_collator Purpose: Add a collator entry to the validator console’s collator list and configure optional behaviors. Syntax CopyAsk AIadd_collator <adnl-id> <workchain>:<shard_hex> [--self-collate true|false] [--select-mode random|ordered|round_robin] Behavior <adnl-id> accepts base64 or hex. Hex values are automatically converted to base64 before storing. <workchain>:<shard_hex> identifies the shard (e.g., 0:2000000000000000). Use the same format shown in the validator console output. If the shard already exists in the collator list, the command appends the ADNL and optionally updates self_collate or select_mode. Otherwise, it creates a new shard entry using defaults (self_collate=true, select_mode=random). Persists the updated list using set-collators-list so the validator console starts assigning work to the new collator. Example CopyAsk AIadd_collator 2F3C7A...B91 0:2000000000000000 --self-collate true --select-mode ordered ​delete_collator Purpose: Remove one or more collator entries from the validator console list. Syntax CopyAsk AIdelete_collator [<workchain>:<shard_hex>] <adnl-id> Behavior Accepts an optional shard selector. When omitted, the ADNL is removed from every shard where it appears. <adnl-id> can be base64 or hex; hex values are converted automatically. After removal, the command cleans up empty shard sections in the stored collator list. Examples CopyAsk AIdelete_collator 0:2000000000000000 2F3C7A...B91 delete_collator 2F3C7A...B91 ​print_collators Purpose: Inspect the current collator list and optional liveness information. Syntax CopyAsk AIprint_collators [--json] Behavior By default, prints the human-readable output from show-collators-list, augmented with online/offline status when collation-manager-stats provides data. With --json, returns the parsed collator list in JSON format, matching the structure passed to set-collators-list. Examples CopyAsk AIprint_collators print_collators --json ​reset_collators Purpose: Clear the entire collator list stored in the validator console. Syntax CopyAsk AIreset_collators Behavior Calls clear-collators-list and removes all shard/ADNL mappings. Reports an error if the console rejects the reset; otherwise, prints reset_collators - OK. Was this page helpful?YesNoSuggest editsRaise issuePreviousCollatorCollator mode lets a node produce blocks for selected shardchains without running the full validator stack. The commands below help you configure local collators, adjust the validator allowlist, and manage collator-specific configuration JSON.Next⌘IgithubxtelegramPowered by MintlifyOn this pageOperational notesGovernance and electionsvovevcPerformance diagnosticscheck_efLocal collator registryadd_collatordelete_collatorprint_collatorsreset_collators",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:27:52.248Z"
  },
  {
    "id": "docs-ton-org--ecosystem-node-mytonctrl-btc-teleport",
    "title": "BTC Teleport",
    "url": "https://docs.ton.org/ecosystem/node/mytonctrl/btc-teleport",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeOverviewRun a node with MyTonCtrlRun a validatorIntegrate MyTonCtrl with PrometheusSetting up a local blockchain using MyLocalTonMyTonCtrl referenceOverviewCoreInstallerWalletValidatorCollatorNominator poolsLiquid stakingCustom overlaysUtilitiesTelegram alertingBackupBTC TeleportStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationMyTonCtrl referenceBTC TeleportEcosystemBlockchain nodeMyTonCtrl referenceBTC TeleportCopy pageThe BTC Teleport module manages the optional Bitcoin bridge (Teleport) client shipped with MyTonCtrl. Use these commands to inspect proposals, vote on them, or remove the Teleport installation when no longer needed.Copy page​Operational notes Teleport installation happens automatically when validator mode is enabled unless btcTeleportDisabled is set. Use these commands to check governance participation or clean up. Voting attaches 1.5 TON from the validator wallet. Ensure the wallet has sufficient balance before sending votes. The module caches proposals it has voted on (saveOffersBtcTeleport) to avoid duplicate submissions. ​remove_btc_teleport Purpose: Uninstall the Teleport binaries, keystore, and system service. Syntax CopyAsk AIremove_btc_teleport [--force] Behavior Runs scripts/remove_btc_teleport.sh to delete the Teleport repository (/usr/src/ton-teleport-btc-periphery), keystore, and systemd service. By default, it refuses to run if the validator is currently a masterchain participant. Use --force only when the node is not producing masterchain blocks or after exiting the validator set. Prints an error if the removal script fails. Example CopyAsk AIremove_btc_teleport --force Was this page helpful?YesNoSuggest editsRaise issuePreviousOverviewNext⌘IgithubxtelegramPowered by MintlifyOn this pageOperational notesremove_btc_teleport",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:27:55.623Z"
  },
  {
    "id": "docs-ton-org--foundations-whitepapers-tvm",
    "title": "Telegram Open Network Virtual Machine",
    "url": "https://docs.ton.org/foundations/whitepapers/tvm",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersOverviewTVMTON BlockchainThe Open NetworkCatchain consensusGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationWhitepapersTelegram Open Network Virtual MachineBlockchain foundationsWhitepapersTelegram Open Network Virtual MachineCopy pageWhitepaper by Dr. Nikolai DurovCopy pageAuthor: Nikolai Durov Date: March 23, 2020 : Original whitepaper, PDF ​Abstract The aim of this text is to provide a description of the Telegram Open Network Virtual Machine (TON VM or TVM), used to execute smart contracts in the TON Blockchain. ​Introduction The primary purpose of the Telegram Open Network Virtual Machine (TON VM or TVM) is to execute smart-contract code in the TON Blockchain. TVM must support all operations required to parse incoming messages and persistent data, and to create new messages and modify persistent data. Additionally, TVM must meet the following requirements: It must provide for possible future extensions and improvements while retaining backward compatibility and interoperability, because the code of a smart contract, once committed into the blockchain, must continue working in a predictable manner regardless of any future modifications to the VM. It must strive to attain high “(virtual) machine code” density, so that the code of a typical smart contract occupies as little persistent blockchain storage as possible. It must be completely deterministic. In other words, each run of the same code with the same input data must produce the same result, regardless of specific software and hardware used.1 The design of TVM is guided by these requirements. While this document describes a preliminary and experimental version of TVM,2 the backward compatibility mechanisms built into the system allow us to be relatively unconcerned with the efficiency of the operation encoding used for TVM code in this preliminary version. TVM is not intended to be implemented in hardware (e.g., in a specialized microprocessor chip); rather, it should be implemented in software running on conventional hardware. This consideration lets us incorporate some high-level concepts and operations in TVM that would require convoluted microcode in a hardware implementation but pose no significant problems for a software implementation. Such operations are useful for achieving high code density and minimizing the byte (or storage cell) profile of smart-contract code when deployed in the TON Blockchain. ​1 Overview This chapter provides an overview of the main features and design principles of TVM. More detail on each topic is provided in subsequent chapters. ​1.0 Notation for bitstrings The following notation is used for bit strings (or bitstrings)—i.e., finite strings consisting of binary digits (bits), 0\\texttt{0}0 and 1\\texttt{1}1—throughout this document. ​1.0.1. Hexadecimal notation for bitstrings When the length of a bitstring is a multiple of four, we subdivide it into groups of four bits and represent each group by one of sixteen hexadecimal digits 0\\texttt{0}0—9\\texttt{9}9, A\\texttt{A}A—F\\texttt{F}F in the usual manner: 016↔0000\\texttt{0}_{16}\\leftrightarrow\\texttt{0000}016​↔0000, 116↔0001\\texttt{1}_{16}\\leftrightarrow\\texttt{0001}116​↔0001, …\\ldots…, F16↔1111\\texttt{F}_{16}\\leftrightarrow\\texttt{1111}F16​↔1111. The resulting hexadecimal string is our equivalent representation for the original binary string. ​1.0.2. Bitstrings of lengths not divisible by four If the length of a binary string is not divisible by four, we augment it by one 1\\texttt{1}1 and several (maybe zero) 0\\texttt{0}0s at the end, so that its length becomes divisible by four, and then transform it into a string of hexadecimal digits as described above. To indicate that such a transformation has taken place, a special “completion tag” _\\texttt{\\_}_ is added to the end of the hexadecimal string. The reverse transformation (applied if the completion tag is present) consists in first replacing each hexadecimal digit by four corresponding bits, and then removing all trailing zeroes (if any) and the last 1\\texttt{1}1 immediately preceding them (if the resulting bitstring is non-empty at this point). Notice that there are several admissible hexadecimal representations for the same bitstring. Among them, the shortest one is “canonical”. It can be deterministically obtained by the above procedure. For example, 8A\\texttt{8A}8A corresponds to binary string 10001010\\texttt{10001010}10001010, while 8A_\\texttt{8A\\_}8A_ and 8A0_\\texttt{8A0\\_}8A0_ both correspond to 100010\\texttt{100010}100010. An empty bitstring may be represented by either ’ ’, '8_\\texttt{8\\_}8_', '0_\\texttt{0\\_}0_', '_\\texttt{\\_}_', or '00_\\texttt{00\\_}00_'. ​1.0.3. Emphasizing that a string is a hexadecimal representation of a bitstring Sometimes we need to emphasize that a string of hexadecimal digits (with or without a _\\texttt{\\_}_ at the end) is the hexadecimal representation of a bitstring. In such cases, we either prepend x\\texttt{x}x to the resulting string (e.g., x8A\\texttt{x8A}x8A), or prepend x{\\texttt{x\\{}x{ and append }\\texttt{\\}}} (e.g., x{2D9_}\\texttt{x\\{2D9\\_\\}}x{2D9_}, which is 00101101100\\texttt{00101101100}00101101100). This should not be confused with hexadecimal numbers, usually prepended by 0x\\texttt{0x}0x (e.g., 0x2D9\\texttt{0x2D9}0x2D9 or 0x2d9\\texttt{0x2d9}0x2d9, which is the integer 729). ​1.0.4. Serializing a bitstring into a sequence of octets When a bitstring needs to be represented as a sequence of 8-bit bytes (octets), which take values in integers 0…2550\\ldots2550…255, this is achieved essentially in the same fashion as above: we split the bitstring into groups of eight bits and interpret each group as the binary representation of an integer 0…2550\\ldots2550…255. If the length of the bitstring is not a multiple of eight, the bitstring is augmented by a binary 1\\texttt{1}1 and up to seven binary 0\\texttt{0}0s before being split into groups. The fact that such a completion has been applied is usually reflected by a “completion tag” bit. For instance, 00101101100\\texttt{00101101100}00101101100 corresponds to the sequence of two octets (0x2d,0x90)(\\texttt{0x2d}, \\texttt{0x90})(0x2d,0x90) (hexadecimal), or (45,144)(45,144)(45,144) (decimal), along with a completion tag bit equal to 1\\texttt{1}1 (meaning that the completion has been applied), which must be stored separately. In some cases, it is more convenient to assume the completion is enabled by default rather than store an additional completion tag bit separately. Under such conventions, 8n8n8n-bit strings are represented by n+1n+1n+1 octets, with the last octet always equal to 0x80=128\\texttt{0x80}=1280x80=128. ​1.1 TVM is a stack machine First of all, TVM is a stack machine. This means that, instead of keeping values in some “variables” or “general-purpose registers”, they are kept in a (LIFO) stack, at least from the “low-level” (TVM) perspective.3 Most operations and user-defined functions take their arguments from the top of the stack, and replace them with their result. For example, the integer addition primitive (built-in operation) ADD\\texttt{ADD}ADD does not take any arguments describing which registers or immediate values should be added together and where the result should be stored. Instead, the two top values are taken from the stack, they are added together, and their sum is pushed into the stack in their place. ​1.1.1. TVM values The entities that can be stored in the TVM stack will be called TVM values, or simply values for brevity. They belong to one of several predefined value types. Each value belongs to exactly one value type. The values are always kept on the stack along with tags uniquely determining their types, and all built-in TVM operations (or primitives) only accept values of predefined types. For example, the integer addition primitive ADD\\texttt{ADD}ADD accepts only two integer values, and returns one integer value as a result. One cannot supply ADD\\texttt{ADD}ADD with two strings instead of two integers expecting it to concatenate these strings or to implicitly transform the strings into their decimal integer values; any attempt to do so will result in a run-time type-checking exception. ​1.1.2. Static typing, dynamic typing, and run-time type checking In some respects TVM performs a kind of dynamic typing using run-time type checking. However, this does not make the TVM code a “dynamically typed language” like PHP or Javascript, because all primitives accept values and return results of predefined (value) types, each value belongs to strictly one type, and values are never implicitly converted from one type to another. If, on the other hand, one compares the TVM code to the conventional microprocessor machine code, one sees that the TVM mechanism of value tagging prevents, for example, using the address of a string as a number—or, potentially even more disastrously, using a number as the address of ",
    "category": "infrastructure",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:28:02.021Z"
  },
  {
    "id": "docs-ton-org--foundations-addresses-serialize",
    "title": "Reading and writing addresses",
    "url": "https://docs.ton.org/foundations/addresses/serialize",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesOverviewInternal address formatsReading and writing addressesDerivingMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationAddressesReading and writing addressesBlockchain foundationsAddressesReading and writing addressesCopy pageCopy pageOn this page, the main issues of interaction with the addresses are described: how to create and parse; how to check the validity; how to convert from one format to another. ​Using online converter The best user-friendly online parser and address converter in TON blockchain is TON Address tool. If the address is entered in any format, the system will provide all possible formats for the address, provided that it is entered correctly. Otherwise, a warning will be displayed indicating that the address is invalid. ​Using SDK There are at least four SDKs for interacting with TON blockchain, written in TypeScript; Java; Go; Python. You can use any of them, including for working with addresses. However, we focus here on the most used one: the one written in TypeScript. Namely, we examine ton-core address module. The internal addresses are represented as instances of the Address class. You can access it in your favorite IDE using the following import. CopyAsk AIimport { Address } from \"@ton/core\"; readonly workChain: number; readonly hash: Buffer; As for the external addresses, they are represented as instances of the ExternalAddress class. Similarly, you can access it as follows. CopyAsk AIimport { ExternalAddress } from \"@ton/core\"; readonly value: bigint; readonly bits: number; ​Create, parse, and convert addresses The creation is simple. CopyAsk AI// There is a hash validation check inside the Address constructor. const internalAddress = new Address(some_wc, some_valid_hash); const externalAddress = new ExternalAddress(some_value, some_bits); You can parse the internal addresses string and then convert from one format to another as follows. CopyAsk AIconst address1 = Address.parse('EQDKbjIcfM6ezt8KjKJJLshZJJSqX7XOA4ff-W72r5gqPrHF'); const address2 = Address.parse('0:ca6e321c7cce9ecedf0a8ca2492ec8592494aa5fb5ce0387dff96ef6af982a3e'); // or via its convenient wrapper // const address1 = address('EQDKbjIcfM6ezt8KjKJJLshZJJSqX7XOA4ff-W72r5gqPrHF'); // const address2 = address('0:ca6e321c7cce9ecedf0a8ca2492ec8592494aa5fb5ce0387dff96ef6af982a3e'); // these two addresses are equal console.log(address1.equals(address2)); // true // toString arguments: urlSafe {true means using '-' and '_' instead of '+' and '/'; false means the opposite}; // bounceable {true means the address is bounceable; false means non-bounceable}; // testOnly {true means the address is for Testnet; false means for Mainnet}. // default values: true, true, false. console.log(address1.toString()); // EQDKbjIcfM6ezt8KjKJJLshZJJSqX7XOA4ff-W72r5gqPrHF console.log(address1.toString({urlSafe: false})) // EQDKbjIcfM6ezt8KjKJJLshZJJSqX7XOA4ff+W72r5gqPrHF console.log(address1.toString({bounceable: false})) // UQDKbjIcfM6ezt8KjKJJLshZJJSqX7XOA4ff-W72r5gqPuwA console.log(address1.toString({testOnly: true})) // kQDKbjIcfM6ezt8KjKJJLshZJJSqX7XOA4ff-W72r5gqPgpP console.log(address1.toString({bounceable: false, testOnly: true})) // 0QDKbjIcfM6ezt8KjKJJLshZJJSqX7XOA4ff-W72r5gqPleK // output the address in raw format console.log(address1.toRawString()); // 0:ca6e321c7cce9ecedf0a8ca2492ec8592494aa5fb5ce0387dff96ef6af982a3e // returns a Buffer with the user‑friendly format address address1.toStringBuffer(); // the same for address2 console.log(address2.toString()); // EQDKbjIcfM6ezt8KjKJJLshZJJSqX7XOA4ff-W72r5gqPrHF console.log(address2.toRawString()); // 0:ca6e321c7cce9ecedf0a8ca2492ec8592494aa5fb5ce0387dff96ef6af982a3e // returns a Buffer with the raw format address address2.toStringBuffer(); If you are sure that your string accurately represents the address in raw or user-friendly format, you can also use the following methods. CopyAsk AIconst address1 = Address.parseFriendly('EQDKbjIcfM6ezt8KjKJJLshZJJSqX7XOA4ff-W72r5gqPrHF'); const address2 = Address.parseRaw('0:ca6e321c7cce9ecedf0a8ca2492ec8592494aa5fb5ce0387dff96ef6af982a3e'); However, there is no separate method for parsing external addresses from a string. ​Validate addresses The validity of the address is checked at the time of its parsing. An attempt to parse an invalid address will result in an error. However, you can check separately whether a string is a valid address in raw or user-friendly formats. CopyAsk AIconsole.log(Address.isFriendly('EQDKbjIcfM6ezt8KjKJJLshZJJSqX7XOA4ff-W72r5gqPrHF')) // true console.log(Address.isRaw('EQDKbjIcfM6ezt8KjKJJLshZJJSqX7XOA4ff-W72r5gqPrHF')) // false console.log(Address.isFriendly('0:ca6e321c7cce9ecedf0a8ca2492ec8592494aa5fb5ce0387dff96ef6af982a3e')) // false console.log(Address.isRaw('0:ca6e321c7cce9ecedf0a8ca2492ec8592494aa5fb5ce0387dff96ef6af982a3e')) // true Was this page helpful?YesNoSuggest editsRaise issuePreviousDerivingNext⌘IgithubxtelegramPowered by MintlifyOn this pageUsing online converterUsing SDKCreate, parse, and convert addressesValidate addresses",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "testnet",
      "mainnet",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "python",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:28:04.042Z"
  },
  {
    "id": "docs-ton-org--foundations-addresses-derive",
    "title": "Deriving addresses",
    "url": "https://docs.ton.org/foundations/addresses/derive",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesOverviewInternal address formatsReading and writing addressesDerivingMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationAddressesDeriving addressesBlockchain foundationsAddressesDeriving addressesCopy pageCopy pageIt is often useful to derive an address of an account to interact with it, either on-chain or off-chain. The general algorithm for address derivation is to compose the StateInit of an account, calculate its hash, and build the address in the desired format. The StateInit is distinct from the account’s current state. It is the initial state, which an account stores at deployment. After that, state can be changed by the smart contract itself — for example, by updating the data. Since the address depends on StateInit, to derive the address it is necessary to compose the initial state rather than the current one. In practice, address derivation is mostly about composing the correct StateInit. ​On-chain derivation ​On-chain — simple If it’s known how to compose the contract’s initial code and data, it’s enough to follow the general algorithm mentioned above as is. Code and data form a StateInit, and the workchain is usually hardcoded. Below is one of the most common patterns when code is a constant cell known in advance and data is composed at runtime. TolkCopyAsk AI// Compose an address builder fun calculateAddress( code: cell, data: cell, workchain: int ): builder { val addr = AutoDeployAddress { workchain, stateInit: ContractState { code, data } }; return addr.buildAddress(); } // Placeholder for the code cell encoded as a bag of cells fun getCode(): cell asm \"B{b5ee9c724101010100020000004cacb9cd} B>boc PUSHREF\"; // Placeholder for data that is usually assembled at runtime fun getData(): cell { return beginCell() .storeUint(123, 123) .storeSlice(\"hello, world\") .endCell(); } fun main() { val code = getCode(); val data = getData(); val workchain = BASECHAIN; val builderWithAddress = calculateAddress(code, data, workchain); // Example usage if the derived address has to be written in another cell. val exampleCell = beginCell() .storeBuilder(builderWithAddress) .endCell(); debug.print(exampleCell); } See all 38 lines The b5ee9c724101010100020000004cacb9cd in the getCode function is a placeholder for a hardcoded code cell in BoC format known at compile-time. The getData function is a placeholder for building a data cell, and the actual implementation depends on the storage layout of the target smart contract. Usually, data is composed in a parametrized way, but this does not alter the rest of the logic — only the getData function. The calculateAddress function uses the AutoDeployAddress built-in that handles all the underlying StateInit and address composing logic. In the Tolk stdlib, the code and data pair is represented by ContractState. The buildAddress method returns a builder containing the resulting address, which can be cheaply stored in another builder — the most common use case. ​On-chain — contract sharding When working with the contract sharding pattern, child contracts usually have a StateInit that depends on the parent. In the example below, the dependence is implemented by adding the parent address to the child StateInit. The same logic from the simple on-chain case works here, and only getData has to be changed. TolkCopyAsk AI// Compose an address builder using the AutoDeployAddress built-in. fun calculateAddress(code: cell, data: cell, workchain: int): builder { val addr = AutoDeployAddress { workchain, stateInit: ContractState { code, data } }; return addr.buildAddress(); } // Placeholder for the code cell encoded as a BoC. fun getCode(): cell asm \"B{b5ee9c724101010100020000004cacb9cd} B>boc PUSHREF\"; // Placeholder for child data that depends on the parent address. fun getChildData(parentAddress: address): cell { return beginCell() .storeSlice(\"hello, world\") .storeAddress(parentAddress) .endCell(); } fun main() { val code = getCode(); val parentAddress = contract.getAddress(); val data = getChildData(parentAddress); val workchain = BASECHAIN; val builderWithAddress = calculateAddress(code, data, workchain); // Example usage if the derived address has to be written in another cell. val exampleCell = beginCell() .storeBuilder(builderWithAddress) .endCell(); debug.print(exampleCell); } See all 35 lines Child contracts also often have some kind of index or additional data that they depend on, but it is case-specific and up to the implementation. The common pattern is to include at least the parent address in StateInit. ​On-chain — vanity A vanity contract allows customizing the address of a smart contract that is being deployed. It does that by making its own StateInit depend on some salt that is randomly generated many times until a desired address is found. In this case, there is no real correlation between the data the contract holds and its final address. So there is no way to actually derive the address. The only option left is to define a constant with the actual address that is obtained in advance. TolkCopyAsk AI// Constant address in raw format. const VANITY_ADDRESS_RAW: address = address(\"0:4de24b95c1c3c9b6a94231460716192c7d2b4e444ca6ae9a98bc5c4b3fcdef3f\"); // Constant address in user-friendly format. const VANITY_ADDRESS_USER_FRIENDLY: address = address(\"EQBN4kuVwcPJtqlCMUYHFhksfStOREymrpqYvFxLP83vP-Ci\"); fun main() { debug.print(VANITY_ADDRESS_RAW); debug.print(VANITY_ADDRESS_USER_FRIENDLY); } ​On-chain — prefixed The toShard field in AutoDeployAddress allows smart contracts to have a specific prefix in the address for the purpose of deploying it to a certain shardchain. This can be useful for cross-contract latency optimization, as in Jetton 2.0. This may seem similar to the vanity case, but it serves a different purpose. A vanity generator finds such a StateInit that an address composed from its hash will have certain letters in a prefix or suffix. The toShard does not alter the whole address and only tells the blockchain to replace the first few bits of the address to which the contract is being deployed. This optimization is used in Jetton 2.0. The logic here is more similar to the simple case. The only difference is the additional toShard field. TolkCopyAsk AI// Compose an address builder using the AutoDeployAddress built-in. fun deriveAddress(target: address, prefixLength: int): builder { val code = getCode(); val data = getData(); val workchain = BASECHAIN; val addr = AutoDeployAddress { workchain, stateInit: ContractState { code, data }, toShard: { fixedPrefixLength: prefixLength, closeTo: target } }; return addr.buildAddress(); } // Placeholder for the code cell encoded as a BoC. fun getCode(): cell asm \"B{b5ee9c724101010100020000004cacb9cd} B>boc PUSHREF\"; // Placeholder for data cell composition. fun getData(): cell { return beginCell().endCell(); } fun main() { // Using a constant as a target. val constTarget: address = address(\"0:AA00000000000000000000000000000000000000000000000000000000000000\"); val constBuilder = deriveAddress(constTarget, 8); // Example usage if the derived address has to be written in another cell. val constCell = beginCell() .storeBuilder(constBuilder) .endCell(); debug.print(constCell); // Using contract's own address as a target. val runtimeTarget = contract.getAddress(); val runtimeBuilder = deriveAddress(runtimeTarget, 8); // Example usage if the derived address has to be written in another cell. val runtimeCell = beginCell() .storeBuilder(runtimeBuilder) .endCell(); debug.print(runtimeCell); } See all 46 lines Prefix length limitThe max possible prefix length is defined in the blockchain config’s param 43 as max_acc_fixed_prefix_length. ​Off-chain derivation ​Off-chain — simple The logic mirrors the on-chain example. The @ton/core library has the contractAddress function that handles StateInit hash calculation and composes the address. CopyAsk AIimport { contractAddress, Cell, beginCell } from \"@ton/core\"; // constant code from a BoC const code = Cell.fromBoc( Buffer.from(\"b5ee9c724101010100020000004cacb9cd\", \"hex\"), )[0]; // data composing example const data = beginCell() .storeUint(123, 123) .storeStringTail(\"hello, world!\") .endCell(); const init = { code, data, }; const addr = contractAddress(0, init); console.log(addr); // EQC235M1tplyIg2OUQZQgG8D3BNF6_TZJ1932iaIV26XBVCH See all 21 lines ​Off-chain — contract sharding The logic mirrors the on-chain example. The parent address is hardcoded in this example but could just as well be derived on its own. CopyAsk AIimport { contractAddress, Cell, beginCell, Address } from \"@ton/core\"; // constant code from a BoC const code = Cell.fromBoc( Buffer.from(\"b5ee9c724101010100020000004cacb9cd\", \"hex\"), )[0]; const parentAddress = Address.parse( \"EQBKgXCNLPexWhs2L79kiARR1phGH1LwXxRbNsCFF9doc2lN\", ); const data = beginCell() .storeStringTail(\"hello, world!\") // include the parent address in the chil",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "deployment",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:28:05.595Z"
  },
  {
    "id": "docs-ton-org--ecosystem-wallet-apps-addresses-workflow",
    "title": "Addresses workflow",
    "url": "https://docs.ton.org/ecosystem/wallet-apps/addresses-workflow",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appswallet.ton.orgTonkeeperGet coins on testnetDeep linksAddresses workflowExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationWallet appsAddresses workflowEcosystemWallet appsAddresses workflowCopy pageCopy pageTo understand this article, it is necessary to periodically refer to account status page. At the moment, TON wallets work with addresses as follows: When receiving: Wallets display the user’s address in a user-friendly bounceable or non-bounceable form. When sending: A user sends a message with funds and, possibly, a comment to the destination’s wallet address in one of the user-friendly formats through the wallet application. The wallet app checks the validity of the destination address representation - its length, valid characters, prefix, and checksum. If the address is not valid, then an alert is shown and the sending operation is not performed. If the address has a testnet flag, and the wallet app works with the mainnet network, then an alert is shown and the sending operation is not performed. The wallet app reads the bounceable flag from the address. The wallet app checks the destination address. If it has the uninitialized status, the app force-sets the bounce field of the sending message to false and ignores the bounceable/non-bounceable flag from the address representation. If the destination is not uninitialized, then the wallet app uses the bounceable/non-bounceable flag from the address representation for the bounce field of the sending message. Was this page helpful?YesNoSuggest editsRaise issuePreviousOverviewNext⌘IgithubxtelegramPowered by Mintlify",
    "category": "wallets",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "testnet",
      "mainnet",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:28:08.482Z"
  },
  {
    "id": "docs-ton-org--foundations-serialization-merkle-update",
    "title": "Merkle updates",
    "url": "https://docs.ton.org/foundations/serialization/merkle-update",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationCellsLibrary referencesMerkle proofsMerkle updatesPruned branchesBag of cellsAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationSerializationMerkle updatesBlockchain foundationsSerializationMerkle updatesCopy pageCopy pageMerkle update cells always have two references, c1, c2, and behave like a Merkle proof for both. The level of a Merkle update cell, 0 <= l < 3, is determined as max{Lvl(c1) - 1, Lvl(c2) - 1, 0}. Each Merkle update cell serializes as follows: one tag byte with value 0x04; the 256-bit higher hash of the referenced cell c1 or the representation hash of c if its level equals zero; the same for the second reference c2; 2 bytes that store the depth of the old deleted subtree that was replaced by the reference c1; 2 bytes that store the depth of the new deleted subtree that was replaced by the reference c2. Was this page helpful?YesNoSuggest editsRaise issuePreviousPruned branchesNext⌘IgithubxtelegramPowered by Mintlify",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:28:11.207Z"
  },
  {
    "id": "docs-ton-org--foundations-actions-overview",
    "title": "Actions",
    "url": "https://docs.ton.org/foundations/actions/overview",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsOverviewSend messageReserve coinsSet codeChange libraryConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationActionsActionsBlockchain foundationsActionsActionsCopy pageCopy pageThere are four actions that a smart contract can perform during the action phase: send a message; reserve coins; change its libraries; change its code. A smart contract can create up to 255 such actions during its execution. Actions are created during the compute phase by special TVM instructions. When an action is created, it is populated into the output action list of the smart contract. From the low-level perspective, the output action list is a linked list where each action is represented as a cell. Finally, in the action phase, created actions are executed in the order they were populated into the output action list. CopyAsk AIout_list_empty$_ = OutList 0; out_list$_ {n:#} prev:^(OutList n) action:OutAction = OutList (n + 1); action_send_msg#0ec3c86d mode:(## 8) out_msg:^(MessageRelaxed Any) = OutAction; action_set_code#ad4de08e new_code:^Cell = OutAction; action_reserve_currency#36e6b809 mode:(## 8) currency:CurrencyCollection = OutAction; libref_hash$0 lib_hash:bits256 = LibRef; libref_ref$1 library:^Cell = LibRef; action_change_library#26fa1dd4 mode:(## 7) libref:LibRef = OutAction; Was this page helpful?YesNoSuggest editsRaise issuePreviousSend messageNext⌘IgithubxtelegramPowered by Mintlify",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:28:15.396Z"
  },
  {
    "id": "docs-ton-org--languages-tolk-basic-syntax",
    "title": "Tolk basic syntax",
    "url": "https://docs.ton.org/languages/tolk/basic-syntax",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedOverviewBasic syntaxIdioms and conventionsType systemSyntax detailsLanguage featuresMigrating from FunCChangelogTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationTolkTolk basic syntaxLanguagesTolkTolk basic syntaxCopy pageCopy pageSyntax of Tolk is similar to TypeScript, Rust, and Kotlin. It is designed to be straightforward to read and write. Below is a list of basic syntax elements with examples. Most sections end with a link to a detailed topic. ​Imports Imports exist at the top of the file: CopyAsk AIimport \"another-file\" // symbols from `another-file.tolk` can now be used In typical workflows, an IDE inserts imports automatically (for example, when selecting an element from auto‑completion). The entire file is imported. There are no “modules” or “exports”, all symbols must have unique names project-wise. See: imports. ​Structures A struct Point holding two 8-bit integers: CopyAsk AIstruct Point { x: int8 y: int8 } fun demo() { // create an object val p1: Point = { x: 10, y: 20 }; // the same, type of p2 is auto-inferred val p2 = Point { x: 10, y: 20 }; } methods are declared like fun Point.method(self), read below fields can be of any types: numeric, cell, union, etc. (see type system) fields can have default values: x: int8 = 0 fields can be private and readonly structs can be generic: struct Wrapper<T> { ... } If all fields are serializable, a struct can be automatically serialized: CopyAsk AI// makes a cell containing hex \"0A14\" val c = p1.toCell(); // back to { x: 10, y: 20 } val p3 = Point.fromCell(c); See: structures. ​Functions A function that calculates the sum of two integers: CopyAsk AIfun sum(a: int, b: int): int { return a + b; } parameter types are mandatory the return type can be omitted: it will be auto-inferred, like in TypeScript parameters can have a default value: fun f(b: int = 0) statements inside a block are separated by semicolons ; generic functions: fun f<T>(value: T) { ... } assembler functions: fun f(...): int asm \"...\" See: functions and methods. ​Methods A function declared as fun <receiver>.name(...) is a method. if the first parameter is self, it’s an instance method if not self, it’s a static method CopyAsk AI// `self` — instance method (invoked on a value) fun Point.sumCoords(self) { return sum(self.x, self.y); } // not `self` — static method fun Point.createZero(): Point { return { x: 0, y: 0 }; } fun demo() { val p = Point.createZero(); // { 0, 0 } return p.sumCoords(); // 0 } by default, self is immutable, but mutate self allows modifying an object methods may be declared not only for a struct, but for any type, even a primitive: CopyAsk AIfun int.isNegative(self) { return self < 0 } See: functions and methods. ​Variables Inside functions, variables are declared with val or var keywords. The val keyword declares a variable that is assigned exactly once (immutable): CopyAsk AIval coeff = 5; // cannot change its value, `coeff += 1` is an error The var keyword declares a variable that may be reassigned: CopyAsk AIvar x = 5; x += 1; // now 6 Variable’s type can be specified after its name: CopyAsk AIvar x: int8 = 5; Declaring variables at the top-level (not inside functions) is supported via global keyword. See: variables. ​Constants Declaring constants is allowed at the top-level (not inside functions): CopyAsk AIconst ONE = 1 const MAX_AMOUNT = ton(\"0.05\") const ADMIN_ADDRESS = address(\"EQ...\") To group integer constants, enums are also useful. ​Value semantics Tolk follows value semantics: assignments create independent copies, and function calls do not mutate arguments unless explicitly specified. CopyAsk AIvar a = Point { x: 1, y: 2 }; var b = a; // `b` is a copy b.x = 99; // `a.x` remains 1 someFn(a); // pass a copy; `a` will not change // but there can be mutating functions, called this way: anotherFn(mutate a); See: mutability. ​Semicolons semicolons are optional at the top-level (after imports, aliases, etc.) required between statements in a function after the last statement in a block, it’s also optional CopyAsk AI// optional at the top-level const ONE = 1 type UserId = int // required inside functions fun demo() { val x = 5; val y = 6; return x + y // optional after the last statement } ​Comments Like most modern languages, Tolk supports single-line (or end-of-line) and multi-line (block) comments: CopyAsk AI// This is a single-line comment /* This is a block comment across multiple lines. */ const TWO = 1 /* + 100 */ + 1 // 2 ​Conditional operators CopyAsk AIfun sortNumbers(a: int, b: int) { if (a > b) { return (b, a) } else { return (a, b) } } In Tolk, if is a statement, with else if and else optional blocks. A ternary operator is also available: CopyAsk AIval sign = a > 0 ? 1 : a < 0 ? -1 : 0; See: conditions and loops. ​Union types and matching Union types allow a variable to hold “one of possible types”. They are typically handled by match: CopyAsk AIfun processValue(value: int | slice) { match (value) { int => { value * 2 } slice => { value.loadUint(8) } } } Alternatively, test a union with is or !is operators: CopyAsk AIfun processValue(value: int | slice) { if (value is slice) { // call methods for `slice` return; } // value is `int` return value * 2; } Unions types are commonly used when handling incoming messages. See: union types. ​While loop CopyAsk AIwhile (i > 0) { // ... i -= 1; } The for loop does not exist. See: conditions and loops. ​Assert and throw CopyAsk AIconst ERROR_NO_BALANCE = 403; // in some function throw ERROR_NO_BALANCE; // or conditional throw assert (balance > 0) throw ERROR_NO_BALANCE; A try-catch statement is also supported, although it is not commonly used in contracts. See: exceptions. ​Iterate over a map CopyAsk AIfun iterateOverMap(m: map<int32, Point>) { var r = m.findFirst(); while (r.isFound) { // ... r = m.iterateNext(r); } } See: maps. ​Send a message to another contract An outgoing message body is typically represented by a structure (for example, RequestedInfo). CopyAsk AIval reply = createMessage({ bounce: BounceMode.NoBounce, value: ton(\"0.05\"), dest: someAddress, body: RequestedInfo { ... } }); reply.send(SEND_MODE_REGULAR); See: constructing and sending messages. ​Contract getters Contract getters (or “get methods”) are declared with get fun: CopyAsk AIget fun currentOwner() { val storage = lazy Storage.load(); return storage.ownerAddress; } See: contract getters.Was this page helpful?YesNoSuggest editsRaise issuePreviousIdioms and conventionsNext⌘IgithubxtelegramPowered by MintlifyOn this pageImportsStructuresFunctionsMethodsVariablesConstantsValue semanticsSemicolonsCommentsConditional operatorsUnion types and matchingWhile loopAssert and throwIterate over a mapSend a message to another contractContract getters",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:28:17.351Z"
  },
  {
    "id": "docs-ton-org--languages-tolk-idioms-conventions",
    "title": "Idioms and conventions",
    "url": "https://docs.ton.org/languages/tolk/idioms-conventions",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedOverviewBasic syntaxIdioms and conventionsType systemSyntax detailsLanguage featuresMigrating from FunCChangelogTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationTolkIdioms and conventionsLanguagesTolkIdioms and conventionsCopy pageCopy pageThis section summarizes common patterns and conventions used in idiomatic Tolk code. While Basic syntax introduces the language itself, this page outlines the preferred ways of expressing ideas and best practices in Tolk. It may serve as a style reference throughout development. ​Auto-serialization instead of slices/builders Tolk type system is designed to entirely avoid manual cell parsing. The presence of beginCell() indicates a possibly wrong approach. All practical use cases in contract interaction are expressed with structures, unions, and references. CopyAsk AIstruct Holder { owner: address lastUpdated: uint32 extra: Cell<ExtraInfo> } fun demo(data: Holder) { // make a cell with 299 bits and 1 ref val c = data.toCell(); // unpack it back val holder = Holder.fromCell(c); } Familiar with TL-B?The type system is considered as a replacement for TL-B. Read Tolk vs TL-B. See: automatic serialization. ​Cell<T> — a “cell with known shape” All data in TON is stored in cells that reference each other. To express clear data relation, use typed cells — Cell<T>. Literally, it means: a cell whose contents is T: CopyAsk AIstruct Holder { // ... extra: Cell<ExtraInfo> } struct ExtraInfo { someField: int8 // ... } fun getDeepData(value: Holder) { // `value.extra` is a reference // use `load()` to access its contents val data = value.extra.load(); return data.someField; } See: cell references in serialization. ​Not “fromCell”, but “lazy fromCell” In practice, when reading data from cells, prefer lazy: lazy SomeStruct.fromCell(c) over SomeStruct.fromCell(c) lazy typedCell.load() over typedCell.load() The compiler loads only requested fields, skipping the rest. It reduces gas consumption and bytecode size. CopyAsk AIget fun publicKey() { val st = lazy Storage.load(); // <-- here \"skip 65 bits, preload uint256\" is inserted return st.publicKey } See: lazy loading. ​Custom serializers — if can’t express with types Even though the type system is very rich, there still may occur situations where binary serialization is non-standard. Tolk allows to declare custom types with arbitrary serialization rules. CopyAsk AItype MyString = slice fun MyString.packToBuilder(self, mutate b: builder) { // custom logic } fun MyString.unpackFromSlice(mutate s: slice) { // custom logic } And just use MyString as a regular type — everywhere: CopyAsk AIstruct Everywhere { tokenName: MyString fullDomain: Cell<MyString> } An interesting example. Imagine a structure which tail is signed: CopyAsk AIstruct SignedRequest { signature: uint256 // hash of all data below is signed field1: int32 field2: address? // ... } The task is to parse it and check signature. A manual solution is obvious: read uint256, calculate the hash of the remainder, read other fields. What about the type system? Even this complex scenario can be expressed by introducing a synthetic field that is populated on loading: CopyAsk AItype HashOfRemainder = uint256 struct SignedRequest { signature: uint256 restHash: HashOfRemainder // populated on load field1: int32 field2: address? // ... } fun HashOfRemainder.unpackFromSlice(mutate s: slice) { // `s` is after reading `signature` in our case; // we don't need to load anything — // just calculate the hash on the fly return s.hash() } fun demo(input: slice) { val req = SignedRequest.fromSlice(input); assert (req.signature == req.restHash) throw XXX; } See: serialization of type aliases. ​Contract storage = struct + load + save Contract storage is a regular struct, serialized into persistent on-chain data. It is convenient to add load and store methods: CopyAsk AIstruct Storage { counterValue: int64 } fun Storage.load() { return Storage.fromCell(contract.getData()) } fun Storage.save(self) { contract.setData(self.toCell()) } See: contract storage. ​Message = struct with a 32-bit prefix By convention, every message in TON has an opcode — a unique 32-bit number. In Tolk, every struct can have a “serialization prefix” of arbitrary length. 32-bit prefixes are called opcodes. So, every incoming and outgoing message is a struct with a prefix: CopyAsk AIstruct (0x12345678) CounterIncrement { // ... } Guidelines for choosing opcodes When implementing jettons, NFTs, and other standards, use predefined prefixes according to the specification of each TEP. When developing custom protocols, use any random numbers. See: structures. ​Handle a message = structs + union + match The suggested pattern to handle messages: each incoming message is a struct with an opcode combine these structs into a union parse it via lazy fromSlice and match over variants CopyAsk AIstruct (0x12345678) CounterIncrement { incBy: uint32 } struct (0x23456789) CounterReset { initialValue: int64 } type AllowedMessage = CounterIncrement | CounterReset fun onInternalMessage(in: InMessage) { val msg = lazy AllowedMessage.fromSlice(in.body); match (msg) { CounterIncrement => { // use `msg.incBy` } CounterReset => { // use `msg.initialValue` } else => { // invalid input; a typical reaction is: // ignore empty messages, \"wrong opcode\" if not assert (in.body.isEmpty()) throw 0xFFFF } } } Notice lazy: it also works with unions and does “lazy match” by a slice prefix. It’s much more efficient than manual parsing an opcode and branching via if (op == TRANSFER_OP). See: handling messages and pattern matching. ​Send a message = struct + createMessage To send a message from contract A to contract B, declare a struct, specify an opcode and fields expected by a receiver use createMessage + send CopyAsk AIstruct (0x98765432) RequestedInfo { // ... } fun respond(/* ... */) { val reply = createMessage({ bounce: BounceMode.NoBounce, value: ton(\"0.05\"), dest: addressOfB, body: RequestedInfo { // ... initialize fields } }); reply.send(SEND_MODE_REGULAR); } When both contracts are developed in the same project (sharing common codebase), such a struct is both an outgoing message for A and an incoming message for B. ​Deploy another contract = createMessage A common case: a minter deploys a jetton wallet, knowing wallet’s code and initial state. This “deployment” is actually sending a message, auto-attaching code+data, and auto-calculating its address: CopyAsk AIval deployMsg = createMessage({ // address auto-calculated, code+data auto-attached dest: { stateInit: { code: jettonWalletCode, data: emptyWalletStorage.toCell(), } } }); A preferred way is to extract generating stateInit to a separate function, because it’s used not only to send a message, but also to calculate/validate an address without sending. CopyAsk AIfun calcDeployedJettonWallet(/* ... */): AutoDeployAddress { val emptyWalletStorage: WalletStorage = { // ... initialize fields from parameters }; return { stateInit: { code: jettonWalletCode, data: emptyWalletStorage.toCell() } } } fun demoDeploy() { val deployMsg = createMessage({ // address auto-calculated, code+data auto-attached dest: calcDeployedJettonWallet(...), // ... }); deployMsg.send(mode); } See: tolk-bench repo for reference jettons. ​Shard optimization = createMessage “Deploy a contract to a specific shard” is also done with the same technique. For example, in sharded jettons, a jetton wallet must be deployed to the same shard as the owner’s wallet. CopyAsk AIval deployMsg = createMessage({ dest: { stateInit: { code, data }, toShard: { closeTo: ownerAddress, fixedPrefixLength: 8 } } }); Following the guideline above, the task is resolved by adding just a couple lines of code. Sharding will automatically be supported in createMessage and other address calculations. CopyAsk AIfun calcDeployedJettonWallet(/* ... */): AutoDeployAddress { // ... return { stateInit: ..., toShard: { closeTo: ownerAddress, fixedPrefixLength: SHARD_DEPTH } } } See: sharding in createMessage. ​Emitting events/logs to off-chain Emitting events and logs “to the outer world” is done via external messages. They are useful for monitoring: being indexed by TON indexers, they show “a picture of on-chain activity”. These are also messages and also cost gas, but are constructed in a slightly different way. Create a struct to represent the message body Use createExternalLogMessage + send CopyAsk AIstruct DepositEvent { // ... } fun demo() { val emitMsg = createExternalLogMessage({ dest: createAddressNone(), body: DepositEvent { // ... } }); emitMsg.send(SEND_MODE_REGULAR); } See: sending external messages. ​Return a struct from a get method When a contract getter (get fun) needs to return several values — introduce a structure and return it. Do not return unnamed tensors like (int, int, int). Field names provide clear metadata for client wrappers and human readers. CopyAsk AIs",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "deployment",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "react",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:28:19.460Z"
  },
  {
    "id": "docs-ton-org--languages-tolk-changelog",
    "title": "Changelog",
    "url": "https://docs.ton.org/languages/tolk/changelog",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedOverviewBasic syntaxIdioms and conventionsType systemSyntax detailsLanguage featuresMigrating from FunCChangelogTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationTolkChangelogLanguagesTolkChangelogCopy pageCopy page​v1.2 Introduced address as “internal only”. Delivered rich bounces: return the full body instead of 256 bits. Provided low-cost builder-to-slice, StateInit, and address composition. Improved compilation errors. Added support for anonymous functions. Added the borrow checker and related undefined-behavior checks. ​v1.1 Added map<K, V> — a wrapper over TVM dictionaries. Added enum — group numeric constants into a distinct type. Added private and readonly fields in structures. Enhanced overload resolution and partial specialization. ​v1.0 Added the lazy keyword. Added auto-detect and inline functions at the compiler level. Added various peephole optimizations for gas efficiency. Added onInternalMessage and onBouncedMessage, TVM 11 support. Added custom pack and unpack serializers for custom types. ​v0.99 Added createMessage. Added createExternalLogMessage. Added sharding support for calculating addresses “close to another contract”. ​v0.13 Added auto-packing to and from cells, builders, and slices. Added type address. Added Lateinit variables. Added defaults for parameters. ​v0.12 Added structures struct A { ... }. Added generics struct<T> and type<T>. Added methods fun Point.getX(self). Renamed stdlib functions to short methods. ​v0.11 Added type aliases type NewName = <existing type>. Added union types T1 | T2 | .... Added pattern matching for types. Added the is and !is operators. Added pattern matching for expressions. Allowed the semicolon to be omitted for the last statement in a block. ​v0.10 Added fixed-width integers such as int32 and uint64. Added the coins type and the ton(\"0.05\") function. Added bytesN and bitsN types backed by slices at the TVM level. Replaced \"...\"c postfixes with stringCrc32(\"...\") functions. Added support 0b... number literals in addition to 0x.... Added support trailing commas. ​v0.9 Added nullable types int?, cell?, and others; introduce null safety. Updated the standard library, includingasm definitions, to support nullability. Introduced smart casts, like in TypeScript and Kotlin. Added the ! operator (non-null assertion). Treated code after throw as unreachable. Added the never type. ​v0.8 Introduced syntax tensorVar.0 and tupleVar.0 for reading and writing. Allowed cell, slice, and similar terms to be used as valid identifiers rather than keywords. ​v0.7 Refactored compiler internals and introduce an AST-level semantic analysis kernel. Changed the type system to static typing. Provided clear and readable error messages for type mismatch. Added generic functions fun f<T>(...) and instantiations such as f<int>(...). Added bool type and type casting through value as T. ​v0.6 The first public release. Tolk is a fork of FunC with iterative improvements. In 2024, a pull request for FunC v0.5.0 was submitted together with a roadmap for further development. Instead of merging it, it was forked. Tolk was first announced at TON Gateway in 2024. The released version was marked v0.6, indicating its relation to the FunC v0.5.Was this page helpful?YesNoSuggest editsRaise issuePreviousOverviewNext⌘IgithubxtelegramPowered by MintlifyOn this pagev1.2v1.1v1.0v0.99v0.13v0.12v0.11v0.10v0.9v0.8v0.7v0.6",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:28:21.438Z"
  },
  {
    "id": "docs-ton-org--languages-tolk-from-func-tolk-vs-func",
    "title": "Tolk vs FunC",
    "url": "https://docs.ton.org/languages/tolk/from-func/tolk-vs-func",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedOverviewBasic syntaxIdioms and conventionsType systemSyntax detailsLanguage featuresMigrating from FunCTolk vs FunCTolk vs TL-BStandard librariesConverterChangelogTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationMigrating from FunCTolk vs FunCLanguagesTolkMigrating from FunCTolk vs FunCCopy pageCopy pageFunC is the first high-level language for writing smart contracts in TON. For years, it was the only option. Lots of production code was written in FunC, and it will always be alive on-chain and in developers’ hearts. Tolk replaces FunC with modern syntax, a robust type system, and built-in serialization — while generating efficient assembly code. Released in 2025, now it is considered the primary language for the TON ecosystem. ​How to migrate from FunC to Tolk Scan the list below to get the overall picture. Explore the tolk-bench repo as a source of reference contracts. Use the FunC-to-Tolk converter to migrate existing projects. ​Gas benchmarks The tolk-bench repository compares FunC and Tolk on several TEPs. For every metric measured, gas consumption reduced 30–50%. Primarily it’s a result of the language design. ​What Tolk and FunC have in common Both languages target into Fift assembler. Tolk is not “a wrapper” that transpiles to FunC — it has its own semantic and optimization kernel. Both languages work on TVM after being compiled to bytecode. TVM is a stack machine, imposing architectural and runtime restrictions. Both languages have IDE plugins, although support for Tolk is way better: JetBrains IDEs, VS Code, Cursor, Windsurf, etc. Both languages are available in blueprint and other client-side tooling. Command-line mode is also supported. But all language aspects are completely different — a huge list below. ​List of “Tolk vs FunC” differences Tolk and FunC are completely different. It’s even inaccurate to compare them — the difference lies in the design, not in syntax. Nevertheless, let’s try to summarize the details. ​Tolk reminds TypeScript and Rust FunC: resembles C (“FunC” stands for “functional C”) Tolk: resembles TypeScript, Rust, and Kotlin CopyAsk AIfun sum(a: int, b: int): int { return a + b; } See: basic syntax. ​Tolk has structures FunC: return long unnamed tensors such as (int, slice, int, int) Tolk: declare a struct, it’s the same efficient CopyAsk AIstruct Demo { previousValue: int256 ownerAddress: address effectsCount: uint32 totalAmount: coins } See: structures. ​Automatic serialization FunC: manual bit-level work with builders and slices Tolk: declare a struct and call fromCell and toCell CopyAsk AIstruct Point { x: int8 y: int8 } fun demo() { var value: Point = { x: 10, y: 20 }; // makes a cell containing \"0A14\" (hex) var c = value.toCell(); // back to { x: 10, y: 20 } var p = Point.fromCell(c); } Pay attention to the use of int8, uint64, coins — all of them are TVM integers (see numbers). See: automatic serialization. ​Lazy loading FunC: for optimization, manual juggling with preloads and skips Tolk: the lazy keyword loads only requested fields skipping the rest CopyAsk AIget fun publicKey() { val st = lazy Storage.load(); // <-- here \"skip 65 bits, preload uint256\" is inserted return st.publicKey } See: lazy loading. ​The bool type FunC: only integers, ‘true’ is -1, ‘false’ is 0; ifnot Tolk: type bool and logical operators && || ! are supported CopyAsk AIif (trustInput || validate(input)) { // ... } See: booleans. ​The address type FunC: only slices (binary data); parse and compare bits Tolk: type address with convenient methods and operator == CopyAsk AIif (in.senderAddress == storage.ownerAddress) { val workchain = storage.ownerAddress.getWorkchain(); // ... } See: address. ​Null safety FunC: any variable can hold null, which may lead to runtime errors Tolk: provides nullable types T?, null safety, and smart casts CopyAsk AIfun checkWithOptional(a: int, b: int?): bool { if (b == null) { return checkSingle(a); } return b >= 0 && checkDouble(a, b); } See: nullability. ​Everything else in the type system FunC: several types exposing TVM primitives Tolk: a wide range of types, including unions, generics, and enums CopyAsk AIstruct Container<T> { element: T? } struct Nothing type Wrapper<T> = Nothing | Container<T> See: type system overview. ​Methods for any types FunC: global-scope functions only Tolk: both functions and methods — for structures and even primitives CopyAsk AI// no `self` — static method fun Point.createZero(): Point { return { x: 0, y: 0 } } // has `self` — instance method fun Point.sumCoords(self) { return self.x + self.y } // even for primitives: cells, integers, tuples, etc. fun tuple.isEmpty(self) { return self.size() == 0 } See: functions and methods. ​No impure keyword FunC: once impure is forgotten, a call may be dropped Tolk: the compiler does not remove user function calls CopyAsk AIfun validate(input: SomeStruct) { // ... } ​No ~tilde methods FunC: x~f() and x.f() are different (mutating and not) Tolk: only the dot — a single, consistent way to call methods CopyAsk AIval delta = someSlice.loadUint(32); // mutates someSlice val owner = someSlice.loadAddress(); See: mutability. ​Native maps over TVM dictionaries FunC: m~idict_set_builder(1,32,begin_cell().store_uint(10,32)) Tolk: m.set(1, 10) CopyAsk AIvar m: map<int8, int32> = createEmptyMap(); m.set(1, 10); m.addIfNotExists(2, -20); m.delete(2); // now: [ 1 => 10 ] See: maps. ​Modern message handling FunC: () recv_internal(4 params) and parse a message cell Tolk: fun onInternalMessage(in) and use in.senderAddress, etc. CopyAsk AIfun onInternalMessage(in: InMessage) { // internal non-bounced messages arrive here in.senderAddress; in.originalForwardFee; // and other fields } fun onBouncedMessage(in: InMessageBounced) { // bounced messages arrive here } See: message handling. ​No if (op == OP_TRANSFER) for opcodes FunC: if-else to route an incoming message based on opcode Tolk: use union types and pattern matching CopyAsk AItype MyMessage = | CounterIncBy | CounterReset // ... fun onInternalMessage(in: InMessage) { val msg = lazy MyMessage.fromSlice(in.body); match (msg) { CounterIncBy => { // ... } CounterReset => { // ... } // ... } } See: pattern matching. ​No “ignore empty messages” pattern FunC: recv_internal() starts with if (slice_empty?(...)) Tolk: just use else in match CopyAsk AIfun onInternalMessage(in: InMessage) { val msg = lazy MyMessage.fromSlice(in.body); match (msg) { CounterReset => { /* ... */ } // ... handle all variants of the union else => { // for example: ignore empty messages if (in.body.isEmpty()) { return } throw 0xFFFF } } } See: lazy matching. ​Native message composition FunC: store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1) etc. Tolk: createMessage that auto-detects body ref or not CopyAsk AIval reply = createMessage({ bounce: BounceMode.NoBounce, value: ton(\"0.05\"), dest: senderAddress, body: RequestedInfo { ... } }); reply.send(SEND_MODE_REGULAR); See: message sending. ​Native deployment and StateInit FunC: manually pack contract’s code and data according to TL-B Tolk: createMessage auto-computes destination CopyAsk AIval deployMsg = createMessage({ // address auto-calculated, code+data auto-attached dest: { stateInit: { code: contractCodeCell, data: emptyStorage.toCell(), }, // optionally control workchains and sharding } }); See: message sending. ​op::increase is not a valid identifier FunC: allows any symbols in identifiers, even var 2+2 = ... is ok Tolk: alphanumeric identifiers, 2+2 is 4, as expected CopyAsk AIconst OP_INCREASE = 0x12345678 See: variables. ​Small functions are inlined automatically FunC: prefer larger functions for reduced gas consumption Tolk: the compiler auto-inlines functions with zero overhead CopyAsk AIfun int.zero() { return 0 } fun int.inc(mutate self, byValue: int = 1): self { self += byValue; return self; } fun main() { return int.zero().inc().inc() } is reduced to “return 2” in assembler: CopyAsk AImain() PROC:<{ 2 PUSHINT }> Note: inline modifier in FunC works at the Fift level, it’s sub-optimal due to extra stack permutations. In Tolk, inlining works at the compiler level and is combined with constant folding. See: compiler optimizations. ​Consecutive builder.storeUint are merged FunC: manually combine constant stores into b.storeUint(0x18,6) Tolk: merges b.storeUint(...).storeUint(...) if constant CopyAsk AIb.storeUint(0, 1) .storeUint(1, 1) .storeUint(1, 1) .storeUint(0, 1) .storeUint(0, 2) is translated to just CopyAsk AIb{011000} STSLICECONST See: compiler optimizations. ​Standard library redesigned Functions from stdlib.fc now use longer, descriptive naming: FunCTolkcur_lt()blockchain.logicalTime()car(l)listGetHead(l)raw_reserve(coins)reserveToncoinsOnBalance(coins)~dump(x)debug.print(x) Many global-scope functions became methods for primitives: FunCTolks.slice_hash()s.hash()equal_slices_bits(a, b)a.bitsEqual(b)t.tuple_len()t.size()t~tpush",
    "category": "languages",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "deployment",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:28:23.790Z"
  },
  {
    "id": "docs-ton-org--languages-tolk-from-func-converter",
    "title": "FunC-to-Tolk converter",
    "url": "https://docs.ton.org/languages/tolk/from-func/converter",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedOverviewBasic syntaxIdioms and conventionsType systemSyntax detailsLanguage featuresMigrating from FunCTolk vs FunCTolk vs TL-BStandard librariesConverterChangelogTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationMigrating from FunCFunC-to-Tolk converterLanguagesTolkMigrating from FunCFunC-to-Tolk converterCopy pageCopy pageThe converter allows any FunC project to be transformed into Tolk with a single command: CopyAsk AInpx @ton/convert-func-to-tolk contracts This is a syntax-level converter that assists in migrating contracts to Tolk. It rewrites FunC code with one-to-one semantics and emits a Tolk version of the contract that remains close to the FunC original. Example input: jetton-minter.fc. Example output: jetton-minter.tolk. The converted contract does not use modern Tolk features such as structures, auto-serialization, or clean message composition. After some manual fixes, it compiles, runs, and passes tests. If a contract does not compile after conversion, refer to the GitHub repository. It contains common issues and provides ways to fix them. ​Refactoring Use the modern onInternalMessage. Extract a Storage struct with toCell and fromCell. Refactor incoming messages into structs with 32-bit opcodes – incrementally, one message at a time. Define a union of possible messages and match it using lazy. Extract outgoing messages into structs and send them. Maintain tests at every stageKeeping tests passing throughout the refactoring process ensures safe, incremental modernization without breaking functionality. ​Examples Tolk vs FunC benchmarks repository contains contracts migrated from FunC, preserving the original logic and passing the same tests. To see how each contract was rewritten step by step, use the Git history.Was this page helpful?YesNoSuggest editsRaise issuePreviousChangelogNext⌘IgithubxtelegramPowered by MintlifyOn this pageRefactoringExamples",
    "category": "languages",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:28:25.646Z"
  },
  {
    "id": "docs-ton-org--languages-tolk-types-list-of-types",
    "title": "Type system overview",
    "url": "https://docs.ton.org/languages/tolk/types/list-of-types",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedOverviewBasic syntaxIdioms and conventionsType systemList of typesNumbersBooleansAddressCells, slices, buildersStringsStructuresType aliasesGenericsEnumsNullable typesUnion typesTensorsTuplesMapsCallablesVoid and neverType checks and castsOverall: TVM stackOverall: serializationSyntax detailsLanguage featuresMigrating from FunCChangelogTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationType systemType system overviewLanguagesTolkType systemType system overviewCopy pageCopy pageTolk has the following types: numbers — int, int32, uint64, coins, and others. boolean — true and false. address — internal, external, and none. cells — containers with up to 1023 bits of data and up to 4 references to other cells, plus the cell manipulation primitives of TVM: builders and slices. structures — multiple fields grouped into one entity. generics — any struct can be generic <T>. enums — distinct types containing integer variants. nullable types — null safety and safe casts. union types — variables holding one of several possible values. tensors — multiple values placed sequentially on the stack. tuples — multiple values stored in a single TVM tuple. maps — key-value dictionaries. callables — first-class functions. void and never — both represent the absence of a value. To make an interchangeable alias for an existing type, including structural types, there are type aliases. Smart contracts run on a stack-based virtual machine, TVM, which imposes specific rules on how values are represented at runtime. For example, there is no distinct type for strings — they are not native to TVM and thus are emulated using slices. All on-chain data and communication rely entirely on cells, so the type system focuses on binary serialization and clear data relationships: Type checks and casts covers casting with the unsafe as operator. TVM stack representation summarizes how types map to the TVM stack. Serialization describes how types serialize and relate to TL-B. Was this page helpful?YesNoSuggest editsRaise issuePreviousNumbersNext⌘IgithubxtelegramPowered by Mintlify",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:28:28.088Z"
  },
  {
    "id": "docs-ton-org--languages-tolk-features-message-handling",
    "title": "Handling messages",
    "url": "https://docs.ton.org/languages/tolk/features/message-handling",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedOverviewBasic syntaxIdioms and conventionsType systemSyntax detailsLanguage featuresHandling messagesContract storageContract gettersSending messagesAutomatic serializationLazy loadingPayload in jettonsStandard libraryAssembler functionsCompiler optimizationsMigrating from FunCChangelogTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationLanguage featuresHandling messagesLanguagesTolkLanguage featuresHandling messagesCopy pageCopy pageEach Tolk contract has specials entrypoints — reserved functions to handle various types of messages. From the language perspective, handling an incoming message is just ordinary code. ​onInternalMessage In 99% of cases, a contract handles internal messages. An end user does not interact with a contract directly; instead, interaction occurs through the user’s wallet, which sends an internal message to the contract. The entrypoint is declared this way: CopyAsk AIfun onInternalMessage(in: InMessage) { // internal non-bounced messages arrive here } A basic guideline is the following: For each incoming message, declare a struct with a unique 32-bit prefix (opcode). Declare a union type “all available messages”. Parse this union from in.body and match it over structures. CopyAsk AIstruct (0x12345678) CounterIncrement { incBy: uint32 } struct (0x23456789) CounterReset { initialValue: int64 } type AllowedMessage = CounterIncrement | CounterReset fun onInternalMessage(in: InMessage) { val msg = lazy AllowedMessage.fromSlice(in.body); match (msg) { CounterIncrement => { // use `msg.incBy` } CounterReset => { // use `msg.initialValue` } else => { // invalid input; a typical reaction is: // ignore empty messages, \"wrong opcode\" if not assert (in.body.isEmpty()) throw 0xFFFF } } } ​Brief explanation of the example struct declares any business data (particularly, messages and storage). It’s like a TypeScript class. See structures. (0x12345678) is called a “message opcode” (32 bit). Unique prefixes help routing in.body (binary data). AllowedMessage is a type alias for a union type, similar to TypeScript (and in some way, to Rust’s enums). See union types. in: InMessage provides access to message properties: in.body, in.senderAddress, and so on. T.fromSlice parses binary data to T. See auto-serialization. Combined with lazy, it’s done on demand. See lazy loading. match routes a union type. Inside each branch, type of msg is narrowed (called “smart cast”). See pattern matching. throw 0xFFFF is a standard reaction on “unrecognized message”. But typically, a contract should ignore empty messages: it’s “just top-up balance” (send some Toncoin, body is empty). That’s why throw is wrapped by if or assert. See conditions and loops. Bounced messages do not enter onInternalMessage. Read onBouncedMessage below. ​How to define and modify contract’s storage A storage is also a regular structure. It’s convenient to add load and store methods accessing blockchain’s persistent data: CopyAsk AIstruct Storage { counterValue: int64 } fun Storage.load() { return Storage.fromCell(contract.getData()) } fun Storage.save(self) { contract.setData(self.toCell()) } Then, in match cases, invoke those methods: CopyAsk AImatch (msg) { CounterIncrement => { var storage = lazy Storage.load(); storage.counterValue += msg.incBy; storage.save(); } // ... } Alternatively, load the storage above match instead of doing it in every branch. For further reading, consider contract’s storage in details. ​Old-fashioned onInternalMessage In old times, a handler was declared this way in FunC language: CopyAsk AI() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure { ;; manually parse in_msg_full to retrieve sender_address and others } Tolk also allows to use old-style declarations: CopyAsk AIfun onInternalMessage(myBalance: coins, msgValue: coins, msgFull: cell, msgBody: slice) { // manually parse msgFull to retrieve senderAddress and others } For instance, after using convert-func-to-tolk, the result is exactly as above. Prefer using a modern solution with InMessage: it’s not only easier, but also cheaper in gas terms. Transitioning after auto-conversion is trivial: myBalance => contract.getOriginalBalance() (it’s not a property of a message, it’s a state of a contract) msgValue => in.valueCoins msgFull => use in.senderAddress etc., no need for manual parsing msgBody => in.body ​onBouncedMessage A special entrypoint for handling bounced messages also exists. When a contract sends a message to another, but the another fails to handle it, a message is bounced back to the sender. CopyAsk AIfun onBouncedMessage(in: InMessageBounced) { // messages sent with BounceMode != NoBounce arrive here } InMessageBounced is very similar to InMessage. The only difference is that in.bouncedBody has a special shape depending on how a message was originally sent. ​BounceMode in createMessage When sending a message, it’s required to specify bounce behavior: CopyAsk AIval msg1 = createMessage({ bounce: BounceMode.NoBounce, body: TransferMessage { ... }, // ... }); msg1.send(mode); // will not be bounced on error val msg2 = createMessage({ bounce: BounceMode.RichBounce, body: TransferMessage { ... }, // ... }); msg2.send(mode); // may be bounced BounceMode is an enum with these options available: BounceMode.NoBounce BounceMode.Only256BitsOfBody — in.bouncedBody will be “0xFFFFFFFF” + first 256 bits (cheapest, and often sufficient) BounceMode.RichBounce — allows to access the entire originalBody; also, gasUsed, exitCode, and some other properties of a failed request are available (most expensive) BounceMode.RichBounceOnlyRootCell — the same, but originalBody will contain only a root cell ​How to handle in.bouncedBody Depending on BounceMode, in.bouncedBody will look differently. If all bounceable messages are sent with a cheap Only256BitsOfBody: CopyAsk AIfun onBouncedMessage(in: InMessageBounced) { // in.bouncedBody is 0xFFFFFFFF + 256 bits in.bouncedBody.skipBouncedPrefix(); // handle the rest, keep the 256-bit limit in mind } If you use RichBounce, that’s the way: CopyAsk AIfun onBouncedMessage(in: InMessageBounced) { val rich = lazy RichBounceBody.fromSlice(in.bouncedBody); // handle rich.originalBody // use rich.xxx to get exitCode, gasUsed, and so on } Mixing different modes (sending some messages as cheap and others as rich) complicates handling and is discouraged. So, the binary body of an outgoing message (TransferMessage above) is either in.bouncedBody (256 bits) or rich.originalBody (the entire slice). To handle this correctly, create a union “all messages theoretically bounceable” handle it with lazy in onBouncedMessage CopyAsk AIstruct (0x98765432) TransferMessage { // ... } // ... and other messages // some of them are bounceable (send not with NoBounce) type TheoreticallyBounceable = TransferMessage // | ... // example for BounceMode.Only256BitsOfBody fun onBouncedMessage(in: InMessageBounced) { in.bouncedBody.skipBouncedPrefix(); // skips 0xFFFFFFFF val msg = lazy TheoreticallyBounceable.fromSlice(in.bouncedBody); match (msg) { TransferMessage => { // revert changes using `msg.xxx` } // ... } } ​onExternalMessage Besides internal messages, a contract may handle external messages that arrive from off-chain. For example, a wallet contract handles external messages, performing signature validation via a public key. CopyAsk AIfun onExternalMessage(inMsg: slice) { // external messages arrive here } When a contract accepts an external message, it has a very limited gas amount for execution. Once a request is validated, remember to call acceptExternalMessage() to increase this limit. Also, commitContractDataAndActions() might be useful. Both are standard functions with detailed comments, an IDE provides them. ​Other reserved entrypoints Besides the functions above, several predefined prototypes also exist: fun onTickTock — triggers when tick and tock transactions occur fun onSplitPrepare and fun onSplitInstall — prepared for split/install transactions, currently unavailable in the blockchain fun main is often used for short snippets and demos This program is correct: CopyAsk AIfun main() { return 123 } It compiles, runs, and pushes 123 onto the stack. Its TVM method_id is 0.Was this page helpful?YesNoSuggest editsRaise issuePreviousContract storageNext⌘IgithubxtelegramPowered by MintlifyOn this pageonInternalMessageBrief explanation of the exampleHow to define and modify contract’s storageOld-fashioned onInternalMessageonBouncedMessageBounceMode in createMessageHow to handle in.bouncedBodyonExternalMessageOther reserved entrypoints",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "react",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:28:29.509Z"
  },
  {
    "id": "docs-ton-org--languages-fift-deep-dive",
    "title": "Fift deep dive",
    "url": "https://docs.ton.org/languages/fift/deep-dive",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftOverviewFift and TVM assemblyDeep diveSimple multisig contractWhitepaperFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationFiftFift deep diveLanguagesFiftFift deep diveCopy pageCopy pageFift is a high-level stack-based language used for local manipulation of cells and other TVM primitives. Its primary purpose is to compile TVM assembly code into contract code as a bag-of-cells (BoC). ​Simple arithmetic Use the Fift interpreter as a calculator with reverse Polish notation: CopyAsk AI6 17 17 * * 289 + . 2023 ok This example calculates: 17 * 17 = 289 6 * 289 = 1734 1734 + 289 = 2023 ​Standard output CopyAsk AI27 emit .\"[30;1mgrey text\" 27 emit .\"[37m\" grey text ok emit prints the Unicode character corresponding to the number on top of the stack .\"...\" outputs a constant string ​Defining functions (Fift words) To define a word, follow these steps: Enclose the word’s effects in curly braces {}. Add a colon : after the closing brace. Specify the word’s name after the colon. The first line defines the word increment as a function that increases x by 1. Examples: CopyAsk AI// Fift.fif { x 1 + } : increment { minmax drop } : min { minmax nip } : max In TON, multiple defining words exist, not just :. They differ in behavior: Active words – Operate inside curly braces {}. Prefix words – Do not require a trailing space. CopyAsk AI// Fift.fif { bl word 1 2 ' (create) } \"::\" 1 (create) { bl word 0 2 ' (create) } :: : { bl word 2 2 ' (create) } :: :_ { bl word 3 2 ' (create) } :: ::_ { bl word 0 (create) } : create ​Conditional execution Execute code blocks conditionally using cond: CopyAsk AI{ { .\"true \" } { .\"false \" } cond } : ?. 4 5 = ?. 4 5 < ?. false true ok { .\"hello \" } execute .\"world\" hello world ok ​Loops Use loop primitives for repetitive operations: CopyAsk AI// GetOpt.fif // ( l c -- l') Removes first c elements from list l { ' safe-cdr swap times } : list-delete-first Loop word times takes two arguments - let’s call them cont and n - and executes cont n times. Here list-delete-first takes continuation of safe-cdr (command deleting head from Lisp-style list), places it under c, and then c times removes head from list present on stack. while/until provide conditional looping. ​Comments Comments in Fift are defined in Fift.fif and come in two forms: Single-line comments: Start with // and continue to the end of the line Multiline comments: Start with /* and end with */ CopyAsk AI// Fift.fif { 0 word drop 0 'nop } :: // { char \" word 1 { swap { abort } if drop } } ::_ abort\" { { bl word dup \"\" $= abort\"comment extends after end of file\" \"*/\" $= } until 0 'nop } :: /* ​How comments work Fift programs are sequences of words that transform the stack or define new words. Comments must work even during word definitions, requiring them to be active words (defined with ::). Breaking down the // definition: 0 - Pushes zero onto the stack word - Reads characters until reaching one matching the top stack value (zero is special - skips leading spaces then reads to end of line) drop - Removes the comment text from the stack 0 - Pushes zero again (number of results for :: definition) 'nop - Pushes an execution token that does nothing (equivalent to { nop }) ​Using Fift for defining TVM assembly codes CopyAsk AI// Asm.fif (line order reversed) x{00} @Defop NOP { 1 ' @addop does create } : @Defop { tuck sbitrefs @ensurebitrefs swap s, } : @addop { @havebitrefs ' @| ifnot } : @ensurebitrefs { 2 pick brembitrefs 1- 2x<= } : @havebitrefs { rot >= -rot <= and } : 2x<= ... ​How @Defop works @Defop checks available space for the opcode using @havebitrefs. If space is insufficient, it writes to another builder via @| (implicit jump). Important: Always use x{A988} @addop instead of x{A988} s, to avoid compilation failures when space is limited. ​Including cells in contracts You can embed large bag-of-cells into contracts: CopyAsk AI<b 8 4 u, 8 4 u, \"fift/blob.boc\" file>B B>boc ref, b> <s @Defop LDBLOB This defines an opcode that: Writes x{88} (PUSHREF) when included in the program Adds a reference to the specified bag-of-cells Pushes the cell to the TVM stack when executing LDBLOB ​Special features ​Ed25519 cryptography Fift provides built-in support for Ed25519 cryptographic operations: newkeypair - Generates a private-public key pair priv>pub - Derives a public key from a private key ed25519_sign[_uint] - Creates a signature for given data using a private key ed25519_chksign - Verifies an Ed25519 signature ​TVM interaction runvmcode and similar commands - Executes TVM with a code slice taken from the stack ​File operations Save BoC to file: CopyAsk AIboc>B \".../contract.boc\" B>file ​Continue learning Fift: A Brief Introduction - Nikolai Durov Was this page helpful?YesNoSuggest editsRaise issuePreviousSimple multisig contractNext⌘IgithubxtelegramPowered by MintlifyOn this pageSimple arithmeticStandard outputDefining functions (Fift words)Conditional executionLoopsCommentsHow comments workUsing Fift for defining TVM assembly codesHow @Defop worksIncluding cells in contractsSpecial featuresEd25519 cryptographyTVM interactionFile operationsContinue learning",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:28:30.744Z"
  },
  {
    "id": "docs-ton-org--languages-fift-multisig",
    "title": "Simple multisig contract with Fift",
    "url": "https://docs.ton.org/languages/fift/multisig",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftOverviewFift and TVM assemblyDeep diveSimple multisig contractWhitepaperFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationFiftSimple multisig contract with FiftLanguagesFiftSimple multisig contract with FiftCopy pageCopy pageThis information is very low-level. It could be hard for newcomers and designed for advanced people who want to understand Fift. The use of Fift is not required in everyday tasks. ​Overview This tutorial helps you learn how to deploy your multisig contract. Recall that a (n,k)(n, k)(n,k)-multisig contract is a multi-signature wallet with nnn private key holders, which accepts requests to send messages if the request (a.k.a. order, query) collects at least kkk holders’ signatures. Based on the original multisig contract code and updates by akifoq: Original TON Blockchain multisig-code.fc akifoq/multisig with Fift libraries to work with multisig. Prefer videos over text?Watch this if you are new to multi-signature wallets: What is Multisig Technology? (video) ​What you’ll learn How to create and customize a simple multisig wallet. How to deploy a multisig wallet using a Lite client. How to sign a request and send it in a message to the blockchain. ​Set up your environment Before we begin our journey, check and prepare your environment. Install func, fift, lite-client binaries, and fiftlib from the latest GitHub release. Clone the repository and open its directory in CLI. CopyAsk AIgit clone https://github.com/akifoq/multisig.git cd ./multisig ​Get started Compile the code to Fift. Prepare multisig owner’s keys. Deploy your contract. Interact with the deployed multisig wallet in the blockchain. ​Compile the contract Compile the contract to Fift with: CopyAsk AIfunc -o multisig-code.fif -SPA stdlib.fc multisig-code.fc ​Prepare multisig owner’s keys ​Create participant’s keys To create a key, you need to run: CopyAsk AIfift -s new-key.fif $KEY_NAME$ Where KEY_NAME is the file name where the private key will be written. For example: CopyAsk AIfift -s new-key.fif multisig_key We’ll receive a multisig_key.pk file with the private key inside. ​Collect public keys Also, the script will issue a public key in the format: CopyAsk AIPublic key = Pub5XqPLwPgP8rtryoUDg2sadfuGjkT4DLRaVeIr08lb8CB5HW Anything after Public key = needs to be saved somewhere! Let’s store it in a file called keys.txt. It’s essential to have one public key per line. ​Deploy your contract ​Deploy via lite-client After creating all the keys, you need to collect the public keys into a text file, keys.txt. For example: CopyAsk AIPubExXl3MdwPVuffxRXkhKN1avcGYrm6QgJfsqdf4dUc0an7/IA PubH821csswh8R1uO9rLYyP1laCpYWxhNkx+epOkqwdWXgzY4 After that, you need to run: CopyAsk AIfift -s new-multisig.fif 0 $WALLET_ID$ wallet $KEYS_COUNT$ ./keys.txt $WALLET_ID$: the wallet number assigned to the current key. It is recommended that each new wallet with the same key use a unique $WALLET_ID$. $KEYS_COUNT$: the number of keys needed for confirmation, usually equal to the number of public keys. Wallet ID explainedIt is possible to create many wallets with the same keys (Alice’s key, Bob’s key). What should we do if Alice and Bob already share a wallet? That’s why $WALLET_ID$ is crucial here. The script will output something like: CopyAsk AInew wallet address = 0:4bbb2660097db5c72dd5e9086115010f0f8c8501e0b8fef1fe318d9de5d0e501 (Saving address to file wallet.addr) Non-bounceable address (for init): 0QBLuyZgCX21xy3V6QhhFQEPD4yFAeC4_vH-MY2d5dDlAbel Bounceable address (for later access): kQBLuyZgCX21xy3V6QhhFQEPD4yFAeC4_vH-MY2d5dDlAepg (Saved wallet creating query to file wallet-create.boc) Keep the bounceable address — this is the wallet address we will be using. If you have a “public key must be 48 characters long” error, please make sure your keys.txt uses Unix-style line endings (LF). For example, line endings can be changed via Sublime Text. ​Activate your contract You need to send some TON to the newly generated wallet. For example, 0.5 TON. You can send testnet coins via @testgiver_ton_bot. After that, run lite-client: CopyAsk AIlite-client -C global.config.json Where to get global.config.json?You can get a fresh config file global.config.json for Mainnet or Testnet. After starting a Lite client, it’s best to run the time command in the lite-client console to make sure the connection was successful: CopyAsk AItime Okay, Lite client works! After that, you need to deploy the wallet. Run the command: CopyAsk AIsendfile ./wallet-create.boc After that, the wallet will be ready to work within a minute. ​Interact with a multisig wallet ​Create a request First, you need to create a message request: CopyAsk AIfift -s create-msg.fif $ADDRESS$ $AMOUNT$ $MESSAGE$ $ADDRESS$ - address where to send coins. $AMOUNT$ - number of coins (in TON). $MESSAGE$ - the file name for the compiled message. For example: CopyAsk AIfift -s create-msg.fif EQApAj3rEnJJSxEjEHVKrH3QZgto_MQMOmk8l72azaXlY1zB 0.1 message Use the -C comment attribute to add a comment for your transaction. To get more information, run the create-msg.fif file without parameters. ​Choose a wallet Next, you need to choose a wallet to send coins from: CopyAsk AIfift -s create-order.fif $WALLET_ID$ $MESSAGE$ -t $AWAIT_TIME$ Where: $WALLET_ID$ — ID of the wallet backed by this multisig contract. $AWAIT_TIME$ — time in seconds the smart contract will await signatures from the multisig wallet owners for the request. $MESSAGE$ — name of the message BoC file created in the previous step. The request expires if $AWAIT_TIME$ elapses before the request is signed. As usual, $AWAIT_TIME$ equals a couple of hours (7200 seconds). For example: CopyAsk AIfift -s create-order.fif 0 message -t 7200 The resulting file is saved as order.boc. order.boc must be shared with key holders; they must sign it. ​Sign your part To sign, run: CopyAsk AIfift -s add-signature.fif $KEY$ $KEY_INDEX$ $KEY$ - file name containing the private key to sign, without extension. $KEY_INDEX$ - index of the given key in keys.txt (zero-based). For example, for our multisig_key.pk file: CopyAsk AIfift -s add-signature.fif multisig_key 0 ​Create a message After everyone has signed the order, it needs to be turned into a message for the wallet and signed again with the following command: CopyAsk AIfift -s create-external-message.fif wallet $KEY$ $KEY_INDEX$ In this case, only one signature from a wallet owner is enough. The idea is that you can’t attack a contract with invalid signatures. For example: CopyAsk AIfift -s create-external-message.fif wallet multisig_key 0 ​Send the signed message to the TON blockchain After that, start lite-client again: CopyAsk AIlite-client -C global.config.json And finally, we want to send our sign! Just run: CopyAsk AIsendfile wallet-query.boc If everyone else signed the request, it would be completed! You did it! ​See also Multisignature wallet v2 Was this page helpful?YesNoSuggest editsRaise issuePreviousWhitepaperWhitepaper by Dr. Nikolai DurovNext⌘IgithubxtelegramPowered by MintlifyOn this pageOverviewWhat you’ll learnSet up your environmentGet startedCompile the contractPrepare multisig owner’s keysCreate participant’s keysCollect public keysDeploy your contractDeploy via lite-clientActivate your contractInteract with a multisig walletCreate a requestChoose a walletSign your partCreate a messageSend the signed message to the TON blockchainSee also",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "testnet",
      "mainnet",
      "transaction",
      "testing",
      "tutorial",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:28:32.896Z"
  },
  {
    "id": "docs-ton-org--languages-fift-whitepaper",
    "title": "Fift: A Brief Introduction",
    "url": "https://docs.ton.org/languages/fift/whitepaper",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftOverviewFift and TVM assemblyDeep diveSimple multisig contractWhitepaperFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationFiftFift: A Brief IntroductionLanguagesFiftFift: A Brief IntroductionCopy pageWhitepaper by Dr. Nikolai DurovCopy pageAuthor: Nikolai Durov Date: July 4, 2019 : Original whitepaper, PDF ​Introduction This document provides a brief description of Fift, a stack-based general-purpose programming language optimized for creating, debugging, and managing TON Blockchain smart contracts. Fift has been specifically designed to interact with the TON Virtual Machine (TON VM or TVM) and the TON Blockchain. In particular, it offers native support for 257-bit integer arithmetic and TVM cell manipulation shared with TVM, as well as an interface to the Ed25519-based cryptography employed by the TON Blockchain. A macro assembler for TVM code, useful for writing new smart contracts, is also included in the Fift distribution. Being a stack-based language, Fift is not unlike Forth. Because of the brevity of this text, some knowledge of Forth might be helpful for understanding Fift.1 However, there are significant differences between the two languages. For instance, Fift enforces runtime type-checking, and keeps values of different types (not only integers) in its stack. A list of words (built-in functions, or primitives) defined in Fift, along with their brief descriptions, is presented in Appendix A. Please note that the current version of this document describes a preliminary test version of Fift; some minor details are likely to change in the future. ​Contents Overview Fift basics List of Fift stack value types Comments Terminating Fift Simple integer arithmetic Stack manipulation words Defining new words Named constants Integer and fractional constants, or literals String literals Simple string manipulation Boolean expressions, or flags Integer comparison operations String comparison operations Named and unnamed variables Tuples and arrays Lists Atoms Command line arguments in script mode Blocks, loops, and conditionals Defining and executing blocks Conditional execution of blocks Simple loops Loops with an exit condition Recursion Throwing exceptions Dictionary, interpreter, and compiler The state of the Fift interpreter Active and ordinary words Compiling literals Defining new active words Defining words and dictionary manipulation Dictionary lookup Creating and manipulating word lists Custom defining words Cell manipulation Slice literals Builder primitives Slice primitives Cell hash operations Bag-of-cells operations Binary file I/O and Bytes manipulation TON-specific operations Ed25519 cryptography Smart-contract address parser Dictionary manipulation Invoking TVM from Fift Using the Fift assembler Loading the Fift assembler Fift assembler basics Pushing integer constants Immediate arguments Immediate continuations Control flow: loops and conditionals Macro definitions Larger programs and subroutines References Appendix A: List of Fift words ​1 Overview Fift is a simple stack-based programming language designed for testing and debugging the TON Virtual Machine and the TON Blockchain, but potentially useful for other purposes as well. When Fift is invoked (usually by executing a binary file called fift), it either reads, parses, and interprets one or several source files indicated in the command line, or enters the interactive mode and interprets Fift commands read and parsed from the standard input. There is also a “script mode”, activated by command line switch -s, in which all command line arguments except the first one are passed to the Fift program by means of the variables $n and $#. In this way, Fift can be used both for interactive experimentation and debugging as well as for writing simple scripts. All data manipulated by Fift is kept in a (LIFO) stack. Each stack entry is supplemented by a type tag, which unambiguously determines the type of the value kept in the corresponding stack entry. The types of values supported by Fift include Integer (representing signed 257-bit integers), Cell (representing a TVM cell, which consists of up to 1023 data bits and up to four references to other cells), Slice (a partial view of a Cell used for parsing cells), and Builder (used for building new cells). These data types (and their implementations) are shared with TVM, and can be safely passed from the Fift stack to the TVM stack and back when necessary (e.g., when TVM is invoked from Fift by using a Fift primitive such as runvmcode). In addition to the data types shared with TVM, Fift introduces some unique data types, such as Bytes (arbitrary byte sequences), String (UTF-8 strings), WordList, and WordDef (used by Fift to create new “words” and manipulate their definitions). In fact, Fift can be extended to manipulate arbitrary “objects” (represented by the generic type Object), provided they are derived from C++ class td::CntObject in the current implementation. Fift source files and libraries are usually kept in text files with the suffix .fif. A search path for libraries and included files is passed to the Fift executable either in a -I command line argument or in the FIFTPATH environment variable. If neither is set, the default library search path /usr/lib/fift is used. On startup, the standard Fift library is read from the file Fift.fif before interpreting any other sources. It must be present in the library search path, otherwise Fift execution will fail. A fundamental Fift data structure is its global dictionary, containing words — or, more precisely, word definitions — that correspond both to builtin primitives and functions and to user-defined functions *. A word can be executed in Fift simply by typing its name (a UTF-8 string without space characters) in interactive mode. When Fift starts up, some words (primitives) are already defined (by some C++ code in the current implementation); other words are defined in the standard library Fift.fif. After that, the user may extend the dictionary by defining new words or redefining old ones. Fift words are typically shorter than functions or subroutines of other programming languages, such as Forth or Factor. The dictionary is supposed to be split into several vocabularies, or namespaces; however, namespaces are not implemented yet, so all words are currently defined in the same global namespace. The Fift parser for input source files and for the standard input (in the interactive mode) is rather simple: the input is read line-by-line, then blank characters are skipped, and the longest prefix of the remaining line that is (the name of) a dictionary word is detected and removed from the input line *. After that, the word thus found is executed, and the process repeats until the end of the line. When the input line is exhausted, a subsequent line is read from the current input file or the standard input. Notice that in contrast to Forth, Fift word names are case-sensitive: dup and DUP are distinct words. In order to be detected, most words require a blank character or an end-of-line immediately after them; this is reflected by appending a space to their names in the dictionary. Other words, called prefix words, do not require a blank character immediately after them. If no word is found, the string consisting of the first remaining characters of the input line until the next blank or end-of-line character is interpreted as an Integer and pushed into the stack. For instance, if we invoke Fift, type 2 3 + . (and press Enter), Fift first pushes an Integer constant equal to 2 into its stack, followed by another integer constant equal to 3. After that, the built-in primitive + is parsed and found in the dictionary; when invoked, it takes the two topmost elements from the stack and replaces them with their sum (5 in our example). Finally, . is a primitive that prints the decimal representation of the top-of-stack Integer, followed by a space. As a result, we observe \"5 ok\" printed by the Fift interpreter into the standard output. The string \"ok\" is printed by the interpreter whenever it finishes interpreting a line read from the standard input in the interactive mode. A list of built-in words may be found in Appendix A. ​2 Fift basics This chapter provides an introduction into the basic features of the Fift programming language. The discussion is informal and incomplete at first, but gradually becomes more formal and more precise. In some cases, later chapters and Appendix A provide more details about the words first mentioned in this chapter; similarly, some tricks that will be dutifully explained in later chapters are already used here where appropriate. ​2.1 List of Fift stack value types Currently, the values of the following data types can be kept in a Fift stack: TypeDescriptionDenoted by IntegerA signed 257-bit integer. Usually denoted by x, y, or z i",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "testnet",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:28:36.150Z"
  },
  {
    "id": "docs-ton-org--languages-tl-b-tooling",
    "title": "Tooling",
    "url": "https://docs.ton.org/languages/tl-b/tooling",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BOverviewSyntax and SemanticsSimple examplesComplex and non-trivial examplesTEP examplesToolingFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationTL-BToolingLanguagesTL-BToolingCopy pageCopy page​TL-B parsers TL-B libraries provide serializers and parsers for basic TL-B types and can serialize to and deserialize from the corresponding binary format. LanguageSDKSocial Kotlinton-kotlintonkotlinGotonutilstonutilsGotongotongo_libTypeScripttlb-parser-Pythontonpydtontech ​TL-B generators The tlb-codegen package generates TypeScript code for serializing and deserializing structures based on a provided TL-B scheme. The tonpy package also supports code generation in Python for serializing and deserializing structures according to a given TL-B scheme. ​TL-B online editors The convenient TL-B online editor allows you to write TL-B schemes and immediately see the results of parsing and serialization.Was this page helpful?YesNoSuggest editsRaise issuePreviousOverviewNext⌘IgithubxtelegramPowered by MintlifyOn this pageTL-B parsersTL-B generatorsTL-B online editors",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "python",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:28:38.855Z"
  },
  {
    "id": "docs-ton-org--languages-func-cookbook",
    "title": "FunC cookbook",
    "url": "https://docs.ton.org/languages/func/cookbook",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCOverviewCookbookLanguageLibrariesChangelogKnown issuesTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationFunCFunC cookbookLanguagesFunCFunC cookbookCopy pageCopy pageThe FunC cookbook was created to consolidate all the knowledge and best practices from experienced FunC developers in one place. The goal is to make it easier for future developers to build smart contracts efficiently. Unlike the rest of the official FunC documentation, this guide focuses on solving everyday challenges that FunC developers encounter during smart contract development. ​Statements ​How to use flags in if statements To check whether an event is relevant, use a flag variable of type integer. The flag can either be 0, representing false, or -1, representing true. See absence of boolean type. When checking the flag in if..else statements, it is unnecessary to use the == operator, since a 0 evaluates to false, and any nonzero value is considered to be true in if..else statements. CopyAsk AIint flag = 0; ;; false ;; ... ;; ... if (flag) { ;; No need to use flag == -1 ;; do something } else { ;; reject } ​How to write a repeat loop A repeat loop helps execute an action a fixed number of times. The example below computes exponentiation of number to the exponent exponent, and illustrates it with specific values number = 2 and exponent = 5: CopyAsk AIint number = 2; int exponent = 5; int result = 1; ;; Will store the final result: number^exponent repeat(exponent) { ;; The repeat multiplies variable \"number\", ;; exactly an \"exponent\" number of times result *= number; } ;; result holds value 32 ​How to write a while loop A while loop is useful when the number of iterations is unknown. The following example processes the references in the message cell. Each cell can store up to four references to other cells: CopyAsk AIcell inner_cell = begin_cell() ;; Create a new empty builder .store_uint(123, 16) ;; Store uint with value 123 and length 16 bits .end_cell(); ;; Convert builder to a cell ;; Create a cell, which will have two references to inner_cell cell message = begin_cell() .store_ref(inner_cell) ;; Store cell as reference .store_ref(inner_cell) ;; A second time .end_cell(); slice msg = message.begin_parse(); ;; Convert cell to slice while (msg.slice_refs_empty?() != -1) { ;; Iterate while there are refs to process ;; Recall that -1 is true. cell inner_cell = msg~load_ref(); ;; Load cell from slice msg ;; do something } References: Non-modifying notation using . begin_cell store_uint end_cell store_ref begin_parse slice_refs_empty? load_ref ​How to write a do until loop Use a do..until loop when the loop must execute at least once. CopyAsk AIint flag = 0; do { ;; iterate this as long as \"flag\" is false (0). ;; It would execute at least once even if the flag ;; were already true before entering the loop. } until (flag == -1); ;; Stop when \"flag\" becomes -1 ​Cells and slices ​How to determine if a slice is empty Before working with a slice, checking whether it contains any data is essential to ensure proper processing. The slice_empty? method can be used for this purpose. However, it returns 0 (false) if the slice contains at least one bit of data or one reference. CopyAsk AI;; Creating empty slice slice empty_slice = \"\"; ;; compile-time built-in \"\" produces a slice with no bits ;; `slice_empty?()` returns `true` because the slice doesn't have any `bits` and `refs`. empty_slice.slice_empty?(); ;; Creating slice which contains bits only slice slice_with_bits_only = \"Hello, world!\"; ;; compile-time built-in produces a slice ;; containing the ASCII binary code of the string ;; `slice_empty?()` returns `false` because the slice has bits. slice_with_bits_only.slice_empty?(); ;; Create an empty dummy cell for use later cell dummy_cell = begin_cell().end_cell(); ;; Creating slice which contains refs only slice slice_with_refs_only = begin_cell() .store_ref(dummy_cell) ;; Add the dummy cell as a reference .end_cell() ;; this creates the cell .begin_parse(); ;; this creates a slice from the cell ;; `slice_empty?()` returns `false` because the slice has cell references. slice_with_refs_only.slice_empty?(); ;; Creating slice which contains bits and refs slice slice_with_bits_and_refs = begin_cell() .store_slice(\"Hello, world!\") ;; Add bits from the slice computed ;; using the compile-time built-in .store_ref(dummy_cell) ;; Add the dummy cell as a reference .end_cell() .begin_parse(); ;; `slice_empty?()` returns `false` because the slice has bits and references. slice_with_bits_and_refs.slice_empty?(); References: Non-modifying notation using . \"<ascii string>\" compile-time builtin, where <ascii string> is an ASCII string slice_empty? begin_cell end_cell store_ref begin_parse store_slice ​How to determine if slice is empty (no bits, but may have refs) If only the presence of bits matters and the cell references in the slice can be ignored, use the slice_data_empty? function. CopyAsk AI;; Creating empty slice slice empty_slice = \"\"; ;; compile-time built-in \"\" produces a slice with no bits ;; `slice_data_empty?()` returns `true` because the slice doesn't have any bits. empty_slice.slice_data_empty?(); ;; Creating slice which contains bits only slice slice_with_bits_only = \"Hello, world!\"; ;; compile-time built-in produces a slice ;; containing the ASCII binary code of the string ;; `slice_data_empty?()` returns `false` because the slice has bits. slice_with_bits_only.slice_data_empty?(); ;; Create an empty dummy cell for use later cell dummy_cell = begin_cell().end_cell(); ;; Creating slice which contains refs only slice slice_with_refs_only = begin_cell() .store_ref(dummy_cell) ;; Add the dummy cell as a reference .end_cell() ;; this creates the cell .begin_parse(); ;; this creates a slice from the cell ;; `slice_data_empty?()` returns `true` because the slice doesn't have any bits slice_with_refs_only.slice_data_empty?(); ;; Creating slice which contains bits and refs slice slice_with_bits_and_refs = begin_cell() .store_slice(\"Hello, world!\") ;; Add bits from the slice computed ;; using the compile-time built-in .store_ref(dummy_cell) ;; Add the dummy cell as a reference .end_cell() .begin_parse(); ;; `slice_data_empty?()` returns `false` because the slice has bits. slice_with_bits_and_refs.slice_data_empty?(); References: Non-modifying notation using . \"<ascii string>\" compile-time builtin, where <ascii string> is an ASCII string. slice_data_empty? begin_cell end_cell store_ref begin_parse store_slice ​How to determine if slice is empty (no refs, but may have bits) If only cell references are of interest, their presence can be checked using the slice_refs_empty? function. CopyAsk AI;; Creating empty slice slice empty_slice = \"\"; ;; compile-time built-in \"\" produces a slice with no bits ;; `slice_refs_empty?()` returns `true` because the slice doesn't have any cell references. empty_slice.slice_refs_empty?(); ;; Creating slice which contains bits only slice slice_with_bits_only = \"Hello, world!\"; ;; compile-time built-in produces a slice ;; containing the ASCII binary code of the string ;; `slice_refs_empty?()` returns `true` because the slice doesn't have any cell references. slice_with_bits_only.slice_refs_empty?(); ;; Create an empty dummy cell for use later cell dummy_cell = begin_cell().end_cell(); ;; Creating slice which contains refs only slice slice_with_refs_only = begin_cell() .store_ref(dummy_cell) ;; Add the dummy cell as a reference .end_cell() ;; this creates the cell .begin_parse(); ;; this creates a slice from the cell ;; `slice_refs_empty?()` returns `false` because the slice has cell references. slice_with_refs_only.slice_refs_empty?(); ;; Creating slice which contains bits and refs slice slice_with_bits_and_refs = begin_cell() .store_slice(\"Hello, world!\") ;; Add bits from the slice computed ;; using the compile-time built-in .store_ref(dummy_cell) ;; Add the dummy cell as a reference .end_cell() .begin_parse(); ;; `slice_refs_empty?()` returns `false` because the slice has cell references. slice_with_bits_and_refs.slice_refs_empty?(); References: Non-modifying notation using . \"<ascii string>\" compile-time builtin, where <ascii string> is an ASCII string. slice_refs_empty? begin_cell end_cell store_ref begin_parse store_slice ​How to determine if a cell is empty To check whether a cell contains any data, it must first be converted into a slice. If only the data bits matter, use slice_data_empty?. If only cell references matter, use slice_refs_empty?. If the presence of any data (bits or cell references) needs to be checked, use slice_empty?. CopyAsk AI;; Create an empty dummy cell for use later cell dummy_cell = begin_cell().end_cell(); cell cell_with_bits_and_refs = begin_cell() .store_uint(1337, 16) .store_ref(dummy_cell) .end_cell(); ;; To check that cell_with_bits_and_refs is empty, ;; first obtain a slice slice cs = cell_with_bi",
    "category": "languages",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:28:41.392Z"
  },
  {
    "id": "docs-ton-org--languages-func-changelog",
    "title": "Changelog",
    "url": "https://docs.ton.org/languages/func/changelog",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCOverviewCookbookLanguageLibrariesChangelogKnown issuesTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationFunCChangelogLanguagesFunCChangelogCopy pageCopy page​Version 0.4.6 Released in Dec 2024. Fixes: try/catch handling. Pure flag for functions stored in variables. ​Version 0.4.5 Released in Oct 2024. Fixes: Bug in optimization of operator <<. ​Version 0.4.4 Released in May 2023. New features: Better error-handling. Fixes: catch stack recovery. ​Version 0.4.3 Released in Apr 2023. New features: Improved optimization of int constants and unused variables. Fixes: Better handling of incorrect inputs: fix UB and prevent crashes on some inputs. Analysis of repeat loops. ​Version 0.4.2 Released in Mar 2023. New features: FunC Mathlib. Fixes: Handling of incorrect integer literal values. ​Version 0.4.1 Released in Jan 2023. New features: Added pragmas for precise control of computation order: allow-post-modification and compute-asm-ltr. Added legacy tester, a collection of smart-contracts which is used to check whether a compiler update changes compilation results. Fixes: Compiler crashes for some exotic inputs. ​Version 0.4.0 Released in Jan 2023. New features: try/catch statements. throw_arg, throw_arg_if, and throw_arg_unless functions. Support for in-place modification and mass assignment of global variables, e.g., a~inc() and (a, b) = (3, 5), where a is global. Fixes: Disallowed ambiguous modification of local variables after their usage in the same expression. For example, var x = (ds, ds~load_uint(32), ds~load_unit(64)); is forbidden, while var x = (ds~load_uint(32), ds~load_unit(64), ds); is allowed. Allowed empty inline functions. Fixed a rare optimization bug in while loops. ​Version 0.3.0 Released in Oct 2022. New features: Support for multiline asm statements. Allow duplicate definitions of identical constants and asm statements. Enable bitwise operations for constants. ​Version 0.2.0 Released in Aug 2022. New features: Unbalanced if/else branches, where some branches return a value while others do not. Fixes: FunC incorrectly handles while(false) loops (#377). FunC generates incorrect code for if/else branches (#374). FunC incorrectly returns from conditions in inline functions (#370). Asm.fif: splitting large function bodies incorrectly interferes with inline (#375). ​Version 0.1.0 Released in May 2022. New features: Constants Compile-time built-ins Semver pragmas Includes Fixes: Resolved rare bugs in Asm.fif. ​Initial version The initial version of FunC was developed by Telegram, but active development stopped after May 2020. The May 2020 release is referred to as the “initial” version.Was this page helpful?YesNoSuggest editsRaise issuePreviousKnown issuesNext⌘IgithubxtelegramPowered by MintlifyOn this pageVersion 0.4.6Version 0.4.5Version 0.4.4Version 0.4.3Version 0.4.2Version 0.4.1Version 0.4.0Version 0.3.0Version 0.2.0Version 0.1.0Initial version",
    "category": "languages",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:28:43.601Z"
  },
  {
    "id": "docs-ton-org--languages-fift",
    "title": "Fift language overview",
    "url": "https://docs.ton.org/languages/fift",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftOverviewFift and TVM assemblyDeep diveSimple multisig contractWhitepaperFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationFiftFift language overviewLanguagesFiftFift language overviewCopy pageCopy pageThe official language of TON Blockchain is Tolk, and all other languages are deemed legacy. That said, you can still use them and contribute to the surrounding tooling or documentation. Fift is a stack-based general-purpose tacit programming language optimized for creating, debugging, and managing smart contracts on TON Blockchain. It has been specifically designed to interact with TON Virtual Machine (TVM) and TON Blockchain. In particular, it offers native support for 257-bit integer arithmetic and cell manipulation, as well as an interface to the Ed25519-based cryptography employed by TON. Fift also includes a macro assembler for TVM code, which is a common intermediate target of higher-level languages such as Tolk, FunC, and Tact, as well as a common textual bitcode representation of smart contracts. For more examples of the latter, see various blockchain explorers and disassembled smart contracts. ​Installation ​Interpreter and libraries Fift interpreter binaries for Windows, macOS (Intel or Arm64), and Ubuntu can be downloaded from the latest GitHub release. Make sure to also download the necessary libraries — download and unpack the smartcont_lib.zip. The lib/ folder inside contains standard libraries of Fift, which must be exposed to it when running the interpreter. Consider the following example installation steps: 1Download the latest Fift binary Windows Linux macOSGo to the latest GitHub release, download fift.exe and place it somewhere on your PATH. To see the current state of the PATH variable, run echo $env:PATH in the PowerShell.Go to the latest GitHub release, download fift-linux-x86_64 (64-bit, x86 arch) or fift-linux-arm64 (64-bit, Arm arch), and place it somewhere on your $PATH as fift. To see the current state of the $PATH variable, run echo $PATH | tr ':' '\\n' in the terminal.Go to the latest GitHub release, download fift-mac-x86-64 (64-bit, Intel) or fift-mac-arm64 (64-bit, Apple Silicon), and place it somewhere on your $PATH as fift. To see the current state of the $PATH variable, run echo $PATH | tr ':' '\\n' in the terminal.2Download Fift's standard libraries Download smartcont_lib.zip from the latest GitHub release. Unzip it and extract the contents. Move the extracted lib/ folder somewhere convenient. You can also place it under a different name. For example, for Linux and macOS, it can be moved to ~/.local/lib/fiftlib For Windows, to ~/.fiftlib 3Run FiftTo invoke the Fift binary, you’ll need to pass it the standard libraries as such:CopyAsk AIfift -I /path/to/extracted/lib -i Asm.fif If you see errors or red-colored output lines, double-check the placement of the Fift binary and related libraries from previous steps.Otherwise, write the following and press “Enter”:CopyAsk AI2 2 + .s If you see “4 ok”, then Fift has been successfully installed on your machine!To learn about other launch options, add the -h flag by the end of the prior Fift invocation command. For Linux and macOS, it might be convenient to make an alias as such:CopyAsk AI# Within .bash_aliases or .zsh_aliases alias fift=\"/path/to/fift -I /path/to/extracted/lib -i Asm.fif\" ​Additional tooling ​Extensions and plugins VS Code extension - powerful and feature-rich extension for Visual Studio Code (VSCode) and VSCode-based editors like VSCodium, Cursor, Windsurf, and others. Get it on the Visual Studio Marketplace. Get it on the Open VSX Registry. Or install from the .vsix files in nightly releases. JetBrains IDEs plugin - provides syntax highlighting, code navigation, and more. Language Server (LSP Server) - supports Sublime Text, (Neo)Vim, Helix, and other editors with LSP support. ​Online utilities TxTracer: Assembly playground TxTracer: Code explorer with assembly output TxTracer: TVM instruction table ​Getting started Here is a simple Hello, World! example written in Fift: CopyAsk AI.\"Hello, World!\" When executed with fift binary, it produces the following output: CopyAsk AIHello, World! ok There, ok means successful end of execution of the given code snippet. When things go awry, there may still be an ok by the end, albeit prefixed with several red lines of cryptic-looking stack traces. Those are how Fift reports errors, and this is one of the major reasons why Fift is considered a legacy language.Any errors encountered during execution clear the stack!Hence, to actually know what happened, one needs to preemptively check stack contents. For that, use the “printf debugging” approach with the .s word — it dumps current stack contents to the console without modifying the stack.CopyAsk AI\"Hello, \" .s // \"Hello, \" \"World!\" .s // \"Hello, \" \"World!\" $+ // \"Hello, World!\" type // Hello, World! ok // Now, the stack is clear. To continue learning Fift, see the educational materials section, or move to the follow-up references. Fift and TVM assemblyDeep dive into FiftSimple multi-signature walletWhitepapers (see below) ​Educational materials ​Whitepapers While most of the information described there holds some truth, the fiftbase.pdf whitepaper is still considered legacy due to a lack of updates and gradual integration of its contents into actual documentation pages.However, it is the most exhaustive reference manual on Fift to date, so you can still use it to learn a lot about Fift. Fift language specification, web versionTacit stack-based programming language with a deep connection to TVM.Fift language specification, PDFOriginal documentation written by Dr. Nikolai Durov, a comprehensive whitepaper. ​Articles Introduction to Fift ​Videos and playlists «His majesty Fift»In Russian ​Examples Simple multi-signature walletMulti-signature wallet v2 ​See also Multisignature wallet v2 Forth language Factor language Uiua language Concatenative languages Was this page helpful?YesNoSuggest editsRaise issuePreviousFift and TVM assemblyNext⌘IgithubxtelegramPowered by MintlifyOn this pageInstallationInterpreter and librariesAdditional toolingExtensions and pluginsOnline utilitiesGetting startedEducational materialsWhitepapersArticlesVideos and playlistsExamplesSee also",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:28:46.107Z"
  },
  {
    "id": "docs-ton-org--languages-func-types",
    "title": "FunC types",
    "url": "https://docs.ton.org/languages/func/types",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCOverviewCookbookLanguageCommentsTypesLiteralsOperatorsExpressionsStatementsProgram declarationsReserved words and built-insDictionariesLibrariesChangelogKnown issuesTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationLanguageFunC typesLanguagesFunCLanguageFunC typesCopy pageCopy pageFunC offers a range of built-in types covering all the types the TVM has. On the other hand, FunC has no custom user-defined types like records or classes. ​Atomic types Each of these types occupies a single entry on the TVM stack. inta 257-bit signed integer type. Overflow checks are enabled by default and trigger an exception.cella TVM cell type for persistent data storage on TON Blockchain. Data is organized in a bag of cells, with each cell containing up to 1023 bits of arbitrary data and up to four references to other cells.slicea read-only view of a cell that allows sequential access to its data and references. A cell can be converted into a slice, extracting stored bits and references without modifying the original cell.buildera mutable structure used to construct cells by adding data and references before finalizing them into a new cell.tuplean ordered collection of up to 255 elements, each capable of holding a value of any type.conta TVM continuation employed for execution flow management in TVM instructions. ​Special null value Any atomic type allows the special value null which represents the absence of an actual value of that type. For example, a function that searches the position of an integer in a list may return null to signify that it could not find the integer. The null value can be obtained by calling the function null(). For example, in this snippet, an integer variable is declared and initialized with null: CopyAsk AIint a = null(); ;; a has value null Since null is a valid value for any atomic type, keep the following in mind when working with functions: Functions that return an atomic type may return null. Functions that expect an atomic type as input could also accept null. For library functions specifications explicitly indicate when null is acceptable as a valid input or output. Example: cell_depth(cell c) receives a cell as input, and its specification states that if the input cell is null, the function returns 0. ​No boolean type FunC does not have a boolean type. Instead, booleans are represented as integers: false is 0, true is -1, a 257-bit integer with all bits set to 1. Logical operations are performed using bitwise operations. In conditional statements, loops, and conditional expressions any nonzero integer is regarded as true. ​Typed holes FunC supports type inference through the type holes: _ and var serve as placeholders resolved during type checking; _ is for functions, and var is for variables. Example: CopyAsk AIvar x = 2; The type checker determines that x is of type int since 2 is an int. As another example, in the following function declaration: CopyAsk AI_ someFunction(int a) { return a + 1; } the type checker infers that _ has type int, as the return expression a + 1 is of type int. See Function declarations for more details. ​Composite types To represent non-atomic, composite types, simpler types can be combined with the following three operations. ​Function type A functional type is written in the form A -> B, where: A is the input type, which is called domain. B is the output type, which is called codomain. For example, the type int -> cell represents a function that: Takes an integer as input. Returns a cell as output. Like in functional programming, it is possible to declare function types which have in their domain and codomain other function types. For example, (int -> int) -> int is a function with domain int -> int and codomain int. Similarly, cell -> (slice -> slice) is a function with domain cell and codomain slice -> slice ​Tuple type Tuple types in FunC are written in the form [A, B, ...] and represent TVM tuples with fixed length and known component types at compile time. A tuple occupies one entry on the TVM stack, even if it is a zero-length tuple. For example, [int, cell] defines a tuple with exactly two elements: The first element is an integer. The second element is a cell. The type [] represents an empty tuple. There is only one value of this type, the empty tuple, which is also written as []. The empty tuple [] occupies one stack entry. ​Tensor type Tensor types represent ordered collections of values and are written in the form (A, B, ...). These types occupy multiple TVM stack entries, unlike atomic types, which use a single entry. Example: A function foo of type int -> (int, int) takes one integer as input and returns two integers as output, each one occupying a stack entry. Example call: CopyAsk AI(int a, int b) = foo(42); Internally, the function consumes one stack entry and produces two. Type representation: Values (2, (3, 9)) of type (int, (int, int)) and (2, 3, 9) of type (int, int, int) are stored identically as three stack entries containing the values 2, 3, and 9, respectively. However, FunC treats (int, (int, int)) and (int, int, int) as distinct types. The following code will not compile: CopyAsk AI(int a, int b, int c) = (2, (3, 9)); However, this code will compile correctly: CopyAsk AI(int a, (int b, int c)) = (2, (3, 9)); FunC enforces strict type consistency, so only matching tensor structures are allowed. Exception: a type of the form (A) is considered by the type checker as the same type as A. Special case: unit type() The unit type () is used to indicate that: A function does not return a value, or A function takes no arguments The unit type () has a single value, also written as (), occupying zero stack entries. Examples print_int has the type int -> (), meaning it takes an integer but returns nothing. random has the type () -> int, meaning it takes no arguments but returns an integer. ​Polymorphism with type variables FunC supports polymorphic functions. Example: CopyAsk AIforall X -> (X, X) duplicate(X value) { return (value, value); } Here, X is a type variable that allows the function to operate on values of any type. Type variables are declared between forall and ->. The function receives a value of type X, and duplicates this value to return a value of type (X, X). For example, Calling duplicate(6) produces (6, 6). Calling duplicate([]) produces two copies of an empty tuple: ([], []). Type variables in polymorphic functions cannot be instantiated with tensor types. The only exception is a tensor of a single element (a), where a is not a tensor type itself. The compiler treats (a) as equivalent to a. For more details, see the Polymorphism with forall section. ​User-defined types FunC does not support defining custom types beyond the type constructions described above. ​Type width Every value in FunC occupies a certain number of stack entries. If this number is consistent for all values of a given type, it is called the type width. For example, all atomic types have a type width of 1, because all their values occupy a single stack entry. The tensor type (int, int) has type width 2, because all its values occupy 2 stack entries.Was this page helpful?YesNoSuggest editsRaise issuePreviousLiteralsNext⌘IgithubxtelegramPowered by MintlifyOn this pageAtomic typesSpecial null valueNo boolean typeTyped holesComposite typesFunction typeTuple typeTensor typePolymorphism with type variablesUser-defined typesType width",
    "category": "languages",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:28:48.017Z"
  },
  {
    "id": "docs-ton-org--languages-func-functions",
    "title": "FunC functions",
    "url": "https://docs.ton.org/languages/func/functions",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCOverviewCookbookLanguageCommentsTypesLiteralsOperatorsExpressionsStatementsProgram declarationsOverviewFunctionsReserved functionsAssembler functionsGlobal variablesCompiler directivesReserved words and built-insDictionariesLibrariesChangelogKnown issuesTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationProgram declarationsFunC functionsLanguagesFunCLanguageProgram declarationsFunC functionsCopy pageCopy pageEvery function declaration or definition follows a common pattern. The general form is: CopyAsk AI[<forall declarator>] <return type> <function name>(<comma separated function args>) <specifiers> <function body> where [ ... ] represents an optional entry. Here, <forall declarator> is the forall declarator, which declares that the function is polymorphic. This is optional. <return type> is the return type of the function. <function name> is the function name. <comma separated function args> is a comma separated list of function arguments, each argument consisting on a type and the argument’s name. <specifiers> are specifiers that instruct the compiler on how to process the function. <function body> is the actual function body, which can be of three kinds: an empty body, an assembler body, or a standard body. ​Return type The return type can be any atomic or composite type, as described in the Types section. For example, the following functions are valid: CopyAsk AIint foo() { return 0; } (int, int) foo'() { return (0, 0); } [int, int] foo''() { return [0, 0]; } (() -> int) foo'''() { return foo; } () foo''''() { return (); } FunC also supports type inference with the use of underscore _ as the return type. For example: CopyAsk AI_ divAndMod(int m, int n) { return (m /% n); } There, the function divAndMod has the inferred type (int, int) -> (int, int). The function computes the division and modulo of the parameters m and n by using the division and modulo operator /%, which always returns a two-element tensor (int, int). ​Function name A function name can be any valid identifier. Additionally, it may start with the symbols . or ~, which have specific meanings explained in the special function call notation section. Specifically, refer to this section to understand how the symbols . or ~ affect the function name. For example, udict_add_builder?, dict_set, and ~dict_set are all valid function names, and each is distinct. These functions are defined in stdlib.fc. FunC reserves several function names. See the reserved functions article for more details. ​Function arguments A function can receive zero or more argument declarations, each declaration separated by a comma. The following kinds of argument declarations are allowed: Ordinary declaration: an argument is declared using its type followed by its name. Example: CopyAsk AIint foo(int x) { return x + 2; } Here, int x declares an argument named x of type int in function foo. An example that declares multiple arguments: CopyAsk AIint foo(int x, int y) { return x + y; } An example that declares no arguments: CopyAsk AIint foo() { return 0; } Unused argument declaration: only its type needs to be specified. Example: CopyAsk AIint first(int x, int) { return x; } This is a valid function of type (int, int) -> int, but the function does not use its second argument. Argument with inferred type declaration: If an argument’s type is not explicitly declared, it is inferred by the type-checker. For example, CopyAsk AIint inc(x) { return x + 1; } This defines a function inc with the inferred type int -> int, meaning x is automatically recognized as an int. Even though a function may appear to take multiple arguments, it takes a single tensor type argument. For more details on this distinction, refer to the function call section.However, for convenience, the individual components of this tensor are conventionally referred to as function arguments. ​Specifiers In FunC, function specifiers modify the behavior of functions. There are three types: impure Either inline or inline_ref, but not both method_id One, multiple, or none can be used in a function declaration. However, they must appear in the order of the above list, e.g., impure must come before inline and method_id, inline_ref must come before method_id, etc. ​impure specifier The impure specifier indicates that a function has side effects, such as modifying contract storage, sending messages, or throwing exceptions. If a function is not marked as impure and its result is unused, the FunC compiler may delete the function call for optimization. For example, the stdlib.fc function random changes the internal state of the random number generator: CopyAsk AIint random() impure asm \"RANDU256\"; The impure keyword prevents the compiler from removing calls to this function: CopyAsk AIvar n = 0; random(); ;; Even though the result of random is not used, ;; the compiler will not remove this call ;; because random has the impure specifier. ​Inline specifier A function marked as inline is directly substituted into the code wherever it is called, eliminating the function call overhead. Recursive calls are not allowed for inline functions. For example: CopyAsk AI(int) add(int a, int b) inline { return a + b; } Since the add function is marked with the inline specifier, the compiler substitutes add(a, b) with a + b directly in the code. For instance, the compiler will replace the following code: CopyAsk AIvar a = 1; var b = 2; var n = add(a, b); with this code: CopyAsk AIvar a = 1; var b = 2; var n = a + b; ​inline_ref specifier When a function is marked with the inline_ref specifier, its code is stored in a separate cell. Each time the function is called, the TVM executes a CALLREF command, which loads the code stored in the referenced cell and executes the function code. To give you a very high level idea on how to visualize this, think how programs are stored in the blockchain. Anything in the blockchain is a cell. A program is a directed acyclic graph (DAG) of cells. Each cell stores TVM instructions, and can have up to 4 references to other cells. Each one of those references represent code that the TVM can jump to. So, you can picture a program like this: CopyAsk AICell 1 instruction 1 instruction 2 ..... call reference A ..... instruction n ---------------------------------------- Reference to cell A | Reference to cell B | where Reference to cell A, and Reference to cell B are references to other cells containing further code of the program. When the TVM executes the instruction call reference A, the TVM loads the cell referenced by Reference to cell A and executes the cell. When a function is marked as inline_ref, its code is placed in a separate cell, name it C. Then, everywhere the function is called in the original program, it is replaced with a call reference C. Then, the reference to C is added to the original program as a cell reference. More concretely, imagine the following program: CopyAsk AIint foo() inline_ref { return 1; } int main() { return (foo() + foo()); } Then, this would create two cells, one storing the code of the main function, call it cell M; and another cell storing the code of the foo function, because it is marked as inline_ref, call it cell F. The two calls to foo inside main will be replaced by reference calls to F. And the reference to F is added as a reference in cell M: CopyAsk AICell M call reference to F call reference to F ADD ---------------------------------------- Reference to F | Cell F 1 PUSHINT When call reference to F executes, the TVM loads the cell for F and executes it. As the example suggests, contrary to the inline specifier, the code for foo is not duplicated, because the two calls for foo are loading the same cell. As such, inline_ref is generally more efficient regarding code size. The only case where inline might be preferable is if the function is called just once, because loading cell references costs gas. However, recursive calls to inline_ref functions remain impossible, as TVM cells do not support cyclic references. ​method_id specifier In a TVM program, every function has an internal integer ID that identifies it uniquely. These IDs are necessary because of the way the TVM calls functions within a program: it uses a dictionary where each key is a function ID that maps to the corresponding function code. When the TVM needs to invoke a particular function, the TVM looks up the ID in the dictionary and executes the corresponding code. By default, functions are assigned sequential numbers starting from 1. If a function has the method_id specifier, the compiler will compute an ID using the formula (crc16(<function_name>) & 0xffff) | 0x10000 instead. Additionally, such function becomes a get-method (or getter method), which are functions that can be invoked by its name in lite client or TON explorer. The method_id specifier has the variant method_id(<some_number>), which al",
    "category": "languages",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:28:50.521Z"
  },
  {
    "id": "docs-ton-org--standard-wallets-performance",
    "title": "Performance benchmark",
    "url": "https://docs.ton.org/standard/wallets/performance",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsHow they workMnemonicsComparisonPerformance benchmarkHow to interactHistoryV4V5Highload WalletsLockup walletPreprocessed Wallet V2Restricted walletTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationWalletsPerformance benchmarkStandard contractsWalletsPerformance benchmarkCopy pageCopy pageThe following benchmarks compare gas consumption and throughput across different wallet versions when sending multiple messages. These measurements help determine the most cost-effective wallet for specific use cases. The benchmarks measure the gas consumed by the wallet contract itself, including fwd_fee and gas costs. The final transaction fee may vary depending on the destination address and message processing requirements. Each benchmark includes theoretical and real-time measurements: theoretically, messages can be sent every 3-5 seconds when a new block appears, but in practice, messages can be sent every 12-14 seconds due to network conditions and block confirmation times. The complete benchmark source code and test suite is available on GitHub repository Preprocessed Wallet V2 is shown separately because it is a community implementation and not an official TON standard. Users assume all risks when using this wallet implementation. Always verify the contract code and understand the security implications before use. ​Sending TONs ​1 Messages Wallet VersionGas delta %Fee delta %RequestsTotal GasGas/MsgTotal Fee (TON)Fee/Msg (TON)Real Time (s)Theory Time (s)Wallet V2R1 ✅BestBest12,7692,7690.00171080.001710813s4sWallet V2R2+2.78%+1.80%12,8462,8460.00174160.001741613s4sWallet V3R1+5.34%+3.46%12,9172,9170.00177000.001770013s4sWallet V3R2+8.12%+5.26%12,9942,9940.00180080.001800813s4sWallet V4R2+19.46%+12.60%13,3083,3080.00192640.001926413s4sWallet V5R1+78.36%+56.34%14,9394,9390.00267480.002674813s4sHighload Wallet V3+187.32%+187.14%17,9567,9560.00491240.004912413s4s Preprocessed Wallet V2 Wallet VersionGas delta %Fee delta %RequestsTotal GasGas/MsgTotal Fee (TON)Fee/Msg (TON)Real Time (s)Theory Time (s)Preprocessed Wallet V2-44.49%-18.98%11,5371,5370.00138600.001386013s4s ​4 Messages Wallet VersionGas delta %Fee delta %RequestsTotal GasGas/MsgTotal Fee (TON)Fee/Msg (TON)Real Time (s)Theory Time (s)Wallet V2R1 ✅BestBest14,6951,1730.00309080.000772713s4sWallet V2R2+1.70%+0.99%14,7721,1930.00312160.000780413s4sWallet V3R1+3.15%+1.91%14,8431,2100.00315000.000787513s4sWallet V3R2+4.85%+2.91%14,9201,2300.00318080.000795213s4sWallet V4R2+11.50%+6.97%15,2341,3080.00330640.000826613s4sWallet V5R1+51.06%+39.53%17,0901,7720.00431280.001078213s4sHighload Wallet V3+69.56%+109.25%17,9561,9890.00646760.001616913s4s Preprocessed Wallet V2 Wallet VersionGas delta %Fee delta %RequestsTotal GasGas/MsgTotal Fee (TON)Fee/Msg (TON)Real Time (s)Theory Time (s)Preprocessed Wallet V2-67.26%-29.99%11,5373840.00216360.000540913s4s ​200 Messages Wallet VersionGas delta %Fee delta %RequestsTotal GasGas/MsgTotal Fee (TON)Fee/Msg (TON)Real Time (s)Theory Time (s)Wallet V2R1+2907.69%+42.99%50234,7501,1730.15454000.00077270010m 50s3m 20sWallet V2R2+2958.97%+44.41%50238,6001,1930.15608000.00078040010m 50s3m 20sWallet V3R1+3002.56%+45.73%50242,1501,2100.15750000.00078750010m 50s3m 20sWallet V3R2+3053.84%+47.15%50246,0001,2300.15904000.00079520010m 50s3m 20sWallet V4R2+3253.84%+52.96%50261,7001,3080.16532000.00082660010m 50s3m 20sWallet V5R1+1792.30%+3.01%1147,6227380.11132880.00055664413s4sHighload Wallet V3 ✅BestBest17,956390.10807400.00054037013s4s Preprocessed Wallet V2 Wallet VersionGas delta %Fee delta %RequestsTotal GasGas/MsgTotal Fee (TON)Fee/Msg (TON)Real Time (s)Theory Time (s)Preprocessed Wallet V2-82.05%-50.99%11,53770.05296680.00026483413s4s ​1000 Messages Wallet VersionGas delta %Fee delta %RequestsTotal GasGas/MsgTotal Fee (TON)Fee/Msg (TON)Real Time (s)Theory Time (s)Wallet V2R1+3683.87%+44.18%2501,173,7501,1730.77270000.00077270054m 10s16m 40sWallet V2R2+3748.38%+45.61%2501,193,0001,1930.78040000.00078040054m 10s16m 40sWallet V3R1+3803.22%+46.94%2501,210,7501,2100.78750000.00078750054m 10s16m 40sWallet V3R2+3867.74%+48.37%2501,230,0001,2300.79520000.00079520054m 10s16m 40sWallet V4R2+4119.35%+54.23%2501,308,5001,3080.82660000.00082660054m 10s16m 40sWallet V5R1+2264.51%+3.46%4733,8887330.55451520.00055451552s16sHighload Wallet V3 ✅BestBest431,689310.53592200.00053592213s4s Preprocessed Wallet V2 Wallet VersionGas delta %Fee delta %RequestsTotal GasGas/MsgTotal Fee (TON)Fee/Msg (TON)Real Time (s)Theory Time (s)Preprocessed Wallet V2-80.64%-50.79%46,14860.26370720.00026370752s16s ​Sending Comment ​1 Messages Wallet VersionGas delta %Fee delta %RequestsTotal GasGas/MsgTotal Fee (TON)Fee/Msg (TON)Real Time (s)Theory Time (s)Wallet V2R1 ✅BestBest12,7692,7690.00176200.001762013s4sWallet V2R2+2.78%+1.74%12,8462,8460.00179280.001792813s4sWallet V3R1+5.34%+3.35%12,9172,9170.00182120.001821213s4sWallet V3R2+8.12%+5.10%12,9942,9940.00185200.001852013s4sWallet V4R2+19.46%+12.23%13,3083,3080.00197760.001977613s4sWallet V5R1+78.36%+54.71%14,9394,9390.00272600.002726013s4sHighload Wallet V3+187.32%+184.60%17,9567,9560.00501480.005014813s4s Preprocessed Wallet V2 Wallet VersionGas delta %Fee delta %RequestsTotal GasGas/MsgTotal Fee (TON)Fee/Msg (TON)Real Time (s)Theory Time (s)Preprocessed Wallet V2-44.49%-18.43%11,5371,5370.00143720.001437213s4s ​4 Messages Wallet VersionGas delta %Fee delta %RequestsTotal GasGas/MsgTotal Fee (TON)Fee/Msg (TON)Real Time (s)Theory Time (s)Wallet V2R1 ✅BestBest14,6951,1730.00329560.000823913s4sWallet V2R2+1.70%+0.93%14,7721,1930.00332640.000831613s4sWallet V3R1+3.15%+1.79%14,8431,2100.00335480.000838713s4sWallet V3R2+4.85%+2.73%14,9201,2300.00338560.000846413s4sWallet V4R2+11.50%+6.54%15,2341,3080.00351120.000877813s4sWallet V5R1+51.06%+37.07%17,0901,7720.00451760.001129413s4sHighload Wallet V3+69.56%+108.67%17,9561,9890.00687720.001719313s4s Preprocessed Wallet V2 Wallet VersionGas delta %Fee delta %RequestsTotal GasGas/MsgTotal Fee (TON)Fee/Msg (TON)Real Time (s)Theory Time (s)Preprocessed Wallet V2-67.26%-28.13%11,5373840.00236840.000592113s4s ​200 Messages Wallet VersionGas delta %Fee delta %RequestsTotal GasGas/MsgTotal Fee (TON)Fee/Msg (TON)Real Time (s)Theory Time (s)Wallet V2R1+2907.69%+35.54%50234,7501,1730.16478000.00082390010m 50s3m 20sWallet V2R2+2958.97%+36.81%50238,6001,1930.16632000.00083160010m 50s3m 20sWallet V3R1+3002.56%+37.97%50242,1501,2100.16774000.00083870010m 50s3m 20sWallet V3R2+3053.84%+39.24%50246,0001,2300.16928000.00084640010m 50s3m 20sWallet V4R2+3253.84%+44.41%50261,7001,3080.17556000.00087780010m 50s3m 20sWallet V5R1 ✅+1792.30%Best1147,6227380.12156880.00060784413s4sHighload Wallet V3Best+5.74%17,956390.12855400.00064277013s4s Preprocessed Wallet V2 Wallet VersionGas delta %Fee delta %RequestsTotal GasGas/MsgTotal Fee (TON)Fee/Msg (TON)Real Time (s)Theory Time (s)Preprocessed Wallet V2-82.05%-48.00%11,53770.06320680.00031603413s4s ​1000 Messages Wallet VersionGas delta %Fee delta %RequestsTotal GasGas/MsgTotal Fee (TON)Fee/Msg (TON)Real Time (s)Theory Time (s)Wallet V2R1+3683.87%+36.02%2501,173,7501,1730.82390000.00082390054m 10s16m 40sWallet V2R2+3748.38%+37.29%2501,193,0001,1930.83160000.00083160054m 10s16m 40sWallet V3R1+3803.22%+38.46%2501,210,7501,2100.83870000.00083870054m 10s16m 40sWallet V3R2+3867.74%+39.73%2501,230,0001,2300.84640000.00084640054m 10s16m 40sWallet V4R2+4119.35%+44.91%2501,308,5001,3080.87780000.00087780054m 10s16m 40sWallet V5R1 ✅+2264.51%Best4733,8887330.60571520.00060571552s16sHighload Wallet V3Best+5.38%431,689310.63832200.00063832213s4s Preprocessed Wallet V2 Wallet VersionGas delta %Fee delta %RequestsTotal GasGas/MsgTotal Fee (TON)Fee/Msg (TON)Real Time (s)Theory Time (s)Preprocessed Wallet V2-80.64%-48.01%46,14860.31490720.00031490752s16s ​Sending Jettons ​1 Messages Wallet VersionGas delta %Fee delta %RequestsTotal GasGas/MsgTotal Fee (TON)Fee/Msg (TON)Real Time (s)Theory Time (s)Wallet V2R1 ✅BestBest12,7692,7690.00210120.002101213s4sWallet V2R2+2.78%+1.46%12,8462,8460.00213200.002132013s4sWallet V3R1+5.34%+2.81%12,9172,9170.00216040.002160413s4sWallet V3R2+8.12%+4.28%12,9942,9940.00219120.002191213s4sWallet V4R2+19.46%+10.26%13,3083,3080.00231680.002316813s4sWallet V5R1+78.36%+45.87%14,9394,9390.00306520.003065213s4sHighload Wallet V3+187.32%+170.94%17,9567,9560.00569320.005693213s4s Preprocessed Wallet V2 Wallet VersionGas delta %Fee delta %RequestsTotal GasGas/MsgTotal Fee (TON)Fee/Msg (TON)Real Time (s)Theory Time (s)Preprocessed Wallet V2-44.49%-15.45%11,5371,5370.00177640.001776413s4s ​4 Messages Wallet VersionGas delta %Fee delta %RequestsTotal GasGas/MsgTotal Fee (TON)Fee/Msg (TON)Real Time (s)Theory Time (s)Wallet V2R1 ✅BestBest14,6951,1730.00465240.001163113s4sWallet V2R2+1.70%+0.66%14,7721,1930.00468320.001170813s4sWallet V3R1+3.15%+1.27%14,8431,2100.00471160.001177913s4sWallet V3R2+4.85%+1.93%14,9201,2300.00474240.001185613s4sWallet V4R2+11.50%+4.63%",
    "category": "wallets",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:28:52.742Z"
  },
  {
    "id": "docs-ton-org--standard-wallets-interact",
    "title": "How to interact with wallet",
    "url": "https://docs.ton.org/standard/wallets/interact",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsHow they workMnemonicsComparisonPerformance benchmarkHow to interactHistoryV4V5Highload WalletsLockup walletPreprocessed Wallet V2Restricted walletTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationWalletsHow to interact with walletStandard contractsWalletsHow to interact with walletCopy pageCopy pageCreating a wallet involves several steps Generate a mnemonic; wallet will be still in nonexist status. Derive the public key and the wallet address out of it. Put some funds to the address; wallet account will move to uninit status. Deploy code of wallet contract to that address; account will move to active status. ​Derive wallet address The following algorithm is used by wallet apps, and has to be replicated if the same wallet address should be generated programmatically. A wallet account’s address is derived from StateInit that stores in its data field two values: public_key, dependent on the mnemonic; wallet_id, a special salt-like field, dependent on the wallet contract type and the network_id. Sometimes wallet_id is also called subwallet_id in some of the libraries and documentation. They mean the same thing. This means that the mnemonic alone does not determine an address uniquely: wallet_id has to be known to compute the address. ​Default wallet_id values NetworkV4R2V5Mainnet0x29a9a317 (698983191)0x7FFFFF11 (2147483409)Testnet0x29a9a317 (698983191)0x7FFFFFFD (2147483645) For Wallet V4R2 wallet_id is defined as first 4 bytes from TON mainnet blockchain initial state hash. There is no specific logic why this number was chosen, community needed some default value and this one works well enough. For Wallet V5, wallet_id is different between Mainnet and Testnet for security reasons. There will be different wallet addresses for different networks with the same mnemonic. This prevents replaying transactions from testnet on mainnet, and ensuing loss of funds. The wallet_id value is obtained from network_id: -239 for mainnet, -3 for testnet, wallet_version: currently always 0, subwallet_number: 0 by default, workchain: 0 for basechain by the following algorithm: CopyAsk AItype WalletIdV5 = { // currently always 0 readonly walletVersion: number; // -239 for mainnet, -3 for testnet readonly networkGlobalId: number; // 0 for basechain readonly workchain: number; // 0 for the first wallet with this mnemonic readonly subwalletNumber: number; } export function storeWalletIdV5(walletId: WalletIdV5) { return (builder: Builder) => { builder.storeInt(walletId.networkGlobalId, 32); builder.storeInt(walletId.workchain, 8); builder.storeUint(walletId.walletVersion, 8); builder.storeUint(walletId.subwalletNumber, 32); } } Algorithm here is presented for educational purposes, in most cases there is no need to reimplement it. Use the existing implementation from TON SDKs instead. ​Examples The following examples use wrappers for wallet contracts from the @ton/ton TypeScript SDK. ​Wallet V4R2 CopyAsk AIimport { mnemonicToPrivateKey } from '@ton/crypto'; import { WalletContractV4 } from '@ton/ton'; // 12‑ or 24‑word mnemonic (space‑separated) const mnemonic = 'bread table ...'; // async function for await const main = async () => { const keyPair = await mnemonicToPrivateKey( mnemonic.split(' ') ); const walletContractV4 = WalletContractV4.create({ workchain: 0, publicKey: keyPair.publicKey, // this magic number is default wallet_id for V4R2 wallet contract walletId: 0x29a9a317, }); console.log(walletContractV4.address); } void main(); See all 21 lines ​Wallet V5 CopyAsk AIimport { mnemonicToPrivateKey } from '@ton/crypto'; import { WalletContractV5R1 } from '@ton/ton'; // 12‑ or 24‑word mnemonic (space‑separated). const mnemonic = 'foo bar baz ...'; // async function for await const main = async () => { const keyPair = await mnemonicToPrivateKey( mnemonic.split(' '), ); // testnet const testnetV5Wallet = WalletContractV5R1.create({ walletId: { networkGlobalId: -3, }, publicKey: keyPair.publicKey, workchain: 0, }); console.log(testnetV5Wallet.address); // mainnet const mainnetV5Wallet = WalletContractV5R1.create({ walletId: { networkGlobalId: -239, }, publicKey: keyPair.publicKey, workchain: 0, }); console.log(mainnetV5Wallet.address); }; void main(); See all 36 lines This wallet contract instance can be used to send messages to the blockchain. ​Comments Wallet apps can attach short human-readable notes — commonly called comments — to outgoing internal messages. On-chain they are just message bodies with a specific layout that ecosystem agreed to interpret as text. ​Comment format The first 32 bits of the incoming message body must be the opcode 0x00000000. This value signals that the rest of the payload should be treated as a comment. The remaining bytes are UTF-8 encoded text. Wallet apps should tolerate invalid or empty strings — many senders emit messages without a comment or with zero-length payloads. When parsing, always inspect the opcode before assuming a text comment. If the opcode differs, fall back to handling other contract-specific payloads. Because comments ride inside ordinary internal messages, the format works identically for: native Toncoin transfers between wallets; Jetton transfers, where the wallet forwards an internal message to the token wallet along with the comment payload; NFT transfers, where the comment travels in the same forwarding message that moves the ownership record. ​Attaching a comment when sending To include a comment in an outgoing transfer, construct an internal message body that starts with 0x00000000 and append the UTF-8 bytes of the note YOU want to share. Most wallet libraries expose helpers for this, but the underlying steps are: Allocate a cell. Store the 32-bit zero opcode. Store the text as a byte string (UTF-8 encoded). Send the internal message along with the desired Toncoin, Jettons, or NFT payload. Receivers that follow the convention will display the decoded text to the user. Contracts that do not recognize the opcode will simply ignore it or treat the message body as opaque data, so comments are backward-compatible with existing transfers. ​Example: Sending a comment with @ton/core CopyAsk AIimport { Cell, beginCell } from '@ton/core'; function createCommentCell(comment: string): Cell { return beginCell() // opcode for comment .storeUint(0, 32) // UTF-8 encoded text in snake encoding .storeStringTail(comment) .endCell(); } Was this page helpful?YesNoSuggest editsRaise issuePreviousHistoryNext⌘IgithubxtelegramPowered by MintlifyOn this pageDerive wallet addressDefault wallet_id valuesExamplesWallet V4R2Wallet V5CommentsComment formatAttaching a comment when sendingExample: Sending a comment with @ton/core",
    "category": "wallets",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "testnet",
      "mainnet",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:28:55.357Z"
  },
  {
    "id": "docs-ton-org--standard-wallets-lockup",
    "title": "Lockup wallet",
    "url": "https://docs.ton.org/standard/wallets/lockup",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsHow they workMnemonicsComparisonPerformance benchmarkHow to interactHistoryV4V5Highload WalletsLockup walletPreprocessed Wallet V2Restricted walletTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationWalletsLockup walletStandard contractsWalletsLockup walletCopy pageCopy pageLockup wallet is a specialized wallet contract that locks funds until a specified time. The repository contains two implementations with different unlocking mechanisms. ​Universal Lockup Wallet Universal Lockup Wallet implements time-based fund locking with allowlist functionality. All funds unlock simultaneously when the time restrictions expire. Source code: universal/uni-lockup-wallet.fc ​Use cases Escrow services. Lock funds until conditions are met, with allowlist of valid recipients. ​Persistent memory layout CopyAsk AIstorage$_ seqno:uint32 subwallet_id:uint32 public_key:uint256 config_public_key:uint256 allowed_destinations:(PfxHashmapE 267 ^Cell) total_locked_value:Coins locked:HashmapE 32 Coins total_restricted_value:Coins restricted:HashmapE 32 Coins = Storage; seqno: 32-bit sequence number for replay protection. subwallet_id: 32-bit wallet identifier. public_key: 256-bit Ed25519 public key for signing external messages (wallet operations). config_public_key: 256-bit Ed25519 public key for signing internal messages that add locked funds. This separation allows a third party to initialize and fund the lockup wallet without having access to spend the funds. allowed_destinations: Prefix dictionary of allowlisted destination addresses (uses pfxdict_get? for prefix matching). total_locked_value: Total amount of locked funds (unrestricted destinations). locked: Dictionary mapping unlock timestamps to locked amounts. total_restricted_value: Total amount of restricted funds (allowlist-only). restricted: Dictionary mapping unlock timestamps to restricted amounts. ​Message layout ​External message body layout signature: 512-bit Ed25519 signature. subwallet_id: 32-bit subwallet identifier. valid_until: 32-bit Unix timestamp. msg_seqno: 32-bit sequence number. Message list: References to messages to send. The contract unlocks expired funds, reserves locked amounts using raw_reserve(effectively_locked, 2), and sends messages. Each message is sent with its specified mode, but if mode is not 2, it’s forced to mode 3 (pay fees separately, ignore errors). ​Internal message body layout Internal messages with op = 0x82eaf9c4 (rwallet_op) allow adding locked funds: CopyAsk AIrwallet_op#82eaf9c4 signature:(## 512) cmd:(## 32) only_restrict:(## 1) timestamp:(## 32) = InternalMsgBody; Message requirements: Must carry ≥1 TON value. Contain valid signature from config_public_key. cmd must be 0x373aa9f4 (restricted_transfer). only_restrict: Flag determining lock type: 1 for restricted funds, 0 for locked funds. timestamp: Unix timestamp for unlock. Internal messages with other opcodes from allowlisted addresses are silently ignored. ​Get methods int seqno() returns current sequence number. int wallet_id() returns current subwallet ID. int get_public_key() returns stored public key. (int, int, int) get_balances_at(int time) returns balance, restricted value, and locked value at specified time. (int, int, int) get_balances() returns current balance, restricted value, and locked value. int check_destination(slice destination) returns whether destination address is allowlisted. There is no get-method for config_public_key. This is by design — the configuration key is only used internally for adding locked funds. ​Exit codes Exit codeDescription 31Signature verification failed (wrong_signature)32Config signature verification failed33Message value too small (< 1 TON)34Sequence number mismatch (wrong_seqno)35Subwallet ID mismatch (wrong_subwallet_id)36Message expired (replay_protection)40Unknown operation code (unknown_op)41Unknown command (unknown_cmd) ​Vesting Wallet Vesting Wallet implements gradual fund unlocking over time with an optional cliff period. The funds unlock linearly according to a vesting schedule. Available through web interface. Source code. ​Use cases Employee token vesting. Lock employee tokens with vesting schedule (e.g., 4 years with 1-year cliff). ​Persistent memory layout CopyAsk AIstorage$_ stored_seqno:uint32 stored_subwallet:uint32 public_key:uint256 start_time:uint64 total_duration:uint32 unlock_period:uint32 cliff_duration:uint32 total_amount:Coins allow_elector:Bool = Storage; stored_seqno: 32-bit sequence number (replay protection). stored_subwallet: 32-bit wallet identifier. public_key: 256-bit Ed25519 public key for signing external messages. start_time: 64-bit Unix timestamp when vesting begins. total_duration: 32-bit total vesting duration in seconds. unlock_period: 32-bit period between unlocks in seconds. cliff_duration: 32-bit cliff period before first unlock. total_amount: Total amount subject to vesting. allow_elector: Boolean flag that bypasses vesting restrictions for transfers to Elector and Config contracts. ​Message layout ​External message body layout signature: 512-bit Ed25519 signature. subwallet_id: 32-bit subwallet identifier. valid_until: 32-bit Unix timestamp. msg_seqno: 32-bit sequence number. Optional: One message reference. If present, mode MUST be 3 (pay fees separately, ignore errors). The contract calculates locked amount based on vesting schedule: Before start_time + cliff_duration: All funds locked. During vesting: Linear unlock based on unlock_period. After start_time + total_duration: All funds unlocked. When allow_elector is enabled, vesting restrictions are bypassed for transfers to system contracts (see allow_elector field description above). ​Internal message body layout Internal messages are ignored (no operations performed). ​Get methods int seqno() returns current sequence number. int get_public_key() returns stored public key. int get_locked_amount(int now_time) returns locked amount at specified time. (int, int, int, int, int, int) get_lockup_data() returns (start_time, total_duration, unlock_period, cliff_duration, total_amount, allow_elector). ​Exit codes Exit codeDescription 33Sequence number mismatch34Subwallet ID mismatch35Signature verification failed36Message expired (valid_until check failed)37Invalid number of message references38Invalid send mode (must be 3 if message present) Was this page helpful?YesNoSuggest editsRaise issuePreviousSpecificationNext⌘IgithubxtelegramPowered by MintlifyOn this pageUniversal Lockup WalletUse casesPersistent memory layoutMessage layoutExternal message body layoutInternal message body layoutGet methodsExit codesVesting WalletUse casesPersistent memory layoutMessage layoutExternal message body layoutInternal message body layoutGet methodsExit codes",
    "category": "wallets",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:29:15.232Z"
  },
  {
    "id": "docs-ton-org--standard-wallets-restricted",
    "title": "Restricted wallet",
    "url": "https://docs.ton.org/standard/wallets/restricted",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsHow they workMnemonicsComparisonPerformance benchmarkHow to interactHistoryV4V5Highload WalletsLockup walletPreprocessed Wallet V2Restricted walletTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationWalletsRestricted walletStandard contractsWalletsRestricted walletCopy pageCopy pageSecurity warningRestricted Wallet is unmaintained and has unresolved security issues. Restricted Wallet is a specialized wallet contract that restricts transfers to predefined owner address, and some operations with Elector and Config contracts. It is used in Single Nominator project to securely hold a validator stake and participate in elections without a risk of stealing funds from it. ​What makes it different Unlike standard wallets that allow transfers to any address, Restricted Wallet implements address-based restrictions that limit where funds can be sent. Standard wallet behavior: You can send funds to any valid address. Restricted Wallet behavior: You can only send funds to the predefined owner address or do operations with Elector (new stake, recover stake request, new complaint, and vote for a complaint) and Config (vote for specific proposal to change config) contracts. ​How it works ​Allowed actions Send a message to the owner of this wallet. Send “vote for a configuration proposal” message to the Config contract. Send “new stake”, “recover stake request”, “new complaint”, or “vote for a complaint” messages to the Elector contract. It is allowed to use message modes 128, 64, 2, and 1. Mode 2 (ignore errors) is always enabled when sending messages from this wallet. ​Implementation ​Source code Repository: EmelyanenkoK/nomination-contract/restricted-wallet Was this page helpful?YesNoSuggest editsRaise issuePreviousOverviewNext⌘IgithubxtelegramPowered by MintlifyOn this pageWhat makes it differentHow it worksAllowed actionsImplementationSource code",
    "category": "wallets",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:29:17.255Z"
  },
  {
    "id": "docs-ton-org--standard-wallets-highload",
    "title": "Highload wallets",
    "url": "https://docs.ton.org/standard/wallets/highload",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsHow they workMnemonicsComparisonPerformance benchmarkHow to interactHistoryV4V5Highload WalletsOverviewHighload Wallet v3Highload Wallet v2Lockup walletPreprocessed Wallet V2Restricted walletTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationHighload WalletsHighload walletsStandard contractsWalletsHighload WalletsHighload walletsCopy pageCopy pageHighload Wallets are specialized wallet contracts designed for services that need to send hundreds of transactions per second, such as cryptocurrency exchanges, payment processors, and high-volume trading platforms. ​What makes them different Unlike standard wallets (v3, v4, v5) that use sequential processing with a seqno counter, Highload Wallets (v2 and v3) store processed request identifiers in a dictionary, enabling parallel transaction submission without blocking. seqno (sequence number) is a counter that increments with each transaction. Standard wallets use it for replay protection — each transaction must match the current seqno value. Standard wallet limitation: Each transaction must wait for the previous one to complete. If you send 100 transactions, they must process sequentially: transaction 2 waits for transaction 1, transaction 3 waits for transaction 2, and so on. Highload Wallet advantage: You can send 100, 1,000, or 100,000 transactions simultaneously. Each transaction uses a unique query_id instead of a sequential seqno, allowing parallel processing without conflicts. ​Version history ​Highload Wallet v1 The first highload wallet, using a simple seqno counter: Simple seqno-based: Sequential processing like standard wallets Batch support: Could send up to 255 messages per transaction Replay protection rollback: If the action phase failed, replay protection would roll back (learn about) Legacy contracts: Highload Wallet v1 and v2 are deprecated. Use Highload Wallet v3 for all new deployments. ​Highload Wallet v2 Improved version with dictionary-based replay protection: Fund locking risk: Under certain conditions, the contract could enter a state where funds become inaccessible High gas costs: Storage updates and cleanup operations consumed excessive gas Replay protection rollback: If the action phase failed, replay protection would roll back (learn about) Legacy contracts: Highload Wallet v1 and v2 are deprecated. Use Highload Wallet v3 for all new deployments. ​Highload Wallet v3 The current recommended version, redesigned to solve all previous architectural problems: More requests: Up to 8,380,416 unique query IDs with efficient rotation Lower gas costs: Optimized cleanup and storage operations Maximum safety: Architectural design prevents fund locking; bulletproof Guaranteed replay protection: Unlike v1, v2, and standard wallets v1-v4, replay protection never rolls back even if the action phase fails. The two-transaction pattern ensures the query_id is always committed before attempting to send messages. ​Highload Wallet version comparison Featurev1v2v3Replay rollback on action failure⚠️ Yes⚠️ Yes✅ No (two-transaction pattern)Fund locking risk✅ No⚠️ Yes✅ NoGas efficiencyNot optimized⚠️ High cleanup costs✅ OptimizedMax batch size255 messages255 messages254 messagesReplay protectionSimple seqnoQuery ID dictionaryDual dictionary + timestampTransaction patternSingle transactionSingle transactionTwo-transaction patternQuery ID spaceSequential seqno~32,0008,380,416 unique IDsParallel submissions❌ Sequential only✅ Supported✅ SupportedStatus⚠️ Deprecated⚠️ Deprecated✅ Recommended ​Replay protection rollback Standard wallets (v1-v4) and Highload wallets (v1-v2) share a fundamental problem: if the action phase fails (e.g., insufficient funds), the entire transaction rolls back, including replay protection marks. This causes lite-servers to retry the same message repeatedly, burning gas for a long time. Highload v3’s solution: Uses a two-transaction pattern where replay protection is committed in the first transaction, and actions are performed in a separate internal transaction. This guarantees replay protection never rolls back, even if sending messages fails. ​See also Highload Wallet v3 — complete technical reference and how-to guides Highload Wallet v2 — legacy version (deprecated) Highload Wallet v1 — legacy version (deprecated) Was this page helpful?YesNoSuggest editsRaise issuePreviousHow to create Highload Wallet v3Next⌘IgithubxtelegramPowered by MintlifyOn this pageWhat makes them differentVersion historyHighload Wallet v1Highload Wallet v2Highload Wallet v3Highload Wallet version comparisonReplay protection rollbackSee also",
    "category": "wallets",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "deployment",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:29:20.186Z"
  },
  {
    "id": "docs-ton-org--standard-wallets-v5-api",
    "title": "Wallet V5 API",
    "url": "https://docs.ton.org/standard/wallets/v5-api",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsHow they workMnemonicsComparisonPerformance benchmarkHow to interactHistoryV4V5OverviewHow to interactHighload WalletsLockup walletPreprocessed Wallet V2Restricted walletTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationV5Wallet V5 APIStandard contractsWalletsV5Wallet V5 APICopy pageCopy pageThis article provides overview of wallet V5 public interfaces, how to interact with them and serialize used data structures. Note, that many of the things we implement in this article are for education purposes and they might need to be refined before production use.Moreover, all these V5 wallet contract interfaces are implemented in @ton/ton client library as WalletV5 contract wrapper class. There are several ways how you can interact with deployed V5 wallet smart contract: Send external signed message Send internal signed message Send internal message from extension Let’s first explore message structure, that is used to perform different actions on wallet contract. ​TL-B This is TL-B for V5 wallet actions, it includes some complex TL-B patterns. You can also find it on GitHub, in the wallet repo. CopyAsk AI// Contract state contract_state$_ is_signature_allowed: (## 1) seqno: # wallet_id: # public_key: (## 256) extensions_dict: (HashmapE 256 int1) = ContractState; // Extended actions in W5: add_extension#02 addr:MsgAddressInt = W5ExtendedAction; delete_extension#03 addr:MsgAddressInt = W5ExtendedAction; set_signature_auth_allowed#04 allowed:Bool = W5ExtendedAction; // note: `m = extended actions count - 1`, so the last ref is not empty cell extended_list_last$_ action:W5ExtendedAction = W5ExtendedActionList 0; extended_list_action$_ {n:#} action:W5ExtendedAction prev:^(W5ExtendedActionList n) = W5ExtendedActionList (n + 1); // `OutList m` is standard actions from block.tlb: w5_actions_request$_ {m:#} {n:#} out_actions:(Maybe ^(OutList m)) extended_actions:(Maybe (W5ExtendedActionList n)) = W5InnerRequest m n; w5_signed_request$_ {m:#} {n:#} wallet_id: # valid_until: # msg_seqno: # inner: (W5InnerRequest m n) signature: bits512 = W5SignedRequest m n; // actions_count = m, extended_actions_count - 1 = n w5_internal_signed_request#73696e74 {m:#} {n:#} request:(W5SignedRequest m n) = W5MsgBody m n; w5_external_signed_request#7369676e {m:#} {n:#} request:(W5SignedRequest m n) = W5MsgBody m n; w5_extension_action_request#6578746e {m:#} {n:#} query_id:uint64 request:(W5InnerRequest m n) = W5MsgBody m n; // opcode detection, actual InternalMsgBody / ExternalMsgBody is in W5MsgBody w5_internal_signed_request#73696e74 rest:Any = InternalMsgBody; w5_external_signed_request#7369676e rest:Any = InternalMsgBody; w5_extension_action_request#6578746e rest:Any = InternalMsgBody; See all 40 lines Three types of messages that were described above can be seen here: CopyAsk AIw5_internal_signed_request#73696e74 {m:#} {n:#} request:(W5SignedRequest m n) = W5MsgBody m n; w5_external_signed_request#7369676e {m:#} {n:#} request:(W5SignedRequest m n) = W5MsgBody m n; w5_extension_action_request#6578746e {m:#} {n:#} query_id:uint64 request:(W5InnerRequest m n) = W5MsgBody m n; Each of them includes the same W5InnerRequest field that dictates whats need to be done by wallet contract. In case of signed messages, the request needs to be verified, so W5InnerRequest is wrapped in W5SignedRequest structure, which contains necessary information for this. Let’s break down these data structures. ​Message structure Message structure for V5 wallet contract is quite cumbersome and hard to read, it’s made for optimal (de-)serialization and not optimized for understanding. It is described in TL-B languages and includes snake-cell pattern. We will try to get a grip of it by breaking down core data structures and how they are used. You can skip to Examples section, where we would use existing high-level libraries that abstract low level logic from the user. ​Inner Request Inner request is defined as follows: CopyAsk AIw5_actions_request$_ {m:#} {n:#} out_actions:(Maybe ^(OutList m)) extended_actions:(Maybe (W5ExtendedActionList n)) = W5InnerRequest m n; V5 wallet supports two main types of actions that can be performed: The action structure allows for: Send Message Actions: Standard message sending with specified mode Extended Actions: Advanced wallet management operations Add Extension: Register new extension addresses Delete Extension: Remove extension addresses Set Signature Auth: Enable/disable signature-based authentication As you can see in TL-B, out_actions are snake-cell list of ordinary out messages, followed then by binary flag has_other_actions and other_actions extended action list. ​Inner Request Structure The Inner Request serialization follows this structure: ​Serialization Layout The Inner Request is serialized in the following order: ​Signed Request Signed message is a message that was signed using owners private key from his dedicated keypair, method from asymmetric cryptography. Later this message will be verified on-chain using public key stored in wallet smart contract - read more about how ownership verification works. Before V5 standard, there was only one way to deliver signed message to wallet contract - via external-in message. However, external messages has certain limitations, e.g. you can only send external-out messages from the smart contracts themselves. This means that it wasn’t possible to deliver signed message from inside the blockchain, from another smart contract. V5 standard adds this functionality, partially enabling gasless transaction. Besides W5InnerRequest field that contains actual actions that will be performed, W5SignedRequest structure contains usual wallet message fields that were in-place in previous versions, read more about them here. ​Examples Here we will take a look at code examples in Typescript using low level serialization library @ton/core. ​How to create Inner Request As per message structure section above, Inner Request consists of 2 kinds of actions, basic send message actions and extended actions that affect contract behavior. Let’s write code that handles packing for extended actions: CopyAsk AIimport { Address, beginCell, Builder, Cell } from '@ton/core'; // declare actions as tagged union export type OutActionAddExtension = { type: 'addExtension'; address: Address; } export type OutActionRemoveExtension = { type: 'removeExtension'; address: Address; } export type OutActionSetIsPublicKeyEnabled = { type: 'setIsPublicKeyEnabled'; isEnabled: boolean; } export type OutActionExtended = OutActionSetIsPublicKeyEnabled | OutActionAddExtension | OutActionRemoveExtension; // store each action content as described in its TL-B specification: // 8 bits for action tag and then useful payload const outActionAddExtensionTag = 0x02; function storeOutActionAddExtension(action: OutActionAddExtension) { return (builder: Builder) => { builder.storeUint(outActionAddExtensionTag, 8).storeAddress(action.address) } } const outActionRemoveExtensionTag = 0x03; function storeOutActionRemoveExtension(action: OutActionRemoveExtension) { return (builder: Builder) => { builder.storeUint(outActionRemoveExtensionTag, 8).storeAddress(action.address) } } const outActionSetIsPublicKeyEnabledTag = 0x04; function storeOutActionSetIsPublicKeyEnabled(action: OutActionSetIsPublicKeyEnabled) { return (builder: Builder) => { builder.storeUint(outActionSetIsPublicKeyEnabledTag, 8).storeUint(action.isEnabled ? 1 : 0, 1) } } // entry point for storing any extended action export function storeOutActionExtendedV5R1(action: OutActionExtended) { switch (action.type) { case 'setIsPublicKeyEnabled': return storeOutActionSetIsPublicKeyEnabled(action); case 'addExtension': return storeOutActionAddExtension(action); case 'removeExtension': return storeOutActionRemoveExtension(action); default: throw new Error('Unknown action type' + (action as OutActionExtended)?.type); } } // and now the hard part - list snake-cell serialization; // we will use this function recursively, to store actions as reference cells one by one function packExtendedActionsRec(extendedActions: OutActionExtended[]): Cell { const [first, ...rest] = extendedActions; let builder = beginCell() .store(storeOutActionExtendedV5R1(first)); if (rest.length > 0) { // if there are more actions, store them recursively builder = builder.storeRef(packExtendedActionsRec(rest)); } return builder.endCell(); } See all 78 lines Now we have to deal with basic action serialization. However, since these are the messages that are described in block.tlb, we can use contract-agnostic code from serialization library to store them. Here is a code snippet for storing V5 wallet actions as per Inner Request TL-B: CopyAsk AIimport { beginCell, Builder, Cell, loadOutList, OutActionSendMsg, SendMode, Slice, storeOutList } from '@ton/core'; // helper functions export function isOutActionExtended(action: OutAction",
    "category": "wallets",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "testnet",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:29:22.474Z"
  },
  {
    "id": "docs-ton-org--ecosystem-wallet-apps-tonkeeper",
    "title": "Tonkeeper",
    "url": "https://docs.ton.org/ecosystem/wallet-apps/tonkeeper",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appswallet.ton.orgTonkeeperGet coins on testnetDeep linksAddresses workflowExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationWallet appsTonkeeperEcosystemWallet appsTonkeeperCopy pageCopy pageTonkeeper is a self‑custodial mobile wallet available on iOS and Android. It supports regular wallets, Jettons, NFTs, and TON Connect. Its github repository can be found here. 🟡 Account balance displays the total amount of Toncoin and other tokens held on account. 🔴 Account address is shown as a base64-encoded string. It can be shared to receive TON, jettons, or NFTs. 🟢 Send/Receive/Scan buttons are used to transfer TON or jettons to another account, receive TON or jettons to the wallet, and scan QR codes to confirm transactions, respectively. ​Create a wallet A wallet is required to do any transactions on a public global network. It is the primary way to interact with the blockchain. This step-by-step guide explains how to use Tonkeeper app to create a testnet wallet account. Testnet is used instead of mainnet, because it is more suitable for development and experimentation, and test coins can be obtained for free on testnet. The procedure works the same way on mainnet, except funds will have to be procured in a different way. Overall procedure is: Generate a mnemonic (a key). It uniquely determines wallet’s address, but the wallet doesn’t exist on blockchain yet, i.e. is in nonexist status. Send some funds to the wallet’s account. Now it will be in uninit status, i.e. already with some balance on it, but without any code yet. Deploy wallet’s code to this address. Some of these funds will be used to pay for the deploy process. Now the wallet is in active status, and can be used for any purpose. Funds at riskAddresses of both mainnet and testnet accounts can be derived from the same mnemonic, i.e. the same key might be used for both wallets. Beware these accounts exist only in their corresponding networks.It’s possible to forget switching to testnet, and accidentally spend real funds on mainnet.It’s possible to accidentally transfer funds to a testnet wallet address on mainnet. These funds will be impossible to recover.Verify which network is used before any funds are sent. ​Generate a key Install Tonkeeper on iOS or Android. Click Create New Wallet Create a passcode and re-enter it. Passcode is used to encrypt the mnemonic. Click Back up your recovery phrase and Back Up Manually. Save 24 words of the mnemonic. Funds at riskMnemonic is the text representation of wallet’s secret key. Losing it is the same as losing access to the wallet. Anyone who has access to the mnemonic can take control of the wallet and move funds. If compromise is suspected, create a new wallet and transfer all funds immediately. Prefer not to store recovery words digitally; write them down and keep them offline. Pass the check that the mnemonic was saved. The main interface of the app should now appear. ​Switch to testnet Click wallet to open the Add Wallet pop-up. In the “Add Wallet” window, scroll down to the “For developers” section. Click the “Testnet Account” card. Enter the recovery phrase that was provided when the wallet was created on Mainnet, then click Confirm. The main interface of the app should now appear, indicating that the testnet is used. Also address of the testnet wallet in the user-friendly format starts with k or 0. ​Add funds into the wallet To get free coins on testnet, follow the guide. ​Quick version Message @testgiver_ton_bot in Telegram. Press the Start or send /start message. Pass the captcha test. Enter and send the testnet wallet address displayed by wallet. Soon after the “Request added to the queue” response, 2 TON will be sent to the wallet. There won’t be any other message that the transfer happened. Use an explorer to check the request status. The account should be in the uninit status now. ​Deploy the code Funds at riskOn-chain transfers are irreversible — verify the recipient and amount before confirming. Use testnet for practice; use mainnet only for real transfers. To deploy the code, send any transaction from the wallet. The recipient can be any address, including the wallet itself. Click Send on the main interface, enter wallet address in “Address or name”, and the “Amount” of TON. Click Continue. Verify the transaction details and swipe if correct. Otherwise, tap < in the top-left corner to edit. After confirmation, enter the passcode. Then, the “History” page displays the sent transaction. Use an explorer to check wallet’s status. It should be active now. ​Check the account state Use a blockchain explorer to inspect the account. For Testnet, use Tonviewer Testnet. Paste the wallet address into the search bar. The account details will appear. In a newly created wallet, the status is nonexist, indicating the wallet is not deployed. ​Verify wallet’s version By default, Tonkeeper creates wallets with the Wallet v5 code deployed on them. To switch wallet contract version to v4: On the main menu, tap the gear icon in the upper-right corner. In “Settings”, select Wallet v4R2 and enter the passcode. The wallet v4r2 is auto-generated and the app returns to the main menu. If v5 is highlighted, v4 has no visual indicator. To check, tap the wallet name — wallet v4r2 — v5 is highlighted, while v4 is not. Was this page helpful?YesNoSuggest editsRaise issuePreviousGet coins on testnetNext⌘IgithubxtelegramPowered by MintlifyOn this pageCreate a walletGenerate a keySwitch to testnetAdd funds into the walletQuick versionDeploy the codeCheck the account stateVerify wallet’s version",
    "category": "wallets",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "testnet",
      "mainnet",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:29:23.618Z"
  },
  {
    "id": "docs-ton-org--ecosystem-wallet-apps-deep-links",
    "title": "Deep links",
    "url": "https://docs.ton.org/ecosystem/wallet-apps/deep-links",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appswallet.ton.orgTonkeeperGet coins on testnetDeep linksAddresses workflowExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationWallet appsDeep linksEcosystemWallet appsDeep linksCopy pageCopy pageDeep links allow to seamlessly direct users from a dApp back to a meaningful location within a TON wallet and invoke corresponding actions. Issue wallet invoices using deep links. See transaction link formats for popular explorers. ​TON Connect invoices CopyAsk AItc://<TON_CONNECT_LINK_BODY> Best for dApps that require multiple transactions within a session or a persistent wallet connection. Advantages Permanent communication channel with the wallet. Users only scan a QR code once. Can track transaction confirmation via the returned BoC. Ready-made SDKs and UI kits for various platforms. Disadvantages If only one payment is needed, users must connect the wallet and confirm the transaction. More complex integration than a ton:// link. Explore TON Connect. ​Deep links invoices The TON link ton:// is less preferred in the ecosystem, but may be useful for simple and tiny one-time payment flow. CopyAsk AIton://<LINK-BODY> Advantages Easy integration. No need to connect a wallet. Disadvantages Users must scan a new QR code for each payment. Cannot track if the user signed the transaction. No information about the user’s address. Requires workarounds for platforms where links are not clickable (e.g., Telegram Desktop bots). The ton:// scheme is part of the broader TON blockchain standard, enabling interoperability across different TON-based wallets and services. ​Example workflows Quick payments: Integrate payment requests directly from your website, allowing users to complete transactions with a single tap using ton:// transfer links. In-app transactions: Use deep links to facilitate seamless transfers between users within your application. Link to specific transfers: Provide support or history review by linking directly to specific transactions or transfers. ​TON transfer Opens the pre-filled Send screen and prompts the user to enter the missing data. Transfer schemeCopyAsk AIton://transfer/<ADDRESS>?amount=<AMOUNT>&text=<TEXT> ParameterDescriptionRequired<ADDRESS>The recipient’s TON address.required<AMOUNT>The amount of TON to send, in nanotons.optional<TEXT>A URL-encoded UTF-8 text message to attach to the transfer.optional ​TON transfer to address schemeCopyAsk AIton://transfer/<ADDRESS> exampleCopyAsk AIton://transfer/UQDYzZmfsrGzhObKJUw4gzdeIxEai3jAFbiGKGwxvxHinf4K ​TON transfer with amount schemeCopyAsk AIton://transfer/<ADDRESS>?amount=<AMOUNT> exampleCopyAsk AIton://transfer/UQDYzZmfsrGzhObKJUw4gzdeIxEai3jAFbiGKGwxvxHinf4K?amount=5000000 ​TON transfer with text comment schemeCopyAsk AIton://transfer/<ADDRESS>?text=<TEXT> exampleCopyAsk AIton://transfer/UQDYzZmfsrGzhObKJUw4gzdeIxEai3jAFbiGKGwxvxHinf4K?text=hello ​TON Transfer with amount and text comment schemeCopyAsk AIton://transfer/<ADDRESS>?amount=<AMOUNT>&text=<TEXT> exampleCopyAsk AIton://transfer/UQDYzZmfsrGzhObKJUw4gzdeIxEai3jAFbiGKGwxvxHinf4K?amount=5000000&text=hello ​Transfer with expiry timestamp Opens the Send screen with an expiry timestamp for the transaction. Scheme with timestampCopyAsk AIton://transfer/<ADDRESS>?amount=<AMOUNT>&text=<TEXT>&exp=<EXPIRY_TIMESTAMP> ParameterDescriptionRequired<ADDRESS>The recipient’s TON address.required<AMOUNT>The amount of TON to send, in nanotons.optional<TEXT>A URL-encoded UTF-8 text message to attach to the transfer.optional<EXPIRY_TIMESTAMP>Expiry timestamp in seconds since the Unix epoch.optional The exp parameter, like other parameters, must be included when constructing the message to ensure the blockchain rejects transactions with an expired exp. ​TON transfer with expiry timestamp scheme tranfser with expiryCopyAsk AIton://transfer/<ADDRESS>?amount=<AMOUNT>&text=<TEXT>&exp=<EXPIRY_TIMESTAMP> example transfer with expiryCopyAsk AIton://transfer/EQD2NmD_lH5f5u1Kj3KfGyTvhZSX0Eg6qp2a5IQUKXxOG21n?amount=100000&text=test&exp=2147483647 ​Jetton transfer Opens the Send screen with a jetton transfer. Jetton is a standard for TON assets, like USDT, USDC and e.t.c. SchemeCopyAsk AIton://transfer/<ADDRESS>?jetton=<JETTON_ADDRESS>&amount=<AMOUNT>&text=<TEXT> ParameterDescriptionRequired<ADDRESS>The recipient’s TON wallet address.required<JETTON_ADDRESS>The jetton master address.required<AMOUNT>The amount of jettons to send.optional<TEXT>A URL-encoded UTF-8 text message to attach to the transfer.optional<EXPIRY_TIMESTAMP>Expiry timestamp in seconds since the Unix epoch.optional One whole Jetton for <AMOUNT> is defined by decimals the number of fractional digits unit that represents the smallest indivisible amount of the token (similar to satoshi in Bitcoin). Read more...One whole Jetton=unit×10decimal\\text{One whole Jetton} = unit \\times 10^{decimal}One whole Jetton=unit×10decimalFor example, a USDT Jetton on TON defines decimals = 6. This means:1 USDT=1,000,000 smallest units1\\ \\text{USDT} = 1{,}000{,}000\\ \\text{smallest units}1 USDT=1,000,000 smallest unitsOr, in general form:One whole USDT=unit×106\\text{One whole USDT} = unit \\times 10^{6}One whole USDT=unit×106Typically Jetton on TON defines with decimals = 9, for example, DUST jetton. This means:1 DUST=1,000,000,000 smallest units1\\ \\text{DUST} = 1{,}000{,}000{,}000\\ \\text{smallest units}1 DUST=1,000,000,000 smallest unitsOr, in general form:One whole DUST=unit×109\\text{One whole DUST} = unit \\times 10^{9}One whole DUST=unit×109 ​Transfer default jetton Typically, jetton decimals in amount are equal 9 and evaluation same as for Toncoin. schemeCopyAsk AIton://transfer/<ADDRESS>?jetton=<JETTON_ADDRESS>&amount=<AMOUNT>&text=<TEXT> example transfer 0.005 DUSTCopyAsk AIton://transfer/UQDYzZmfsrGzhObKJUw4gzdeIxEai3jAFbiGKGwxvxHinf4K?jetton=EQBlqsm144Dq6SjbPI4jjZvA1hqTIP3CvHovbIfW_t-SCALE&amount=5000000&text=hello ​Transfer USDT While Toncoin requires nine decimal places and 1 Toncoin equals 1 billion (10910^9109) nanoToncoin, USDT only uses six decimal places. This means that 1 USDT unit stands for 1 million (10610^6106) microUSDT units. The AMOUNT below requires the microUSDT format. schemeCopyAsk AIton://transfer/<ADDRESS>?jetton=<JETTON_ADDRESS>&amount=<AMOUNT>&text=<TEXT> example transfer 0.005 USDTCopyAsk AIton://transfer/UQDYzZmfsrGzhObKJUw4gzdeIxEai3jAFbiGKGwxvxHinf4K?jetton=EQCxE6mUtQJKFnGfaROTKOt1lZbDiiX1kCixRv7Nw2Id_sDs&amount=5000&text=hello ​Transfer with binary data Opens the emulation screen or screen with alert about blind signing transactions with amount and destination. schemeCopyAsk AIton://transfer/<ADDRESS>?amount=<AMOUNT>&bin=<BINARY_DATA> ParameterDescriptionRequired<ADDRESS>The recipient’s TON address.required<AMOUNT>The amount of TON to send, in nanotons.optional<BINARY_DATA>A URL-encoded base64 BoC which will be attached as a body to internal message.optional example transfer with binary dataCopyAsk AIton://transfer/UQDYzZmfsrGzhObKJUw4gzdeIxEai3jAFbiGKGwxvxHinf4K?amount=5000000&bin=te6cckECBQEAARUAAUWIAMEY4jHsfgXgPZLLJhtH/oPEOBKZZb6Y4/RJaJnbXc4GDAEBnBSf8D7P51eitphXHiTNAS6WXVDOgcxIxFWf7JICcG9ooFRNCDzTZbHg0mlW6782P8huKd5wzYK3huSVDMGTrQgpqaMXaMF9SAAAACsAAwIBaGIAV+9GxkYnezSj7VSw9vtlmc5RJ5lsyyItoKd5rFDpJZUgL68IAAAAAAAAAAAAAAAAAAEDAaFfzD0Ug3czLfk9/4aAArAmxHNbYrurO/IYyD89+mJZ/XDMnkMemHy/nTsrzYDwAYIxxGPY/AvAeyWWTDaP/QeIcCUyy30xx+iS0TO2u5wMIDgEACIAAAAAUmVmI05PTmQxZ0pCUK4fW14= ​Wallet-specific invoices Use wallet‑specific links to create simple jetton and Toncoin transfers. The syntax is usually similar to ton://transfer links, but always check each wallet’s documentation. Example: transferring 1 USDT to EQCxE6mUtQJKFnGfaROTKOt1lZbDiiX1kCixRv7Nw2Id_sDs: Tonkeeper mobile linkCopyAsk AIhttps://app.tonkeeper.com/transfer/saint.ton?amount=1000000&jetton=EQCxE6mUtQJKFnGfaROTKOt1lZbDiiX1kCixRv7Nw2Id_sDs Tonkeeper web linkCopyAsk AIhttps://app.tonkeeper.com/transfer/saint.ton?amount=1000000&jetton=EQCxE6mUtQJKFnGfaROTKOt1lZbDiiX1kCixRv7Nw2Id_sDs MyTonWalletCopyAsk AIhttps://my.tt/transfer/UQDYzZmfsrGzhObKJUw4gzdeIxEai3jAFbiGKGwxvxHinf4K?amount=1000000&jetton=EQCxE6mUtQJKFnGfaROTKOt1lZbDiiX1kCixRv7Nw2Id_sDs Find more wallet-specific features in the documentation: Tonkeeper - docs.tonconsole.com MyTonWallet - help.mytonwallet.io ​Explorers links To generate a transaction link, the service must obtain the account address, logical time (lt), and transaction hash by calling the getTransactions method. Using these values, Tonviewer, Tonscan, and Toncoin Explorer render the transaction page according to the following formats respectively: Tonviewer links Tonscan links Toncoin Explorer links ​Tonviewer ​Mainnet Tonviewer Mainnet linkCopyAsk AIhttps://tonviewer.com/transaction/<hash as hex> Tonviewer Mainnet link exampleCopyAsk AIhttps://tonviewer.com/transaction/aee8d185a0c8f73c787bf1872ee9659ac53ce11a90b16b384856a7821eff8c29 ​Testnet Tonviewer Testnet linkCopyAsk AIhttps:/",
    "category": "wallets",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "dapp",
      "api",
      "sdk",
      "testnet",
      "mainnet",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:29:27.041Z"
  },
  {
    "id": "docs-ton-org--standard-tokens-jettons-comparison",
    "title": "Jetton comparison",
    "url": "https://docs.ton.org/standard/tokens/jettons/comparison",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensOverviewMetadataJettonsOverviewHow it worksComparisonMintless JettonMinting jettonsBurnHow to find Jetton walletHow to transfer JettonsGet Jetton wallet dataGet supply dataDeploy mintless JettonAPINFTAirdropVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationJettonsJetton comparisonStandard contractsTokensJettonsJetton comparisonCopy pageCopy pageThis article will compare different implementations of the TEP-74 standard and explore the best version for each use case. ​In short Jetton 2.0 is the latest and most optimized Jetton implementation. Unlike previous versions, it deploys Jetton Wallets in the same shardchain as the owner’s Toncoin wallet. See it in action: Jetton 2.0 repository. ​Implementation history ​Jetton 1.0 Release date: Apr 18, 2022 GitHub Since the initial TEP-74 publication on 12.03.2022, this was the first public Jetton release. It doesn’t support Jetton Wallet Discovery (TEP-89 standard) and contains some gas estimation techniques that are now considered bad practice. Overall, this implementation is deprecated and shouldn’t be used for any production development. ​Discoverable Jetton Release date: Jan 19, 2023 GitHub For a long time, this version was the most widely adopted in the community. The minter.ton.org UI mint tool deploys Jettons with this code. It contains the necessary minimum feature-wise, but isn’t optimized for the latest TVM and blockchain changes. Also, the repository itself doesn’t include any advanced tests and scripts. ​Stablecoin contract Release date: Apr 14, 2024 GitHub With the USDT release on TON, an advanced version of the Jetton contract was developed. This version introduces many new TVM gas assertion techniques, as well as extended functionality. Since USDT is a centralized asset, there are specific requirements and restrictions for its operations. More specifically, there is no burn opcode, which means that formally, the Governance contract is not TEP-compliant, as Jetton burn functionality is part of the standard. Also, the Minter contract includes a governance mechanism that allows users to perform any actions on other Jetton Wallets. Another noticeable advantage of this implementation is extensive testing. All previous versions didn’t test edge cases of config changes that will affect storage / forward fees. This test suite became the foundation for all future Jetton versions. ​Notcoin contract Release date: Apr 25, 2024 GitHub This version is straightforward - it is a forked Stablecoin contract with removed governance functionality and added burn mechanism. Until recent times, it was the most suitable Jetton for basic on-chain coin use cases. ​Mintless Jetton Release date: Sep 22, 2024 GitHub During the time of massive on-chain project airdrops and CEX listings, there was a demand for a cheap and easy way to distribute initial Jetton tokens. You can read more about the history here. This version is also made from the Stablecoin contract with removed governance and allowed burn. It’s implemented as a Merkle-proof airdrop, enabling the minting of Jettons directly on the Jetton-Wallet contract in a decentralized manner. The implementation is designed to support large-scale airdrops without incurring high costs or placing a significant load on the blockchain. To this day, Mintless Jetton is the only widely known implementation that uses the custom_payload field in the original transfer#0f8a7ea5 TL-B. After the initial claim, each Jetton Wallet can be used as a regular Jetton (which it actually is). Note that to use Mintless Jetton to its full extent, you will need to cooperate with wallets for additional indexing and payload creation. ​Jetton 2.0 Release date: Aug 1, 2025 GitHub This is the latest Jetton implementation. It utilizes new shardchain optimizations — Jetton Wallet holding a user’s token balance is now always deployed in the same shardchain as the owner’s wallet. This became possible after the TON node introduced functionality to deploy smart contracts into a specific shardchain. It makes transfers and operations with Jetton 2.0 up to 3 times faster under heavy network load compared to the previous versions of Jetton. This version is recommended for all new projects working with Jettons.Was this page helpful?YesNoSuggest editsRaise issuePreviousMintless JettonNext⌘IgithubxtelegramPowered by MintlifyOn this pageIn shortImplementation historyJetton 1.0Discoverable JettonStablecoin contractNotcoin contractMintless JettonJetton 2.0",
    "category": "tokens",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:29:29.054Z"
  },
  {
    "id": "docs-ton-org--standard-tokens-jettons-mintless-overview",
    "title": "Mintless Jetton",
    "url": "https://docs.ton.org/standard/tokens/jettons/mintless/overview",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensOverviewMetadataJettonsOverviewHow it worksComparisonMintless JettonMinting jettonsBurnHow to find Jetton walletHow to transfer JettonsGet Jetton wallet dataGet supply dataDeploy mintless JettonAPINFTAirdropVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationJettonsMintless JettonStandard contractsTokensJettonsMintless JettonCopy pageCopy page​Introduction To understand this document, you should be familiar with the other basic Jetton standards. TON has introduced Mintless Jettons, an innovative extension of the Jetton standard. Mintless extension adopts Merkle proofs, using them to make airdrops without requiring traditional minting processes. In this article, we will explore how mintless jettons work and how to use them. ​Overview Mintless jettons are an extension (TEP-177 and TEP-176) of the standard Jetton implementation (TEP-74) on TON Blockchain. This implementation enables large-scale, decentralized airdrops to millions of users while minimizing costs and blockchain load. Note that to use a mintless jetton to its full extent, you will need to establish an off-chain architecture. ​Basic features Scalability: Traditional minting processes can be resource-intensive and costly when distributing tokens to a vast number of users. Efficiency: By utilizing Merkle trees, mintless jettons store a single hash representing all airdropped amounts, reducing storage requirements. User-friendly airdrops: No separate pre-claim: wallets attach a Merkle proof on first transfer, so users don’t perform a manual claim action. Because mintless jettons extend the standard jettons, you can interact with them the same way as standard jettons — no additional steps required. ​How it works Mintless jettons leverage Merkle trees and cryptographic proofs to enable efficient, decentralized airdrops without traditional minting. Here’s a detailed breakdown of the technical implementation: ​Merkle Tree Foundation The core innovation lies in representing all airdrop data as a single Merkle tree, where: Leaf nodes contain airdrop information for individual addresses Internal nodes store cryptographic hashes of their children Root hash represents the entire airdrop dataset with a single 256-bit value This approach reduces storage from O(n) per recipient to O(1) for the entire airdrop. ​Data Structures Airdrop HashMap represents how we store individual users’ airdrop information. CopyAsk AI_ amount:Coins start_from:uint48 expired_at:uint48 = AirdropItem; _ _(HashMap 267 AirdropItem) = Airdrop; Each airdrop entry contains: amount: Number of tokens allocated to the recipient start_from: Unix timestamp when claiming becomes available expired_at: Unix timestamp when claiming expires The complete airdrop is stored as a HashMap where the key is a 267-bit internal TON account address and the value is an AirdropItem structure. For the Jetton Master contract, standard storage is extended with merkle_hash: 256-bit root hash of the Merkle tree containing all airdrop data. The standard wallet storage is extended with: merkle_hash: Copy of the master’s Merkle hash for validation already_claimed: Boolean flag indicating whether the airdrop has been claimed ​Claiming Mechanism CopyAsk AImerkle_airdrop_claim#0df602d6 proof:^Cell = CustomPayload; The claiming process uses the custom_payload field in standard jetton transfers with: 0x0df602d6: Operation identifier for Merkle airdrop claims proof: MerkleProof exotic cell containing the cryptographic proof CopyAsk AItransfer#0f8a7ea5 query_id:uint64 amount:(VarUInteger 16) destination:MsgAddress response_destination:MsgAddress custom_payload:(Maybe ^Cell) forward_ton_amount:(VarUInteger 16) forward_payload:(Either Cell ^Cell) = InternalMsgBody; The standard transfer message is enhanced by including the claim proof in custom_payload. ​Cryptographic Proof Validation When a jetton wallet receives a transfer with a claim payload, it performs these validation steps: Merkle Proof Verification Extracts the MerkleProof exotic cell from custom_payload Verifies the proof’s cryptographic integrity against the stored merkle_hash Ensures the proof path leads to a valid AirdropItem for the sender’s address Timestamp Validation Checks that now() >= start_from (claiming period has begun) Verifies that now() <= expired_at (claiming period hasn’t expired) Claim Status Check Ensures already_claimed == false (prevents double-claiming) Amount Validation Extracts the airdrop amount from the validated AirdropItem Credits this amount to the wallet’s balance ​State Transitions Before Claim: CopyAsk AIJettonWallet { balance: 0, already_claimed: false, merkle_hash: <root_hash> } After Successful Claim: CopyAsk AIJettonWallet { balance: <airdrop_amount>, already_claimed: true, merkle_hash: <root_hash> } ​Off-chain Infrastructure ​Merkle Tree Generation Data Collection: Gather all recipient addresses and their allocated amounts Tree Construction: Build a binary Merkle tree with AirdropItem structures as leaves Hash Computation: Calculate SHA-256 hashes recursively up to the root Proof Generation: Create individual Merkle proofs for each recipient ​Proof Serving Static Storage: Host the complete Merkle tree data at mintless_merkle_dump_uri Dynamic API: Implement custom_payload_api_uri to serve individual proofs on demand Caching: Optimize proof retrieval with appropriate caching strategies ​Supporting mintless jettons in wallet applications Wallet applications play a key role in improving the user experience with mintless jettons: Display unclaimed jettons: Wallets should show users the jettons they are eligible to claim based on the Merkle tree data. Automated claim process: When users initiate an outgoing transfer, wallets should automatically include the necessary Merkle proof in the transfer message’s custom payload. Wallets can achieve this by: Integrating with the off-chain API specified in the custom payload API: Check if the jetton is mintless. Verify whether the wallet owner has claimed it. If unclaimed, retrieve data from the custom payload API and add the off-chain balance to the on-chain one. If the user hasn’t claimed the airdrop, retrieve the custom payload and initialization data from the Custom Payload API and include it in the transfer message to the Jetton wallet. Using a custom API: Download the airdrop tree from mintless_merkle_dump_uri in the jetton metadata. Parse the data as explained in Merkle tree generation. Make the parsed result available via API. Wallets are not required to support mintless claims, including indexing airdrop trees. Wallet applications may charge the jetton issuer for this service. ​Supporting mintless jettons in DApps (DEX/Lending platforms) Because wallet applications handle claims automatically, DApps don’t need special logic for mintless jettons. DApps can use APIs (such as TonAPI or Ton Center API) to display unclaimed balances. To improve the user experience, DApps can check if the user’s wallet application supports a specific mintless jetton. If unsupported, retrieve the airdrop proof and initialization data from the Jetton API and include it in the transfer message. ​See also Understanding mintless jettons: a comprehensive guide - the original post. Mintless jetton standard implementation Jetton offchain payloads TEP Jetton metadata standard Was this page helpful?YesNoSuggest editsRaise issuePreviousMinting jettonsNext⌘IgithubxtelegramPowered by MintlifyOn this pageIntroductionOverviewBasic featuresHow it worksMerkle Tree FoundationData StructuresClaiming MechanismCryptographic Proof ValidationState TransitionsOff-chain InfrastructureMerkle Tree GenerationProof ServingSupporting mintless jettons in wallet applicationsSupporting mintless jettons in DApps (DEX/Lending platforms)See also",
    "category": "tokens",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "dapp",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:29:30.922Z"
  },
  {
    "id": "docs-ton-org--standard-tokens-jettons-mint",
    "title": "How to mint new jettons",
    "url": "https://docs.ton.org/standard/tokens/jettons/mint",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensOverviewMetadataJettonsOverviewHow it worksComparisonMintless JettonMinting jettonsBurnHow to find Jetton walletHow to transfer JettonsGet Jetton wallet dataGet supply dataDeploy mintless JettonAPINFTAirdropVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationJettonsHow to mint new jettonsStandard contractsTokensJettonsHow to mint new jettonsCopy pageCopy pageWarning — funds at riskMinting and sending messages can move funds. Scope: your wallet and the target jetton contracts. Rollback: on-chain transfers are final; rotate keys if a mnemonic leaks. Do first (testnet): use a test wallet and testnet RPC before mainnet. In order to mint new jettons, that particular Jetton must be mintable. Otherwise, it’s impossible. Next, only mintable Jettons are considered. Minting is not a specified operation in any of the existing TEPs. Its implementation is left to the developer’s choice. The following typescript code example is based on the minting implementation in Notcoin jetton minter contract. This example contains a manual assembly of all the necessary messages and is useful for studying their possible structure. CopyAsk AIimport { Address, beginCell, internal, toNano } from \"@ton/core\"; import { TonClient, WalletContractV4 } from \"@ton/ton\"; import { mnemonicToPrivateKey } from \"@ton/crypto\"; async function main() { const jettonMasterAddress = Address.parse('<JETTON_MASTER_ADDR>'); const receiverAddress = Address.parse('<RECEIVER_ADDR>'); const destinationAddress = Address.parse('<WALLET_ADDR>'); // let's add some forward_payload const forwardPayload = beginCell() .storeUint(0, 32) // 0 opcode means we have a comment .storeStringTail('Mint') .endCell(); // Forming the master message // internal transfer is also unspecified by the standard, but there is a suggested format in TEP 0074 const masterMessage = beginCell() .storeUint(0x178d4519, 32) // opcode for jetton transfer-internal .storeUint(0, 64) // query id .storeCoins(toNano(5)) // jetton amount, amount * 10^9. That is an amount we want to mint .storeAddress(jettonMasterAddress) // from_address. For minting could be any. The Jetton wallet will check from context that the sender is the Jetton master contract and accept the transfer. .storeAddress(destinationAddress) // response destination .storeCoins(toNano('0.02')) // forward_ton_amount - if >0, will send notification message .storeBit(1) // either forward_payload .storeRef(forwardPayload) // we have forward_payload, store it as a reference .endCell(); // forming the mint message const mintMessageBody = beginCell() .storeUint(0x642b7d07, 32) // opcode for mint .storeUint(0, 64) // query id .storeAddress(receiverAddress) // the user's regular wallet address .storeCoins(toNano(0.1)) // Toncoin intended to user's Jetton wallet .storeRef(masterMessage) // internal transfer message .endCell(); const mintMessage = internal({ to: jettonMasterAddress, value: toNano('0.1'), bounce: true, body: mintMessageBody }); // connect to your regular wallet const client = new TonClient({ endpoint: 'https://toncenter.com/api/v2/jsonRPC', }); const provider = client.provider(destinationAddress); const MNEMONIC = process.env.MNEMONIC; if (!MNEMONIC) throw new Error(\"Set MNEMONIC to a test mnemonic (testnet).\"); const keyPair = await mnemonicToPrivateKey(MNEMONIC.split(\" \")); const walletContract = WalletContractV4.create({ workchain: 0, publicKey: keyPair.publicKey, }); // send the mint message through your wallet const seqno = await walletContract.getSeqno(provider); await walletContract.sendTransfer(provider, { seqno: seqno, secretKey: keyPair.secretKey, messages: [ mintMessage, ], }); } void main(); However, there is an SDK that allows you to avoid manually creating all the necessary messages. An example of how it can be used to send the mint message is provided below: CopyAsk AIimport { Address } from '@ton/core'; import { AssetsSDK, PinataStorageParams, createApi, createSender, importKey } from \"@ton-community/assets-sdk\"; async function main() { const NETWORK = 'testnet'; const api = await createApi(NETWORK); const keyPair = await importKey(process.env.MNEMONIC!); const sender = await createSender('highload-v2', keyPair, api); const storage: PinataStorageParams = { pinataApiKey: process.env.PINATA_API_KEY!, pinataSecretKey: process.env.PINATA_SECRET!, }; const sdk = AssetsSDK.create({ api: api, storage: storage, sender: sender, }); const JETTON_ADDRESS = Address.parse('MY_JETTON_ADDRESS'); const jetton = sdk.openJetton(JETTON_ADDRESS); const RECEIVER_ADDRESS = Address.parse('RECEIVER_ADDRESS'); await jetton.sendMint(sender, RECEIVER_ADDRESS, 1200000n); } void main(); Finally, you can use web services as TON MINTER and avoid writing code, just follow the guides.Was this page helpful?YesNoSuggest editsRaise issuePreviousBurnNext⌘IgithubxtelegramPowered by Mintlify",
    "category": "tokens",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "testnet",
      "mainnet",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:29:32.628Z"
  },
  {
    "id": "docs-ton-org--standard-tokens-jettons-burn",
    "title": "Burn",
    "url": "https://docs.ton.org/standard/tokens/jettons/burn",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensOverviewMetadataJettonsOverviewHow it worksComparisonMintless JettonMinting jettonsBurnHow to find Jetton walletHow to transfer JettonsGet Jetton wallet dataGet supply dataDeploy mintless JettonAPINFTAirdropVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationJettonsBurnStandard contractsTokensJettonsBurnCopy pageCopy pageBurning is a process of reducing supply of a certain Jetton, mostly in order to create deflation. ​Web services To burn Jettons manually, use a web service, for example Minter: Connect your wallet using TON Connect. Enter the Jetton master contract address into the “Jetton address” field. Click the “Burn” button in your wallet’s balance field and enter the amount you want to burn. Confirm burning in your wallet application. ​Another approach An alternative way to burn tokens is to send them to a “zero” account, see How to transfer page. A wallet app can be used for this. ​Programmatically In more complex cases, it is usually done with an SDK (for example, assets-sdk) that handles low-level message serialization details. The provided example uses TON Center API. You’ll need a mnemonic of a wallet that will pay for the burn. JETTON_WALLET_ADDR stands for the Jetton wallet that holds tokens that will be burned. Funds at riskBeware that API keys and mnemonic must not be committed or shared publicly.A better approach is to use a .env file that is excluded from repository with .gitignore. For GitHub CI purposes, consult their documentation. CopyAsk AIimport { Address, toNano, WalletContractV5R1, TonClient } from \"@ton/ton\"; import { mnemonicToPrivateKey } from \"@ton/crypto\"; import { AssetsSDK, createApi } from \"@ton-community/assets-sdk\"; const NETWORK = \"testnet\"; // a list of 24 space-separated words const MNEMONIC = \"foo bar baz ...\"; const JETTON_WALLET_ADDR = Address.parse(\"<JETTON_WALLET_ADDR>\"); async function main() { // create an RPC client that will send network requests const client = new TonClient({ endpoint: \"https://toncenter.com/api/v2/jsonRPC\", }); // extract private and public keys from the mnemonic const keyPair = await mnemonicToPrivateKey(MNEMONIC.split(\" \")); // create a client for TON wallet const wallet = WalletContractV5R1.create({ workchain: 0, // public key is required to deploy a new wallet // if it wasn't deployed yet publicKey: keyPair.publicKey, }); const provider = client.provider(wallet.address); // sender is an object used by assets-sdk to send messages // private key is used to sign messages sent to a wallet const sender = wallet.sender(provider, keyPair.secretKey); // create an assets-sdk client const api = await createApi(NETWORK); const sdk = AssetsSDK.create({ api, sender, }); // create a client for interacting with given jetton wallet const jetton = sdk.openJettonWallet(JETTON_WALLET_ADDR); // burn 1200000 jettons await jetton.sendBurn(sender, 1200000n); } void main(); Was this page helpful?YesNoSuggest editsRaise issuePreviousHow to find Jetton walletNext⌘IgithubxtelegramPowered by MintlifyOn this pageWeb servicesAnother approachProgrammatically",
    "category": "tokens",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "testnet",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:29:34.740Z"
  },
  {
    "id": "docs-ton-org--standard-tokens-jettons-transfer",
    "title": "How to transfer Jettons",
    "url": "https://docs.ton.org/standard/tokens/jettons/transfer",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensOverviewMetadataJettonsOverviewHow it worksComparisonMintless JettonMinting jettonsBurnHow to find Jetton walletHow to transfer JettonsGet Jetton wallet dataGet supply dataDeploy mintless JettonAPINFTAirdropVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationJettonsHow to transfer JettonsStandard contractsTokensJettonsHow to transfer JettonsCopy pageCopy pageTEP-74 standard specifies that Jetton wallets must support transfer operation. Funds at riskEach jetton stores a decimals parameter in its metadata. Transferring without accounting for decimals can result in sending 1000 times the intended amount—irreversible on mainnet.Mitigation: Always retrieve and apply the correct decimals value. Test on testnet first. Read decimals parameter for details. To attach a comment, the message has to encode it in forward_payload field, and forward_ton_amount is some amount of Toncoin attached to let the receiving wallet process the message. Format of forward_payload for comments and other kinds of attached data can be found in the API section. If forward_ton_amount is 0, forward_payload doesn’t have to comply with the schema. A single manual transfer can be done with a web service (for example, Minter). A programmatic transfer is usually done with an SDK (for example, assets-sdk) that handles low-level message serialization details. The provided example uses TON Center API that might require a key. Also you’ll need a mnemonic of a wallet that will pay for the transfer. Funds at riskBeware that API keys and mnemonic must not be committed or shared publicly.A better approach is to use a .env file that is excluded from repository with .gitignore. For GitHub CI purposes, consult their documentation. CopyAsk AIimport { Address, toNano, WalletContractV5R1, TonClient } from \"@ton/ton\"; import { mnemonicToPrivateKey } from \"@ton/crypto\"; import { AssetsSDK, createApi } from \"@ton-community/assets-sdk\"; const network = \"testnet\"; // a list of 24 space-separated words const mnemonic = \"foo bar baz\"; const apiKey = \"<API_KEY>\"; const jettonMasterAddress = Address.parse(\"<JETTON_MASTER_ADDR>\"); const destinationRegularWalletAddress = Address.parse(\"<DESTINATION_WALLET_ADDR>\"); async function main() { // create an RPC client that will send network requests const client = new TonClient({ endpoint: \"https://toncenter.com/api/v2/jsonRPC\", apiKey, }); // extract private and public keys from the mnemonic const keyPair = await mnemonicToPrivateKey(mnemonic.split(\" \")); // create a client for TON wallet const wallet = WalletContractV5R1.create({ workchain: 0, // public key is required to deploy a new wallet // if it wasn't deployed yet publicKey: keyPair.publicKey, }); const provider = client.provider(wallet.address); // sender is an object used by assets-sdk to send messages // private key is used to sign messages sent to a wallet const sender = wallet.sender(provider, keyPair.secretKey); // create an assets-sdk client const api = await createApi(network); const sdk = AssetsSDK.create({ api, sender }); // create a client for interacting with jettons of a // certain type const jetton = await sdk.openJetton(jettonMasterAddress); // create a client for the sender's Jetton wallet const jettonWallet = await jetton.getWallet(sdk.sender!.address!); // tell sender's Jetton wallet to transfer Jettons await jettonWallet.send(sender, destinationRegularWalletAddress, toNano(10)); } void main(); See all 51 lines For reference, here’s a low-level example of the process, where message serialization is done manually. CopyAsk AIimport { Address, beginCell, internal, SendMode, toNano } from \"@ton/core\"; import { TonClient, WalletContractV5R1, TupleItemSlice } from \"@ton/ton\"; import { mnemonicToPrivateKey } from \"@ton/crypto\"; // a list of 24 space-separated words const mnemonic = \"foo bar baz\"; const apiKey = \"<API key>\"; const jettonMasterAddress = Address.parse( \"<Jetton master address>\", ); const destinationRegularWalletAddress = Address.parse( \"<destination wallet address>\", ); async function main() { // connect to your regular walletV5 const client = new TonClient({ endpoint: \"https://toncenter.com/api/v2/jsonRPC\", apiKey, }); const keyPair = await mnemonicToPrivateKey(mnemonic.split(\" \")); const walletContract = WalletContractV5R1.create({ workchain: 0, publicKey: keyPair.publicKey, }); const provider = client.provider(walletContract.address); // Find your Jetton wallet Address const walletAddressCell = beginCell() .storeAddress(walletContract.address) .endCell(); const el: TupleItemSlice = { type: \"slice\", cell: walletAddressCell, }; const data = await client.runMethod( jettonMasterAddress, \"get_wallet_address\", [el], ); const jettonWalletAddress = data.stack.readAddress(); // form the transfer message const forwardPayload = beginCell() .storeUint(0, 32) // 0 opcode means we have a comment .storeStringTail(\"for coffee\") .endCell(); const messageBody = beginCell() // opcode for jetton transfer .storeUint(0x0f8a7ea5, 32) // query id .storeUint(0, 64) // jetton amount, amount * 10^9 .storeCoins(toNano(5)) // the address of the new jetton owner .storeAddress(destinationRegularWalletAddress) // response destination (in this case, the destination wallet) .storeAddress(destinationRegularWalletAddress) // no custom payload .storeBit(0) // forward amount - if >0, will send notification message .storeCoins(toNano(\"0.02\")) // store forwardPayload as a reference .storeBit(1) .storeRef(forwardPayload) .endCell(); const transferMessage = internal({ to: jettonWalletAddress, value: toNano(\"0.1\"), bounce: true, body: messageBody, }); // send the transfer message through your wallet const seqno = await walletContract.getSeqno(provider); await walletContract.sendTransfer(provider, { seqno: seqno, secretKey: keyPair.secretKey, messages: [transferMessage], sendMode: SendMode.PAY_GAS_SEPARATELY, }); } void main(); See all 89 linesWas this page helpful?YesNoSuggest editsRaise issuePreviousGet Jetton wallet dataNext⌘IgithubxtelegramPowered by Mintlify",
    "category": "tokens",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "testnet",
      "mainnet",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:29:36.621Z"
  },
  {
    "id": "docs-ton-org--standard-tokens-jettons-wallet-data",
    "title": "How to get Jetton wallet data",
    "url": "https://docs.ton.org/standard/tokens/jettons/wallet-data",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensOverviewMetadataJettonsOverviewHow it worksComparisonMintless JettonMinting jettonsBurnHow to find Jetton walletHow to transfer JettonsGet Jetton wallet dataGet supply dataDeploy mintless JettonAPINFTAirdropVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationJettonsHow to get Jetton wallet dataStandard contractsTokensJettonsHow to get Jetton wallet dataCopy pageCopy pageTo retrieve the Jetton wallet’s account jetton amount, owner identification information, and other details related to a specific Jetton wallet contract, use the get_wallet_data() get method within the Jetton wallet contract. This method returns the following data: NameTypeDescription balanceVarUInteger 16the amount of nano tokens on the Jetton walletownerMsgAddressthe address of owner’s regular walletjetton_master_addressMsgAddressthe address of the Jetton master contractjetton_wallet_codeCella code of the Jetton wallet You can call the get_wallet_data() method from your favorite IDE: CopyAsk AIimport { Address, TonClient } from \"@ton/ton\"; async function main() { const client = new TonClient({ endpoint: \"https://toncenter.com/api/v2/jsonRPC\", }); const JettonwalletAddress = Address.parse( \"EQDmVdCZ2SALvyfCDVlPLr0hoPhUxgjNFtTAxemz9V_C5wbN\", ); const data = await client.runMethod(JettonwalletAddress, \"get_wallet_data\"); const Stack = data.stack; console.log(\"Balance in nano tokens: \", Stack.readNumber()); // wallet address console.log(\"Owner: \", Stack.readAddress().toString({ bounceable: false })); console.log(\"Jetton Master address: \", Stack.readAddress().toString()); // default BoC encoding in viewers console.log(\"Jetton Wallet code: \", Stack.readCell().toBoc().toString('hex')); } void main(); Or call it through a web service, such as Tonviewer: Finally, you can get this information using the API.Was this page helpful?YesNoSuggest editsRaise issuePreviousGet supply dataNext⌘IgithubxtelegramPowered by Mintlify",
    "category": "tokens",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:29:38.004Z"
  },
  {
    "id": "docs-ton-org--standard-tokens-jettons-supply-data",
    "title": "How to get supply data",
    "url": "https://docs.ton.org/standard/tokens/jettons/supply-data",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensOverviewMetadataJettonsOverviewHow it worksComparisonMintless JettonMinting jettonsBurnHow to find Jetton walletHow to transfer JettonsGet Jetton wallet dataGet supply dataDeploy mintless JettonAPINFTAirdropVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationJettonsHow to get supply dataStandard contractsTokensJettonsHow to get supply dataCopy pageCopy pageTo retrieve specific Jetton data, use the Jetton master contract’s get_jetton_data() method. This method returns the following data: NameTypeDescription total_supplyVarUInteger 16the total number of issued jettons measured in indivisible unitsmintableBoolIndicates whether new jettons can be minted (-1 for true, 0 for false)admin_addressAddressadmin’s addressjetton_contentCelldata formatted according to TEP-64jetton_wallet_codeCella code of the corresponding Jetton wallet You can call the get_jetton_data() method from your favorite IDE: CopyAsk AIimport { TonClient, Address } from \"@ton/ton\" async function main() { const client = new TonClient({ endpoint: 'https://toncenter.com/api/v2/jsonRPC', }); const JettonMasterAddress = Address .parse('0:b113a994b5024a16719f69139328eb759596c38a25f59028b146fecdc3621dfe'); const data = await client.runMethod(JettonMasterAddress, 'get_jetton_data'); const Stack = data.stack; console.log(Stack.readNumber()); // Total supply console.log(Stack.readNumber()); // mintable console.log(Stack.readAddress().toString()); // Admin address console.log(Stack.readCell()); // jetton_content console.log(Stack.readCell()) // jetton_wallet_code } void main(); Or call it through a web service, such as Tonviewer: Finally, you can get this information using the API.Was this page helpful?YesNoSuggest editsRaise issuePreviousDeploy mintless JettonNext⌘IgithubxtelegramPowered by Mintlify",
    "category": "tokens",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:29:40.286Z"
  },
  {
    "id": "docs-ton-org--standard-tokens-jettons-mintless-deploy",
    "title": "How to deploy mintless Jetton",
    "url": "https://docs.ton.org/standard/tokens/jettons/mintless/deploy",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensOverviewMetadataJettonsOverviewHow it worksComparisonMintless JettonMinting jettonsBurnHow to find Jetton walletHow to transfer JettonsGet Jetton wallet dataGet supply dataDeploy mintless JettonAPINFTAirdropVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationJettonsHow to deploy mintless JettonStandard contractsTokensJettonsHow to deploy mintless JettonCopy pageCopy page​Introduction Mintless jettons represent a revolutionary approach to token distribution on the TON blockchain. This guide provides a comprehensive walkthrough for deploying mintless jettons, from initial setup to production deployment and ongoing maintenance. Before deploying a mintless jetton, ensure you understand the basic concepts and have experience with standard jetton deployment. Prerequisites Before starting the deployment process, ensure you have: A TON wallet with sufficient funds for deployment Understanding of Merkle trees and cryptographic proofs Access to hosting infrastructure for off-chain data List of airdrop recipients with their allocated amounts Development environment set up for TON smart contracts ​Step-by-Step Deployment Guide Deploying a mintless jetton involves several critical steps: ​1. Prepare the Merkle Tree The foundation of any mintless jetton is a properly constructed Merkle tree containing all airdrop data. ​Data Collection Compile recipient list: Gather all wallet addresses eligible for the airdrop Determine allocations: Assign token amounts to each recipient based on your distribution criteria Set time constraints: Define start_from and expired_at timestamps for claim availability ​Tree Generation Process CopyAsk AIAirdropItem Structure: - amount: Coins (allocated tokens) - start_from: uint48 (Unix timestamp for claim start) - expired_at: uint48 (Unix timestamp for claim expiry) Generate a Merkle tree with all airdrop recipients and their respective amounts Each leaf contains an AirdropItem with amount, start time, and expiry Compute the root merkle_hash that will be stored on-chain ​Best Practices Validate addresses: Ensure all recipient addresses are valid TON addresses Check allocations: Verify total allocation doesn’t exceed intended supply Test tree generation: Use small datasets first to validate your tree construction process ​2. Deploy the Jetton Master Contract The jetton master contract must be extended to support mintless functionality. ​Contract Requirements Include the merkle_hash in the contract’s storage Implement the get_mintless_airdrop_hashmap_root get-method Ensure compatibility with TEP-177 standard Use the mintless jetton standard implementation as a reference ​Storage Extensions CopyAsk AIStandard jetton storage + { merkle_hash: uint256 // Root hash of the Merkle tree } ​Deployment Checklist Contract includes merkle_hash in storage All standard jetton methods are implemented Mintless-specific get-methods are available Contract has been thoroughly tested Deployment transaction has sufficient gas ​3. Set Up Off-Chain Infrastructure Mintless jettons require robust off-chain infrastructure to serve Merkle proofs and tree data. ​Merkle Tree Hosting Storage options: TON Storage, IPFS, AWS S3, or other reliable hosting File format: Store complete tree as BoC (Bag of Cells) file Accessibility: Ensure high availability and fast access times Redundancy: Consider multiple hosting locations for reliability ​Custom Payload API Implementation Implement an API endpoint that provides: Individual Merkle proofs for specific addresses Initialization data for Jetton wallet deployment Verification of claim eligibility API Endpoints: CopyAsk AIGET /api/v1/proof/{address} Response: { \"proof\": \"base64_encoded_merkle_proof\", \"init_data\": \"base64_encoded_init_data\", \"amount\": \"1000000000\", \"start_from\": 1699123200, \"expired_at\": 1699209600 } ​Performance Considerations Caching: Implement aggressive caching for frequently requested proofs Load balancing: Use CDN or load balancers for high-traffic scenarios Rate limiting: Protect against abuse while ensuring legitimate access ​4. Configure Metadata Update your jetton’s metadata to include mintless-specific fields. ​Required Metadata Fields According to the metadata standard: CopyAsk AI{ \"name\": \"Your Mintless Token\", \"symbol\": \"YMT\", \"decimals\": \"9\", \"description\": \"Description of your token\", \"image\": \"https://example.com/token-logo.png\", \"mintless_merkle_dump_uri\": \"https://example.com/merkle-tree.boc\", \"custom_payload_api_uri\": \"https://example.com/api/v1/\" } ​Key Considerations mintless_merkle_dump_uri: Direct link to the complete Merkle tree data custom_payload_api_uri: Base URL for the custom payload API Hosting reliability: Ensure these URIs remain accessible long-term HTTPS requirement: Use secure connections for all external resources ​Development Tools and Utilities Several specialized tools can assist with mintless jetton development and auditing. ​mintless-proof-generator (TON Core) Official utility from the TON blockchain core team for Merkle proof generation and verification. ​Installation Clone and build: CopyAsk AIgit clone https://github.com/ton-blockchain/ton cd ton git checkout testnet mkdir build && cd build cmake ../ make mintless-proof-generator The compiled utility is located at build/crypto/mintless-proof-generator. ​Usage Parse and verify Merkle tree: CopyAsk AIbuild/crypto/mintless-proof-generator parse <input-boc> <output-file> This command: Prints the mintless Merkle dump cell hash Stores the airdrop list in <output-file> Format: <address> <amount> <start_from> <expired_at> (one per line) Generate all Merkle proofs: CopyAsk AIbuild/crypto/mintless-proof-generator make_all_proofs <input-boc> <output-file> Use this for creating the complete proof set needed for custom_payload_api_uri. ​mintless-toolbox (Tonkeeper) Community-developed utility from the Tonkeeper team with additional features. ​Installation CopyAsk AIgit clone https://github.com/tonkeeper/mintless-toolbox.git cd mintless-toolbox make ​Usage Dump airdrop data: CopyAsk AI./bin/mintless-cli dump <airdrop-filename> This utility: Reads airdrop files in various formats Outputs data in CSV format: address,amount,start_from,expired_at Provides additional validation and formatting options Was this page helpful?YesNoSuggest editsRaise issuePreviousAPINext⌘IgithubxtelegramPowered by MintlifyOn this pageIntroductionStep-by-Step Deployment Guide1. Prepare the Merkle TreeData CollectionTree Generation ProcessBest Practices2. Deploy the Jetton Master ContractContract RequirementsStorage ExtensionsDeployment Checklist3. Set Up Off-Chain InfrastructureMerkle Tree HostingCustom Payload API ImplementationPerformance Considerations4. Configure MetadataRequired Metadata FieldsKey ConsiderationsDevelopment Tools and Utilitiesmintless-proof-generator (TON Core)InstallationUsagemintless-toolbox (Tonkeeper)InstallationUsage",
    "category": "tokens",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "testnet",
      "transaction",
      "deployment",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:29:43.009Z"
  },
  {
    "id": "docs-ton-org--standard-tokens-nft-deploy",
    "title": "How to deploy an NFT item",
    "url": "https://docs.ton.org/standard/tokens/nft/deploy",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensOverviewMetadataJettonsNFTOverviewHow it worksDeploy an NFT itemHow to transferHow to get metadata of an NFT itemHow to verify NFT itemComparisonSBT: How it worksReference implementationNFT 2.0APIAirdropVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationNFTHow to deploy an NFT itemStandard contractsTokensNFTHow to deploy an NFT itemCopy pageCopy pageThe creator sends a message to the collection contract, which deploys a new NFT item with the specified data: the initial owner and the item-specific content. The NFT standard does not prescribe how this data must be supplied; implementations may vary. Typically, the creator provides the initial owner and item-specific content for each NFT, or this information is derived from the collection itself. Since the deployment process is not specified by the standard, logic can vary, and the recipes on this page might not apply to every contract. The reference NFT implementation and most modifications follow the same path: the collection owner sends a message with deploy parameters to the collection, and the collection deploys the item. ​Deploy an item with a wallet To deploy an item from a wallet, send a message from the wallet to the collection contract. ​Prerequisites Node.js 22+ Packages: @ton/ton, @ton/core, @ton/crypto A funded Testnet wallet mnemonic in the MNEMONIC environment variable The sending wallet must be the collection owner; otherwise the collection rejects deployments Funds and secretsThis procedure spends funds, uses a wallet mnemonic, and interacts with a collection contract. Run it on Testnet first to test the desired behavior. The following example uses the @ton/ton stack for TypeScript. These libraries provide interfaces to work with wallet contracts and compose messages. CopyAsk AIimport { Address, beginCell, internal, toNano } from \"@ton/core\"; import { TonClient, WalletContractV5R1, SendMode } from \"@ton/ton\"; import { mnemonicToPrivateKey } from \"@ton/crypto\"; const collectionAddress = Address.parse(\"<COLLECTION_ADDRESS>\"); const recipientAddress = Address.parse(\"<RECIPIENT_ADDRESS>\"); const itemContent = \"<ITEM_CONTENT>\"; async function main() { // Toncenter endpoint (Testnet) const client = new TonClient({ endpoint: \"https://testnet.toncenter.com/api/v2/jsonRPC\", }); // Obtain the next item index const nextItemIndex = ( await client.runMethod( collectionAddress, \"get_collection_data\", ) ).stack.readBigNumber(); // Read the next item index. See the explanation after the code. // individual content const content = beginCell() .storeStringTail(itemContent) .endCell(); const body = beginCell() // deploy opcode .storeUint(1, 32) // query id .storeUint(0, 64) .storeUint(nextItemIndex, 64) // Forwarded to the new item as its initial balance. // Ensure `value` >= this amount + all fees. .storeCoins(toNano(\"0.005\")) .storeRef( beginCell() .storeAddress(recipientAddress) .storeRef(content) .endCell(), ) .endCell(); // Compose deploy message const msg = internal({ to: collectionAddress, // Total attached to the collection. Must cover // the forwarded amount below (0.005) plus // execution/storage fees; // keep a safety margin (e.g., 0.01-0.02 TON) value: toNano(\"0.01\"), bounce: true, body, }); // Initialize wallet const mnemonic = process.env.MNEMONIC; if (!mnemonic) { throw new Error(\"Set MNEMONIC\"); } const keyPair = await mnemonicToPrivateKey( mnemonic.split(\" \") ); const walletContract = client.open( WalletContractV5R1.create({ workchain: 0, // basechain publicKey: keyPair.publicKey, }), ); // Send the mint message through the wallet const seqno = await walletContract.getSeqno(); await walletContract.sendTransfer({ seqno: seqno, secretKey: keyPair.secretKey, // Good practice to use these modes for // regular wallet transfers sendMode: SendMode.IGNORE_ERRORS | SendMode.PAY_GAS_SEPARATELY, messages: [msg], }); } void main(); See all 86 lines Where <COLLECTION_ADDRESS> — the collection contract address. <RECIPIENT_ADDRESS> — the initial owner address for the new item. <ITEM_CONTENT> — item-specific content path or key (for example, 0.json). Explanation of body cell composition: .storeUint(1, 32) — operation code 1 selects “deploy single item” in the reference collection contract. TEP-62 does not specify this opcode, so in custom implementations, this can differ. .storeUint(0, 64) — query_id. Used for correlating responses with requests. It has no impact on deployment logic and 0 is a commonly used placeholder in cases where no extra logic relies on it. .storeUint(nextItemIndex, 64) — item_index. Index of the item to deploy, obtained from the collection’s get_collection_data get-method. See Return collection data. .storeCoins(toNano(\"0.005\")) — amount forwarded to the new item at deployment to cover its initial balance/fees. Adjust if extra item contract logic requires more. TL-B for the reference implementation CopyAsk AIdeploy_nft#00000001 query_id:uint64 item_index:uint64 amount:Coins content:^Cell = InternalMsgBody; In the reference contract, the body for op=1 consists of query_id, item_index, amount, and a reference to content. See the TL-B overview. ​Verify In a block explorer, confirm the transaction for <COLLECTION_ADDRESS> succeeded and inspect the transaction trace to see the internal message that deployed the item. To verify via code: call get_nft_address_by_index(<INDEX>) — where <INDEX> is the item index used in the deploy message (the next_item_index read from get_collection_data) — on the collection to obtain the item address; then call get_nft_data on the item and check that the owner is <RECIPIENT_ADDRESS> and the content is <ITEM_CONTENT>. ​Deploy an item with a smart contract To deploy an item from a smart contract, send a message from the contract to the collection contract. ​Prerequisites Enough Testnet funds on the calling contract to cover fees and attached value (for example, ≥ 0.02 TON) <COLLECTION_ADDRESS>, <RECIPIENT_ADDRESS>, <INDEX>, <ITEM_CONTENT> The calling contract must be the collection owner; otherwise the collection rejects deployments Funds and secretsThis smart contract interacts with a collection contract. Run it on Testnet first to test the desired behavior. The following example is a minimal smart contract that only implements the item deployment logic. In real deployments, this is integrated into a larger flow. TolkCopyAsk AI// SnakeString describes a (potentially long) string inside a cell; // short strings are stored as-is, like \"my-picture.png\"; // long strings are nested refs, like \"xxxx\".ref(\"yyyy\".ref(\"zzzz\")) type SnakeString = slice fun SnakeString.unpackFromSlice(mutate s: slice) { // SnakeString can only be the last: it's \"the remainder\"; // for correctness, it's better to validate it has no more refs: assert (s.remainingRefsCount() <= 1) throw 5; val snakeRemainder = s; s = createEmptySlice(); // no more left to read return snakeRemainder } fun SnakeString.packToBuilder(self, mutate b: builder) { b.storeSlice(self) } struct NftItemInitAtDeployment { recipientAddress: address content: Cell<SnakeString> } struct (0x00000001) DeployNft { queryId: uint64 itemIndex: uint64 attachTonAmount: coins initParams: Cell<NftItemInitAtDeployment> } fun onInternalMessage(in: InMessage) { // The whole logic will be in `onInternalMessage` // for demonstration purposes. In real deployments this should // usually be gated behind authorization and other checks. val deploy = DeployNft { queryId: 0, itemIndex: <INDEX>, // will be sent to the item contract on deployment attachTonAmount: ton(\"0.005\"), initParams: NftItemInitAtDeployment { recipientAddress: address(\"<RECIPIENT_ADDRESS>\"), content: (\"<ITEM_CONTENT>\" as SnakeString).toCell() }.toCell() }; val msg = createMessage({ bounce: true, dest: address(\"<COLLECTION_ADDRESS>\"), value: ton(\"0.01\"), body: deploy }); msg.send(SEND_MODE_PAY_FEES_SEPARATELY); } Where <COLLECTION_ADDRESS> — the collection contract address. <RECIPIENT_ADDRESS> — the initial owner address for the new item. <INDEX> — item’s index. Note that obtaining the actual index on-chain is not possible, so a smart contract that performs these deployments should handle that logic itself (for example, store the latest used index and increment it on each deployment). <ITEM_CONTENT> — item-specific content path or key (for example, 0.json). The top of the snippet defines structs for the deploy message and can be modified depending on the NFT implementation specifics. The sending logic lives in onInternalMessage for simplicity. It composes a message with hard-coded example values and sends that message to the collection contract. ​Verify In a block explorer, confirm the transaction from the calling contract to <COLLECTION_ADDRESS> succeeded and inspect the transaction trace to see the internal message that deployed the item. To verify via code: call get_nft_address_by_index(<INDEX>) on the collection to obtain the ",
    "category": "tokens",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "testnet",
      "transaction",
      "deployment",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:29:44.529Z"
  },
  {
    "id": "docs-ton-org--standard-tokens-nft-transfer",
    "title": "How to transfer an NFT",
    "url": "https://docs.ton.org/standard/tokens/nft/transfer",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensOverviewMetadataJettonsNFTOverviewHow it worksDeploy an NFT itemHow to transferHow to get metadata of an NFT itemHow to verify NFT itemComparisonSBT: How it worksReference implementationNFT 2.0APIAirdropVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationNFTHow to transfer an NFTStandard contractsTokensNFTHow to transfer an NFTCopy pageCopy pageNFT transfer is an operation specified in TEP 0062. Its implementation must comply with this standard, and NFT item contracts must support the logic described there. The NFT transfer message is also specified and must comply with the corresponding TL-B scheme. This scheme involves, among other things, forward_amount: the amount of nanotons to be sent to the destination address; forward_payload: optional custom data that should be sent to the destination address. For the forward_payload field there are specific requirements: In the case of a simple comment, forward_payload must starts with 0x00000000 and the comment must be contained in the remainder of the forward_payload. In turn, if the comment begins with the byte 0xff, the remainder is a “binary comment”, which should not be displayed to the end user as text (only as hex dump if necessary). The intended use of “binary comments” is, e.g., to contain a purchase identifier for payments in a store, to be automatically generated and processed by the store’s software. does not begin with the byte 0xff, the comment is a text one; it can be displayed “as is” to the end user of a wallet. If forward_payload contains a binary message for interacting with the destination smart contract, then there are no prefixes. Use a wallet app that supports NFTs (for example, Tonkeeper) and follow its guide. Alternatively, perform the transfer manually. The example below illustrates a programmatic transfer: Funds at riskBeware that API keys and mnemonic must not be committed or shared publicly.A better approach is to use a .env file that is excluded from repository with .gitignore. For GitHub CI purposes, consult their documentation. CopyAsk AIimport { WalletContractV5R1, TonClient, Address, toNano } from \"@ton/ton\"; import { mnemonicToPrivateKey } from \"@ton/crypto\"; import { AssetsSDK, createApi } from \"@ton-community/assets-sdk\"; async function main() { const client = new TonClient({ endpoint: \"https://toncenter.com/api/v2/jsonRPC\", }); const MNEMONIC = process.env.MNEMONIC as string; // set via environment const keyPair = await mnemonicToPrivateKey(MNEMONIC.split(\" \")); const wallet = WalletContractV5R1.create({ workchain: 0, publicKey: keyPair.publicKey, }); const provider = client.provider(wallet.address); const sender = wallet.sender(provider, keyPair.secretKey); const NETWORK = \"testnet\"; const api = await createApi(NETWORK); const sdk = AssetsSDK.create({ api, sender, }); const NFT_ADDRESS = Address.parse(\"<NFT_ITEM_ADDR>\"); const nftItem = await sdk.openNftItem(NFT_ADDRESS); const RECEIVER_ADDRESS = Address.parse(\"<RECEIVER_ADDR>\"); await nftItem.send(sender, RECEIVER_ADDRESS, { value: toNano(10) }); } void main(); where: <NFT_ITEM_ADDR> — the address of the NFT item to be transferred. <RECEIVER_ADDR> — the address of the recipient. Was this page helpful?YesNoSuggest editsRaise issuePreviousHow to get metadata of an NFT itemNext⌘IgithubxtelegramPowered by Mintlify",
    "category": "tokens",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "testnet",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:29:46.480Z"
  },
  {
    "id": "docs-ton-org--standard-tokens-nft-metadata",
    "title": "How to get metadata of an NFT item",
    "url": "https://docs.ton.org/standard/tokens/nft/metadata",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensOverviewMetadataJettonsNFTOverviewHow it worksDeploy an NFT itemHow to transferHow to get metadata of an NFT itemHow to verify NFT itemComparisonSBT: How it worksReference implementationNFT 2.0APIAirdropVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationNFTHow to get metadata of an NFT itemStandard contractsTokensNFTHow to get metadata of an NFT itemCopy pageCopy pageMetadata is split into two parts: the collection stores collection‑wide data, and the item stores item‑specific data (not necessarily the full metadata). ​High level There is a TON Center API method that retrieves metadata. ​Low level To get full NFT metadata: Resolve the NFT item address by index from the collection (if needed) using get_nft_address_by_index(index). Get the item’s individual content from the item contract using get_nft_data(). Get the full metadata from the collection contract using get_nft_content(index, individual_content). See more about metadata.Was this page helpful?YesNoSuggest editsRaise issuePreviousHow to verify NFT itemNext⌘IgithubxtelegramPowered by MintlifyOn this pageHigh levelLow level",
    "category": "tokens",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:29:48.466Z"
  },
  {
    "id": "docs-ton-org--standard-tokens-nft-verify",
    "title": "How to verify NFT item",
    "url": "https://docs.ton.org/standard/tokens/nft/verify",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensOverviewMetadataJettonsNFTOverviewHow it worksDeploy an NFT itemHow to transferHow to get metadata of an NFT itemHow to verify NFT itemComparisonSBT: How it worksReference implementationNFT 2.0APIAirdropVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationNFTHow to verify NFT itemStandard contractsTokensNFTHow to verify NFT itemCopy pageCopy pageBecause the collection is the source of truth, verification goes through it: Read the NFT item index from the item contract via get_nft_data(). Query the collection with get_nft_address_by_index(index). If the returned address equals the NFT item address, the item belongs to the collection. ​High level There is an API method that performs this verification off‑chain with a single request. Provide the addresses of the NFT item and NFT collection: TypeScriptCopyAsk AIasync function main() { const itemAddress = \"EQD3LzasMd4GAmhIEkCQ4k6LnziTqNZ6VPtRfeZKHu0Fmkho\"; const collectionAddress = \"EQCOtGTvX-RNSaiUavmqNcDeblB3-TloZpvYuyGOdFnfy-1N\"; const url = `https://toncenter.com/api/v3/nft/items?limit=1&address=${itemAddress}&collection_address=${collectionAddress}`; const options = { method: \"GET\", body: undefined }; try { const response = await fetch(url, options); const data = await response.json(); if (data[\"nft_items\"].length > 0) { console.log(\"✅ item in collection\"); } else { console.log(\"❌ item not in collection\"); } } catch (error) { console.error(error); } } main(); ​Low level First, read the NFT item index. If the collection returns the same NFT item address for that index, the item belongs to the collection. TypeScriptCopyAsk AIimport { Address, Cell } from \"@ton/ton\"; async function main() { const itemAddress = \"EQD3LzasMd4GAmhIEkCQ4k6LnziTqNZ6VPtRfeZKHu0Fmkho\"; const collectionAddress = \"EQCOtGTvX-RNSaiUavmqNcDeblB3-TloZpvYuyGOdFnfy-1N\"; const url = \"https://toncenter.com/api/v2/runGetMethod\"; const itemPayload = { address: itemAddress, stack: [] as any[], method: \"get_nft_data\", }; const headers = { \"Content-Type\": \"application/json\", }; try { const itemResp = await fetch(url, { method: \"POST\", headers, body: JSON.stringify(itemPayload), }); if (!itemResp.ok) { throw new Error( `Item request failed: ${itemResp.status} ${itemResp.statusText}`, ); } const itemJson: any = await itemResp.json(); const itemStack = itemJson?.result?.stack; if (!Array.isArray(itemStack) || !Array.isArray(itemStack[1])) { throw new Error(\"Unexpected item stack format\"); } const hex = String(itemStack[1][itemStack[1].length - 1] ?? \"\"); const itemIndex = Number.parseInt( hex.startsWith(\"0x\") ? hex.slice(2) : hex, 16, ); const collectionPayload = { address: collectionAddress, stack: [[\"int\", itemIndex]], method: \"get_nft_address_by_index\", }; await new Promise((resolve) => setTimeout(resolve, 2000)); const colResp = await fetch(url, { method: \"POST\", headers, body: JSON.stringify(collectionPayload), }); if (!colResp.ok) { throw new Error( `Collection request failed: ${colResp.status} ${colResp.statusText}`, ); } const realAddress = await colResp.json(); console.log(\"itemIndex:\", itemIndex); const b64 = realAddress?.result?.stack?.[0][1].bytes as string; const boc = Buffer.from(b64, \"base64\"); const cell = Cell.fromBoc(boc)[0]; const slice = cell.beginParse(); const resAddress = slice.loadAddress(); if (resAddress.toString() == Address.parse(itemAddress).toString()) { console.log(\"✅ item in collection\"); } else { console.log(\"❌ item not in collection\"); } } catch (error) { console.error(error); } } main(); Was this page helpful?YesNoSuggest editsRaise issuePreviousComparisonNext⌘IgithubxtelegramPowered by MintlifyOn this pageHigh levelLow level",
    "category": "tokens",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:29:49.847Z"
  },
  {
    "id": "docs-ton-org--standard-tokens-nft-nft-2-0",
    "title": "NFT 2.0",
    "url": "https://docs.ton.org/standard/tokens/nft/nft-2.0",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensOverviewMetadataJettonsNFTOverviewHow it worksDeploy an NFT itemHow to transferHow to get metadata of an NFT itemHow to verify NFT itemComparisonSBT: How it worksReference implementationNFT 2.0APIAirdropVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationNFTNFT 2.0Standard contractsTokensNFTNFT 2.0Copy pageCopy page​Concept This section outlines the on-chain and off-chain specifications for NFTs with obligatory royalties. ​Problem On TON, NFTs follow TEP-62 and TEP-64; royalties are defined by TEP-66. To be recognized as an NFT by ecosystem products such as wallets, explorers, and indexers, a smart contract must conform to the interfaces and internal constraints defined by these specifications. TEP-66, the NFT royalty standard, defines the on-chain layout for royalty parameters but does not impose any rules on how royalties should be enforced across the ecosystem. This is intentional: introducing mandatory on-chain royalty enforcement for auctions or other market mechanisms would interfere with the foundational principles of NFTs. This would mean enforcing royalties at the cost of restricting legitimate, non-commercial transfers — such as gifting or migrating assets between personal wallets. These constraints undermine usability and conflict with the open, decentralized principles that define NFTs. These limitations have significantly impacted the TON NFT market. ​Motivation For artists and collection creators, royalties from secondary sales are a primary source of revenue. Without a reliable way to enforce them, the initial mint becomes the only guaranteed income. As a result, some community-driven collections have been traded through Web2 platforms instead of on-chain. In such cases, royalty logic is typically bypassed, and profit distribution becomes unfair within the NFT trading ecosystem. To ensure fair value distribution among all participants — including artists, marketplaces, and sellers — royalty enforcement must be addressed through coordinated off-chain mechanisms. ​Solution The solution for enforcing royalties while maintaining compatibility with existing services and standards involves introducing additional mutable fields in the off-chain metadata. The NFT contracts themselves remain unchanged; instead, the semantics of the metadata associated with each item in the collection are extended. In particular, each item includes a mutable boolean field named royalty_violation, along with a potentially modified image field, in addition to the existing off-chain data standard. ​Execution model The execution model of the proposed royalty-enforcing solution includes both on-chain and off-chain components, working together to abstract blockchain complexity from ecosystem products. 1. Minting and metadata layer: all NFTs are minted on a minting platform that combines on-chain contracts and API. On-chain contracts handle actions like minting, burning, etc. Off-chain metadata includes pack configuration and sale logic: number of items per pack, royalty rules, and mutable fields (e.g., royalty_violation). ScopeRefer to the Mint platform API for detailed integration information and endpoints. 2. NFT store integration: NFT stores integrate solely through the mint API and do not interact with smart contracts directly. Stores can: Query available packs and their metadata (e.g., price, available supply) Request NFT minting by attaching Toncoin on behalf of a user 3. Enforcing a mutable field: a specific field in the off-chain metadata, such as royalty_violation, is updated to reflect policy changes. These updates do not affect the smart contract but are respected by ecosystem products that rely on metadata. 4. Reindexing and propagation: when mutable metadata changes, the Mint Platform API triggers ecosystem products and indexers to reindex the affected items. Indexers read updated metadata and expose critical flags (e.g., royalty_violation = true) via their APIs. ​Mandatory royalty distribution In NFT 2.0, two mandatory royalties must be paid on all primary and secondary sales: Community fund — for ecosystem-support initiatives, including creator-support programs. For example, a program similar to Artist in Residence supports authors producing sticker content. Address: EQDo0y1Ix8Wzqms84bFjL8Vh51RPaEIYwziBBRIi1NMadXui Telegram fund — for future Telegram integrations involving NFT-based stickers. Address: EQB4ZBNOFNSIpi8Qnikm0M0PE1Hv-D-qi40J_nPyYtzA5SAX Primary sale: Community fund — 5% Telegram fund — 5% Optional store royalty defined by store Secondary sale: Community fund — 2.5% Telegram fund — 2.5% Optional store royalty defined by store ​Royalty violation marking Royalty payment assurance works through an off-chain signaling mechanism. Suppose a user or service violates the collection’s royalty policy. In that case, the corresponding NFT item is marked as royalty violated. This status does not involve any on-chain transactions or changes to the contract state. Instead, it’s reflected in the off-chain metadata by setting the royalty_violation field to true. The examples illustrate a standard NFT and the same item when it is marked as royalty violated. CopyAsk AI// Standard NFT metadata { \"name\": \"Magic Mushroom #57\", \"description\": \"Hand drawing brings the NFT an artistic value, while various accessories and materials bring uniqueness and significance in our rapidly changing world.\", \"image\": \"https://s.getgems.io/nft/c/62695cb92d780b7496caea3a/nft/56/629b9349e034e8e582cf6448.png\", \"attributes\": [ { \"trait_type\": \"Material\", \"value\": \"Wool fabric\" } ] } CopyAsk AI// Royalty violated NFT metadata { \"name\": \"Magic Mushroom #58\", \"description\": \"Hand drawing brings the NFT an artistic value, while various accessories and materials bring uniqueness and significance in our rapidly changing world.\", \"image\": \"https://s.getgems.io/nft-local/b/c/687f5a964d396571109281fa/629b9349e034e8e582cf6449\", \"attributes\": [ { \"trait_type\": \"Material\", \"value\": \"Wool fabric\" }, { \"trait_type\": \"Royalty violation\", \"value\": \"True\" } ], \"royalty_violation\": true } Ecosystem products are expected to restrict functionality for NFTs in this status. To indicate the violation in the UI, the image is replaced with a blurred version labeled accordingly. If a third-party marketplace or secondary platform offers NFTs with forced royalty trading but does not respect collection-level royalty rules, all NFT items traded on that platform are marked as royalty violated. This strictly limits their availability across the ecosystem: wallets and explorers show these items as royalty violated in collection views, and NFT marketplaces or stores that follow the royalty policy do not allow trading or offers for them. As a result, it is not possible to use restricted items in any service that follows this royalty policy. ​The royalty violation process The flowchart illustrates how a royalty violation results in an NFT being flagged as royalty_violation and how this status is propagated through the ecosystem to user-facing interfaces. ​NFT 2.0 royalty policy ​Royalty-free operations Not all NFT-related operations are subject to royalty fees. Some actions — such as ownership transfers without commercial intent — are allowed without triggering a royalty. These operations are considered part of the core NFT protocol and do not represent value-generating events. ​List of royalty-free operations Ownership transfer without commercial intent NFT item donation ​Royalty-bearing operations All operations that involve commercial intent must include royalty payments, as defined by the TEP-66 specification. This includes all market-based NFT trading models, such as auctions and offer mechanisms, as well as NFT-related DeFi use cases like floor perpetuals and staking. ​Retrieving royalty parameters According to the specification, the sales contract must retrieve royalty parameters from the collection contract and calculate payments based on that data. The easiest way to obtain royalty parameters is by calling the royalty_params() get method on the main collection contract. It returns (int numerator, int denominator, slice destination), where the royalty share is calculated as numeratordenominator\\frac{numerator}{denominator}denominatornumerator​. For example, if numerator = 11 and denominator = 1000, the royalty share is 1.1%. The numerator must be less than the denominator. The destination is a slice of type MsgAddress, indicating the address where the royalty should be sent. Mandatory royalties are ecosystem-level fees and are not returned by royalty_params(). They must be applied separately. ​Marketplace responsibilities Marketplaces that comply with the NFT 2.0 specification are expected to send muldiv(price, numerator, denominator) to the destination address after an NFT sale or any other successful commercial operation. Marketplaces SHOULD NOT send royalty payments",
    "category": "tokens",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:29:53.215Z"
  },
  {
    "id": "docs-ton-org--standard-tokens-nft-api",
    "title": "API",
    "url": "https://docs.ton.org/standard/tokens/nft/api",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensOverviewMetadataJettonsNFTOverviewHow it worksDeploy an NFT itemHow to transferHow to get metadata of an NFT itemHow to verify NFT itemComparisonSBT: How it worksReference implementationNFT 2.0APIAirdropVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationNFTAPIStandard contractsTokensNFTAPICopy pageCopy pageNFT messages and methods specified in TEPs. ​TEP-62 ​NFT Item ​Transfer message layout FieldTypeDescriptiontransferuint32tag equal to 0x5fcc3d14query_iduint64arbitrary request numbernew_ownerMsgAddressaddress of the new owner of the NFT itemresponse_destinationMsgAddressoptional address to receive excess Toncoin, usually the sender’s addresscustom_payloadMaybe ^Celloptional custom dataforward_amountVarUInteger 16the amount of Toncoin to be sent to the new ownerforward_payloadEither Cell ^Celloptional data that should be forwarded to the new owner ​Forward payload formats To send a simple comment in the forward_payload, the forward_payload must start with 0x00000000 (32-bit unsigned integer equal to zero); the remainder of the forward_payload contains the comment. If the comment does not begin with the byte 0xff, the comment is a text one; it can be displayed “as is” to the end user of a wallet (after filtering invalid and control characters and checking that it is a valid UTF-8 string). For instance, users may indicate the purpose (“for coffee”) of a simple transfer from their wallet to the wallet of another user in this text field. On the other hand, if the comment begins with the byte 0xff, the remainder is a “binary comment”, which should not be displayed to the end user as text (only as a hex dump if necessary). The intended use of “binary comments” is, e.g., to contain a purchase identifier for payments in a store, to be automatically generated and processed by the store’s software. If the forward_payload contains a binary message for interacting with the destination smart contract (for example, with DEX), then there are no prefixes. ​Ownership assigned message layout FieldTypeDescriptionownership_assigneduint32tag equal to 0x05138d91query_iduint64should be equal to request’s query_idprev_ownerMsgAddressaddress of the previous owner of this NFT itemforward_payloadEither Cell ^Cellshould be equal to request’s forward_payload ​Excesses message layout FieldTypeDescriptionexcessesuint32tag equal to 0xd53276dbquery_iduint64should be equal to request’s query_id ​Get static data message layout FieldTypeDescriptionget_static_datauint32tag equal to 0x2fcb26a2query_iduint64arbitrary request number ​Report static data message layout FieldTypeDescriptionreport_static_datauint32tag equal to 0x8b771735query_iduint64should be equal to request’s query_idindexuint256numerical index of this NFT in the collectioncollectionMsgAddressaddress of the smart contract of the collection to which this NFT belongs Verify that item belongs to collection via get method in collection, see more here ​get_nft_data() No arguments. Outputs: FieldTypeDescriptioninit?intif not zero, then this NFT is fully initialized and ready for interactionindexintnumerical index of this NFT in the collectioncollection_addressMsgAddressaddress of the smart contract of the collection to which this NFT belongsowner_addressMsgAddressaddress of the current owner of this NFTindividual_contentCellindividual NFT content in any format Verify that item belongs to collection via get method in collection, see more here ​NFT Collection ​get_collection_data() No arguments. Outputs: FieldTypeDescriptionnext_item_indexintthe count of currently deployed NFT items in collectioncollection_contentCellcollection content in a format that complies with TEP-64owner_addressMsgAddresscollection owner address, zero address if no owner ​get_nft_address_by_index() Argument: index as int. Output: address as MsgAddress. ​get_nft_content() Arguments: index as int individual_content as Cell Output: full_content as Cell. ​TEP-66 ​Get royalty params message layout FieldTypeDescriptionget_royalty_paramsuint32tag equal to 0x693d3950query_iduint64arbitrary request number ​Report royalty params message layout FieldTypeDescriptionreport_royalty_paramsuint32tag equal to 0xa8cb00adquery_iduint64should be equal to request’s query_idnumeratoruint16royalty numeratordenominatoruint16royalty denominatordestinationMsgAddressaddress to send royalty ​royalty_params() No arguments. Outputs: FieldTypeDescriptionnumeratorintroyalty numerator (e.g., 11)denominatorintroyalty denominator (e.g., 1000)destinationMsgAddressaddress to send royalty Royalty share is numerator / denominator. For example, if numerator = 11 and denominator = 1000, then royalty share is 11 / 1000 * 100% = 1.1%. ​TEP-85 ​SBT Item ​Prove ownership message layout FieldTypeDescriptionprove_ownershipuint32tag equal to 0x04ded148query_iduint64arbitrary request numberdestinationMsgAddressaddress of the contract to which the ownership should be provenforward_payload^Cellany data for sending to the destination address from SBTwith_contentBoolif true, SBT’s individual content cell will be included in the message Should be rejected if sender address is not the owner’s address. ​Request owner message layout FieldTypeDescriptionrequest_owneruint32tag equal to 0xd0c3bfeaquery_iduint64arbitrary request numberdestinationMsgAddressaddress of the contract to which the ownership should be provenforward_payload^Cellany data for sending to the destination address from SBTwith_contentBoolif true, SBT’s individual content cell will be included in the message ​Destroy message layout FieldTypeDescriptiondestroyuint32tag equal to 0x1f04537aquery_iduint64arbitrary request number Should be rejected if sender address is not the owner’s address. Sets the owner’s address and authority to null, and sends an excesses message with the contract’s balance. ​Revoke message layout FieldTypeDescriptionrevokeuint32tag equal to 0x6f89f5e3query_iduint64arbitrary request number Should be rejected if sender address is not the authority’s address or if already revoked. Sets revoked_at to current unix time. ​Ownership proof message layout FieldTypeDescriptionownership_proofuint32tag equal to 0x0524c7aequery_iduint64should be equal to request’s query_iditem_iduint256ID of an SBTownerMsgAddressSBT owner’s addressdata^Celldata cell passed in prove_ownershiprevoked_atuint64unix time when SBT was revoked, 0 if it was notindividual_contentMaybe ^CellSBT’s individual content if with_content was true, null if not ​Owner info message layout FieldTypeDescriptionowner_infouint32tag equal to 0x0dd607e3query_iduint64should be equal to request’s query_iditem_iduint256ID of an SBTinitiatorMsgAddressaddress of request initiatorownerMsgAddressSBT owner’s addressdata^Celldata cell equal to request’s forward_payloadrevoked_atuint64unix time when SBT was revoked, 0 if it was notcontentMaybe ^CellSBT’s content if with_content was true, null if not ​get_nft_data() Same as NFT standard. No arguments. Outputs: FieldTypeDescriptioninit?intif not zero, then this SBT is fully initialized and ready for interactionindexintnumerical index of this SBT in the collectioncollection_addressMsgAddressaddress of the smart contract of the collection to which this SBT belongsowner_addressMsgAddressSBT owner’s addressindividual_contentCellindividual SBT content in any format ​get_authority_address() No arguments. Outputs: FieldTypeDescriptionauthoritysliceauthority’s address that can revoke SBT, returns addr_none (2 zero bits) if no authority This method is mandatory for SBT. If there is no authority it should return addr_none (2 zero bits). ​get_revoked_time() No arguments. Outputs: FieldTypeDescriptionrevoked_atintunix time of when SBT was revoked, 0 when not revokedWas this page helpful?YesNoSuggest editsRaise issuePreviousAirdropNext⌘IgithubxtelegramPowered by MintlifyOn this pageTEP-62NFT ItemTransfer message layoutForward payload formatsOwnership assigned message layoutExcesses message layoutGet static data message layoutReport static data message layoutget_nft_data()NFT Collectionget_collection_data()get_nft_address_by_index()get_nft_content()TEP-66Get royalty params message layoutReport royalty params message layoutroyalty_params()TEP-85SBT ItemProve ownership message layoutRequest owner message layoutDestroy message layoutRevoke message layoutOwnership proof message layoutOwner info message layoutget_nft_data()get_authority_address()get_revoked_time()",
    "category": "tokens",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:29:54.578Z"
  },
  {
    "id": "docs-ton-org--foundations-serialization-merkle",
    "title": "Merkle proofs",
    "url": "https://docs.ton.org/foundations/serialization/merkle",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationCellsLibrary referencesMerkle proofsMerkle updatesPruned branchesBag of cellsAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationSerializationMerkle proofsBlockchain foundationsSerializationMerkle proofsCopy pageCopy pageMerkle proof cells verify that some cell tree data belongs to the full tree. This design allows the verifier to avoid storing the entire tree’s content while still being able to verify the content using the root hash. A Merkle proof cell contains exactly one reference c. Its level 0 <= l < 3 is max{Lvl(c) - 1, 0}. Each Merkle proof cell serializes as follows: one tag byte with value 0x03; the 256-bit first higher hash of the referenced cell c or the representation hash of c if its level equals zero; 2 bytes that store the depth of the deleted subtree that was replaced by the reference. Was this page helpful?YesNoSuggest editsRaise issuePreviousMerkle updatesNext⌘IgithubxtelegramPowered by Mintlify",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:29:57.140Z"
  },
  {
    "id": "docs-ton-org--foundations-serialization-pruned",
    "title": "Pruned branches",
    "url": "https://docs.ton.org/foundations/serialization/pruned",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationCellsLibrary referencesMerkle proofsMerkle updatesPruned branchesBag of cellsAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationSerializationPruned branchesBlockchain foundationsSerializationPruned branchesCopy pageCopy pagePruned branch cells are cells that represent deleted subtrees of the tree of cells. May have any level between 1 and 3, which is equal to the level of a root of the pruned subtree plus one. Each of pruned branch cells get serialized as follows. The 1-byte tag that always equals 1. The byte that contains the pruned branch level mask, 1 <= mask <= 7. The number of hashes stored in the pruned branch cell is equal to the number of 1-bits in the mask. Next, h * 32 bytes store representations hashes of roots of the pruned subtrees starting from the last one. For example, if the mask equals 3 (binary 011), then the pruned tree cell contains representation hashes of the second and the first pruned subtrees in sequential order, but not the third one. Finally, h * 2 bytes store the depths of the pruned subtrees starting from the last one. Was this page helpful?YesNoSuggest editsRaise issuePreviousBag of cellsNext⌘IgithubxtelegramPowered by Mintlify",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:29:58.852Z"
  },
  {
    "id": "docs-ton-org--languages-tl-b-simple-examples",
    "title": "Simple examples",
    "url": "https://docs.ton.org/languages/tl-b/simple-examples",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BOverviewSyntax and SemanticsSimple examplesComplex and non-trivial examplesTEP examplesToolingFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationTL-BSimple examplesLanguagesTL-BSimple examplesCopy pageCopy page​Maybe CopyAsk AInothing$0 {X:Type} = Maybe X; just$1 {X:Type} value:X = Maybe X; The Maybe combinator is used to represent optional values. In this case, the first bit indicates a value. If the bit is 0, the value is not serialized and skipped. If the bit is 1, the value follows and is serialized. ​Either CopyAsk AIleft$0 {X:Type} {Y:Type} value:X = Either X Y; right$1 {X:Type} {Y:Type} value:Y = Either X Y; The Either type is used when one of two possible result types may be present. The choice of type depends on the prefix bit. If the prefix bit is 0, then the left type is serialized. If it is 1, the right type is serialized. This construct is used, for example, when serializing messages, where the body is either included directly in the main cell or stored in a separate referenced cell. ​Both CopyAsk AIpair$_ {X:Type} {Y:Type} first:X second:Y = Both X Y; The Both type variation is used exclusively with regular pairs, where both types are serialized sequentially without any conditions. ​VarUInteger n CopyAsk AIvar_uint$_ {n:#} len:(#< n) value:(uint (len * 8)) = VarUInteger n; The combinator is parameterized by a natural number n, represented in curly brackets. For a given n, VarUInteger n describes the serialization of a natural number m, which in its binary representation contains no more than (n - 1) * 8 bits. First, the number of bytes required for writing m, that is called len, is serialized into ⌈log⁡2n⌉\\lceil \\log_{2}n \\rceil⌈log2​n⌉ bits as an unsigned big-endian integer. Then m itself is serialized as a uint on len*8 bits. Thus, the size of the serialization of a particular m through the combinator VarUInteger n depends on m. For example, VarUInteger 32 is used to represent the amount of a certain extra currency on an account. We can store in that type values up to 2**248 - 1. Let’s serialize the value = 27583 according to that type. The binary representation of value is 110101110111111. It requires 15 bits to write it as an unsigned integer, so we need len = 2 bytes. The len is serialized as 00010 (into ⌈log⁡232⌉=5\\lceil \\log_{2} 32 \\rceil = 5⌈log2​32⌉=5 bits). Then, the value is serialized as 0110101110111111 into len * 8 = 16 bits. Thus, the complete serialization of 27583 through VarUInteger 32 type description is 00010 0110101110111111. Another important example is VarUInteger 16, which is used to represent account’s balance. We can store in that type values up to 2**120 - 1. According to that type, the value = 27583 will be serialized as 0010 0110101110111111, because len = 2 is serialized into ⌈log⁡216⌉=4\\lceil \\log_{2} 16 \\rceil = 4⌈log2​16⌉=4 bits.Was this page helpful?YesNoSuggest editsRaise issuePreviousComplex and non-trivial examplesNext⌘IgithubxtelegramPowered by MintlifyOn this pageMaybeEitherBothVarUInteger n",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "example",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:32:37.854Z"
  },
  {
    "id": "docs-ton-org--languages-tl-b-complex-and-non-trivial-examples",
    "title": "Complex and non-trivial examples",
    "url": "https://docs.ton.org/languages/tl-b/complex-and-non-trivial-examples",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BOverviewSyntax and SemanticsSimple examplesComplex and non-trivial examplesTEP examplesToolingFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationTL-BComplex and non-trivial examplesLanguagesTL-BComplex and non-trivial examplesCopy pageCopy page​Unary The unary functional type is commonly used for dynamic sizing in structures such as hml_short. Unary supports two main options: CopyAsk AIunary_zero$0 = Unary ~0; unary_succ$1 {n:#} x:(Unary ~n) = Unary ~(n + 1); The unary_zero variation is straightforward: if the first bit is 0, the result of the entire unary deserialization is 0. The unary_succ variation, however, is more complex: it is loaded recursively and represents a value of ~(n + 1). This means it repeatedly calls itself until it reaches unary_zero. In other words, the desired value will equal the number of units in a row. For example, consider the serialization of the bitstring 110. The deserialization call chain is as follows: CopyAsk AIunary_succ$1 -> unary_succ$1 -> unary_zero$0 Once unary_zero is reached, the value is returned up the call stack, similar to how values are returned in a recursive function. To better visualize the result, let’s trace the return path: 0 -> ~(0 + 1) -> ~(1 + 1) -> 2 This shows that the bitstring 110 corresponds to Unary 2. ​Hashmap The Hashmap complex type is used to store dictionaries from FunC smart contract code, i.e., dict. We need a support structure: CopyAsk AIbit$_ (## 1) = Bit; The following TL-B structures are used to serialize a Hashmap with a fixed key length: CopyAsk AIhm_edge#_ {n:#} {X:Type} {l:#} {m:#} label:(HmLabel ~l n) {n = (~m) + l} node:(HashmapNode m X) = Hashmap n X; hmn_leaf#_ {X:Type} value:X = HashmapNode 0 X; hmn_fork#_ {n:#} {X:Type} left:^(Hashmap n X) right:^(Hashmap n X) = HashmapNode (n + 1) X; hml_short$0 {m:#} {n:#} len:(Unary ~n) {n <= m} s:(n * Bit) = HmLabel ~n m; hml_long$10 {m:#} n:(#<= m) s:(n * Bit) = HmLabel ~n m; hml_same$11 {m:#} v:Bit n:(#<= m) = HmLabel ~n m; unary_zero$0 = Unary ~0; unary_succ$1 {n:#} x:(Unary ~n) = Unary ~(n + 1); hme_empty$0 {n:#} {X:Type} = HashmapE n X; hme_root$1 {n:#} {X:Type} root:^(Hashmap n X) = HashmapE n X; This root structure is HashmapE n X that can be in one of the two possible states: either hme_empty or hme_root. ​Hashmap parsing example As an example, consider the following cell, represented in binary form: CopyAsk AI[1] -> { [00] -> { [1001000] -> { [1010000010000001100001001], [1010000010000000001101111] }, [1011100000000000001100001001] } } This cell uses the HashmapE structure with an 8-bit key size, and its values are represented using the uint16 type—that is, HashmapE 8 uint16. The HashmapE structure utilizes three distinct key types: CopyAsk AI1 = 777 17 = 111 128 = 777 To parse this Hashmap, we must first determine which structure type to use: either hme_empty or hme_root. This is decided by identifying the correct prefix. The hme_empty variation is indicated by a single bit 0 (hme_empty$0), while the hme_root variation is indicated by a single bit 1 (hme_root$1). After reading the first bit, if it is 1 (1[1]), we know it is the hme_root variation. Next, we can populate the structure variables with known values. The initial result is: hme_root$1 {n:#} {X:Type} root:^(Hashmap 8 uint16) = HashmapE 8 uint16; Here, the one-bit prefix is already read. The curly braces {} indicate conditions that need not be read. Specifically: {n:#} indicates that n is any uint32 number. {X:Type} means that X can be any type. The next portion to read is root:^(Hashmap 8 uint16), where the ^ symbol denotes a link that must be loaded. CopyAsk AI[00] -> { [1001000] -> { [1010000010000001100001001], [1010000010000000001101111] }, [1011100000000000001100001001] } ​Initiating branch parsing According to our schema, this is the correct Hashmap 8 uint16 structure. Next, we populate it with known values, resulting in the following: CopyAsk AIhm_edge#_ {n:#} {X:Type} {l:#} {m:#} label:(HmLabel ~l 8) {8 = (~m) + l} node:(HashmapNode m uint16) = Hashmap 8 uint16; As shown above, conditional variables {l:#} and {m:#} have appeared, but both values are unknown at this stage. After reading the corresponding label, we can deduce that n is part of the equation {n = (~m) + l}. This means we must calculate both l and m, where the sign indicates the resulting value of ~. To determine the value of l, we need to load the label:(HmLabel ~l uint16) sequence. Below, we outline the 3 basic structural options for HmLabel: CopyAsk AIhml_short$0 {m:#} {n:#} len:(Unary ~n) {n <= m} s:(n * Bit) = HmLabel ~n m; hml_long$10 {m:#} n:(#<= m) s:(n * Bit) = HmLabel ~n m; hml_same$11 {m:#} v:Bit n:(#<= m) = HmLabel ~n m; Each option is determined by its corresponding prefix. Our root cell comprises 2 zero bits, displayed as (2[00]). Therefore, the only logical option is hml_short$0, which starts with a prefix of 0. Next, let’s fill in the hml_short structure with known values: CopyAsk AIhml_short$0 {m:#} {n:#} len:(Unary ~n) {n <= 8} s:(n * Bit) = HmLabel ~n 8 At this point, we don’t know the value of n. However, since it includes a ~ character, we can calculate it. To do so, we load len:(Unary ~n); more about unary here. Starting with 2[00], only one bit remains after defining the HmLabel type. We load this final bit and observe that its value is 0, which indicates that the unary_zero$0 variation is used. This means that the n value for the HmLabel variation is zero. Now, we can complete the hml_short structure by using the calculated n value: CopyAsk AIhml_short$0 {m:#} {n:#} len:0 {n <= 8} s:(0 * Bit) = HmLabel 0 8 We have an empty HmLabel, denoted by s = 0, which means there is nothing to load. Next, we complete our structure by incorporating the calculated value of l, as follows: CopyAsk AIhm_edge#_ {n:#} {X:Type} {l:0} {m:#} label:(HmLabel 0 8) {8 = (~m) + 0} node:(HashmapNode m uint16) = Hashmap 8 uint16; Now that we have calculated the value of l, we can also calculate m using the equation n = (~m) + 0, which simplifies to m = n - 0. Therefore, m = n = 8. With all unknown values determined, we can load the node:(HashmapNode 8 uint16). Regarding the HashmapNode, we have several options: CopyAsk AIhmn_leaf#_ {X:Type} value:X = HashmapNode 0 X; hmn_fork#_ {n:#} {X:Type} left:^(Hashmap n X) right:^(Hashmap n X) = HashmapNode (n + 1) X; In this case, we determine the option not by using the prefix but by examining the parameter. Specifically, if n = 0, the correct result will be either hmn_leaf or hmn_fork. Since, in this example, n = 8, we use the hmn_fork variation. Now, we can fill in the known values as follows: CopyAsk AIhmn_fork#_ {n:#} {X:uint16} left:^(Hashmap n uint16) right:^(Hashmap n uint16) = HashmapNode (n + 1) uint16; After entering the known values, we must calculate the HashmapNode (n + 1) uint16. This means that the resulting value of n must be equal to our parameter, i.e., 8. To calculate the local value of n, we use the following formula: n = (n_local + 1) -> n_local = (n - 1) -> n_local = (8 - 1) -> n_local = 7. CopyAsk AIhmn_fork#_ {n:#} {X:uint16} left:^(Hashmap 7 uint16) right:^(Hashmap 7 uint16) = HashmapNode (7 + 1) uint16; Now that we know the formula, obtaining the final result is straightforward. Next, we load the left and right branches, and for each subsequent branch, the process is repeated. ​Analyzing loaded hashmap values Continuing the previous example, let’s examine how loading branches work for dictionary values. For instance, given the bitstring: 28[1011100000000000001100001001]. The result is once again hm_edge, and the next step is to fill in the sequence with the correct known values as follows: CopyAsk AIhm_edge#_ {n:#} {X:Type} {l:#} {m:#} label:(HmLabel ~l 7) {7 = (~m) + l} node:(HashmapNode m uint16) = Hashmap 7 uint16; Next, the HmLabel response is loaded using the HmLabel variation, as the prefix is 10. CopyAsk AIhml_long$10 {m:#} n:(#<= m) s:(n * Bit) = HmLabel ~n m; Now, let’s fill in the sequence: CopyAsk AIhml_long$10 {m:#} n:(#<= 7) s:(n * Bit) = HmLabel ~n 7; The new construction, n:(#<= 7), clearly denotes a sizing value that corresponds to the number 7, which is, in fact, the log2 of the number + 1. For simplicity, however, we can count the number of bits required to represent the number 7. In binary, the number 7 is written as 111, which means 3 bits are needed. Therefore, the value for n = 3. CopyAsk AIhml_long$10 {m:#} n:(## 3) s:(n * Bit) = HmLabel ~n 7; Next, we load n into the sequence, which results in 111. As noted earlier, this coincidentally equals 7. Then, we load s into the sequence, which consists of 7 bits: 0000000. Remember, s is part of the key. Afterward, we return to the top of the sequence and fill in the resulting l: CopyAsk AIhm_edge#_ {n:#} {X:Type} {l:#} {m:#} label:(HmLabel 7 7) {7 = (~m) + 7} node:(HashmapNode m uint16) = Hashmap 7 uint16; Then we calculate th",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "example",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:32:40.159Z"
  },
  {
    "id": "docs-ton-org--languages-tl-b-tep-examples",
    "title": "TEP examples",
    "url": "https://docs.ton.org/languages/tl-b/tep-examples",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BOverviewSyntax and SemanticsSimple examplesComplex and non-trivial examplesTEP examplesToolingFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationTL-BTEP examplesLanguagesTL-BTEP examplesCopy pageCopy pageThe purpose of this article is to explain common TL-B examples that you encounter when reading our standards. ​NFT The NFT collection and each NFT item are separate smart contracts in TON Blockchain. Each specific implementation must comply with the TEP 0062 standard. When reading this TEP, you encounter a TL-B schema that describes the serialization of a message that transfers the rights of a given NFT item to another user. CopyAsk AItransfer#5fcc3d14 query_id:uint64 new_owner:MsgAddress response_destination:MsgAddress custom_payload:(Maybe ^Cell) forward_amount:(VarUInteger 16) forward_payload:(Either Cell ^Cell) = InternalMsgBody; Thus, a cell corresponds to this TL-B scheme if it sequentially contains: 32-bits that represents the hexadecimal number 0x5fcc3d14. An arbitrary request number that is an unsigned 64-bit integer in binary form. An address of the new owner of the NFT item that is a sequence of bits corresponding to the MsgAddress TL-B scheme (see the address page for details). An address where to send a response with confirmation of a successful transfer and the rest of the incoming message coins. It is serialized as the previous field. Optional custom data. For the description of how the Maybe type works, see simple examples page. The amount of nanotons to be sent to the new owner. For the explanation of how VarUInteger n works, see simple examples page. The optional custom data that should be sent to the new owner. For the description of how the Either type works, see simple examples page. The knowledge gained from analyzing the TL-B schemes above is sufficient to understand all the schemes that you will encounter when analyzing the Jetton, NFT Royalty, SBT, Jetton wallet standards. ​Jetton It was mentioned above that an example of the TL-B scheme related to NFTs is sufficient to understand all schemes related to Jettons. However, as Jetton transactions are among the most common on the TON blockchain, we will analyze relevant schemes separately. A standard interface for Jettons (TON fungible tokens) is specified in TEP 0074. To transfer tokens from one wallet to another, it is required to send a message to the sender’s jetton-wallet corresponding to the following TL-B scheme. For the description of how data types VarUInteger n, Maybe, and Either work, see simple examples page. CopyAsk AItransfer#0f8a7ea5 query_id:uint64 amount:(VarUInteger 16) destination:MsgAddress response_destination:MsgAddress custom_payload:(Maybe ^Cell) forward_ton_amount:(VarUInteger 16) forward_payload:(Either Cell ^Cell) = InternalMsgBody; Thus, a cell corresponds to this TL-B scheme if it sequentially contains: 32-bits that represents the hexadecimal number 0x0f8a7ea5. An arbitrary request number that is an unsigned 64-bit integer in binary form. An amount of transferred jettons in elementary units. An address of the new owner of jettons, which is a sequence of bits corresponding to the MsgAddress TL-B scheme (see the address page for details). An address to which to send a response with confirmation of a successful transfer and the rest of the incoming message coins. It is serialized as the previous field. Optional custom data. The amount of nanotons to be sent to the new owner. Optional custom data that should be sent to the destination address. If forward_amount > 0, the receiver’s jetton-wallet should send a message to the destination address with forward_amount nanotons attached and with the following TL-B schema. CopyAsk AItransfer_notification#7362d09c query_id:uint64 amount:(VarUInteger 16) sender:MsgAddress forward_payload:(Either Cell ^Cell) = InternalMsgBody; Thus, a cell corresponds to this TL-B scheme if it sequentially contains: 32 bits that represent the hexadecimal number 0x7362d09c. An arbitrary request number that is an unsigned 64-bit integer in binary form. An amount of transferred jettons in elementary units. An address of the previous owner of transferred jettons. Optional custom data that should be sent to the destination address. The rest of the TL-B schemes corresponding to the Jettons can be examined in a similar way. ​DNS TON DNS is a service for translating human-readable domain names (such as test.ton or mysite.temp.ton) into TON smart contract addresses. It is specified in TEP 0081. Let’s consider TL-B schemes of DNS Records values: CopyAsk AIproto_http#4854 = Protocol; proto_list_nil$0 = ProtoList; proto_list_next$1 head:Protocol tail:ProtoList = ProtoList; cap_is_wallet#2177 = SmcCapability; cap_list_nil$0 = SmcCapList; cap_list_next$1 head:SmcCapability tail:SmcCapList = SmcCapList; dns_smc_address#9fd3 smc_addr:MsgAddressInt flags:(## 8) { flags <= 1 } cap_list:flags . 0?SmcCapList = DNSRecord; dns_next_resolver#ba93 resolver:MsgAddressInt = DNSRecord; dns_adnl_address#ad01 adnl_addr:bits256 flags:(## 8) { flags <= 1 } proto_list:flags . 0?ProtoList = DNSRecord; dns_storage_address#7473 bag_id:bits256 = DNSRecord; _ (HashmapE 256 ^DNSRecord) = DNS_RecordSet; The first thing you need to pay attention to: how lists of arbitrary length are formed. For instance, ProtoList combinator consists of two constructors: proto_list_nil that indicates the end of a list and proto_list_next that indicates that there is a record of protocol followed by the next record or the end of a list. When deserializing data of the ProtoList type, the prefix 1 or 0 is read first. If the prefix is 0, then we have reached the end of the list and there is nothing more to read. Otherwise, the protocol entry is read, followed by a prefix indicating whether the next protocol entry will be followed or the end of the list. The same applies to the SmcCapList type. Next, pay attention to the DNSRecord type. The constructors dns_next_resolver and dns_storage_address are simple. Let’s deal with the dns_adnl_addressconstructor: first comes the 0xad01 prefix; then 256 bits representing ADNL address; next, the 8-bit flag, which is currently bounded by 1; finally, if the first bit of the flag is 1, the serialization continued with ProtoList type; if the first bit of the flag is 0, then serialization is completed. The serialization of dns_smc_address follows the same logic.Was this page helpful?YesNoSuggest editsRaise issuePreviousToolingNext⌘IgithubxtelegramPowered by MintlifyOn this pageNFTJettonDNS",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "example",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:32:42.495Z"
  },
  {
    "id": "docs-ton-org--v3-concepts-dive-into-ton-introduction",
    "title": "Start here",
    "url": "https://docs.ton.org/v3/concepts/dive-into-ton/introduction",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationStart hereStart hereCopy pageCopy pageThe documentation is organized by layers of detail, with lower-level details appearing later. EcosystemTools and libraries for developing on TON, and how to use them.Payment processingGuides on monitoring and handling blockchain transactions for business applications, such as exchanges.Standard contractsWorking with most popular standardized contracts.Contract developmentGuides on developing smart-contracts.LanguagesReference documentation for TON-specific languages.TON Virtual MachineDescription of the low-level language that runs smart-contracts, and details of the runtime.Blockchain foundationsComprehensive description of the blockchain. Includes web version of whitepapers.ContributeDocumentation on writing this documentation. This is a condensed description of TON. The rest of the documentation may assume that all of this is already known to the reader. TON is a blockchain. It provides a distributed platform for storing data and code, as well as running computations, all the ingredients to host applications. Roughly speaking, it works as if it were a single server executing all the code. The hosted applications are called smart-contracts. The platform runs on a set of servers, called nodes. Most important type of nodes, validators, are owned by individuals or organizations with a large stake in TON and great interest in keeping the platform safe, fair, and operational. Validators have to reach consensus on the state of the blockchain. Typically, the process takes 5 seconds to reach transaction finality, a time to mint a new block. Toncoin is TON’s primary cryptocurrency. It is used to pay for the execution of smart contracts, the storage of their data, and network traffic. Such payments are called fees. There are two instances of TON blockchain: mainnet and testnet. Mainnet is the “real” network. It’s where actual payments in Toncoin are made. Applications use mainnet by default. The other network is testnet, and it is used by TON developers to check that their applications work correctly before deploying them to mainnet. It uses “test coins” that barely have any value. Usually when the TON blockchain gets an update, it is first deployed to testnet, and then to mainnet after a brief period of testing, so sometimes they may run different software. Also their configuration, availability, and throughput might be different. Each network is split into workchains that can freely interact with each other, but their implementations may differ significantly. At the moment, there are two workchains: basechain (workchain_id = 0) for regular use, and a very similar masterchain (workchain_id = -1) for TON’s internal bookkeeping. The masterchain follows mostly the same rules, except that using it is more expensive to limit the amount of traffic that interferes with TON’s internals. To be freely scalable, each workchain is split into shards. The number of shards is determined dynamically based on the current network load. Internally, every shard is implemented as a separate blockchain. Except for increased latency, the effect on the user-facing code is minimal. The nodes that run the blockchain interact via the ADNL protocol. User-facing applications usually use servers that proxy JSON HTTP requests into the ADNL network. The official version of such a proxy server is provided by the liteserver software. There are public instances of liteserver, so developers are not required to host one on their own servers. ADNL works over TCP, so it’s impossible to connect to ADNL from a web page. Browsers intentionally do not provide an API to send arbitrary TCP traffic. Servers do not have this limitation, as they can interact with the blockchain over ADNL, either by raw TCP or by wrapping ADNL through HTTP. It’s easiest to visualize the blockchain as a set of accounts. Each account has an address and a status. Over its lifetime, an account changes its status among four values: nonexist: There wasn’t a single operation with the account, or it was removed. It has neither a balance, nor code. uninit: If some Toncoin is transferred to an account, it now exists, but there is still no smart contract code on it. It now has a balance. active: After a deploy message (see below) with code and initial data is sent to an account, it becomes active and can process other messages. It now has a balance, code, and internal state. frozen: If an account is overdue on its storage fees, it will be frozen until the fees are paid. If the overdue amount reaches a maximum limit specified by the blockchain, the account goes completely bankrupt, is removed, and ceases to exist. The code on an active account is a smart contract. The term contract is often used for an account that holds the code. The internal address of an account is a pair of two numbers: its workchain ID and a 256-bit number. It may be displayed in the raw format (e.g., 0:4098805d2272a61b375350c6b2f5faaaf27c8267d8e7521ff2045104fdc7de76), but is usually shown in a user-friendly format (e.g., UQBKgXCNLPexWhs2L79kiARR1phGH1LwXxRbNsCFF9doczSI). Addresses specify where messages should be delivered. There are three types of messages: internal messages are sent between accounts; incoming external messages are sent from code outside the blockchain to a contract; outgoing external messages are broadcast to the external network; somewhat similar to adding them into the globally available list of all outgoing external messages that ever happened. Every internal message should have some Toncoin attached to it so that it can pay for the cost of handling it. External messages cannot have Toncoin attached to them because they spend some of their time outside the blockchain, and only the blockchain can prove the transfer of Toncoin is correct. Incoming external messages come from an external address, and outgoing external messages go to an external address. The state of the account changes only when it handles messages. Messages also change the account’s balance. Usually, to have a state and a balance, and to handle messages, the account must be active. Formally, a message is only an intent: it has a destination, possibly some Toncoin, and data. After the message is handled and all the necessary changes are applied to the blockchain, the message is packed, along with a description of those changes, into a single packet of data, called a transaction. A transaction records the state changes on an account. Some transactions might happen without any message. A message might also be a deploy message if it has a StateInit structure attached with its initial code and data. When such a message is sent, the hash of StateInit must match the destination address. If it does, the code and data are stored in the account at that address, and the account becomes active. Both the code and data stored in the account may change in the future, but its address will remain the same as when it was originally deployed. Internal and incoming external messages execute the account’s code. The code is interpreted by TON Virtual Machine (TVM). It is written in bitcode, a binary format specific to TVM. In the future, TVM might support multiple binary languages, codepages, but at the moment there is only codepage 0 (CP0). Most development is done in the Tolk, a high-level programming language. Its compiler is included in the Blueprint development environment and will be available to all projects created from the template. Originally, Fift, a Forth-like assembly language, and FunC, a C-like intermediate-level language, were used for contract development. When execution starts, the message and current account state are provided to the code. By the end of execution, the account might change its state or code, or send internal or outgoing external messages. The execution follows a process whose steps are called phases. Fees are deducted during this process. Fees might be deducted from the account’s balance or from the Toncoin the message carries, depending on the mode of the message, or by explicit choice made in the contract’s code. Execution cost is first measured in gas units, then converted to Toncoin. This unit is separate so that if code execution becomes computationally cheaper (or more expensive), validators can vote to change the price of gas in Toncoin. If something goes wrong, a non-zero exit code might be returned, no changes to state or code are saved, and no further messages are sent. If the message that resulted in a failed transaction is marked as bounceable, a bounce message is sent back to the sender. Bounce messages are used to inform the sender that handling of their message failed. They can carry either truncated or full body of the original message. The most common reason a code is executed is when some account has received a mes",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "testnet",
      "mainnet",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:32:44.945Z"
  },
  {
    "id": "docs-ton-org--v3-concepts-dive-into-ton-ton-ecosystem-wallet-apps",
    "title": "Wallets",
    "url": "https://docs.ton.org/v3/concepts/dive-into-ton/ton-ecosystem/wallet-apps",
    "content": "Skip to main contentDeprecated! Please, visit the new documentation at docs.ton.org Deprecated, go to new docs!On this pageWallets Overview​ This article provides an overview of various wallet types in the TON ecosystem, focusing on their primary features, security models, and intended users — ranging from everyday users to developers. It helps you choose the right wallet and explains how wallets support TON’s goal of mass adoption. Explore the full ton.org/wallets catalog for more wallet options. Non-custodial wallets​ Non-custodial wallets empower users with full ownership and control over their private keys and funds. Unlike custodial wallets, which a third party manages, non-custodial wallets store private keys exclusively with the user, secured using a seed phrase (also called recovery phrase) — a unique sequence of 24 words. Software (hot) wallets​ A software wallet — commonly referred to as a hot wallet — runs locally on a device such as a smartphone or computer, storing private keys securely within the device’s storage. Below is a selection of prominent non-custodial software wallets. Wallets for everyday users​ WalletDescriptionPlatformsTestnet AccessLinksTonkeeperOpen-source wallet commonly used in the TON ecosystem. Supports tokens and NFTs.iOS, Android Create wallet and save recovery phrase. From main screen, tap wallet name → Add Wallet → Testnet Account. Enter saved recovery phrase. GitHubWallet APIMyTonWalletOpen-source web wallet supporting tokens, NFTs, TON DNS, TON Sites and TON Proxy — also compatible with TRON.iOS, Android, Chrome, Firefox Open Settings. Scroll down and tap MyTonWallet app version. Select the environment in the popup. GitHubTelegramTonhubOpen-source, mobile-first wallet with Ton Nominator integration.iOS, Android Requires different app for iOS Same app for Android Tap 6+ times on the app version to change the environment GitHubBug bounty Wallets for developers​ WalletDescriptionPlatformsLinksHighlightsTONDevWalletOpen-source desktop wallet designed for development and testing.DesktopGitHubSeamless integration with TON ConnectLocal transaction emulation before on-chain submission.Manage multiple keys and walletsTON WalletOriginal wallet from TON Core demonstrating reference implementation.iOS, Android, macOS, Linux, Windows, ChromeGitHubGitHub for iOSADNL connection supportCross-platform architectureBug bounty programSupports the testnet parameter in the browserOpenMaskOpen-source Chrome extension wallet focused on Web3 and DApp development.ChromeGitHubDocsChrome extension optimized for DApp developmentMultiple wallet support warningTONDevWallet is for development and testing only. Do NOT use it to store real funds — it is insecure and does NOT provide adequate protection. Hardware (cold) wallets​ Hardware wallets are physical devices that store private keys offline, isolating them from internet risks. Even when authorizing transactions, these devices sign them in a secure, offline environment, ensuring private keys never leave the device. WalletDescriptionLinksLedgerHardware wallet with offline key storage. Uses Ledger Live app to manage assets.TON blog postOfficial siteSafePalHardware wallet supporting decentralized applications.Official site Custodial wallets​ In custodial wallets, a third party — such as a cryptocurrency exchange — holds and manages users’ private keys. This means users entrust the entity with the storage and control of their assets. WalletDescriptionLinks@walletTelegram bot for sending, receiving, and trading Toncoin via P2P. Supports Telegram Mini Apps.—@cryptobotTelegram bot wallet for storing, sending, and exchanging Toncoin.Pay API@tonrocketbotTelegram bot wallet for Toncoin storage, transfers, and trading.Exchange API, Pay API Multi-signature wallets​ WalletDescriptionLinksTonkeyA multi-signature wallet that offers advanced control over asset access and approvals.GitHub See also​ Explorers Wallet contracts Was this article useful?YesNoEdit this pageLast updated on Sep 4, 2025 by Daniil SedovOverviewNon-custodial walletsSoftware (hot) walletsHardware (cold) walletsCustodial walletsMulti-signature walletsSee alsoUseGet a WalletGet ToncoinStakeAccept PaymentsApps & ServicesDomainsUSDT on TONCross-Chain BridgesLearnTON ConceptDecentralized NetworkRoadmapTonStatHistory of MiningToncoinValidatorsWhite PaperBrand AssetsSustainabilityFor BuildersTON Builders PortalGetting StartedDocumentationTelegram Mini AppsDev ChatsBug BountyFind a JobFind a TalentUse CasesGameFiMemecoins & TokensCommunity ToolsTON SitesCommunityCommunitiesBlogCareers",
    "category": "wallets",
    "tags": [
      "ton",
      "wallet",
      "nft",
      "telegram",
      "mini app",
      "ton connect",
      "dapp",
      "api",
      "testnet",
      "transaction",
      "testing",
      "builder",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:32:47.839Z"
  },
  {
    "id": "docs-ton-org--v3-concepts-dive-into-ton-ton-ecosystem-explorers-in-ton",
    "title": "Overview",
    "url": "https://docs.ton.org/v3/concepts/dive-into-ton/ton-ecosystem/explorers-in-ton",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersOverviewUsing TonviewerSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationExplorersOverviewEcosystemExplorersOverviewCopy pageCopy pageExplorers are web tools for reading blockchain data. They let you look up accounts, transactions, blocks, and smart contracts, making it easy to verify activity and debug issues. ​Explorer A blockchain explorer is a website that indexes on‑chain data and presents it in a searchable user interface (UI). In TON, explorers commonly show account balances, recent transactions, jettons and non‑fungible tokens (NFTs), contract code and state, and links to related blocks and messages. ​What explorers show Balances and assets: TON, jettons, and NFTs held by an address Transactions and messages: history, fees, phases, and traces Blocks and validators: block contents, masterchain and shardchain details Smart contracts: code, state, disassembly, and known contract type Analytics: top entities, volumes, gas, fees, and network health ​Indexers Indexers continuously read blocks from nodes, parse messages and transactions, and store them in a database optimized for queries. Explorers rely on these indexers to provide fast search, traces, higher‑level events, and historical views beyond what a single node exposes by default. ​Explorers comparison ExplorerTypeMainnetTestnetOfficial TonviewerGeneral‑purposetonviewer.comTestnetNoTonscan.orgGeneral‑purposetonscan.orgTestnetNoTonscan.comGeneral‑purposetonscan.com-NoTON ExplorerLow‑level/coreexplorer.toncoin.orgTestnetYes Official: maintained by the TON Foundation or an affiliated team The verifier tool powers contract code verification.Was this page helpful?YesNoSuggest editsRaise issuePreviousUsing TonviewerNext⌘IgithubxtelegramPowered by MintlifyOn this pageExplorerWhat explorers showIndexersExplorers comparison",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "testnet",
      "mainnet",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:32:49.494Z"
  },
  {
    "id": "docs-ton-org--v3-concepts-dive-into-ton-ton-blockchain-overview",
    "title": "Start here",
    "url": "https://docs.ton.org/v3/concepts/dive-into-ton/ton-blockchain/overview",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationStart hereStart hereCopy pageCopy pageThe documentation is organized by layers of detail, with lower-level details appearing later. EcosystemTools and libraries for developing on TON, and how to use them.Payment processingGuides on monitoring and handling blockchain transactions for business applications, such as exchanges.Standard contractsWorking with most popular standardized contracts.Contract developmentGuides on developing smart-contracts.LanguagesReference documentation for TON-specific languages.TON Virtual MachineDescription of the low-level language that runs smart-contracts, and details of the runtime.Blockchain foundationsComprehensive description of the blockchain. Includes web version of whitepapers.ContributeDocumentation on writing this documentation. This is a condensed description of TON. The rest of the documentation may assume that all of this is already known to the reader. TON is a blockchain. It provides a distributed platform for storing data and code, as well as running computations, all the ingredients to host applications. Roughly speaking, it works as if it were a single server executing all the code. The hosted applications are called smart-contracts. The platform runs on a set of servers, called nodes. Most important type of nodes, validators, are owned by individuals or organizations with a large stake in TON and great interest in keeping the platform safe, fair, and operational. Validators have to reach consensus on the state of the blockchain. Typically, the process takes 5 seconds to reach transaction finality, a time to mint a new block. Toncoin is TON’s primary cryptocurrency. It is used to pay for the execution of smart contracts, the storage of their data, and network traffic. Such payments are called fees. There are two instances of TON blockchain: mainnet and testnet. Mainnet is the “real” network. It’s where actual payments in Toncoin are made. Applications use mainnet by default. The other network is testnet, and it is used by TON developers to check that their applications work correctly before deploying them to mainnet. It uses “test coins” that barely have any value. Usually when the TON blockchain gets an update, it is first deployed to testnet, and then to mainnet after a brief period of testing, so sometimes they may run different software. Also their configuration, availability, and throughput might be different. Each network is split into workchains that can freely interact with each other, but their implementations may differ significantly. At the moment, there are two workchains: basechain (workchain_id = 0) for regular use, and a very similar masterchain (workchain_id = -1) for TON’s internal bookkeeping. The masterchain follows mostly the same rules, except that using it is more expensive to limit the amount of traffic that interferes with TON’s internals. To be freely scalable, each workchain is split into shards. The number of shards is determined dynamically based on the current network load. Internally, every shard is implemented as a separate blockchain. Except for increased latency, the effect on the user-facing code is minimal. The nodes that run the blockchain interact via the ADNL protocol. User-facing applications usually use servers that proxy JSON HTTP requests into the ADNL network. The official version of such a proxy server is provided by the liteserver software. There are public instances of liteserver, so developers are not required to host one on their own servers. ADNL works over TCP, so it’s impossible to connect to ADNL from a web page. Browsers intentionally do not provide an API to send arbitrary TCP traffic. Servers do not have this limitation, as they can interact with the blockchain over ADNL, either by raw TCP or by wrapping ADNL through HTTP. It’s easiest to visualize the blockchain as a set of accounts. Each account has an address and a status. Over its lifetime, an account changes its status among four values: nonexist: There wasn’t a single operation with the account, or it was removed. It has neither a balance, nor code. uninit: If some Toncoin is transferred to an account, it now exists, but there is still no smart contract code on it. It now has a balance. active: After a deploy message (see below) with code and initial data is sent to an account, it becomes active and can process other messages. It now has a balance, code, and internal state. frozen: If an account is overdue on its storage fees, it will be frozen until the fees are paid. If the overdue amount reaches a maximum limit specified by the blockchain, the account goes completely bankrupt, is removed, and ceases to exist. The code on an active account is a smart contract. The term contract is often used for an account that holds the code. The internal address of an account is a pair of two numbers: its workchain ID and a 256-bit number. It may be displayed in the raw format (e.g., 0:4098805d2272a61b375350c6b2f5faaaf27c8267d8e7521ff2045104fdc7de76), but is usually shown in a user-friendly format (e.g., UQBKgXCNLPexWhs2L79kiARR1phGH1LwXxRbNsCFF9doczSI). Addresses specify where messages should be delivered. There are three types of messages: internal messages are sent between accounts; incoming external messages are sent from code outside the blockchain to a contract; outgoing external messages are broadcast to the external network; somewhat similar to adding them into the globally available list of all outgoing external messages that ever happened. Every internal message should have some Toncoin attached to it so that it can pay for the cost of handling it. External messages cannot have Toncoin attached to them because they spend some of their time outside the blockchain, and only the blockchain can prove the transfer of Toncoin is correct. Incoming external messages come from an external address, and outgoing external messages go to an external address. The state of the account changes only when it handles messages. Messages also change the account’s balance. Usually, to have a state and a balance, and to handle messages, the account must be active. Formally, a message is only an intent: it has a destination, possibly some Toncoin, and data. After the message is handled and all the necessary changes are applied to the blockchain, the message is packed, along with a description of those changes, into a single packet of data, called a transaction. A transaction records the state changes on an account. Some transactions might happen without any message. A message might also be a deploy message if it has a StateInit structure attached with its initial code and data. When such a message is sent, the hash of StateInit must match the destination address. If it does, the code and data are stored in the account at that address, and the account becomes active. Both the code and data stored in the account may change in the future, but its address will remain the same as when it was originally deployed. Internal and incoming external messages execute the account’s code. The code is interpreted by TON Virtual Machine (TVM). It is written in bitcode, a binary format specific to TVM. In the future, TVM might support multiple binary languages, codepages, but at the moment there is only codepage 0 (CP0). Most development is done in the Tolk, a high-level programming language. Its compiler is included in the Blueprint development environment and will be available to all projects created from the template. Originally, Fift, a Forth-like assembly language, and FunC, a C-like intermediate-level language, were used for contract development. When execution starts, the message and current account state are provided to the code. By the end of execution, the account might change its state or code, or send internal or outgoing external messages. The execution follows a process whose steps are called phases. Fees are deducted during this process. Fees might be deducted from the account’s balance or from the Toncoin the message carries, depending on the mode of the message, or by explicit choice made in the contract’s code. Execution cost is first measured in gas units, then converted to Toncoin. This unit is separate so that if code execution becomes computationally cheaper (or more expensive), validators can vote to change the price of gas in Toncoin. If something goes wrong, a non-zero exit code might be returned, no changes to state or code are saved, and no further messages are sent. If the message that resulted in a failed transaction is marked as bounceable, a bounce message is sent back to the sender. Bounce messages are used to inform the sender that handling of their message failed. They can carry either truncated or full body of the original message. The most common reason a code is executed is when some account has received a mes",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "testnet",
      "mainnet",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:32:52.880Z"
  },
  {
    "id": "docs-ton-org--v3-guidelines-quick-start-getting-started",
    "title": "Your first smart contract",
    "url": "https://docs.ton.org/v3/guidelines/quick-start/getting-started",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationContract developmentYour first smart contractContract developmentYour first smart contractCopy pageCopy pageWelcome to your journey into TON smart contract development! In this comprehensive tutorial, you’ll learn to build, deploy, and interact with a smart contract from scratch. ​What you’ll learn By the end of this tutorial, you’ll have: ✅ Built a complete smart contract in Tolk ✅ Deployed it to TON testnet ✅ Interacted with it using TypeScript scripts ✅ Mastered the fundamentals of TON development ​What is a TON smart contract? ​Understanding the basics A smart contract is a computer program stored on TON Blockchain — a distributed database that many computers maintain together. It runs on the TVM (TON Virtual Machine) — the “computer” that runs smart contract code on TON. The contract is made of two parts: Code (compiled TVM instructions) - the “rules” or “program logic” Data (persistent state) - the “memory” that remembers things between interactions Both are stored at a specific address on TON Blockchain, a unique identifier for each smart contract. ​Prerequisites Basic programming - Understanding of variables, functions, if/else statements Command line basics - Comfortable opening terminal and running commands Node.js (v22 or later) — Download here Check if installed: node -v in terminal TON wallet ​Tutorial overview This tutorial is organized into six clear steps that build upon each other: StepWhat You’ll DoKey SkillsStep 1Set up Blueprint toolkitProject structure, development environmentStep 2Learn contract architectureStorage, messages, getters conceptStep 3Write contract in TolkProgramming, message handling, data structuresStep 4Compile to bytecodeBuild process, TVM compilationStep 5Deploy to blockchainTestnet deployment, wallet integrationStep 6Interact with contractMessage sending, get methods, TypeScript integration Let’s dive into development! ​Step 1: Development environment setup We’ll use Blueprint as our development toolkit for smart contracts. Start a new project with: CopyAsk AInpm create ton@latest -- Example --contractName FirstContract --type tolk-empty This will create a project Example with a contract FirstContract. The project structure will look like this: CopyAsk AIExample/ ├── contracts/ # Smart contract source code │ └── first_contract.tolk # Main contract file ├── scripts/ # Deployment and on-chain interaction scripts │ └── deployFirstContract.ts # Script to deploy the contract ├── tests/ # Testing specifications │ └── FirstContract.spec.ts # Contract test file └── wrappers/ # TypeScript wrappers for contract interaction ├── FirstContract.ts # Wrapper class for the smart contract └── FirstContract.compile.ts # Configuration for compiling contract TON provides plugins that add syntax support for various IDEs and code editors. Check out the IDE & plugins section for VS Code and JetBrains support. Now, move into the project directory: CopyAsk AIcd Example ​Step 2: Understanding smart contract architecture Every smart contract in TON is typically divided into three sections: storage, messages, and getters. Storage: Defines the contract’s persistent data. For example, our counter variable must keep its value across calls from different users. Messages: Define how the contract reacts to incoming messages. On TON, the primary way to interact with contracts is by sending messages. Each processed message produces a transaction — a recorded change on the blockchain (like “Alice sent 5 TON to Bob”). Getters: Provide read-only access to contract data without modifying state. For example, we’ll create a getter to return the current value of the counter. Due to the TON architecture, getters cannot be called from other contracts. Inter-contract communication is possible only through messages. ​Step 3: Writing the smart contract We’ll build a simple counter contract: The counter starts from an initial number. Users can send an increase message to increment it, or a reset message to drop it to zero. A getter function will let anyone query the current counter value. We’ll use Tolk to implement this. Tolk looks familiar if you know TypeScript or Rust, but it’s designed specifically for smart contract development. ​3.1 Defining contract storage First, we need a way to store the counter value. Tolk makes this simple with structures: ./contracts/first_contract.tolkCopyAsk AIstruct Storage { counter: uint64 // the current counter value } // load contract data from persistent storage fun Storage.load() { return Storage.fromCell(contract.getData()) } // save contract data to persistent storage fun Storage.save(self) { contract.setData(self.toCell()) } Behind the scenes, structures know how to serialize and deserialize themselves into cells — the fundamental way TON stores data. This happens through the fromCell and toCell functions - Tolk automatically converts between your nice structures and the cell format that TON understands. You may think of cells like containers that hold data on TON: Each cell can store up to 1023 bits of data. Cells can reference other cells (like links). Everything on TON (contracts, messages, storage) is made of cells. Now that we can store data, let’s handle our first messages. ​3.2 Implementing message handlers The main entry point for processing messages in a Tolk contract is the onInternalMessage function. It receives one argument — the incoming message. Among its fields, the most important one for us is body, which contains the payload sent by a user or another contract. Tolk structures are also useful for defining message bodies. In our case, we’ll define two messages: IncreaseCounter — with one field increaseBy, used to increment the counter. ResetCounter — used to reset the counter to zero. Each structure has a unique prefix (0x7e8764ef and 0x3a752f06), widely called opcodes, that lets the contract distinguish between them. ./contracts/first_contract.tolkCopyAsk AIstruct (0x7e8764ef) IncreaseCounter { increaseBy: uint32 } struct (0x3a752f06) ResetCounter {} To group them together, we’ll use a union. Unions allow multiple types to be bundled into a single type that can be serialized and deserialized automatically: ./contracts/first_contract.tolkCopyAsk AItype AllowedMessage = IncreaseCounter | ResetCounter Now we can write our message handler: ./contracts/first_contract.tolkCopyAsk AIfun onInternalMessage(in: InMessage) { // use `lazy` to defer parsing until fields are accessed val msg = lazy AllowedMessage.fromSlice(in.body); // matching our union to determine body structure match (msg) { IncreaseCounter => { // load contract storage lazily (efficient for large or partial reads/updates) var storage = lazy Storage.load(); storage.counter += msg.increaseBy; storage.save(); } ResetCounter => { var storage = lazy Storage.load(); storage.counter = 0; storage.save(); } // this match branch would be executed if the message body does not match IncreaseCounter or ResetCounter structures else => { // reject user message (throw) if body is not empty assert(in.body.isEmpty()) throw 0xFFFF } } } Tolk Language Guide - Complete language documentation View the complete contract on GitHub ​3.3 Adding getter functions Finally, let’s implement a getter so users can read the current counter value: ./contracts/first_contract.tolkCopyAsk AIget fun currentCounter(): int { val storage = lazy Storage.load(); return storage.counter; } ​3.4 Complete contract code We now have a complete smart contract with: Storage: persistent counter value Messages: IncreaseCounter and ResetCounter handlers Getter: currentCounter Here’s the full source code of contracts/first_contract.tolk: ./contracts/first_contract.tolkCopyAsk AIstruct Storage { counter: uint64 } fun Storage.load() { return Storage.fromCell(contract.getData()); } fun Storage.save(self) { contract.setData(self.toCell()); } struct (0x7e8764ef) IncreaseCounter { increaseBy: uint32 } struct (0x3a752f06) ResetCounter {} type AllowedMessage = IncreaseCounter | ResetCounter fun onInternalMessage(in: InMessage) { val msg = lazy AllowedMessage.fromSlice(in.body); match (msg) { IncreaseCounter => { var storage = lazy Storage.load(); storage.counter += msg.increaseBy; storage.save(); } ResetCounter => { var storage = lazy Storage.load(); storage.counter = 0; storage.save(); } else => { assert(in.body.isEmpty()) throw 0xFFFF; } } } get fun currentCounter(): int { val storage = lazy Storage.load(); return storage.counter; } See all 47 lines 🎉 Congratulations — you’ve built your first smart contract in Tolk! You can find the full working code for this tutorial in our GitHub repository. This includes all contract files, scripts, and wrappers ready to use. ​Step 4: Compiling your contract The next step is to build our contract — compile it into bytecode that can be executed by the TVM. With Blueprint, th",
    "category": "how-to",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "testnet",
      "mainnet",
      "transaction",
      "deployment",
      "testing",
      "tutorial",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "react",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:32:57.076Z"
  },
  {
    "id": "docs-ton-org--v3-guidelines-smart-contracts-guidelines",
    "title": "Debugging smart contracts",
    "url": "https://docs.ton.org/v3/guidelines/smart-contracts/guidelines",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationContract developmentDebugging smart contractsContract developmentDebugging smart contractsCopy pageCopy pageAll examples from this article are available on GitHub. Errors in smart contracts can produce an exit code, often indicating a bug in the contract. Use debugging methods to locate and fix the issue. ​Log to the console Most commonly used to print common values: transactions and get-method results. Use findTransaction() to find a transaction by its properties. Use flattenTransaction() to inspect transactions in a more human-readable format. TypeScriptCopyAsk AIimport '@ton/test-utils'; import { toNano } from '@ton/core'; import { Blockchain } from '@ton/sandbox'; import { Test } from './output/sample_Test'; import { findTransaction } from '@ton/test-utils'; import { flattenTransaction } from '@ton/test-utils'; const setup = async () => { const blockchain = await Blockchain.create(); const owner = await blockchain.treasury('deployer'); const contract = blockchain.openContract( await Test.fromInit(), ); const deployResult = await contract.send( owner.getSender(), { value: toNano(0.5), bounce: true }, null, ); return { blockchain, owner, contract, deployResult }; }; it('should deploy correctly', async () => { const { contract, deployResult } = await setup(); const txToInspect = findTransaction( deployResult.transactions, { to: contract.address, deploy: true, }, ); if (txToInspect === undefined) { throw new Error('Requested tx was not found.'); } // User-friendly output console.log(flattenTransaction(txToInspect)); // Verbose output console.log(txToInspect); }); ​Dump values from a contract There are three TVM debug instructions: DUMPSTK, STRDUMP, and DUMP. These instructions are wrapped in functions with different names in each language: Tolk: Functions on a global debug object. FunC: Global functions from stdlib.fc. Tact: dumpStack for DUMPSTK and the dump function for the other two. Tact also prints the exact line where dump is called, so it can quickly be found in the code. Debug instructions consume gas and affect gas measurement. Remove them before measuring gas or deploying to production. ​Explore TVM logs TypeScriptCopyAsk AIconst blockchain = await Blockchain.create(); blockchain.verbosity.vmLogs = \"vm_logs\"; Of all verbosity levels, the two are the most useful: vm_logs — outputs VM logs for each transaction; includes executed instructions and occurred exceptions. vm_logs_full — outputs full VM logs for each transaction; includes executed instructions with binary offsets, the current stack for each instruction, and gas used by each instruction. Typical output for vm_logs looks like this: CopyAsk AI... execute SWAP execute PUSHCONT x30 execute IFJMP execute LDU 64 handling exception code 9: cell underflow default exception handler, terminating vm with exit code 9 The contract attempts to load a 64-bit integer from the slice using LDU 64. Since there is not enough data, execution stops with exit code 9. Inspect the same code with the vm_logs_full verbosity level. The output is heavily truncated at the top. CopyAsk AI... execute PUSHCONT x30 gas remaining: 999018 stack: [ 500000000 CS{Cell{02b168008d0d4580cd8f09522be7c0390a7a632bda4a99291c435b767c95367ebe78e9af0023d36bc5f97853f4c898f868f95b035ae8f555a321d0ffce8d9f6165e2252d7a9077359400060e9fc800000000003d0902d1b85b3919} bits: 711..711; refs: 2..2} 0 Cont{vmc_std} ] code cell hash: F9EAC82B7999AEEF696D592FE2469B9069FB05ED35C92213D7EE516F45AB97CA offset: 344 execute IFJMP gas remaining: 999000 stack: [ 500000000 CS{Cell{02b168008d0d4580cd8f09522be7c0390a7a632bda4a99291c435b767c95367ebe78e9af0023d36bc5f97853f4c898f868f95b035ae8f555a321d0ffce8d9f6165e2252d7a9077359400060e9fc800000000003d0902d1b85b3919} bits: 711..725; refs: 2..2} ] code cell hash: F9EAC82B7999AEEF696D592FE2469B9069FB05ED35C92213D7EE516F45AB97CA offset: 352 execute LDU 64 handling exception code 9: cell underflow default exception handler, terminating vm with exit code 9 To investigate the error in more detail, examine the TVM source code for the LDU instruction. Sometimes several instructions are implemented within a single exec_* method. For example, LDU (load_uint), LDI (load_int) and it’s preload versions (preload_uintandpreload_int).Check how LDU is implemented. Stack is printed as [bottom, ..., top], where top is the top of the stack. Here, the stack contains two values: Top: the slice from which data is being read — CS{Cell{...} bits: 711..725; refs: 2..2} Bottom: an integer value — 500000000 However, the slice contains only 725 bits, of which 711 bits and both references have already been read. The contract attempted to read 64 more bits, but the slice did not contain enough remaining data. In FunC, locate the load_uint(64) call causing the issue and ensure enough bits are available or adjust the read width. ​TVM log limits The size of TVM debug output depends on the verbosity level: LevelSettingMax size0none256 bytes (default)1–4vm_logs vm_logs_location vm_logs_gas vm_logs_full1 MB5vm_logs_verbose32 MB When the output exceeds its limit, it is truncated from the bottom — older entries are discarded, and only the most recent lines are kept. Logs are not rotated. ​Explore the trace For traces that are not too large, print all transactions and inspect them. TypeScriptCopyAsk AIconst result = await contract.send( owner.getSender(), { value: toNano(0.5), bounce: true }, null, ); for (const tx of result.transactions) { console.log(flattenTransaction(tx)); } For large traces, use a GUI tool. Two tools are commonly used: TonDevWallet trace view — requires the TonDevWallet application; does not require a custom @ton/sandbox; requires the @tondevwallet/traces package. TxTracer Sandbox — requires a custom @ton/sandbox package; runs in the browser. Also, these tools allow to explore logs of each transaction. ​Debugging with TVM Retracer Even when a contract executes successfully (exit code = 0) with no errors, the actions may not produce the expected on-chain result. TVM Retracer replays the transaction and displays VM-level execution in detail. ​Scenarios for retracing All execution phases complete without errors, yet the expected outcome is missing. An action is skipped, or a transfer does not reach its destination. A step-by-step view of how the TVM executes contract logic is required, i.e. to trace a bug in a high-level smart-contract language compiler. ​How to analyze a transaction Obtain the transaction hash from a blockchain explorer. Open TVM Retracer and enter the transaction hash. Review the execution: Inspect Logs section for executed instructions and exceptions. Examine Actions cell (C5) to review data passed between contracts. Check message modes — some modes can suppress errors, causing actions to be skipped. Was this page helpful?YesNoSuggest editsRaise issuePreviousSigning messagesNext⌘IgithubxtelegramPowered by MintlifyOn this pageLog to the consoleDump values from a contractExplore TVM logsTVM log limitsExplore the traceDebugging with TVM RetracerScenarios for retracingHow to analyze a transaction",
    "category": "smart-contracts",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:33:01.131Z"
  },
  {
    "id": "docs-ton-org--v3-guidelines-dapps-overview",
    "title": "Welcome toTON Blockchaindocumentation",
    "url": "https://docs.ton.org/v3/guidelines/dapps/overview",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationWelcome to TON Blockchain documentationWelcome toTON BlockchaindocumentationMeet the AI-native, beautiful and comprehensive documentation covering foundations, tools, languages, and APIs.Learn TON in Y minutesOr choose a path →Choose your pathEmbark on a journey tailored to your role, experience, and intent.FreshmanLearn the fundamentals of TON Blockchain. Perfectly suited for newcomers who explore the web3 world through TON.How to read this documentation?Start hereWhat is blockchain?What is a smart contract on TON?Writing your first smart contractNomadFor those coming from another blockchain. Study how things work on TON in comparison and go through hands-on guides for migration.Coming from EthereumCompare the execution model and the ecosystem of TONYour first smart contractWrite and deploy a contract that can be interacted withAceFor amateurs, experts, and learners alike. Take a deep dive into the low-level details, or do a quick reference check and return to your project.BlueprintDevelopment environmentTVM Exit codesComplete list of compute phase exit codesTVM InstructionsComplete list of instructions and opcodesAPI providersTON Center v2 and v3, and othersTON ConnectIntegrate TON into dApps and walletsBlockchain nodesPick the right kind and setup your nodeLooking for something else? Search documentation with Ctrl + K and ask AI right there, or open the assistant panel by pressing Ctrl + I. If nothing was found, ask the community of TON developers, builders and enthusiasts.Join the communityTroubleshoot issues or discuss best practices with other community members.Get supportLearn how to get help on the dedicated pageTelegramAdd the folder with many developer chatsTON TalentsSeek skilled professionals and agencies⌘I",
    "category": "dapps",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "dapp",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:33:03.306Z"
  },
  {
    "id": "docs-ton-org--v3-guidelines-nodes-overview",
    "title": "Overview",
    "url": "https://docs.ton.org/v3/guidelines/nodes/overview",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeOverviewRun a node with MyTonCtrlRun a validatorIntegrate MyTonCtrl with PrometheusSetting up a local blockchain using MyLocalTonMyTonCtrl referenceStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationBlockchain nodeOverviewEcosystemBlockchain nodeOverviewCopy pagePick the right TON node setup and understand the operational work it requires.Copy pageA full node is a software that stores the whole blockchain state locally, opposite to lite-clients, which request small pieces of data from liteservers when needed. It does not solve any problem itself, but provides a base for other services requiring a full blockchain state (validator, liteserver, etc). Usually, full nodes keep only the latest part of the blockchain state, which is vital for ensuring client applications’ network stability and operation. Full nodes prune the state of the TON blockchain they keep. This means the full node automatically removes earlier blocks that become unnecessary for the network to manage its data volume effectively. To allow client applications to look for blocks and transactions and send new transactions into the TON blockchain, full nodes are equipped with the liteserver functionality. A full node can be set up using mytonctrl tool, which also activates validator or liteserver mode for you. ​Full node modes RoleWhat it doesWhen to use itLiteserverStores the latest shards, tracks the masterchain, and serves data to lite-clients.Required for custom infrastructure, analytics, or to back your own APIs.Archive liteserverStores all blockchain data, including old blocks and states.Required for explorers and other services working with historical data.ValidatorSigns blocks, participates in elections, and earns rewards.Needed to run validation with your stake or to operate a nominator pool service.CollatorProduces blocks for validators.Needed to reduce load on your validators by setting up block creation on a separate machine.Nominator poolAccepts funds from stakers and runs a validator with their stake.Needed when you want to securely accept stakes from multiple parties and share rewards between them.Single nominatorSecure way to run a validator without depositing all funds to a hot wallet.Generally, you should use it each time you want to run a new validator.Liquid stakingSame as nominator pool, but exchanges stakers’ funds for a synthetic token to be used in DeFi.Needed to run a liquid staking protocol. ​Do you need your own node? Run your own full node when you need guaranteed uptime or to serve high-volume workloads without third-party rate limits. Validators and staking services need to install a node and activate validator mode. Rely on public endpoints when building prototypes or light integrations. Community liteservers and APIs such as TON Center or other RPC providers already expose the blockchain for read access and transaction submission. ​Pick your target environment If you needRunValidator or nominator capacitySetting up a node using MyTonCtrl with the validator, nominator pool, or single nominator workflows; the wrapper automates validator wallets, overlays, elections, and upgrades.Liteserver APIsSetting up a node using MyTonCtrl with liteserver option (and archive mode if needed) to expose API for applications.An isolated development networkSetting up a local blockchain using MyLocalTon to spin up a local shard, explorer, and APIs for rapid iterations with no mainnet impact. ​Full node The full node is a basic node type within the TON blockchain. It serves as the backbone of the TON blockchain by keeping its block history — in other words, its current state. Compared to archive nodes, full nodes keep only the latest part of the blockchain state, which is vital for ensuring client applications’ network stability and operation. Full nodes prune the state of the TON blockchain they keep. This means the full node automatically removes earlier blocks that become unnecessary for the network to manage its data volume effectively. To allow client applications to look for blocks and transactions and send new transactions into the TON blockchain, full nodes are equipped with the liteserver functionality. ​Archive node The archive node is a full node that keeps the entire block history of the TON blockchain. These nodes act as the decentralized point of truth to ensure consistency of the whole blockchain history. They are a backend for blockchain explorers and other applications relying on deep transaction history. Archive nodes do not prune the blockchain state, elevating system requirements, especially in storage. According to the latest estimations, while full and validator nodes require about 1 TB of disk space, archive nodes need about 12 TB to store the complete block history. ​Validator node Validator nodes or validators are the TON network participants who propose new blocks and verify transactions according to the TON’s proof-of-stake mechanism. In this way, validators contribute to the overall blockchain security. Validators get rewards in TON for successful participation in the validation process. To be entitled to propose and validate blocks, other participants elect validators based on the amount of TON they hold — in other words, their stake. The more TON a validator stakes, the higher its chances of being elected, validating blocks for the network, and earning rewards. As a rule, validator operators motivate other TON holders to stake with them to get passive income from the resulting rewards. In this way, validators ensure network stability and security and contribute to its growth. ​Interacting with TON nodes TON nodes can run in liteserver mode, which allows external applications to interact with the TON blockchain. In this mode, the nodes process requests from clients, enabling them to access blockchain data, send transactions, and retrieve information about blocks and transactions. Liteserver uses the Abstract Datagram Network Layer (ADNL) protocol, so you generally also use ton-http-api (a TON Center-like API), which acts as an HTTP-to-ADNL frontend and exposes an HTTP API. Full and archive nodes typically enable liteserver mode because they store blockchain history and handle external requests. In contrast, validator nodes do not need it as they focus on validating new blocks efficiently without extra workload from external queries. You have two options to allow your application to interact with the TON blockchain: To have a stable connection, you can set up your own full or archive node with a liteserver mode and ton-http-api enabled using MyTonCtrl. If you cannot set up your TON node with a liteserver, you can use TON Center or other RPC providers. Was this page helpful?YesNoSuggest editsRaise issuePreviousRun a node with MyTonCtrlProvision hardware, install MyTonCtrl, and follow runbooks for validator, liteserver, or archive roles.Next⌘IgithubxtelegramPowered by MintlifyOn this pageFull node modesDo you need your own node?Pick your target environmentFull nodeArchive nodeValidator nodeInteracting with TON nodes",
    "category": "how-to",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "frontend",
      "backend",
      "api",
      "sdk",
      "mainnet",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:33:04.865Z"
  },
  {
    "id": "docs-ton-org--v3-guidelines-ton-connect-overview",
    "title": "TON Connect overview",
    "url": "https://docs.ton.org/v3/guidelines/ton-connect/overview",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectOverviewIntegrate a dAppIntegrate a walletManifestsMessage lookupWalletKitTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationTON ConnectTON Connect overviewEcosystemTON ConnectTON Connect overviewCopy pageCopy pageTo integrate with TON, the standard wallet connection protocol is used — TON Connect. It is similar to WalletConnect on Ethereum, but made specifically for TON and covers basic integration aspects. For deeper integrations, it’s common to utilize various supplementary SDKs and APIs. ​About TON Connect Your browser does not support the <video> tag. TON Connect enables secure communication between wallets and decentralized applications, allowing users to authorize transactions while maintaining control of their private keys. Currently, TON Connect supports over 30 wallets and connects to hundreds of major applications across the TON ecosystem. As the mandatory connection protocol for all Telegram Mini Apps, it serves as the gateway to TON’s entire ecosystem of applications and services. Think of it as the essential infrastructure that your institutional clients will need to access any TON-based services — from DeFi protocols to gaming applications to payment systems. For technical architecture details: TON Connect protocol specification on GitHub. ​Are you building a web3 app? Explore the demo apps made with React. Demo TON dApp with ReactDemo TON dApp GitHub repository Proceed with integration and usage recipes. How to integrate a dApp with TONCommon usage examples Skim the related reference pages. App manifest@tonconnect/sdk@tonconnect/ui@tonconnect/ui-react ​Are you building a web3 wallet? Follow the step-by-step guide. How to make a wallet on TON Or skim the related reference pages. Wallet manifestWalletKit reference@tonconnect/protocol For more, see the TON Connect articles from Google Docs. QA GuideNative or web walletsIn-app or browser extension wallets ​Join the community If you have questions about integrating TON into your project, need help troubleshooting issues, or want to discuss best practices with other developers, join our community channels. Telegram folder with many developer chatsList of skilled professionals and agencies ​See also Technical specification of the TON Connect protocol (GitHub) Official list of wallets that support TON Connect (GitHub) HTTP bridge for TON Connect Was this page helpful?YesNoSuggest editsRaise issuePreviousIntegrate a dAppNext⌘IgithubxtelegramPowered by MintlifyOn this pageAbout TON ConnectAre you building a web3 app?Are you building a web3 wallet?Join the communitySee also",
    "category": "integration",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "dapp",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "react",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:33:06.488Z"
  },
  {
    "id": "docs-ton-org--v3-guidelines-web3-overview",
    "title": "Web3 services",
    "url": "https://docs.ton.org/v3/guidelines/web3/overview",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationBlockchain foundationsWeb3 servicesBlockchain foundationsWeb3 servicesCopy pageCopy pageAlthough many people refer to TON only as a blockchain, The Open Network is a combination of the following components: A flexible multi-blockchain platform with Turing-complete smart contracts (TON Blockchain) A peer-to-peer network used by Blockchain Nodes (TON Network) A distributed file storage technology (TON Storage) A network proxy/anonymizer layer (TON Proxy) A Kademlia-like distributed hash table (TON DHT) A service for assigning human-readable names to accounts, smart contracts, services, and network nodes (TON DNS) A platform for micro-payments (TON Payments) This article provides a general overview of TON Services, beyond the blockchain. ​TON Network TON Network is a peer-to-peer network used for accessing the TON Blockchain, sending transactions, and receiving updates. Also, it can support arbitrary distributed services, blockchain-related or not. The cornerstone in TON networking is the ADNL protocol, built on top of the TCP/UDP stack. The TON Distributed Hash Table (DHT) plays a crucial role in the networking component of the TON Project, as it is used to locate other nodes in the network. You can think of it as a big, persistent key-value data storage. The keys of the TON DHT are simply 256-bit integers. In most cases, they are computed as sha256 hashes of a TL-serialized objects. The values assigned to these 256-bit keys are essentially arbitrary byte strings of limited length. ​TON Storage TON Storage allows users to share and store files using The Open Network. Since storing files on-chain isn’t practical, TON Storage only stores Merkle proofs for file content on-chain. It uses TON DHT to find the nodes that have a copy of a required file (e.g., a snapshot of the state of a shardchain, or an old block). Then, one might essentially create a torrent for this file and use TON DHT as a “distributed torrent tracker” for this torrent. ​TON Proxy TON Proxy provides a protocol where nodes wishing to offer their services (with or without compensation) as tunnels for ADNL network traffic can register. Those needing them can then choose one of these nodes based on the price, latency, and bandwidth offered. Since ADNL traffic is encrypted, Proxy can’t access tunneled data, meaning that this protocol is secure. Running TON Proxy allows you to visit TON Sites (HTTP over ADNL). This can be combined with TON DNS and other TON Services, forming together what is called “Open Network”. ​TON DNS TON DNS is a service that translates human-readable domain names like test.ton or mysite.temp.ton into TON smart contract addresses, ADNL addresses used by services on the TON Network such as TON Sites, and more. The standard is implemented using smart contracts and config parameters. TON Domain names are well-established in the ecosystem - various wallet applications and explorers recognize them. TON Domains can be assigned to any ADNL address, meaning that it is possible to assign names to TON Storage files (bags). ​TON Payments TON Payments platform enables “instant payments” - a way to transfer monetary values without the need to commit all transactions to the blockchain. This protocol is built on top of TON Blockchain, using a system of smart contracts. The core idea for such a “lightning network” is point-to-point payment channels. Two parties create a shared “money pool” and then update the balance inside it. The overall overhead of such instant payments is so small that one can use them for micro-payments. For example, a TON file-storing service might charge the user for every 128 KiB of downloaded data, or a paid TON Proxy might require some tiny micro-payment for every 128 KiB of traffic relayed.Was this page helpful?YesNoSuggest editsRaise issuePreviousOverviewNext⌘IgithubxtelegramPowered by MintlifyOn this pageTON NetworkTON StorageTON ProxyTON DNSTON Payments",
    "category": "how-to",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:33:07.932Z"
  },
  {
    "id": "docs-ton-org--v3-documentation-introduction",
    "title": "Start here",
    "url": "https://docs.ton.org/v3/documentation/introduction",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationStart hereStart hereCopy pageCopy pageThe documentation is organized by layers of detail, with lower-level details appearing later. EcosystemTools and libraries for developing on TON, and how to use them.Payment processingGuides on monitoring and handling blockchain transactions for business applications, such as exchanges.Standard contractsWorking with most popular standardized contracts.Contract developmentGuides on developing smart-contracts.LanguagesReference documentation for TON-specific languages.TON Virtual MachineDescription of the low-level language that runs smart-contracts, and details of the runtime.Blockchain foundationsComprehensive description of the blockchain. Includes web version of whitepapers.ContributeDocumentation on writing this documentation. This is a condensed description of TON. The rest of the documentation may assume that all of this is already known to the reader. TON is a blockchain. It provides a distributed platform for storing data and code, as well as running computations, all the ingredients to host applications. Roughly speaking, it works as if it were a single server executing all the code. The hosted applications are called smart-contracts. The platform runs on a set of servers, called nodes. Most important type of nodes, validators, are owned by individuals or organizations with a large stake in TON and great interest in keeping the platform safe, fair, and operational. Validators have to reach consensus on the state of the blockchain. Typically, the process takes 5 seconds to reach transaction finality, a time to mint a new block. Toncoin is TON’s primary cryptocurrency. It is used to pay for the execution of smart contracts, the storage of their data, and network traffic. Such payments are called fees. There are two instances of TON blockchain: mainnet and testnet. Mainnet is the “real” network. It’s where actual payments in Toncoin are made. Applications use mainnet by default. The other network is testnet, and it is used by TON developers to check that their applications work correctly before deploying them to mainnet. It uses “test coins” that barely have any value. Usually when the TON blockchain gets an update, it is first deployed to testnet, and then to mainnet after a brief period of testing, so sometimes they may run different software. Also their configuration, availability, and throughput might be different. Each network is split into workchains that can freely interact with each other, but their implementations may differ significantly. At the moment, there are two workchains: basechain (workchain_id = 0) for regular use, and a very similar masterchain (workchain_id = -1) for TON’s internal bookkeeping. The masterchain follows mostly the same rules, except that using it is more expensive to limit the amount of traffic that interferes with TON’s internals. To be freely scalable, each workchain is split into shards. The number of shards is determined dynamically based on the current network load. Internally, every shard is implemented as a separate blockchain. Except for increased latency, the effect on the user-facing code is minimal. The nodes that run the blockchain interact via the ADNL protocol. User-facing applications usually use servers that proxy JSON HTTP requests into the ADNL network. The official version of such a proxy server is provided by the liteserver software. There are public instances of liteserver, so developers are not required to host one on their own servers. ADNL works over TCP, so it’s impossible to connect to ADNL from a web page. Browsers intentionally do not provide an API to send arbitrary TCP traffic. Servers do not have this limitation, as they can interact with the blockchain over ADNL, either by raw TCP or by wrapping ADNL through HTTP. It’s easiest to visualize the blockchain as a set of accounts. Each account has an address and a status. Over its lifetime, an account changes its status among four values: nonexist: There wasn’t a single operation with the account, or it was removed. It has neither a balance, nor code. uninit: If some Toncoin is transferred to an account, it now exists, but there is still no smart contract code on it. It now has a balance. active: After a deploy message (see below) with code and initial data is sent to an account, it becomes active and can process other messages. It now has a balance, code, and internal state. frozen: If an account is overdue on its storage fees, it will be frozen until the fees are paid. If the overdue amount reaches a maximum limit specified by the blockchain, the account goes completely bankrupt, is removed, and ceases to exist. The code on an active account is a smart contract. The term contract is often used for an account that holds the code. The internal address of an account is a pair of two numbers: its workchain ID and a 256-bit number. It may be displayed in the raw format (e.g., 0:4098805d2272a61b375350c6b2f5faaaf27c8267d8e7521ff2045104fdc7de76), but is usually shown in a user-friendly format (e.g., UQBKgXCNLPexWhs2L79kiARR1phGH1LwXxRbNsCFF9doczSI). Addresses specify where messages should be delivered. There are three types of messages: internal messages are sent between accounts; incoming external messages are sent from code outside the blockchain to a contract; outgoing external messages are broadcast to the external network; somewhat similar to adding them into the globally available list of all outgoing external messages that ever happened. Every internal message should have some Toncoin attached to it so that it can pay for the cost of handling it. External messages cannot have Toncoin attached to them because they spend some of their time outside the blockchain, and only the blockchain can prove the transfer of Toncoin is correct. Incoming external messages come from an external address, and outgoing external messages go to an external address. The state of the account changes only when it handles messages. Messages also change the account’s balance. Usually, to have a state and a balance, and to handle messages, the account must be active. Formally, a message is only an intent: it has a destination, possibly some Toncoin, and data. After the message is handled and all the necessary changes are applied to the blockchain, the message is packed, along with a description of those changes, into a single packet of data, called a transaction. A transaction records the state changes on an account. Some transactions might happen without any message. A message might also be a deploy message if it has a StateInit structure attached with its initial code and data. When such a message is sent, the hash of StateInit must match the destination address. If it does, the code and data are stored in the account at that address, and the account becomes active. Both the code and data stored in the account may change in the future, but its address will remain the same as when it was originally deployed. Internal and incoming external messages execute the account’s code. The code is interpreted by TON Virtual Machine (TVM). It is written in bitcode, a binary format specific to TVM. In the future, TVM might support multiple binary languages, codepages, but at the moment there is only codepage 0 (CP0). Most development is done in the Tolk, a high-level programming language. Its compiler is included in the Blueprint development environment and will be available to all projects created from the template. Originally, Fift, a Forth-like assembly language, and FunC, a C-like intermediate-level language, were used for contract development. When execution starts, the message and current account state are provided to the code. By the end of execution, the account might change its state or code, or send internal or outgoing external messages. The execution follows a process whose steps are called phases. Fees are deducted during this process. Fees might be deducted from the account’s balance or from the Toncoin the message carries, depending on the mode of the message, or by explicit choice made in the contract’s code. Execution cost is first measured in gas units, then converted to Toncoin. This unit is separate so that if code execution becomes computationally cheaper (or more expensive), validators can vote to change the price of gas in Toncoin. If something goes wrong, a non-zero exit code might be returned, no changes to state or code are saved, and no further messages are sent. If the message that resulted in a failed transaction is marked as bounceable, a bounce message is sent back to the sender. Bounce messages are used to inform the sender that handling of their message failed. They can carry either truncated or full body of the original message. The most common reason a code is executed is when some account has received a mes",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "testnet",
      "mainnet",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:33:11.369Z"
  },
  {
    "id": "docs-ton-org--v3-documentation-smart-contracts-overview",
    "title": "Your first smart contract",
    "url": "https://docs.ton.org/v3/documentation/smart-contracts/overview",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationContract developmentYour first smart contractContract developmentYour first smart contractCopy pageCopy pageWelcome to your journey into TON smart contract development! In this comprehensive tutorial, you’ll learn to build, deploy, and interact with a smart contract from scratch. ​What you’ll learn By the end of this tutorial, you’ll have: ✅ Built a complete smart contract in Tolk ✅ Deployed it to TON testnet ✅ Interacted with it using TypeScript scripts ✅ Mastered the fundamentals of TON development ​What is a TON smart contract? ​Understanding the basics A smart contract is a computer program stored on TON Blockchain — a distributed database that many computers maintain together. It runs on the TVM (TON Virtual Machine) — the “computer” that runs smart contract code on TON. The contract is made of two parts: Code (compiled TVM instructions) - the “rules” or “program logic” Data (persistent state) - the “memory” that remembers things between interactions Both are stored at a specific address on TON Blockchain, a unique identifier for each smart contract. ​Prerequisites Basic programming - Understanding of variables, functions, if/else statements Command line basics - Comfortable opening terminal and running commands Node.js (v22 or later) — Download here Check if installed: node -v in terminal TON wallet ​Tutorial overview This tutorial is organized into six clear steps that build upon each other: StepWhat You’ll DoKey SkillsStep 1Set up Blueprint toolkitProject structure, development environmentStep 2Learn contract architectureStorage, messages, getters conceptStep 3Write contract in TolkProgramming, message handling, data structuresStep 4Compile to bytecodeBuild process, TVM compilationStep 5Deploy to blockchainTestnet deployment, wallet integrationStep 6Interact with contractMessage sending, get methods, TypeScript integration Let’s dive into development! ​Step 1: Development environment setup We’ll use Blueprint as our development toolkit for smart contracts. Start a new project with: CopyAsk AInpm create ton@latest -- Example --contractName FirstContract --type tolk-empty This will create a project Example with a contract FirstContract. The project structure will look like this: CopyAsk AIExample/ ├── contracts/ # Smart contract source code │ └── first_contract.tolk # Main contract file ├── scripts/ # Deployment and on-chain interaction scripts │ └── deployFirstContract.ts # Script to deploy the contract ├── tests/ # Testing specifications │ └── FirstContract.spec.ts # Contract test file └── wrappers/ # TypeScript wrappers for contract interaction ├── FirstContract.ts # Wrapper class for the smart contract └── FirstContract.compile.ts # Configuration for compiling contract TON provides plugins that add syntax support for various IDEs and code editors. Check out the IDE & plugins section for VS Code and JetBrains support. Now, move into the project directory: CopyAsk AIcd Example ​Step 2: Understanding smart contract architecture Every smart contract in TON is typically divided into three sections: storage, messages, and getters. Storage: Defines the contract’s persistent data. For example, our counter variable must keep its value across calls from different users. Messages: Define how the contract reacts to incoming messages. On TON, the primary way to interact with contracts is by sending messages. Each processed message produces a transaction — a recorded change on the blockchain (like “Alice sent 5 TON to Bob”). Getters: Provide read-only access to contract data without modifying state. For example, we’ll create a getter to return the current value of the counter. Due to the TON architecture, getters cannot be called from other contracts. Inter-contract communication is possible only through messages. ​Step 3: Writing the smart contract We’ll build a simple counter contract: The counter starts from an initial number. Users can send an increase message to increment it, or a reset message to drop it to zero. A getter function will let anyone query the current counter value. We’ll use Tolk to implement this. Tolk looks familiar if you know TypeScript or Rust, but it’s designed specifically for smart contract development. ​3.1 Defining contract storage First, we need a way to store the counter value. Tolk makes this simple with structures: ./contracts/first_contract.tolkCopyAsk AIstruct Storage { counter: uint64 // the current counter value } // load contract data from persistent storage fun Storage.load() { return Storage.fromCell(contract.getData()) } // save contract data to persistent storage fun Storage.save(self) { contract.setData(self.toCell()) } Behind the scenes, structures know how to serialize and deserialize themselves into cells — the fundamental way TON stores data. This happens through the fromCell and toCell functions - Tolk automatically converts between your nice structures and the cell format that TON understands. You may think of cells like containers that hold data on TON: Each cell can store up to 1023 bits of data. Cells can reference other cells (like links). Everything on TON (contracts, messages, storage) is made of cells. Now that we can store data, let’s handle our first messages. ​3.2 Implementing message handlers The main entry point for processing messages in a Tolk contract is the onInternalMessage function. It receives one argument — the incoming message. Among its fields, the most important one for us is body, which contains the payload sent by a user or another contract. Tolk structures are also useful for defining message bodies. In our case, we’ll define two messages: IncreaseCounter — with one field increaseBy, used to increment the counter. ResetCounter — used to reset the counter to zero. Each structure has a unique prefix (0x7e8764ef and 0x3a752f06), widely called opcodes, that lets the contract distinguish between them. ./contracts/first_contract.tolkCopyAsk AIstruct (0x7e8764ef) IncreaseCounter { increaseBy: uint32 } struct (0x3a752f06) ResetCounter {} To group them together, we’ll use a union. Unions allow multiple types to be bundled into a single type that can be serialized and deserialized automatically: ./contracts/first_contract.tolkCopyAsk AItype AllowedMessage = IncreaseCounter | ResetCounter Now we can write our message handler: ./contracts/first_contract.tolkCopyAsk AIfun onInternalMessage(in: InMessage) { // use `lazy` to defer parsing until fields are accessed val msg = lazy AllowedMessage.fromSlice(in.body); // matching our union to determine body structure match (msg) { IncreaseCounter => { // load contract storage lazily (efficient for large or partial reads/updates) var storage = lazy Storage.load(); storage.counter += msg.increaseBy; storage.save(); } ResetCounter => { var storage = lazy Storage.load(); storage.counter = 0; storage.save(); } // this match branch would be executed if the message body does not match IncreaseCounter or ResetCounter structures else => { // reject user message (throw) if body is not empty assert(in.body.isEmpty()) throw 0xFFFF } } } Tolk Language Guide - Complete language documentation View the complete contract on GitHub ​3.3 Adding getter functions Finally, let’s implement a getter so users can read the current counter value: ./contracts/first_contract.tolkCopyAsk AIget fun currentCounter(): int { val storage = lazy Storage.load(); return storage.counter; } ​3.4 Complete contract code We now have a complete smart contract with: Storage: persistent counter value Messages: IncreaseCounter and ResetCounter handlers Getter: currentCounter Here’s the full source code of contracts/first_contract.tolk: ./contracts/first_contract.tolkCopyAsk AIstruct Storage { counter: uint64 } fun Storage.load() { return Storage.fromCell(contract.getData()); } fun Storage.save(self) { contract.setData(self.toCell()); } struct (0x7e8764ef) IncreaseCounter { increaseBy: uint32 } struct (0x3a752f06) ResetCounter {} type AllowedMessage = IncreaseCounter | ResetCounter fun onInternalMessage(in: InMessage) { val msg = lazy AllowedMessage.fromSlice(in.body); match (msg) { IncreaseCounter => { var storage = lazy Storage.load(); storage.counter += msg.increaseBy; storage.save(); } ResetCounter => { var storage = lazy Storage.load(); storage.counter = 0; storage.save(); } else => { assert(in.body.isEmpty()) throw 0xFFFF; } } } get fun currentCounter(): int { val storage = lazy Storage.load(); return storage.counter; } See all 47 lines 🎉 Congratulations — you’ve built your first smart contract in Tolk! You can find the full working code for this tutorial in our GitHub repository. This includes all contract files, scripts, and wrappers ready to use. ​Step 4: Compiling your contract The next step is to build our contract — compile it into bytecode that can be executed by the TVM. With Blueprint, th",
    "category": "smart-contracts",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "testnet",
      "mainnet",
      "transaction",
      "deployment",
      "testing",
      "tutorial",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "react",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:33:13.563Z"
  },
  {
    "id": "docs-ton-org--v3-documentation-dapps-dapps-overview",
    "title": "Welcome toTON Blockchaindocumentation",
    "url": "https://docs.ton.org/v3/documentation/dapps/dapps-overview",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationWelcome to TON Blockchain documentationWelcome toTON BlockchaindocumentationMeet the AI-native, beautiful and comprehensive documentation covering foundations, tools, languages, and APIs.Learn TON in Y minutesOr choose a path →Choose your pathEmbark on a journey tailored to your role, experience, and intent.FreshmanLearn the fundamentals of TON Blockchain. Perfectly suited for newcomers who explore the web3 world through TON.How to read this documentation?Start hereWhat is blockchain?What is a smart contract on TON?Writing your first smart contractNomadFor those coming from another blockchain. Study how things work on TON in comparison and go through hands-on guides for migration.Coming from EthereumCompare the execution model and the ecosystem of TONYour first smart contractWrite and deploy a contract that can be interacted withAceFor amateurs, experts, and learners alike. Take a deep dive into the low-level details, or do a quick reference check and return to your project.BlueprintDevelopment environmentTVM Exit codesComplete list of compute phase exit codesTVM InstructionsComplete list of instructions and opcodesAPI providersTON Center v2 and v3, and othersTON ConnectIntegrate TON into dApps and walletsBlockchain nodesPick the right kind and setup your nodeLooking for something else? Search documentation with Ctrl + K and ask AI right there, or open the assistant panel by pressing Ctrl + I. If nothing was found, ask the community of TON developers, builders and enthusiasts.Join the communityTroubleshoot issues or discuss best practices with other community members.Get supportLearn how to get help on the dedicated pageTelegramAdd the folder with many developer chatsTON TalentsSeek skilled professionals and agencies⌘I",
    "category": "dapps",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "dapp",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:33:18.553Z"
  },
  {
    "id": "docs-ton-org--v3-documentation-nodes-overview",
    "title": "Overview",
    "url": "https://docs.ton.org/v3/documentation/nodes/overview",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeOverviewRun a node with MyTonCtrlRun a validatorIntegrate MyTonCtrl with PrometheusSetting up a local blockchain using MyLocalTonMyTonCtrl referenceStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationBlockchain nodeOverviewEcosystemBlockchain nodeOverviewCopy pagePick the right TON node setup and understand the operational work it requires.Copy pageA full node is a software that stores the whole blockchain state locally, opposite to lite-clients, which request small pieces of data from liteservers when needed. It does not solve any problem itself, but provides a base for other services requiring a full blockchain state (validator, liteserver, etc). Usually, full nodes keep only the latest part of the blockchain state, which is vital for ensuring client applications’ network stability and operation. Full nodes prune the state of the TON blockchain they keep. This means the full node automatically removes earlier blocks that become unnecessary for the network to manage its data volume effectively. To allow client applications to look for blocks and transactions and send new transactions into the TON blockchain, full nodes are equipped with the liteserver functionality. A full node can be set up using mytonctrl tool, which also activates validator or liteserver mode for you. ​Full node modes RoleWhat it doesWhen to use itLiteserverStores the latest shards, tracks the masterchain, and serves data to lite-clients.Required for custom infrastructure, analytics, or to back your own APIs.Archive liteserverStores all blockchain data, including old blocks and states.Required for explorers and other services working with historical data.ValidatorSigns blocks, participates in elections, and earns rewards.Needed to run validation with your stake or to operate a nominator pool service.CollatorProduces blocks for validators.Needed to reduce load on your validators by setting up block creation on a separate machine.Nominator poolAccepts funds from stakers and runs a validator with their stake.Needed when you want to securely accept stakes from multiple parties and share rewards between them.Single nominatorSecure way to run a validator without depositing all funds to a hot wallet.Generally, you should use it each time you want to run a new validator.Liquid stakingSame as nominator pool, but exchanges stakers’ funds for a synthetic token to be used in DeFi.Needed to run a liquid staking protocol. ​Do you need your own node? Run your own full node when you need guaranteed uptime or to serve high-volume workloads without third-party rate limits. Validators and staking services need to install a node and activate validator mode. Rely on public endpoints when building prototypes or light integrations. Community liteservers and APIs such as TON Center or other RPC providers already expose the blockchain for read access and transaction submission. ​Pick your target environment If you needRunValidator or nominator capacitySetting up a node using MyTonCtrl with the validator, nominator pool, or single nominator workflows; the wrapper automates validator wallets, overlays, elections, and upgrades.Liteserver APIsSetting up a node using MyTonCtrl with liteserver option (and archive mode if needed) to expose API for applications.An isolated development networkSetting up a local blockchain using MyLocalTon to spin up a local shard, explorer, and APIs for rapid iterations with no mainnet impact. ​Full node The full node is a basic node type within the TON blockchain. It serves as the backbone of the TON blockchain by keeping its block history — in other words, its current state. Compared to archive nodes, full nodes keep only the latest part of the blockchain state, which is vital for ensuring client applications’ network stability and operation. Full nodes prune the state of the TON blockchain they keep. This means the full node automatically removes earlier blocks that become unnecessary for the network to manage its data volume effectively. To allow client applications to look for blocks and transactions and send new transactions into the TON blockchain, full nodes are equipped with the liteserver functionality. ​Archive node The archive node is a full node that keeps the entire block history of the TON blockchain. These nodes act as the decentralized point of truth to ensure consistency of the whole blockchain history. They are a backend for blockchain explorers and other applications relying on deep transaction history. Archive nodes do not prune the blockchain state, elevating system requirements, especially in storage. According to the latest estimations, while full and validator nodes require about 1 TB of disk space, archive nodes need about 12 TB to store the complete block history. ​Validator node Validator nodes or validators are the TON network participants who propose new blocks and verify transactions according to the TON’s proof-of-stake mechanism. In this way, validators contribute to the overall blockchain security. Validators get rewards in TON for successful participation in the validation process. To be entitled to propose and validate blocks, other participants elect validators based on the amount of TON they hold — in other words, their stake. The more TON a validator stakes, the higher its chances of being elected, validating blocks for the network, and earning rewards. As a rule, validator operators motivate other TON holders to stake with them to get passive income from the resulting rewards. In this way, validators ensure network stability and security and contribute to its growth. ​Interacting with TON nodes TON nodes can run in liteserver mode, which allows external applications to interact with the TON blockchain. In this mode, the nodes process requests from clients, enabling them to access blockchain data, send transactions, and retrieve information about blocks and transactions. Liteserver uses the Abstract Datagram Network Layer (ADNL) protocol, so you generally also use ton-http-api (a TON Center-like API), which acts as an HTTP-to-ADNL frontend and exposes an HTTP API. Full and archive nodes typically enable liteserver mode because they store blockchain history and handle external requests. In contrast, validator nodes do not need it as they focus on validating new blocks efficiently without extra workload from external queries. You have two options to allow your application to interact with the TON blockchain: To have a stable connection, you can set up your own full or archive node with a liteserver mode and ton-http-api enabled using MyTonCtrl. If you cannot set up your TON node with a liteserver, you can use TON Center or other RPC providers. Was this page helpful?YesNoSuggest editsRaise issuePreviousRun a node with MyTonCtrlProvision hardware, install MyTonCtrl, and follow runbooks for validator, liteserver, or archive roles.Next⌘IgithubxtelegramPowered by MintlifyOn this pageFull node modesDo you need your own node?Pick your target environmentFull nodeArchive nodeValidator nodeInteracting with TON nodes",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "frontend",
      "backend",
      "api",
      "sdk",
      "mainnet",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:33:21.517Z"
  },
  {
    "id": "docs-ton-org--v3-documentation-network-protocols-adnl-overview",
    "title": "Overview",
    "url": "https://docs.ton.org/v3/documentation/network/protocols/adnl/overview",
    "content": "Skip to main contentDeprecated! Please, visit the new documentation at docs.ton.org Deprecated, go to new docs!On this pageOverview The Abstract Datagram Network Layer (ADNL) is a fundamental component of TON. ADNL is a peer-to-peer, unreliable datagram protocol in the TON networking stack. ADNL operates over UDP and TCP. ADNL address​ Each participant in the network possesses a 256-bit ADNL address. The ADNL protocol enables the sending and receiving of datagrams using only ADNL addresses, concealing the underlying IP addresses and ports. An ADNL address is a 256‑bit identifier derived as SHA‑256(type_id || public_key), where type_id is a little‑endian uint32 indicating the key type — that is, the SHA‑256 of the TL‑serialized key object. The corresponding private key must be known to receive and decrypt messages intended for a specific address. Encryption and security​ ADNL packets can be signed and encrypted; when signatures are present, recipients verify integrity and authenticity. Neighbor tables​ A TON ADNL node will typically maintain a neighbor table that contains information about other known nodes, including their abstract addresses, public keys, IP addresses, and UDP ports. Over time, this table is updated: new entries are discovered from responses to specific queries, and outdated records are removed. Higher-level protocols such as RLDP operate over ADNL. See also​ Implementation What's next​ To learn more about ADNL, refer to the Low-level ADNL documentation. See the TON Whitepaper. Was this article useful?YesNoEdit this pageLast updated on Sep 18, 2025 by aigerimuADNL addressEncryption and securityNeighbor tablesSee alsoWhat's nextUseGet a WalletGet ToncoinStakeAccept PaymentsApps & ServicesDomainsUSDT on TONCross-Chain BridgesLearnTON ConceptDecentralized NetworkRoadmapTonStatHistory of MiningToncoinValidatorsWhite PaperBrand AssetsSustainabilityFor BuildersTON Builders PortalGetting StartedDocumentationTelegram Mini AppsDev ChatsBug BountyFind a JobFind a TalentUse CasesGameFiMemecoins & TokensCommunity ToolsTON SitesCommunityCommunitiesBlogCareers",
    "category": "general",
    "tags": [
      "ton",
      "wallet",
      "telegram",
      "mini app",
      "builder",
      "address",
      "message",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:33:23.249Z"
  },
  {
    "id": "docs-ton-org--v3-documentation-data-formats-tlb-overview",
    "title": "Overview",
    "url": "https://docs.ton.org/v3/documentation/data-formats/tlb/overview",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BOverviewSyntax and SemanticsSimple examplesComplex and non-trivial examplesTEP examplesToolingFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationTL-BOverviewLanguagesTL-BOverviewCopy pageCopy pageThe Type Language Binary (TL-B) for TON Blockchain is a domain-specific language designed to describe the structure of data in the TON Blockchain. It is used to define how data is serialized and deserialized, ensuring consistency and interoperability across different components of the TON ecosystem. Special TL-B parsers can read schemes to deserialize binary data into different objects. In fact, TL-B is a variant of the original Type Language (TL) developed for the Telegram Messenger and adapted to the specific needs of the TON Blockchain. It is recommended to start by studying the syntax and semantics of TL-B, simultaneously exploring each example through a convenient TL-B online editor. To further your understanding, we recommend referring to the page that describes the most complex examples of TL-B schemes.Was this page helpful?YesNoSuggest editsRaise issuePreviousSyntax and SemanticsNext⌘IgithubxtelegramPowered by Mintlify",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:33:25.817Z"
  },
  {
    "id": "docs-ton-org--v3-documentation-tvm-overview",
    "title": "Overview",
    "url": "https://docs.ton.org/v3/documentation/tvm/overview",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationTVM: TON Virtual MachineOverviewTVM: TON Virtual MachineOverviewCopy pageCopy pageTON Virtual Machine (TVM) is a stack-based virtual machine which executes smart contracts on TON blockchain. TVM is invoked when a message is sent to an account that has deployed contract code, when a get method is called on an account, and in some more rare cases. Executing code on same inputs and prior state deterministically produces same outputs, so that validators can agree on whether code was executed correctly. Every instruction consumes gas. Gas exhaustion stops execution. This limit is imposed so that expensive computations (i.e. infinite loops) cannot be used to exhaust validators’ computation resources, causing denial of service. ​Data model TVM has no random-access memory. Instead it uses a stack of values as a scratchpad. There are no memory addresses. Most instructions either store their parameters directly in the code, or take them from the top of the stack. All values are immutable. Most of the data is stored as immutable tree of cells. Reading and writing of cells is done with slices and builders. There are no function addresses or function pointers. Code is executed from bitcode inside continuations. ​TVM state On incoming messages or get method call, a new instance of TVM is started, with a new state. Derivation of the initial state from the message is described in its own article. The total state of TVM consists of the following components: Stack. A regular stack data structure. The vast majority of instructions pop() operands from the top and push() results back. Control registers. A small fixed set of special registers, denoted as c0, c1, …, c5, and c7 (c6 does not exist). Gas counter. Tracks remaining computation budget. Each instruction decrements gas. When counter hits zero/negative value, an exception is raised, and the run aborts. Current continuation (cc). A special register that stores a list of the next instructions to execute. Similar to the instruction pointer in traditional architectures. Current codepage (cp). Determines how to decode the next instruction in cc. Different codepages may implement different instruction sets, allowing for adding new features to TVM without affecting old smart contracts. Currently, only codepage 0 (cp0) is implemented. Smart contract runs SETCP0 instruction to explicitly use codepage 0. ​TVM data types Values on the stack and inside of registers are of one of the following seven types: TypeDescriptionInteger257-bit signed integer. Has the special NaN value representing arithmetic faults.CellNode of a tree with bit string on it (<= 1023 bits), and up to 4 arrows (refs).SliceRead cursor over a Cell.BuilderWrite cursor to construct a new Cell.TupleList of 0..255 elements of any of seven types. Types of elements can be distinct.ContinuationExecutable Slice with TVM bitcode. Continuations are callable like functions.NullEmpty value. ​Example of a smart contract: counter Here is a sample contract, written in Fift. It implements the following logic: If an event is not an internal message, stop execution. Read 32-bit number (msg_counter) from internal message’s body. Check that it is equal to the 32-bit number stored in c4 (persistent account storage). Increment it. Save it back to c4. When an account with this code gets an internal message, TVM stack is initialized with these values: s0 (top of the stack), function selector, is 0. For other events, e.g., external messages or get method calls, selector will be non-zero. s1, message body. The example contract expects exactly 32 bits here. Three more values s2, s3, s4 are pushed by TVM onto a stack. They won’t be used in the example. After execution finishes, they’ll still be on the stack, and will be silently ignored. In Current stack comments, we represent stack at that moment of execution, keeping its top to the right (e.g., s2 s1 s0, where s0 is the top of the stack). FiftCopyAsk AI<{ // Current stack: msg_body selector // Use codepage 0. Picks the only available instruction set. SETCP0 // This instruction does not affect the stack. // Current stack: msg_body selector // Consume `selector` from the top of the stack. // Stop execution if `selector != 0`, // i.e. \"is not an internal message\". IFRET // Continue execution if we received an internal message. // Current stack: msg_body // Load (LD) unsigned (U) 32-bit integer from a slice. // This instruction pops (consumes) a slice from the stack, // pushes an integer, and then pushes a new slice with // 32 bits cut from it 32 LDU // Current stack: msg_counter msg_body' // msg_body' is a slice whose read cursor was moved by 32 bits // when we loaded a 32-bit integer. // For example, if we had slice x{00000001} on the stack and // then invoked 32 LDU, there will be integer `1` and `x{}` // (empty slice) on the stack // Assert the END of a slice (S). // These instructions consume a slice and check that it is // empty (no more data to read), otherwise it throws an // exception, because there was more data than we expected. ENDS // Current stack: msg_counter // Push c4 (persistent storage) on the stack. // `storage` is a cell c4 PUSH // Current stack: msg_counter storage // Convert Cell to a Slice, i.e. make it readable CTOS // Current stack: msg_counter storage_slice // Read 32-bit unsigned integer from `storage_slice` 32 LDU // Current stack: msg_counter storage_counter storage_slice' // Assert there is no more data in the storage ENDS // Current stack: msg_counter storage_counter // Duplicate s0 (top of stack) under two top values TUCK // Current stack: storage_counter msg_counter storage_counter // Check counters are equal EQUAL // Current stack: storage_counter msg_counter==storage_counter? // Throw an exception with code 33 if it is not equal 33 THROWIFNOT // Current stack: storage_counter // Increase counter INC // Current stack: storage_counter+1 // Create an empty Builder NEWC // Current stack: storage_counter+1 builder // Store (ST) unsigned (U) 32-bit integer `storage_counter+1` to a builder 32 STU // Current stack: builder' // Finalize Builder to a Cell ENDC // Current stack: new_storage // Save `new_storage` to c4 (persistent storage) c4 POP // Current stack: (no values) }> Was this page helpful?YesNoSuggest editsRaise issuePreviousTxTracerNext⌘IgithubxtelegramPowered by MintlifyOn this pageData modelTVM stateTVM data typesExample of a smart contract: counter",
    "category": "infrastructure",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:33:28.468Z"
  },
  {
    "id": "docs-ton-org--v3-documentation-whitepapers-overview",
    "title": "Overview",
    "url": "https://docs.ton.org/v3/documentation/whitepapers/overview",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersOverviewTVMTON BlockchainThe Open NetworkCatchain consensusGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationWhitepapersOverviewBlockchain foundationsWhitepapersOverviewCopy pageCopy pageThe original TON documentation was written by Dr. Nikolai Durov and comprises a series of whitepapers. They provided a comprehensive overview of all aspects of TON. While most of the information described in the original PDFs holds some truth, those whitepapers are considered legacy due to a lack of updates and gradual integration of their contents into actual documentation pages. Notice that “legacy” here does not mean “outdated”, but rather less kept up to date compared to the regular pages. Only an English PDF version of whitepapers is considered “official.” English HTML version is provided by documentation team. The rest are community translations. The code, comments, and documentation may reference “gram” and “nanogram”. These are remnants of the original TON code developed by Telegram. Gram cryptocurrency was never issued. The official currency of TON is Toncoin. WhitepaperPDFHTMLThe Open Network (TON)EN RU ZH ZHEN RUTON Virtual Machine (TVM)EN RU ZHEN RUTON BlockchainEN RU ZHEN RUCatchain consensusEN RU ZHEN RUFift language specificationEN RU ZHENWas this page helpful?YesNoSuggest editsRaise issuePreviousTVMWhitepaper by Dr. Nikolai DurovNext⌘IgithubxtelegramPowered by Mintlify",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:33:31.267Z"
  },
  {
    "id": "docs-ton-org--v3-contribute",
    "title": "How to contribute",
    "url": "https://docs.ton.org/v3/contribute",
    "content": "Skip to main contentDeprecated! Please, visit the new documentation at docs.ton.org Deprecated, go to new docs!On this pageHow to contribute infoLearn how to submit content to TON Documentation here. Contribution guidelines​ Documentation maintainer community​ TON Documentation is entirely open source. Community enthusiasts and early TON contributors have played a key role in creating this open source TON documentation by turning their notes into detailed pages. It was initially written by TON contributors and supported by TON Studio. We aim to educate users about TON through explicit, easily searchable content that appeals to technical experts and casual readers. How to contribute​ Clone the current version from the ton-docs GitHub repository. Choose an area to contribute according to the Style guide and open a related issue. Familiarize yourself with Content standardization and Typography. Before submitting your pull request, complete and verify each milestone in the description checklist. Open a pull request against the main branch with a clear description and concise updates according to the template. Pull request template​ ## DescriptionBrief description of the changes introduced in this pull request. Include any relevant issue numbers or links.Closes [link to issue].## Checklist- [ ] I have created an issue.- [ ] I am working on content that aligns with the [Style guide](https://docs.ton.org/v3/contribute/style-guide/).- [ ] I have reviewed and formatted the content according to [Content standardization](https://docs.ton.org/v3/contribute/content-standardization/).- [ ] I have reviewed and formatted the text in the article according to [Typography](https://docs.ton.org/v3/contribute/typography/). infoTo avoid excessive rework, read the contribution guidelines in the Style guide, Content standardization, and Typography before contributing. Don't worry about minor issues; maintainers will help you fix them during the review process. Development​ Learn the documentation development flow from the ton-docs/README.md document. Best practices for pull requests​ Keep your pull request small. Minor pull requests (~300 lines of diff) are easier to review and more likely to get merged. Make sure the pull request does only one thing; otherwise, please split it. Use descriptive titles. It would be best to follow the commit message style. Build locally and ensure it succeeds without crashes. Use soft wrap: Don't wrap lines at 80 characters; configure your editor to soft wrap. Communicate with other developers​ Get familiar with frequently asked questions in the TON Developers chat. Ask questions related to TON documentation in the TON Docs Club chat in Telegram. Create an issue with your ideas for improvements. Find and take available bounties for the documentation. See ton-docs on GitHub. See also​ Style guide Typography Edit this pageLast updated on Sep 5, 2025 by AlexGContribution guidelinesDocumentation maintainer communityHow to contributeDevelopmentCommunicate with other developersSee alsoUseGet a WalletGet ToncoinStakeAccept PaymentsApps & ServicesDomainsUSDT on TONCross-Chain BridgesLearnTON ConceptDecentralized NetworkRoadmapTonStatHistory of MiningToncoinValidatorsWhite PaperBrand AssetsSustainabilityFor BuildersTON Builders PortalGetting StartedDocumentationTelegram Mini AppsDev ChatsBug BountyFind a JobFind a TalentUse CasesGameFiMemecoins & TokensCommunity ToolsTON SitesCommunityCommunitiesBlogCareers",
    "category": "general",
    "tags": [
      "ton",
      "wallet",
      "telegram",
      "mini app",
      "guide",
      "builder",
      "message",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:33:34.830Z"
  },
  {
    "id": "docs-ton-org--ecosystem-oracles-redstone",
    "title": "RedStone oracle",
    "url": "https://docs.ton.org/ecosystem/oracles/redstone",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesOverviewRedStone oraclePyth oracleBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationOraclesRedStone oracleEcosystemOraclesRedStone oracleCopy pageCopy page​How to use real-time data in TON contracts RedStone is a pull oracle that uses an alternative design for providing oracle data to smart contracts. Instead of constantly persisting data on the contract’s storage, the information is brought on-chain only when needed by end users. Until that moment, data remains in the decentralized cache layer, powered by RedStone light cache gateways and a stream-based data broadcasting protocol. Data is transferred to the contract by end users, who attach signed data packages to their function invocations. The information integrity is verified on-chain through signature checking. ​Install the RedStone SDK Install the RedStone TON connector and other necessary dependencies: CopyAsk AInpm install @redstone-finance/ton-connector @redstone-finance/sdk ​Write code to interact with oracle ​Off-chain data fetch and update The following code snippet demonstrates how to fetch price updates and interact with RedStone contracts on TON: CopyAsk AIimport { TonPricesContractConnector } from \"@redstone-finance/ton-connector\"; import { ContractParamsProvider, getSignersForDataServiceId } from \"@redstone-finance/sdk\"; async function main() { // Configure API endpoint const apiV2Config = { apiEndpoint: \"https://testnet.toncenter.com/api/v2/jsonRPC\", apiKey: \"your-api-key-here\", // Get your TON Center API key }; // Initialize the connector const contractAddress = \"EQCMxfukwpP3BI_6Pn3lmOXgxlp3dPabVGOM0UvJCjsDhkdD\"; const prices = new TonPricesContractConnector(network, contractAddress); // Configure RedStone data service parameters const paramsProvider = new ContractParamsProvider({ dataServiceId: \"redstone-main-demo\", uniqueSignersCount: 1, dataPackagesIds: [\"ETH\", \"BTC\"], authorizedSigners: getSignersForDataServiceId(\"redstone-main-demo\"), }); // Get prices using on-the-fly processing (doesn't modify contract state) const pricesFromPayload = await (await prices.getAdapter()).getPricesFromPayload(paramsProvider); console.log(\"ETH and BTC prices from payload:\", pricesFromPayload); // Write prices to contract storage (modifies contract state) await (await prices.getAdapter()).writePricesFromPayloadToContract(paramsProvider); console.log(\"Prices written to contract storage successfully.\"); // Read prices from contract storage const storedPrices = await (await prices.getAdapter()).readPricesFromContract(paramsProvider); console.log(\"Stored prices:\", storedPrices); // Get timestamp of last update const lastUpdateTimestamp = await (await prices.getAdapter()).readTimestampFromContract(); console.log(\"Last update timestamp:\", lastUpdateTimestamp); } main().catch(console.error); This code snippet does the following: Imports the TonPricesContractConnector and sets up the RedStone SDK. Configures the API endpoint and creates a connector to your deployed contract. Sets up a ContractParamsProvider with the data service ID and feed identifiers. Fetches price data using on-the-fly processing (no gas cost). Writes price data to the contract’s storage (requires gas). Reads stored prices and the last update timestamp from the contract. ​Contract types RedStone provides several contract types for different use cases: ​Price Manager Manages multiple price feeds with signature verification and supports both on-the-fly processing and storage persistence. ​Single Feed Manager Simplified version for handling a single price feed, reducing gas costs for single-feed applications. ​Price Feed An individual feed contract that stores price data for a specific asset. ​Sample Consumer Example consumer contract that demonstrates how to read data from price feeds. ​Error handling Common error codes you might encounter: 300+: Insufficient valid signers (less than signer_count_threshold) 200+: Timestamp validation failed (data too old or in the future) Other codes: See RedStone constants ​Additional resources You may find these additional resources helpful for developing your TON application: RedStone documentation RedStone TON connector RedStone smart contracts RedStone showroom Was this page helpful?YesNoSuggest editsRaise issuePreviousPyth oracleNext⌘IgithubxtelegramPowered by MintlifyOn this pageHow to use real-time data in TON contractsInstall the RedStone SDKWrite code to interact with oracleOff-chain data fetch and updateContract typesPrice ManagerSingle Feed ManagerPrice FeedSample ConsumerError handlingAdditional resources",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "testnet",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:33:36.839Z"
  },
  {
    "id": "docs-ton-org--standard-wallets-highload-v3-specification",
    "title": "Highload Wallet v3 — specification",
    "url": "https://docs.ton.org/standard/wallets/highload/v3/specification",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsHow they workMnemonicsComparisonPerformance benchmarkHow to interactHistoryV4V5Highload WalletsOverviewHighload Wallet v3How to create Highload Wallet v3How to send a single transferHow to send a batch of transfersHow to verify message is processedSpecificationHighload Wallet v2Lockup walletPreprocessed Wallet V2Restricted walletTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationHighload Wallet v3Highload Wallet v3 — specificationStandard contractsWalletsHighload WalletsHighload Wallet v3Highload Wallet v3 — specificationCopy pageCopy pageThis page provides a complete technical specification for Highload Wallet v3, covering storage structure, message formats, replay protection, limitations, and security mechanisms. ​Objective Understand the internal architecture, data structures, and operational mechanics of Highload Wallet v3. This reference page explains how the wallet processes high-throughput transaction flows securely. For practical usage, see How-to guides. ​What is Highload Wallet v3? Highload Wallet v3 is a specialized wallet smart contract designed for services that need to send many transactions in a short time (e.g., cryptocurrency exchanges, payment processors). Key difference from standard wallets: Unlike seqno-based wallets (v3, v4, v5) that require sequential transaction processing, Highload v3 stores processed request identifiers in a dictionary, enabling parallel transaction submission without blocking. Compared to Highload v2: v3 solves architectural issues that could lock funds in v2 and consumes less gas during operations. ​TL-B schema TL-B (Type Language - Binary) is a domain-specific language designed to describe data structures in TON. The schemas below define the binary layout of the contract’s storage, external messages, and internal messages. ​Storage structure CopyAsk AIstorage$_ public_key:bits256 subwallet_id:uint32 old_queries:(HashmapE 13 ^Cell) queries:(HashmapE 13 ^Cell) last_clean_time:uint64 timeout:uint22 = Storage; ​Query ID structure CopyAsk AI_ shift:uint13 bit_number:(## 10) { bit_number >= 0 } { bit_number < 1023 } = QueryId; ​External message structure CopyAsk AI_ {n:#} subwallet_id:uint32 message_to_send:^Cell send_mode:uint8 query_id:QueryId created_at:uint64 timeout:uint22 = MsgInner; msg_body$_ {n:#} signature:bits512 ^(MsgInner) = ExternalInMsgBody; ​Internal message structure (for batch transfers) CopyAsk AIinternal_transfer#ae42e5a4 {n:#} query_id:uint64 actions:^(OutList n) = InternalMsgBody n; internal_transfer is used when the wallet sends a message to itself with an action list for batch transfers. The opcode 0xae42e5a4 is derived from crc32('internal_transfer n:# query_id:uint64 actions:^OutList n = InternalMsgBody n').The canonical TL-B schemas are maintained in the highload-wallet-contract-v3 repository. Below, each field is explained in detail. ​Storage structure The Highload Wallet v3 contract stores six persistent fields: ​public_key (256 bits) Purpose: An Ed25519 public key is used to verify signatures on incoming external messages. How it works: When the wallet receives an external message, it verifies that the 512-bit signature was created by the holder of the private key corresponding to this public key. The public key is not the wallet address. The address is derived from the contract’s StateInit. ​subwallet_id (32 bits) Purpose: Allows a single keypair to control multiple wallets with different addresses. How it works: The subwallet_id is part of the contract’s initial state. Changing it produces a different contract address (because the address is a hash of code + data). Each external message must include the correct subwallet_id; mismatches result in exit code 34. Common use case: One private key manages multiple “virtual” wallets for organizational or accounting purposes. Recommendation: Use subwallet_id: 0x10ad (4269) to avoid conflicts with other wallet types (standard wallets or vesting wallets) derived from the same keypair. See How to create Highload Wallet v3 for details. ​old_queries (HashmapE 13 ^Cell) Purpose: Stores previously processed query_id values during rotation cycles. Structure: Hashmap with 13-bit keys, where each key holds a bitmap of processed query IDs. Usage: Provides a second layer of replay protection. During cleanup, queries → old_queries, creating a double timeout window. Details: See Replay protection mechanism. ​queries (HashmapE 13 ^Cell) Purpose: Stores recently processed query_id values to prevent replay attacks. Structure: Hashmap with 13-bit keys, where each key holds a bitmap of processed query IDs. Usage: When a message arrives, the contract checks if its query_id is already marked in queries or old_queries. If found, the message is rejected as a replay attempt. Details: See Replay protection mechanism. ​last_clean_time (64 bits) Purpose: Unix timestamp (in seconds) of the last cleanup operation. Usage: Tracks when the contract last rotated queries → old_queries. Cleanup triggers when current_time >= last_clean_time + timeout. Details: See Replay protection mechanism. ​timeout (22 bits) Purpose: Defines the validity window (in seconds) for external messages. Usage: Messages are valid if created_at > now() - timeout and created_at <= now(). If expired or from the future, the contract rejects them with exit code 35. 22 bits allows timeout values up to ~4,194,303 seconds (~48.6 days). Details: Replay protection mechanism — how timeout is used Timeout constraints — choosing the right value ​Replay protection mechanism Highload v3 uses a dual-hashmap system (queries and old_queries) combined with timestamps to prevent replay attacks. ​Storage structure for replay protection The contract stores processed query_id values in two hashmaps: old_queries (HashmapE 13 ^Cell): Hashmap with 13-bit keys Each key corresponds to shift (13 bits from query_id) Each value is a cell containing a bitmap of processed bit_number values Stores previously processed query IDs from the last rotation cycle Provides extended protection during rotation queries (HashmapE 13 ^Cell): Same structure as old_queries — hashmap with 13-bit keys Each key corresponds to shift = query_id >> 10 Each value is a cell containing a bitmap of processed bit_number values Stores recently processed query IDs ​How query_id is checked When an external message arrives, the contract: Extracts query_id from the message Splits it into components: shift = query_id >> 10 (13 bits, range 0–8191) bit_number = query_id & 1023 (10 bits, range 0–1022) Checks if bit bit_number is set in queries[shift]: If found → reject with exit code 36 Checks if bit bit_number is set in old_queries[shift]: If found → reject with exit code 36 If not found in either → mark the bit in queries[shift] and proceed Why a hashmap structure? Enables parallel transaction submission — multiple messages can be sent simultaneously without waiting for sequential confirmation. ​Rotation mechanism When current_time >= last_clean_time + timeout, the contract performs cleanup: old_queries := queries — move current queries to old queries := {} — clear current queries hashmap last_clean_time := current_time — update timestamp Additional cleanup: If current_time >= last_clean_time + (2 × timeout) (i.e., no cleanup for twice the timeout period), the contract also clears old_queries completely to prevent unbounded storage growth. Why two hashmaps? This provides a double timeout window for replay protection: A query_id is protected for at least timeout seconds in queries After rotation, it remains in old_queries for another timeout period before deletion Total protection window: between timeout and 2 × timeout Benefit: Prevents replay attacks even if messages arrive near the rotation boundary. ​Timestamp validation The created_at timestamp combined with timeout ensures that even very old messages (beyond the rotation window) are rejected. This creates a time-based boundary for message validity: CopyAsk AIThe message is valid if: created_at > now() - timeout // Not too old created_at <= now() // Not from future Otherwise: reject with exit code 35 Time lag consideration: When a lite-server receives an external message, the contract executes now() which returns the timestamp of the last processed block, not the current system time. Due to network latency and block processing time, this timestamp is typically 5-30 seconds behind your system clock.Best practice: Set created_at to 30-60 seconds before the current time to ensure the message passes validation:CopyAsk AIconst createdAt = Math.floor(Date.now() / 1000) - 30; // 30 seconds ago If created_at equals your current system time, it may appear to be “from the future” when validated on-chain, causing the transaction to fail with exit code 35. ​Uniqueness guarantee Highload v3 will never execute multiple external messages containing the same query_id and created_",
    "category": "wallets",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "deployment",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "python",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:33:38.804Z"
  },
  {
    "id": "docs-ton-org--standard-wallets-highload-v2-specification",
    "title": "Highload Wallet v2 — specification",
    "url": "https://docs.ton.org/standard/wallets/highload/v2/specification",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsHow they workMnemonicsComparisonPerformance benchmarkHow to interactHistoryV4V5Highload WalletsOverviewHighload Wallet v3Highload Wallet v2SpecificationLockup walletPreprocessed Wallet V2Restricted walletTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationHighload Wallet v2Highload Wallet v2 — specificationStandard contractsWalletsHighload WalletsHighload Wallet v2Highload Wallet v2 — specificationCopy pageCopy pageDeprecated: Highload Wallet v2 is a legacy contract. Use Highload Wallet v3 for new deployments.This specification is maintained for reference to support existing legacy systems. This page provides a complete technical specification for Highload Wallet v2, covering storage structure, message formats, replay protection, and limitations. ​What is Highload Wallet v2? Highload Wallet v2 is a specialized wallet contract designed for services that need to send many transactions in a short time. It uses dictionary-based replay protection to enable parallel transaction submission. Key difference from standard wallets: Unlike seqno-based wallets that require sequential transaction processing, Highload v2 stores processed request identifiers in a dictionary, enabling parallel submissions. Replaced by: Highload Wallet v3 ​TL-B schema TL-B (Type Language - Binary) is a domain-specific language designed to describe data structures in TON. The schemas below define the binary layout of the contract’s storage and external messages. ​Storage structure CopyAsk AIstorage$_ subwallet_id:uint32 last_cleaned:uint64 public_key:bits256 queries:(HashmapE 64 Cell) = Storage; ​Query ID structure CopyAsk AI_ query_id:uint64 = QueryId; ​External message structure CopyAsk AI_ mode:uint8 message:^Cell = OutListNode; msg_body$_ signature:bits512 subwallet_id:uint32 query_id:uint64 messages:(HashmapE 16 Cell) = ExternalInMsgBody; ​Storage structure The Highload Wallet v2 contract stores four persistent fields (in this order): ​subwallet_id (32 bits) Purpose: Allows a single keypair to control multiple wallets with different addresses. How it works: The subwallet_id is part of the contract’s initial state. Changing it produces a different contract address. Each external message must include the correct subwallet_id; mismatches result in transaction failure. ​last_cleaned (64 bits) Purpose: Timestamp (in query_id format) of the oldest query that was kept during the last cleanup. How it works: During each transaction, the contract removes queries older than 64 seconds from the queries dictionary. The last_cleaned field tracks the last query ID that was removed. Cleanup logic: CopyAsk AIbound -= (64 << 32); // Clean up records expired more than 64 seconds ago Queries with query_id < (now() - 64) << 32 are removed from storage. Gas costs: Cleanup operations consume gas proportional to the number of expired queries. With many expired queries, cleanup can exceed the 1,000,000 gas limit, causing the transaction to fail. ​public_key (256 bits) Purpose: The Ed25519 public key is used to verify signatures on incoming external messages. How it works: When the wallet receives an external message, it verifies that the 512-bit signature was created by the holder of the private key corresponding to this public key. ​queries (HashmapE 64 Cell) Purpose: Stores processed query_id values for replay protection. Structure: Key: 64-bit query_id Value: Cell containing metadata (typically the timestamp when processed) How it works: Before processing a message, the contract checks if query_id exists in queries. If found, the message is rejected (replay attack). If not found, the query_id is added to queries, and the message is processed. Storage limit: The queries dictionary cannot exceed 65,535 cells. If this limit is reached, the contract will fail during the action phase. ​External message structure ​Message layout CopyAsk AIsignature:bits512 subwallet_id:uint32 query_id:uint64 messages:(HashmapE 16 Cell) Key point: Unlike v3, in v2 the signature is in the same cell as the message body, not in a separate reference cell. ​signature (512 bits) Type: Ed25519 signature (512 bits). What is signed: The hash of the remaining slice after the signature, containing subwallet_id, query_id, and messages. From source code: CopyAsk AIthrow_unless(35, check_signature(slice_hash(in_msg), signature, public_key)); The contract uses slice_hash() on the message body after loading the signature. ​subwallet_id (32 bits) Purpose: Identifies which subwallet this message targets. Validation: Must match the subwallet_id stored in contract storage. ​query_id (64 bits) Purpose: Unique identifier for replay protection and timestamp validation. Structure: The 64-bit value is internally interpreted as a timestamped identifier: High 32 bits: Unix timestamp (seconds) Low 32 bits: counter within that second Validation: The contract checks query_id >= now() << 32, ensuring the query ID is not from the past (based on the current time shifted left by 32 bits). Total unique IDs: Approximately 32,000 unique query IDs (limited by the cleanup mechanism and the bitmap structure). ​messages (HashmapE 16) Purpose: Dictionary of messages to send in this transaction. Structure: Key: uint16 (message index, 0 to 65,535) Value: mode:uint8 + ^Cell (reference to internal message) How it works: The contract iterates through the dictionary and sends each message with its corresponding send mode: CopyAsk AIint i = -1; do { (i, var cs, var f) = dict.idict_get_next?(16, i); if (f) { var mode = cs~load_uint(8); send_raw_message(cs~load_ref(), mode); } } until (~ f); Max batch size: Up to 255 messages (limited by action list size, not dictionary structure). ​Replay protection mechanism ​Validation sequence Check query_id timestamp: query_id >= now() << 32 (exit code 35 if too old) Check replay: query_id must not be in queries (exit code 32 if already processed) Check subwallet: subwallet_id == stored_subwallet (exit code 34 if mismatch) Verify signature: Ed25519 signature verification (exit code 35 if invalid) Mark as processed: Add query_id to queries Send messages: Iterate through the message dictionary and send each message Cleanup: Remove queries older than 64 seconds Rollback issue: Highload Wallet v2 does not use commit() to persist storage changes. If the compute phase fails after accept_message() (e.g., gas limit exceeded during cleanup) or if the action phase fails, all changes roll back, including replay protection. The query_id is not marked as processed, and lite-servers will retry the same message, burning gas repeatedly.Highload Wallet v3 solves this with commit() and a two-transaction pattern. See Why internal messages to self? for details. ​Exit codes Exit codeNameDescriptionHow to fix 0SuccessMessage processed successfully—32Query already executedThe query_id was already processed (found in queries)Use a new, unique query_id34Subwallet ID mismatchThe subwallet_id in the message does not match storageVerify you are using the correct subwallet_id for this wallet35Invalid signature or query_idEd25519 signature verification failed, or query_id is too oldCheck the private key and ensure query_id >= now() << 32 ​Limitations and constraints ​Storage size limit Limit: The queries dictionary cannot exceed 65,535 cells. What happens if exceeded: An exception is thrown during the action phase, and the transaction fails. The failed transaction may be replayed, potentially locking funds. ​Gas limit for cleanup Limit: Transaction gas limit is 1,000,000 gas. What happens if exceeded: Cleanup operations that exceed this limit will fail, preventing the contract from processing new transactions. Recommended limits: Queries within expiration window: ≤ 1,000 Queries cleaned per transaction: ≤ 100 ​Query ID expiration Expiration time: Queries older than 64 seconds are removed from storage during cleanup. Effective limit: With the 64-second expiration window and recommended limit of ≤1,000 queries per window, the effective query ID space is approximately 32,000 unique IDs before cleanup is required. ​Get methods MethodReturnsDescription processed?(query_id)intReturns -1 if processed, 0 if not processed, 1 if unknown (forgotten after cleanup)get_public_key()int (256 bits)Returns the Ed25519 public key ​processed? method details Returns: -1 (true) — the query_id was processed and is still stored in queries 0 (false) — the query_id has not been processed yet 1 (unknown) — the query_id is older than last_cleaned and was forgotten during cleanup ​Implementation Source code: ton-blockchain/ton (highload-wallet-v2-code.fc) SDK wrappers: Go: tonutils-go — includes Highload v2 wrapper Python: pytoniq — includes Highload v2 wrapper For new projects, consider using Highload Wallet v3 instead. ​See also Highload Wallet v3 specification — recommended version Version comparison — v1 vs v2 vs v3 Was this page helpful?YesNoSuggest",
    "category": "wallets",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "deployment",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "python",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:33:41.492Z"
  },
  {
    "id": "docs-ton-org--standard-wallets-highload-v3-create",
    "title": "How to create Highload Wallet v3",
    "url": "https://docs.ton.org/standard/wallets/highload/v3/create",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsHow they workMnemonicsComparisonPerformance benchmarkHow to interactHistoryV4V5Highload WalletsOverviewHighload Wallet v3How to create Highload Wallet v3How to send a single transferHow to send a batch of transfersHow to verify message is processedSpecificationHighload Wallet v2Lockup walletPreprocessed Wallet V2Restricted walletTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationHighload Wallet v3How to create Highload Wallet v3Standard contractsWalletsHighload WalletsHighload Wallet v3How to create Highload Wallet v3Copy pageCopy pageThis guide shows how to create a Highload Wallet v3 instance from scratch: choose configuration parameters, generate a mnemonic, and calculate the wallet address. ​Objective By the end of this guide, you will have: A 24-word mnemonic phrase (seed phrase) for your wallet A calculated wallet address (but not yet deployed on-chain) Configuration parameters: subwalletId and timeout ​Prerequisites Node.js 18+ or TypeScript environment @ton/ton, @ton/core, @ton/crypto packages installed Highload Wallet v3 wrapper and compiled contract code No deployment yet: Creating a wallet calculates its future address but does not deploy it. The wallet will auto-deploy on the first external message (when you send your first transfer). This guide uses TypeScript with the official wrapper. The same logic applies to other SDKs (Go/Python): generate or load a mnemonic, derive a keypair, choose parameters, and calculate the address. ​Step 1: Set up dependencies Install required packages: CopyAsk AInpm install @ton/ton @ton/core @ton/crypto Copy the wrapper and contract code from the official repository: CopyAsk AI# Clone the repository or download these files: # - wrappers/HighloadWalletV3.ts # - wrappers/HighloadQueryId.ts # - Compiled contract BoC (from build/ or inline hex) Why copy wrappers? The official @ton/ton SDK does not include Highload Wallet v3 wrappers yet. Copy HighloadWalletV3.ts and HighloadQueryId.ts from the repository until SDK support is added. ​Step 2: Choose configuration parameters Highload Wallet v3 requires two configuration parameters at creation time: ​timeout Type: uint22 (0 to 4,194,303 seconds) Purpose: Validity window for external messages and cleanup cycle duration The timeout determines: How long a signed external message remains valid: created_at must be within [now - timeout, now] When old processed messages rotate to old_queries: every timeout seconds When old_queries is cleared: after 2 × timeout Choosing a value: RangeUse case Short (60–300s)Fast certainty if message expires; lower storage costs; requires tight synchronizationMedium (1–6 hours)Balanced; suitable for most production useLong (24+ hours)High tolerance for blockchain congestion; higher storage costs; slower certainty on expiration Cannot be changed later: timeout is part of the contract’s initial configuration. Changing it would change the wallet address entirely. See Timeout constraints in the specification for details. ​subwalletId Type: uint32 (0 to 4,294,967,295) Purpose: Isolate multiple wallets derived from the same keypair A single mnemonic can generate multiple independent wallet addresses by varying subwalletId. Each wallet has its own balance, state, and transaction history. Recommended value: 0x10ad (4269). Use a subwalletId different from other wallet types (standard wallets v3/v4/v5 or vesting wallets) derived from the same keypair. The value 0x10ad is recommended in the official repository to avoid conflicts with other contracts. Why this matters: If you use the same subwalletId across different wallet types (e.g., Highload v3 and standard wallet v5), they might share the same address, causing conflicts. Using 0x10ad ensures isolation from standard wallets. See Storage structure in the specification for details. ​Step 3: Generate or load a mnemonic A mnemonic is your wallet’s master secret. It derives the private key used to sign all transactions. ​Generate a new mnemonic CopyAsk AIimport { mnemonicNew } from '@ton/crypto'; const mnemonic = await mnemonicNew(24); // Array of 24 words ​Load an existing mnemonic CopyAsk AIconst mnemonic = 'word1 word2 word3 ... word24'.split(' '); Protect your mnemonic: Anyone with access to your mnemonic can control your wallet and all funds. Store it securely (password manager, hardware wallet, encrypted storage). Never commit it to version control. ​Step 4: Derive the keypair Convert the mnemonic to an Ed25519 keypair: CopyAsk AIimport { mnemonicToPrivateKey } from '@ton/crypto'; const keyPair = await mnemonicToPrivateKey(mnemonic); // keyPair.publicKey — used in contract state // keyPair.secretKey — used to sign external messages ​Step 5: Create the wallet instance Create a Highload Wallet v3 contract instance with your chosen parameters: CopyAsk AIimport { TonClient } from '@ton/ton'; import { Cell } from '@ton/core'; import { HighloadWalletV3 } from './wrappers/HighloadWalletV3'; // Configuration const SUBWALLET_ID = 0x10ad; // Recommended for Highload Wallets const TIMEOUT = 60 * 60 * 24; // 24 hours // Compiled contract code (BoC) const CODE = Cell.fromBoc( Buffer.from( 'b5ee9c7241021001000228000114ff00f4a413f4bcf2c80b01020120020d02014803040078d020d74bc00101c060b0915be101d0d3030171b0915be0fa4030f828c705b39130e0d31f018210ae42e5a4ba9d8040d721d74cf82a01ed55fb04e030020120050a02027306070011adce76a2686b85ffc00201200809001aabb6ed44d0810122d721d70b3f0018aa3bed44d08307d721d70b1f0201200b0c001bb9a6eed44d0810162d721d70b15800e5b8bf2eda2edfb21ab09028409b0ed44d0810120d721f404f404d33fd315d1058e1bf82325a15210b99f326df82305aa0015a112b992306dde923033e2923033e25230800df40f6fa19ed021d721d70a00955f037fdb31e09130e259800df40f6fa19cd001d721d70a00937fdb31e0915be270801f6f2d48308d718d121f900ed44d0d3ffd31ff404f404d33fd315d1f82321a15220b98e12336df82324aa00a112b9926d32de58f82301de541675f910f2a106d0d31fd4d307d30cd309d33fd315d15168baf2a2515abaf2a6f8232aa15250bcf2a304f823bbf2a35304800df40f6fa199d024d721d70a00f2649130e20e01fe5309800df40f6fa18e13d05004d718d20001f264c858cf16cf8301cf168e1030c824cf40cf8384095005a1a514cf40e2f800c94039800df41704c8cbff13cb1ff40012f40012cb3f12cb15c9ed54f80f21d0d30001f265d3020171b0925f03e0fa4001d70b01c000f2a5fa4031fa0031f401fa0031fa00318060d721d300010f0020f265d2000193d431d19130e272b1fb00b585bf03', 'hex' ) )[0]; const client = new TonClient({ endpoint: 'https://testnet.toncenter.com/api/v2/jsonRPC', // This is TESTNET endpoint // apiKey: 'your-api-key' // Optional: get from @tonapibot or @tontestnetapibot }); const wallet = client.open( HighloadWalletV3.createFromConfig( { publicKey: keyPair.publicKey, subwalletId: SUBWALLET_ID, timeout: TIMEOUT, }, CODE ) ); ​Step 6: Get the wallet address Calculate the wallet’s address: CopyAsk AI// Get non-bounceable address for funding const address = wallet.address.toString({ bounceable: false, testOnly: true }); console.log('Wallet address:', address); // Example (truncated): 0Q... (non-bounceable, testnet) This address is deterministic: it depends only on CODE, publicKey, subwalletId, and timeout. The same parameters always produce the same address. Why non-bounceable? When funding a nonexist account, use the non-bounceable format to prevent funds from bouncing back if the account doesn’t exist yet. See Address formats for details. Account status: nonexist The calculated address exists only as a deterministic value. No account exists on the blockchain yet — no balance, no code, no data. ​Step 7: Fund the wallet Funds at risk: You will send TON to this address. Test on testnet first. Verify the wallet address carefully — blockchain transactions cannot be reversed. Required before deployment: Send TON to your wallet address (from Step 6) to prepare it for deployment. External messages (which deploy the wallet) require gas to execute. By funding the address, you transition the account from nonexist to uninit status and provide the balance needed for deployment. See Account status for details on how account states work. Send TON using a faucet (testnet) or from another wallet (mainnet). After funding, the account transitions to uninit status — it has a balance and can accept external messages, but no code or data yet. ​Saving wallet data For convenience, save your wallet configuration to reuse later: CopyAsk AIimport * as fs from 'fs'; const walletData = { mnemonic: mnemonic.join(' '), address: address, // From Step 6 subwalletId: SUBWALLET_ID, timeout: TIMEOUT, }; fs.writeFileSync('.wallet.json', JSON.stringify(walletData, null, 2)); console.log('Wallet saved to .wallet.json'); Never commit .wallet.json: Add it to .gitignore. This file contains your mnemonic. ​Next steps Your wallet is ready for deployment. The wallet will auto-deploy on the first external message.Was this page helpful?YesNoSuggest editsRaise issuePreviousHow to send a single transferNext⌘IgithubxtelegramPowered by MintlifyOn this pageObjectivePrerequisit",
    "category": "wallets",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "testnet",
      "mainnet",
      "transaction",
      "deployment",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "python",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:33:42.704Z"
  },
  {
    "id": "docs-ton-org--ecosystem-node-mytonctrl-overview",
    "title": "Overview",
    "url": "https://docs.ton.org/ecosystem/node/mytonctrl/overview",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeOverviewRun a node with MyTonCtrlRun a validatorIntegrate MyTonCtrl with PrometheusSetting up a local blockchain using MyLocalTonMyTonCtrl referenceOverviewCoreInstallerWalletValidatorCollatorNominator poolsLiquid stakingCustom overlaysUtilitiesTelegram alertingBackupBTC TeleportStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationMyTonCtrl referenceOverviewEcosystemBlockchain nodeMyTonCtrl referenceOverviewCopy pageCopy pageMyTonCtrl is a tool to run and maintain a TON node (validators and liteservers). ​Install MyTonCtrl Run the installer as the non-root operator who will manage the node. The command below fetches dependencies, downloads the script, and starts the interactive setup wizard: CopyAsk AIsudo apt update sudo apt install -y curl wget git ca-certificates python3-pip wget https://raw.githubusercontent.com/ton-blockchain/mytonctrl/master/scripts/install.sh sudo bash install.sh The wizard walks you through hardware validation, TON binary installs, and MyTonCtrl configuration. Use flags to pre-select options or automate deployments: FlagWhat it doesTypical use-d, --dumpDownloads a packaged blockchain dump before first start.Speeds up the initial sync (omit to sync from peers only).-m, --mode validator|liteserver|collatorPre-enables the target mode.Skip switching modes manually after install.-n, --network mainnet|testnetSwitches global config URL and minimum hardware thresholds.Point the node to testnet without editing configs later.-t, --telemetryDisables telemetry uploads during install.Comply with policies that forbid sharing validator stats.-i, --ignore-reqsIgnores the CPU/RAM minimum check.Lab hardware or cloud instances that fall below defaults.-c <PATH>, --config <PATH>Supplies a custom config.json for TON installer steps.Use a vetted mirror instead of the default URL.-g <URL>, --node-repo <URL>Points the TON node build to a different Git repository.Test patched node sources or mirror Git access.-v <VERSION>, --node-version <VERSION>Pins the TON node to a branch, tag, or commit.Lock to a specific release when validating upgrades.-u <USER>, --user <USER>Forces the operator account that owns MyTonCtrl.Keep ownership correct when running the script from automation.-e <PATH>, --env-file <PATH>Loads installer parameters (see below) from an env file.Pre-seed values like ARCHIVE_TTL, shard lists, or ports for CI jobs.-a <AUTHOR>, --author <AUTHOR>-r <REPO>, --repo <REPO>-b <BRANCH>, --branch <BRANCH>Override the Git source for MyTonCtrl and installer scripts.Test forks or feature branches.-p <FILE>, --backup <FILE>Restore from a MyTonCtrl backup archive.Reinstall on fresh hardware using an existing backup.-o, --only-mtcInstall only MyTonCtrl assets (requires -p).Use to interact with a node remotely.-l, --only-nodeInstall only the TON node binaries and services.Pair a fresh node with an existing MyTonCtrl instance elsewhere.--print-envPrints the resolved install command and env values, then exits.Dry-runs CLI answers before performing a real install.-h, --helpPrints installer help and exits.Basic check of available options. Leaving out -m and -p the installer in the interactive CLI, which prompts for network selection, telemetry, and mode enablement. ​Environment variables Set these variables before running install.sh (for example, ARCHIVE_TTL=864000 sudo bash install.sh) to preconfigure node behavior: VariableEffectNotesARCHIVE_TTLOverrides the retention (in seconds) passed to --archive-ttl.Defaults to 2592000 for liteserver mode and 86400 otherwise; set -1 for effectively permanent retention.STATE_TTLSets --state-ttl and shortens the archive TTL by the same amount.Use with ARCHIVE_TTL to keep a smaller state cache.ADD_SHARDAdds one or more --add-shard arguments.Provide shard IDs separated by spaces (for example 0:2000000000000000 0:a000000000000000).ARCHIVE_BLOCKSDownloads archive data via TON Storage during bootstrap.Accepts a single block/UTC date or a range (<from> <to>); dates must be YYYY-MM-DD.COLLATE_SHARDConfigures collator shards during collator mode installs.Space-separated shard IDs; defaults to 0:8000000000000000 if unset. ​Command reference ReferenceWhat it coversCore CommandsEveryday console operations: updating MyTonCtrl, enabling modes, viewing status, and managing settings.Installer CommandsRunning the MyTonInstaller module to configure node services, enable components, and adjust node arguments.Wallet CommandsCreating, importing, exporting, and funding wallets managed by MyTonCtrl.Validator CommandsElection voting, complaint handling, efficiency checks, and collator registry management for validators.Collator CommandsConfiguring collator shards, allowlists, and JSON options when operating in collator mode.Pool CommandsDeploying and operating nominator pools or Orbs single-nominator pools.Liquid Staking CommandsManaging liquid staking controllers, validator-set refreshes, and loan calculations.Custom Overlay CommandsAdding, listing, and removing custom overlays for validator-console telemetry.Utilities CommandsAccount inspection, bookmark management, governance offer utilities, and validator list reporting.Alerting CommandsConfiguring the MyTonCtrl alert bot, toggling alert keys, and testing notifications.Backups CommandsCreating and restoring configuration backups, including keyring exports.BTC Teleport CommandsReviewing Teleport proposals, voting, and uninstalling the Teleport bundle. ​Pick the right guide Provisioning a new node? Start with Setup MyTonCtrl and then use the Core and Installer references for ongoing maintenance. Operating pools or liquid staking? Combine the Pools or Liquid Staking guides with the relevant validator or wallet sections. Keeping eyes on production nodes? Review Alerting, Backups, and Utilities so you can monitor and recover your infrastructure quickly. ​Related resources Setup MyTonCtrl Baseline install & sync checklist Official MyTonCtrl repository Was this page helpful?YesNoSuggest editsRaise issuePreviousCoreInspecting node health, managing modes and settings, maintaining the software stack, and running diagnostics.Next⌘IgithubxtelegramPowered by MintlifyOn this pageInstall MyTonCtrlEnvironment variablesCommand referencePick the right guideRelated resources",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "testnet",
      "mainnet",
      "transaction",
      "deployment",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "python",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:33:45.084Z"
  },
  {
    "id": "docs-ton-org--ecosystem-node-mytonctrl-core",
    "title": "Core",
    "url": "https://docs.ton.org/ecosystem/node/mytonctrl/core",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeOverviewRun a node with MyTonCtrlRun a validatorIntegrate MyTonCtrl with PrometheusSetting up a local blockchain using MyLocalTonMyTonCtrl referenceOverviewCoreInstallerWalletValidatorCollatorNominator poolsLiquid stakingCustom overlaysUtilitiesTelegram alertingBackupBTC TeleportStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationMyTonCtrl referenceCoreEcosystemBlockchain nodeMyTonCtrl referenceCoreCopy pageInspecting node health, managing modes and settings, maintaining the software stack, and running diagnostics.Copy page​about Purpose: Show a mode’s description, whether it is currently enabled, and the settings that belong to the mode. Syntax CopyAsk AIabout <mode_name> Behavior Accepts exactly one mode name from: validator, nominator-pool, single-nominator, liquid-staking, liteserver, collator, alert-bot, prometheus. Fails with a clear message if the mode name is unknown. Prints a header, the human-readable mode description, and the current enablement status. Lists every setting attached to the mode, including a short description and the default value. When a mode has no dedicated settings, the command explicitly states that. Available modes ModeDescription validatorValidator functions. Activates participating in elections and staking.nominator-poolStandard nominator pools.single-nominatorOrbs’ single nominator pools.liquid-stakingLiquid staking controllers.liteserverFor liteserver usage only without validator.collatorBlocks collator-only module.alert-botTelegram bot alertsprometheusPrometheus format data exporter Example CopyAsk AIabout validator ​benchmark Purpose: Measure local disk performance to verify the node meets TON validator requirements. Syntax CopyAsk AIbenchmark Behavior Runs a bundled benchmark script with elevated privileges. The script executes two I/O scenarios (random 4K with queue depths 64 and 1) and a RocksDB stress test. The run takes up to ~200 seconds; the console blocks until completion. Results are printed as a table with read/write throughput, IOPS, and RocksDB random operations. On failure, the command prints the captured error log. ​disable_mode Purpose: Deactivate one of the pluggable modes (validator, nominator-pool, single-nominator, liquid-staking, liteserver, collator, alert-bot, prometheus). Syntax CopyAsk AIdisable_mode <mode_name> Behavior Turns the selected mode off and persists the change immediately. Valid mode names: validator, nominator-pool, single-nominator, liquid-staking, liteserver, collator, alert-bot, prometheus. Refuses to run when the mode name is unknown or when the mode’s own safety checks disallow disabling it (for example, modules may prevent leaving the validator network while critical processes are active). After a successful change, the console session exits so that dependent services can restart with the new configuration. Example CopyAsk AIdisable_mode liteserver ​enable_mode Purpose: Activate a mode that is currently disabled. Syntax CopyAsk AIenable_mode <mode_name> Behavior Validates the requested mode, enforces dependency rules, and enables supplementary components when required. Valid mode names: validator, nominator-pool, single-nominator, liquid-staking, liteserver, collator, alert-bot, prometheus. Examples: enabling validator forces liteserver to be disabled first; enabling liquid-staking makes sure the TON HTTP API is configured; enabling validator automatically installs BTC Teleport unless you disabled it via settings. Persists the change right away and terminates the console session once the command finishes. Example CopyAsk AIenable_mode validator ​Settings commands Purpose: Manage MyTonCtrl configuration values and review their current state. ​get Syntax CopyAsk AIget <setting-name> Behavior Reads the requested setting from the local database and prints it as pretty-printed JSON. Accepts any supported setting key (see list below); unknown keys return null. Strings, numbers, booleans, and objects are displayed exactly as stored. Example CopyAsk AIget sendTelemetry ​set Syntax CopyAsk AIset <setting-name> <setting-value> [--force] Behavior Updates a stored setting. Values are parsed as JSON when possible; otherwise, the raw string is saved. Validates that the key exists and that its parent mode is enabled. Use --force to bypass these checks when preparing a configuration ahead of enabling a mode or when intentionally writing custom keys. Rejects deprecated aliases such as usePool and useController and points you to enable_mode instead. Saves immediately and backs up the database on each change. Examples CopyAsk AIset auto_backup true set liquid_pool_addr \"0:abc123...\" set auto_backup_path /mnt/backups --force ​status_settings Syntax CopyAsk AIstatus_settings Behavior Prints a table listing every supported setting alongside its description, owning mode, default value, and the active value stored in the local database. Useful for auditing overrides before upgrades or for verifying configuration after scripted changes. ​Supported settings stake (mode validator, default null) — Stake amount submitted during elections when defined. stakePercent (mode validator, default 99) — Percentage of the validator wallet to stake when stake is not provided. isSlashing (mode validator, default null) — Enables automatic complaint submission against misbehaving validators. validatorWalletName (mode validator, default wallet_001) — Local wallet identifier used for validator operations. maxFactor (mode validator, default null) — Overrides the maxFactor sent to the Elector; falls back to config 17 when unset. participateBeforeEnd (mode validator, default null) — Seconds before the round end when the validator should join elections. liquid_pool_addr (mode liquid-staking, default null) — Address of the liquid staking pool used for controller operations. min_loan (mode liquid-staking, default 41000) — Minimum loan size in nanoTON for liquid staking borrowing. max_loan (mode liquid-staking, default 43000) — Maximum loan size in nanoTON for liquid staking borrowing. max_interest_percent (mode liquid-staking, default 10) — Interest ceiling (percent) applied to liquid staking loans. duplicateSendfile (mode null, default true) — Duplicates external messages to public lite servers for redundancy. sendTelemetry (mode null, default true) — Enables periodic telemetry submission to TON community services. telemetryLiteUrl (mode null, default https://telemetry.toncenter.com/report_status) — Endpoint used when telemetry is enabled. overlayTelemetryUrl (mode null, default https://telemetry.toncenter.com/report_overlays) — Endpoint for overlay network telemetry reports. duplicateApi (mode null, default sendTelemetry) — Controls whether to forward external messages via TON Center; default follows the sendTelemetry flag. duplicateApiUrl (mode null, default https://[testnet.]toncenter.com/api/v2/sendBoc) — API endpoint used when duplicateApi is active. checkAdnl (mode null, default sendTelemetry) — Checks local UDP port and ADNL connectivity; default follows the sendTelemetry flag. liteclient_timeout (mode null, default 3) — Default timeout, in seconds, for lite-client calls. console_timeout (mode null, default 3) — Default timeout, in seconds, for validator console interactions. fift_timeout (mode null, default 3) — Default timeout, in seconds, for Fift executions. useDefaultCustomOverlays (mode null, default true) — Joins the predefined custom overlays when the node is eligible. defaultCustomOverlaysUrl (mode null, default https://ton-blockchain.github.io/fallback_custom_overlays.json) — Source for the fallback custom overlay configuration. debug (mode null, default false) — Enables verbose console debugging with Python tracebacks. subscribe_tg_channel (mode validator, default false) — Suppresses reminders about subscribing to the TON STATUS Telegram channel. auto_backup (mode validator, default null) — Enables automatic validator backups every election when set truthy. auto_backup_path (mode validator, default /tmp/mytoncore/auto_backups/) — Destination folder for automatic backups. prometheus_url (mode prometheus, default null) — Pushgateway URL for Prometheus metrics. onlyNode (mode null, default null) — When true, restricts MyTonCtrl to telemetry collection without elections. importGc (mode null, default null) — When enabled, removes imported archive block files after use; requires MyTonCtrl restart. btcTeleportDisabled (mode validator, default false) — Prevents automatic BTC Teleport installation during validator setup. ​installer Purpose: Launch the MyTonInstaller utility from inside MyTonCtrl. Syntax CopyAsk AIinstaller installer <installer_command> [installer_args...] Behavior With no arguments, opens the interactive MyTonInstaller console so you can walk through node provisioning tasks. When you pass arguments, MyTonCtrl forwards them to MyTonInstaller’s -c command ",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "testnet",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "python",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:33:46.812Z"
  },
  {
    "id": "docs-ton-org--ecosystem-node-mytonctrl-installer",
    "title": "Installer",
    "url": "https://docs.ton.org/ecosystem/node/mytonctrl/installer",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeOverviewRun a node with MyTonCtrlRun a validatorIntegrate MyTonCtrl with PrometheusSetting up a local blockchain using MyLocalTonMyTonCtrl referenceOverviewCoreInstallerWalletValidatorCollatorNominator poolsLiquid stakingCustom overlaysUtilitiesTelegram alertingBackupBTC TeleportStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationMyTonCtrl referenceInstallerEcosystemBlockchain nodeMyTonCtrl referenceInstallerCopy pageMyTonInstaller complements MyTonCtrl by bootstrapping and maintaining TON node components.Copy pageRun these commands from the installer context of mytonctrl: CopyAsk AIMyTonCtrl> installer Installer> ​status Purpose: Inspect whether required TON services and credentials are in place, and review the current node arguments. Syntax CopyAsk AIstatus Behavior Checks for the presence of validator, mytoncore, console, and liteserver artifacts under /var/ton-work and reports each as enabled/disabled. Loads the active node argument list (from set_node_argument) and prints every flag with its stored values. Does not modify any files, making it safe to rerun as a health check. ​set_node_argument Purpose: Add, update, or remove TON validator/validator-engine command-line arguments. Syntax CopyAsk AIset_node_argument <arg-name> [arg-value] [-d] Behavior Requires at least the argument name (for example, --archive-ttl, -M, --add-shard). When additional values are provided, they are concatenated and passed to the helper script set_node_argument.py, which edits /etc/ton/validator-engine.conf-style settings. Use -d as the final flag to delete the argument instead of setting a value. Runs with root privileges to ensure the validator configuration is writable. Examples CopyAsk AIset_node_argument --archive-ttl 86400 set_node_argument --add-shard 0:2000000000000000 0:a000000000000000 set_node_argument --archive-ttl -d ​enable Purpose: Provision or activate bundled components such as the validator console, liteserver, or auxiliary services. Syntax CopyAsk AIenable <code> Behavior Accepts one of the codes listed below and invokes the corresponding setup routine through mytoninstaller -e enable<code>. If you enable the TON HTTP API (THA), the installer first generates a local liteserver config by running clcf automatically. All routines run with elevated privileges because they create system users, service units, configuration files, or keys. Supported codes CodeComponentPurposeKey tasks FNFirst node bootstrapPrepare a fresh validator environment so MyTonCtrl can manage a node end-to-end.Creates the validator system user, installs the validator engine as a systemd service, generates the initial config.json, downloads blockchain dumps, and performs the first validator start.VCValidator consoleProvide secure CLI access to the validator engine for MyTonCtrl and operators.Generates server/client key pairs, wires them into validator.config.json, updates MyTonCore with console credentials, and restarts validator + MyTonCore to apply.LSliteserverEnable the local liteserver endpoint used by tooling and APIs.Creates liteserver keys, registers them in validator.config.json, updates MyTonCore’s lite-client section, and restarts services to expose the port locally.DSDHT serverRun a standalone DHT node so the validator can advertise itself through the ADNL network.Installs and enables the TON DHT service, provisions keys, selects public ports, generates/prints the ADNL address list, and starts the daemon under systemd.JRJSON-RPC frontendInstall MyTonCtrl’s JSON-RPC bridge for programmatic control.Executes jsonrpcinstaller.sh with root privileges to deploy the service, wiring it for the current node user.THATON HTTP APIExpose the TON HTTP API backed by the local liteserver for REST-like access.Generates a fresh liteserver config when needed and runs ton_http_api_installer.sh to install and configure the HTTP API service.LSPls-proxyProxy the liteserver connection for safer remote access and load balancing.Installs the ls-proxy binary, creates a systemd unit, bootstraps the config with local liteserver credentials, and starts the proxy service.TSTON StorageProvide local TON Storage capabilities for block archives and state downloads.Deploys tonutils-storage, configures public UDP/API ports and external IP, persists the config, registers connectivity details in MyTonCore, and starts the storage daemon. Example CopyAsk AIenable FN ​update Purpose: Rerun enablement routines for installed components to pull updates or repair their configuration. Syntax CopyAsk AIupdate <code> Behavior Shares the same code list and internal handler as enable, but intended for repeat executions when you need to refresh binaries or regenerate configs (for example, after package updates). update JR is the common shorthand for reinstalling or updating the JSON-RPC service. Requires the same elevated privileges as enable because it delegates to the same installer events. Example CopyAsk AIupdate JR ​plsc Purpose: Print the current liteserver configuration JSON. Syntax CopyAsk AIplsc Behavior Reads the configuration produced by GetLiteServerConfig (typically /usr/bin/ton/local.config.json) and prints it as pretty JSON. Useful for verifying that liteserver keys, ports, and peers match expectations after running enable LS or clcf. ​clcf Purpose: Create or refresh the liteserver local configuration file. Syntax CopyAsk AIclcf [-u <user>] Behavior Fetches the latest init block via TON API; if unavailable, falls back to the bundled global.config.json. Base64-encodes the init block and invokes mytoninstaller -e clc -i <base64> under the specified user (defaults to the installer’s current user). Writes /usr/bin/ton/local.config.json and related liteserver files so that services like TON HTTP API can start. Examples CopyAsk AIclcf clcf -u validator ​print_ls_proxy_config Purpose: Display the active ls-proxy configuration file. Syntax CopyAsk AIprint_ls_proxy_config Behavior Reads /var/ls_proxy/ls-proxy-config.json (via get_ls_proxy_config) and prints it in formatted JSON. Allows quick inspection of proxy targets after running enable LSP. ​create_ls_proxy_config_file Purpose: Placeholder for generating an ls-proxy config file. Syntax CopyAsk AIcreate_ls_proxy_config_file Behavior Outputs TODO because the implementation is not there yet. Use print_ls_proxy_config or edit /var/ls_proxy/ls-proxy-config.json manually until this command is implemented. ​drvcf Purpose: Rebuild config.json for the validator engine using existing key material (dangerous recovery). Syntax CopyAsk AIdrvcf Behavior Calls DangerousRecoveryValidatorConfigFile, which scans /var/ton-work/db/keyring, recent election dumps, and mytoncore settings to reconstruct validator, liteserver, control, DHT, and ADNL entries. Prints the reconstructed configuration and any unused keys so you can review the output before applying it manually. Intended for disaster recovery scenarios; it does not overwrite files automatically. ​setwebpass Purpose: Set or change the password for the MyTonCtrl web administration (JSON-RPC) interface. Syntax CopyAsk AIsetwebpass Behavior Runs /usr/src/mtc-jsonrpc/mtc-jsonrpc.py -p, prompting for the new password and updating the credential store. No arguments are accepted; rerun whenever you need to rotate web admin credentials. Was this page helpful?YesNoSuggest editsRaise issuePreviousWalletWallet mode provides convenience utilities for generating, activating, importing, exporting, and moving funds between TON wallets managed by MyTonCtrl.Next⌘IgithubxtelegramPowered by MintlifyOn this pagestatusset_node_argumentenableupdateplscclcfprint_ls_proxy_configcreate_ls_proxy_config_filedrvcfsetwebpass",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "frontend",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:33:49.106Z"
  },
  {
    "id": "docs-ton-org--ecosystem-node-mytonctrl-collator",
    "title": "Collator",
    "url": "https://docs.ton.org/ecosystem/node/mytonctrl/collator",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeOverviewRun a node with MyTonCtrlRun a validatorIntegrate MyTonCtrl with PrometheusSetting up a local blockchain using MyLocalTonMyTonCtrl referenceOverviewCoreInstallerWalletValidatorCollatorNominator poolsLiquid stakingCustom overlaysUtilitiesTelegram alertingBackupBTC TeleportStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationMyTonCtrl referenceCollatorEcosystemBlockchain nodeMyTonCtrl referenceCollatorCopy pageCollator mode lets a node produce blocks for selected shardchains without running the full validator stack. The commands below help you configure local collators, adjust the validator allowlist, and manage collator-specific configuration JSON.Copy page​Operational notes Collator mode cannot be enabled while validator mode is active (enable_mode collator requires disable_mode validator first). setup_collator relies on validator-console RPCs and the underlying node arguments; ensure mytoninstaller utilities are present and the node runs with permissions to edit /etc/ton/validator-engine.conf. Shard identifiers follow TON conventions: workchain is -1 for masterchain or 0 for basechain, and <SHARD_HEX> must be a 16-character hex prefix (e.g., 2000000000000000). Keep your validator wallet and ADNL keys backed up. Removing collators will delete console mappings, but does not revoke keys created with CreateNewKey. ​Collator lifecycle commands ​setup_collator Purpose: Register a local collator for one or more shards and update node arguments accordingly. Syntax CopyAsk AIsetup_collator [--force] [--adnl <ADNL_ID>] <WORKCHAIN>:<SHARD_HEX> [<ADDITIONAL_SHARDS>...] Behavior Requires at least one shard identifier in <WORKCHAIN>:<SHARD_HEX> format (for example 0:2000000000000000). Creates a new ADNL key automatically unless you pass an existing one with --adnl (value must be base64 as returned by newkey). Ensures --add-shard entries exist in the validator-engine arguments. When the node already monitors shards and -M is enabled, the command verifies coverage. Use --force to bypass this safety check if you intentionally widen monitoring. Calls the validator console (add-collator) for each shard and appends the necessary node arguments via mytoninstaller set_node_argument. Logs follow-up commands (add_collator <ADNL> <SHARD>) that validators should run to accept the collator. Example CopyAsk AIsetup_collator 0:2000000000000000 0:4000000000000000 ​stop_collator Purpose: Remove one collator or all local collators from validator-console tracking. Syntax CopyAsk AIstop_collator stop_collator <ADNL_HEX> <WORKCHAIN>:<SHARD_HEX> Behavior Without arguments: prompts for confirmation, then deletes every local collator by iterating over the validator configuration. With specific arguments, targets a single collator. <ADNL_HEX> must be the hex-encoded ADNL ID (as shown by print_local_collators). Issues del-collator commands to the validator console and reports errors if any removal fails. Examples CopyAsk AIstop_collator stop_collator 2F3C7A...B91 0:2000000000000000 ​print_local_collators Purpose: List the collators currently registered on this node. Syntax CopyAsk AIprint_local_collators Behavior Reads the validator configuration and prints a table with each collator’s ADNL (hex) and shard identifier. Returns “No collators found” when none are configured. ​Collation allowlist management ​add_validator_to_collation_wl Purpose: Enable and populate the validator allowlist that is allowed to receive collated blocks. Syntax CopyAsk AIadd_validator_to_collation_wl <ADNL_HEX> [<ADDITIONAL_ADNL>...] Behavior Ensures the allowlist is active (collator-whitelist-enable 1) and then adds each ADNL (hex) via collator-whitelist-add. Throws an error if the validator console rejects any entry. Accepts one or more ADNL IDs in a single invocation. Example CopyAsk AIadd_validator_to_collation_wl 2F3C7A...B91 6AD1CE...004 ​delete_validator_from_collation_wl Purpose: Remove validators from the allowlist. Syntax CopyAsk AIdelete_validator_from_collation_wl <ADNL_HEX> [<ADDITIONAL_ADNL>...] Behavior Calls collator-whitelist-del for each provided ADNL (hex) and raises an error if any deletion fails. Does not disable the allowlist itself; use disable_collation_wl for that. Example CopyAsk AIdelete_validator_from_collation_wl 6AD1CE...004 ​disable_collation_wl Purpose: Turn off the allowlist, allowing any validator to accept blocks. Syntax CopyAsk AIdisable_collation_wl Behavior Sends collator-whitelist-enable 0 to the validator console. Requires no arguments; prints an error if the console command fails. ​print_collation_whitelist Purpose: Show the current contents of the collation allowlist as reported by the validator console. Syntax CopyAsk AIprint_collation_whitelist Behavior Runs collator-whitelist-show and outputs the raw console response, including whether the allowlist is enabled and the listed ADNL IDs. ​Collator configuration JSON commands ​set_collation_config Purpose: Store the preferred collator options JSON location and apply it to the validator console. Syntax CopyAsk AIset_collation_config <PATH_OR_URL> Behavior Accepts either a local filesystem path or an HTTP(S) URL returning JSON. Fetches and validates the document, saves the location to the MyTonCtrl database, and calls setcollatoroptionsjson on the validator console using a temporary file. Reports detailed errors if the file cannot be loaded or the console rejects the update. Example CopyAsk AIset_collation_config https://raw.githubusercontent.com/ton-blockchain/ton-blockchain.github.io/main/default_collator_options.json ​update_collation_config Purpose: Reapply the stored collator options without changing the source location. Syntax CopyAsk AIupdate_collation_config Behavior Reads the previously saved location (defaulting to https://raw.githubusercontent.com/ton-blockchain/ton-blockchain.github.io/main/default_collator_options.json if none was set). Downloads the JSON again and calls setcollatoroptionsjson so changes on the remote source take effect. ​print_collation_config Purpose: Display the current collator options location and the validator console’s active configuration. Syntax CopyAsk AIprint_collation_config Behavior Prints the remembered location, fetches the live configuration with getcollatoroptionsjson, and shows the JSON payload formatted for readability. Useful for verifying whether a recent set_collation_config or update_collation_config call succeeded. Was this page helpful?YesNoSuggest editsRaise issuePreviousNominator poolsPool-focused commands help you manage validator-run nominator pools and Orbs single-nominator pools. The console exposes utilities that create local pool descriptors, deploy the contracts on-chain, and move stake in or out.Next⌘IgithubxtelegramPowered by MintlifyOn this pageOperational notesCollator lifecycle commandssetup_collatorstop_collatorprint_local_collatorsCollation allowlist managementadd_validator_to_collation_wldelete_validator_from_collation_wldisable_collation_wlprint_collation_whitelistCollator configuration JSON commandsset_collation_configupdate_collation_configprint_collation_config",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:33:51.167Z"
  },
  {
    "id": "docs-ton-org--ecosystem-node-mytonctrl-custom-overlays",
    "title": "Custom overlays",
    "url": "https://docs.ton.org/ecosystem/node/mytonctrl/custom-overlays",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeOverviewRun a node with MyTonCtrlRun a validatorIntegrate MyTonCtrl with PrometheusSetting up a local blockchain using MyLocalTonMyTonCtrl referenceOverviewCoreInstallerWalletValidatorCollatorNominator poolsLiquid stakingCustom overlaysUtilitiesTelegram alertingBackupBTC TeleportStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationMyTonCtrl referenceCustom overlaysEcosystemBlockchain nodeMyTonCtrl referenceCustom overlaysCopy pageSets up a custom overlay to speed up synchronization for a group of nodes.Copy page​Operational notes Overlays require MyTonCtrl to run in validator mode with an accessible validator console; the commands rely on console RPCs (addcustomoverlay, showcustomoverlays, delcustomoverlay). Keep ADNL IDs in the configuration consistent with the node’s current validator keys. The helper refuses to deploy static overlays when the node lacks the necessary IDs. Dynamic overlays are re-evaluated each election. MyTonCtrl automatically removes stale overlays tied to old election IDs and creates new ones as rounds roll over. ​add_custom_overlay Purpose: Register a custom overlay configuration and deploy it to the validator console. Syntax CopyAsk AIadd_custom_overlay <overlay-name> <path-to-config> Behavior <overlay-name> is an arbitrary label used inside MyTonCtrl and as the validator-console overlay name. <path-to-config> must point to a JSON file describing overlay nodes. Each key is an ADNL address (hex) and each value specifies whether the node is a block_sender or msg_sender (msg_sender entries may include a msg_sender_priority). Configuration files can include an @validators key to denote dynamic overlays. In that case, MyTonCtrl stores the config and schedules validator-console updates for the current and next election rounds. Static overlays are converted immediately via addcustomoverlay and require that your node owns the listed ADNL IDs; otherwise, the command prints an error. MyTonCtrl caches the config in its database, so overlays persist across restarts. Example CopyAsk AIadd_custom_overlay telemetry-overlay /etc/mytonctrl/overlays/telemetry.json ​Sample config structure CopyAsk AI{ \"3b53...d1\": { \"block_sender\": true }, \"@validators\": [\"0a1f...bc\", \"292e...7a\"], \"7c9d...4e\": { \"msg_sender\": true, \"msg_sender_priority\": 5 } } Keys other than @validators must be ADNL IDs in hex form. For msg_sender entries, set msg_sender to true and optionally include msg_sender_priority (higher numbers mean higher priority). Include @validators only when you want the overlay to track the current validator set automatically. ​list_custom_overlays Purpose: Inspect every overlay definition stored by MyTonCtrl. Syntax CopyAsk AIlist_custom_overlays Behavior Prints each overlay name and the JSON configuration saved in the local database. Highlights whether an overlay is dynamic (@validators present) or static. Helpful for auditing definitions before deploying them on another node. ​delete_custom_overlay Purpose: Remove a stored overlay and, when possible, detach it from the validator console. Syntax CopyAsk AIdelete_custom_overlay <overlay-name> Behavior Deletes <overlay-name> from the MyTonCtrl database. If the overlay was dynamic (tracked via @validators), the validator console updates within ~1 minute to remove it automatically. For static overlays, MyTonCtrl issues delcustomoverlay <overlay-name> so the validator console stops broadcasting it immediately. If the console rejects the operation, the command reports an error so you can intervene manually. Example CopyAsk AIdelete_custom_overlay telemetry-overlay Was this page helpful?YesNoSuggest editsRaise issuePreviousUtilitiesUtility commands provide quick inspection and helper tools for accounts, bookmarks, governance artifacts, and validator data.Next⌘IgithubxtelegramPowered by MintlifyOn this pageOperational notesadd_custom_overlaySample config structurelist_custom_overlaysdelete_custom_overlay",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:33:52.947Z"
  },
  {
    "id": "docs-ton-org--ecosystem-node-mytonctrl-utilities",
    "title": "Utilities",
    "url": "https://docs.ton.org/ecosystem/node/mytonctrl/utilities",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeOverviewRun a node with MyTonCtrlRun a validatorIntegrate MyTonCtrl with PrometheusSetting up a local blockchain using MyLocalTonMyTonCtrl referenceOverviewCoreInstallerWalletValidatorCollatorNominator poolsLiquid stakingCustom overlaysUtilitiesTelegram alertingBackupBTC TeleportStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationMyTonCtrl referenceUtilitiesEcosystemBlockchain nodeMyTonCtrl referenceUtilitiesCopy pageUtility commands provide quick inspection and helper tools for accounts, bookmarks, governance artifacts, and validator data.Copy page​Account inspection ​vas Purpose: View the latest account status, code hash, and recent messages. Syntax CopyAsk AIvas <account-addr|bookmark> Behavior Resolves bookmarks automatically and fetches the account via the lite-client. Prints a status table (address, state, balance, detected contract version), the raw code hash, and the last 10 inbound/outbound messages with relative timestamps. Useful for verifying that deployments succeeded or funds arrived. Example CopyAsk AIvas EQBf...nw ​vah Purpose: Print a paginated message history for an account. Syntax CopyAsk AIvah <account-addr|bookmark> <limit> Behavior Shows the most recent <limit> messages, marking direction (>>> for outgoing, <<< for incoming), amount, and counterparty addresses in base64. Handy when you need deeper history than the default vas preview. Example CopyAsk AIvah EQBf...nw 25 ​Bookmark management ​nb Purpose: Create a bookmark for frequently used addresses. Syntax CopyAsk AInb <bookmark-name> <account-addr> Behavior Validates that <account-addr> is a correct TON address and stores it under <bookmark-name> for future commands (e.g., mg, vas). Example CopyAsk AInb treasury EQBf...nw ​bl Purpose: List all stored bookmarks. Syntax CopyAsk AIbl Behavior Prints a table with each bookmark name, address, and any cached metadata (balance or expiration date if available). ​db Purpose: Delete a bookmark by name. Syntax CopyAsk AIdb <bookmark-name> Behavior Removes the bookmark from MyTonCtrl storage. Future commands must use the raw address unless you recreate the bookmark. Example CopyAsk AIdb treasury ​Governance and configuration helpers ​ol Purpose: Display open governance offers (configuration proposals). Syntax CopyAsk AIol [--json] [hash] Behavior Without flags, prints a table showing hash (trimmed unless you pass the literal hash argument), config ID, votes, win/loss tally, approval percentage, and pass status. --json outputs the raw offer list in JSON format. Examples CopyAsk AIol ol --json ol hash ​od Purpose: Diff a proposal’s configuration against the current config. Syntax CopyAsk AIod <offer-hash> Behavior Fetches the offer, runs lite-client commands to dump the proposed config, and shows a diff between the current value and the proposal. The diff utility must be available in the command shell to run this command. Example CopyAsk AIod xKF+2Cj4wP6w2y... ​cl Purpose: List validator complaints for the current or previous round. Syntax CopyAsk AIcl [past] [--json] [adnl] Behavior With no flags, prints complaint entries with election ID, validator ADNL (trimmed unless adnl is supplied), fine, vote count, approval percent, and pass status (color-coded). past switches to the previous election round; --json dumps raw data. Examples CopyAsk AIcl cl past adnl cl --json ​Election data ​el Purpose: Inspect election entries submitted by validators. Syntax CopyAsk AIel [past] [--json] [adnl] [pubkey] [wallet] Behavior The default view shows trimmed ADNL/pubkey/wallet values along with stake and max-factor. Add past to see the previous round, --json for raw output, or the literals adnl, pubkey, wallet to disable trimming for those columns. Examples CopyAsk AIel el past adnl pubkey el --json ​Validator roster ​vl Purpose: Print the validator list with optional filters and formats. Syntax CopyAsk AIvl [past] [fast] [--json] [adnl] [pubkey] [wallet] [offline] Behavior Default view shows index, trimmed ADNL/pubkey/wallet, stake, efficiency, and online status (color-coded). past loads the previous round; fast avoids extra lite-client calls for performance. --json returns raw data. Passing adnl, pubkey, or wallet prevents trimming for those columns. offline filters to entries marked offline. Examples CopyAsk AIvl vl fast offline vl past --json adnl ​Pool diagnostics ​get_pool_data Purpose: Retrieve detailed pool contract data by name or address. Syntax CopyAsk AIget_pool_data <pool-name|pool-addr> Behavior Accepts either a local pool alias (resolved via stored .addr file) or a base64 contract address. Prints the JSON returned by runmethodfull ... get_pool_data, including stake, elector values, and state flags. Example CopyAsk AIget_pool_data mypool Was this page helpful?YesNoSuggest editsRaise issuePreviousTelegram alertingNext⌘IgithubxtelegramPowered by MintlifyOn this pageAccount inspectionvasvahBookmark managementnbbldbGovernance and configuration helpersolodclElection dataelValidator rostervlPool diagnosticsget_pool_data",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "deployment",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:33:55.593Z"
  },
  {
    "id": "docs-ton-org--ecosystem-node-mytonctrl-alerting",
    "title": "Telegram alerting",
    "url": "https://docs.ton.org/ecosystem/node/mytonctrl/alerting",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeOverviewRun a node with MyTonCtrlRun a validatorIntegrate MyTonCtrl with PrometheusSetting up a local blockchain using MyLocalTonMyTonCtrl referenceOverviewCoreInstallerWalletValidatorCollatorNominator poolsLiquid stakingCustom overlaysUtilitiesTelegram alertingBackupBTC TeleportStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationMyTonCtrl referenceTelegram alertingEcosystemBlockchain nodeMyTonCtrl referenceTelegram alertingCopy pageCopy pageMyTonCtrl Private Alerting Bot is a tool for receiving notifications about node status via Telegram Bot. The bot is designed to send notification messages to Telegram only. It does not manage the validator or process any commands. This bot is part of the MyTonCtrl toolset and is compatible with both validators and liteservers. Create a separate private bot in Telegram and configure it within MyTonCtrl. You can use one bot to monitor multiple nodes. ​Setup To set up the MyTonCtrl Alerting Bot, follow these steps: ​Prepare a bot Visit @BotFather and create a bot by using the command /newbot. After creating a bot, copy the bot token under the “Use this token to access the HTTP API:” line. Go to the bot and press the Start button. This action will allow the bot to send messages. The bot can send messages to either private messages or groups. To receive messages from the bot in a group chat, make sure to add the bot to that group. Visit @getmyid_bot and press the Start button. The bot will reply with a chat ID; use this ID to receive messages from the bot. To receive messages in a group, add @getmyid_bot to the group, and it will provide the chat ID of this group. ​Activate the alert bot in MyTonCtrl Enable the alert-bot using the following command: CopyAsk AIMyTonCtrl> enable_mode alert-bot Execute the command: CopyAsk AIMyTonCtrl> setup_alert_bot <bot_token> <chat_id> In case of a successful setup, the bot sends a welcome message listing all available alerts. ​Operational notes Alerts cover wallet balance thresholds, database usage, validator efficiency/blocks, synchronization, ADNL health, stake acceptance, slashes, and other key metrics. Each alert has an associated cooldown (timeout) to prevent spam. Info-level ok alerts reset state without sound notifications. The bot requires network access to the Telegram API. Ensure outbound HTTPS is permitted from the server. When validator mode is enabled, the alert bot automatically includes wallet and ADNL context in messages. In collator-only or other modes, some alerts may be skipped because prerequisites are missing. ​setup_alert_bot Purpose: Configure the alert bot with the Telegram bot token and chat ID, then start sending events. Syntax CopyAsk AIsetup_alert_bot <bot_token> <chat_id> Behavior Takes the Telegram bot token and chat ID as positional parameters. Run it right after enabling alert-bot mode. Immediately attempts to send the welcome message that lists every alert. Success proves the bot has permission to write to the chat. On success, saves BotToken and ChatId in the local database (myLocal.db) so the scheduler can emit alerts. On failure, logs the Telegram error (and hints if the bot is missing from the chat). ​list_alerts Purpose: Show all predefined alerts and whether they are currently enabled. Syntax CopyAsk AIlist_alerts Behavior Lists every alert key (for example: low_wallet_balance, db_usage_80, out_of_sync) along with the enabled flag and the UNIX timestamp when it was last sent. Helps you audit which alerts are muted and whether recent warnings have fired. ​enable_alert Purpose: Re-enable a previously muted alert. Syntax CopyAsk AIenable_alert <alert_name> Behavior Accepts any alert key defined in the alert module (for example: low_efficiency, service_down, validator_slashed). Sets the alert’s enabled flag to true so future events can trigger notifications. Example CopyAsk AIenable_alert low_wallet_balance ​disable_alert Purpose: Temporarily suppress a specific alert. Syntax CopyAsk AIdisable_alert <alert_name> Behavior Marks the alert as disabled; the scheduler skips sending messages for it until re-enabled. Use when you expect noisy conditions (e.g., during planned maintenance) but still want other alerts to deliver. Example CopyAsk AIdisable_alert service_down ​test_alert Purpose: Send a simple message through the configured alert channel to verify connectivity. Syntax CopyAsk AItest_alert Behavior Requires successful initialization (bot token and chat ID saved). If initialization hasn’t run yet, the command triggers it. Sends Test alert with info severity so you can confirm the chat receives notifications. ​Available alerts low_wallet_balance: Validator wallet balance below 10 TON while the node is working and in sync. low_wallet_balance_ok: Balance recovered to ≥10 TON after a low-balance alert. db_usage_80: TON database usage exceeded 80% (but ≤95%). db_usage_95: TON database usage exceeded 95%. db_usage_ok: Database usage dropped back below 80% after a high-usage alert. low_efficiency: Validator efficiency fell below 90% once ≥80% of the round elapsed. out_of_sync: Node stayed more than 20 seconds behind the masterchain while otherwise running. sync_ok: Node resynced to less than 20 seconds lag after an out-of-sync alert. service_down: Validator service stopped reporting as working (outside of initial sync). service_down_ok: Validator service resumed normal operation after downtime. adnl_connection_failed: Remote ADNL connectivity checks failed for all probe hosts. adnl_connection_ok: ADNL check succeeded again after a failure. zero_block_created: No blocks produced in roughly the last half validation period (~8h on mainnet). zero_block_created_ok: Block production resumed after a zero-block alert. validator_slashed: Validator was slashed in the previous validation round. stake_not_accepted: Election stake submission was rejected (validator missing from the current validator list). stake_accepted: Election stake was accepted (validator present in the current validator list). stake_returned: Elector returned the stake during the post-freeze payout window. stake_not_returned: Stake was not returned during the expected post-freeze payout window. voting: Governance offers with ≥50% approval remain unvoted by this validator. voting_ok: All actionable governance offers have been voted on (no outstanding votes). initial_sync_completed: Initial blockchain sync finished successfully. shard_collators_offline: All registered collators for at least one shard are offline. shard_collators_ok: Collators for previously offline shards reported back online. Was this page helpful?YesNoSuggest editsRaise issuePreviousBackupMyTonCtrl bundles helper scripts for creating and restoring node backups.Next⌘IgithubxtelegramPowered by MintlifyOn this pageSetupPrepare a botActivate the alert bot in MyTonCtrlOperational notessetup_alert_botlist_alertsenable_alertdisable_alerttest_alertAvailable alerts",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "mainnet",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:33:56.956Z"
  },
  {
    "id": "docs-ton-org--ecosystem-node-mytonctrl-backups",
    "title": "Backup",
    "url": "https://docs.ton.org/ecosystem/node/mytonctrl/backups",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeOverviewRun a node with MyTonCtrlRun a validatorIntegrate MyTonCtrl with PrometheusSetting up a local blockchain using MyLocalTonMyTonCtrl referenceOverviewCoreInstallerWalletValidatorCollatorNominator poolsLiquid stakingCustom overlaysUtilitiesTelegram alertingBackupBTC TeleportStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationMyTonCtrl referenceBackupEcosystemBlockchain nodeMyTonCtrl referenceBackupCopy pageMyTonCtrl bundles helper scripts for creating and restoring node backups.Copy pageExporting and restoring backups exposes private keys and validator configuration. Keep backups securely. ​Operational notes Backups capture MyTonCtrl data, validator config, and keyring files. Always store backup archives securely (they contain private keys). Restoration overwrites existing configuration. Ensure the donor node is offline before restoring its backup to avoid data divergence. Both scripts expect sudo or equivalent privileges when manipulating system files. Use the -u flag to match the original install user if necessary. ​Validator automated backups To enable automated backups (only in validator mode), call set auto_backup true on the MyTonCtrl console. These backups will be performed immediately after the node participates in the elections, ensuring that all data needed for the upcoming validation cycle is preserved. By default, automated backups are saved to /tmp/mytoncore/auto_backups/. Call set auto_backup_path <path> to change this path. Automated backups older than 7 days are deleted automatically. ​Standby node It is recommended to maintain at least one standby node that can take over validation duties if the main machine fails. The standby machine should be hosted at a different physical location/ISP. It should have MyTonCtrl installed in full node mode and be synchronized with the TON Blockchain network. Hardware sizing should match main validator configuration. Use create_backup and restore_backup commands described below to transfer validator config to the standby machine. Before transferring the validator configuration to the standby machine, make sure to stop or disable the TON node on the donor machine for approximately 20 minutes. Failure to follow this step may lead to connectivity issues and crashes on both the donor and target machines. Create and retain a backup of standby node’s original configuration before applying or restoring a backup package from another machine. This backup is needed to revert the standby node back to standby mode. ​create_backup Purpose: Generate a compressed archive containing MyTonCtrl configuration, keyring, and validator data. Syntax CopyAsk AIcreate_backup [filename] [-u <user>] Behavior Creates a snapshot of the following data: Node configuration file located at (/var/ton-work/db/config.json) Node keyring found in (/var/ton-work/db/keyring) Node liteserver and console keys stored in (/var/ton-work/keys) MyTonCtrl configuration database and related files located at (~/.local/share/mytoncore) Wallet and pool data Validates the snapshot (ensures the config and database files deserialize) before compressing it into a .tar.gz; defaults to mytonctrl_backup_<hostname>_<timestamp>.tar.gz unless filename specified. Sets archive ownership back to the requested user (-u) and removes the temporary snapshot when done, printing create_backup - OK or ... - Error based on the helper script exit code. Examples CopyAsk AIcreate_backup create_backup mynode-backup-2024-05-01.tar -u validator ​restore_backup Purpose: Restore a previously created backup archive into the current node environment. Syntax CopyAsk AIrestore_backup <filename> [-y] [--skip-create-backup] [-u <user>] Behavior Requires the backup archive filename. Optional flags: -y skips the interactive confirmation prompt. --skip-create-backup prevents MyTonCtrl from making a safety backup of the current state before restoring. -u <user> runs the restore operations as the specified system user (defaults to the current user). Unless --skip-create-backup passed, first runs create_backup so the state can be rolled back if the restore fails. Stops validator and mytoncore services, and restores data from the backup, except for IP address, which will be updated accordingly. On success, reloads MyTonCtrl’s local database, reinstalls BTC Teleport if validator mode is active, prints restore_backup - OK, and exits so MyTonCtrl can be restarted with the restored state. Examples CopyAsk AIrestore_backup mynode-backup-2024-05-01.tar restore_backup mynode-backup-2024-05-01.tar -y --skip-create-backup -u validator Was this page helpful?YesNoSuggest editsRaise issuePreviousBTC TeleportThe BTC Teleport module manages the optional Bitcoin bridge (Teleport) client shipped with MyTonCtrl. Use these commands to inspect proposals, vote on them, or remove the Teleport installation when no longer needed.Next⌘IgithubxtelegramPowered by MintlifyOn this pageOperational notesValidator automated backupsStandby nodecreate_backuprestore_backup",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:33:58.119Z"
  },
  {
    "id": "docs-ton-org--contract-dev-testing-overview",
    "title": "Overview",
    "url": "https://docs.ton.org/contract-dev/testing/overview",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingOverviewReferenceDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationTestingOverviewContract developmentTestingOverviewCopy pageCopy pageTON Sandbox (@ton/sandbox) is a local blockchain emulator that allows you to test smart contracts from TypeScript, without deploying them to a real network, and without running a blockchain node. It provides a complete testing environment that closely mimics the behavior of the actual TON blockchain. Blueprint project template already includes the @ton/sandbox dependency. The companion @ton/test-utils helper library provides matchers for writing tests with Jest. This guide covers everything you need to know about writing, running, and debugging tests for your smart contracts. For other programming languages consult documentation of corresponding SDKs. ​Sandbox vs real network FeatureSandboxReal NetworkSpeedInstant execution~5-15 second finalityCostFreeRequires real TONDeterministicYesNo (depends on network conditions)DebuggingFull introspectionLimited visibilityState ControlComplete controlImmutable history ​Sandbox limitations While Sandbox closely emulates the real network, there are some differences to be aware of: Time-dependent contracts: Sandbox time is controlled, not real-time External dependencies: Cannot interact with real external contracts, but can get their state and emulate them Blockchain imitation: Because there is no concept of blocks in Sandbox, things like sharding do not work. ​Writing tests Blueprint uses Jest as the default testing framework, providing powerful assertion capabilities and excellent TypeScript support. ​Basic test setup Every Blueprint project includes a test template. Here’s the standard structure: tests/MyContract.spec.tsCopyAsk AIimport { Blockchain, SandboxContract, TreasuryContract } from '@ton/sandbox'; import { Cell, toNano } from '@ton/core'; import { MyContract } from '../wrappers/MyContract'; import '@ton/test-utils'; import { compile } from '@ton/blueprint'; describe('MyContract', () => { let code: Cell; beforeAll(async () => { code = await compile('MyContract'); }); let blockchain: Blockchain; let deployer: SandboxContract<TreasuryContract>; let myContract: SandboxContract<MyContract>; beforeEach(async () => { blockchain = await Blockchain.create(); myContract = blockchain.openContract( MyContract.createFromConfig({}, code) ); deployer = await blockchain.treasury('deployer'); const deployResult = await myContract.sendDeploy( deployer.getSender(), toNano('0.05') ); expect(deployResult.transactions).toHaveTransaction({ from: deployer.address, to: myContract.address, deploy: true, success: true, }); }); it('should deploy', async () => { // Contract is already deployed in beforeEach // Add additional deployment checks here }); }); See all 44 lines ​Test isolation Each test should include a fresh Blockchain instance to ensure: Test isolation No state leakage between tests Predictable initial conditions Independent contract deployments Clean environment Fresh treasury wallets Reset logical time and configuration Clear transaction history CopyAsk AIbeforeEach(async () => { // Fresh blockchain for each test blockchain = await Blockchain.create(); // Each test gets clean treasuries deployer = await blockchain.treasury('deployer'); user = await blockchain.treasury('user'); }); ​Understanding transaction results When you send a message to a contract, you receive a SendMessageResult containing: CopyAsk AIconst result = await contract.sendIncrement(user.getSender(), toNano('0.1')); // result.transactions - Array of all transactions in the chain // result.events - Blockchain events emitted // result.externals - External messages generated ​Transaction matchers Blueprint provides powerful matchers for validating transactions: CopyAsk AIexpect(result.transactions).toHaveTransaction({ from: user.address, to: contract.address, value: toNano('1'), op: 0x12345678, // Operation code success: true, outMessagesCount: 2, // Number of outbound messages deploy: false, body: beginCell() .storeUint(0, 32) // Comment op .storeStringTail(\"Hello, user!\") .endCell() }); ​Running tests CopyAsk AI# Run all tests npx blueprint test # Run specific test file npx blueprint test MyContract # Run with coverage npx blueprint test --coverage # Run with gas reporting npx blueprint test --gas-report ​Common pitfalls Avoid These Common Mistakes Shared State: Don’t reuse blockchain instances between tests Async Issues: Always await blockchain operations Time Dependencies: Use blockchain.now for time-sensitive tests Gas Limits: Be aware of the computation and action phase limits Message Ordering: Remember that message processing is sequential Treasury Reuse: Use unique seeds for different test scenarios ​Debugging checklist When tests fail, check these common issues: ✅ Contract is properly deployed before testing ✅ Treasury has sufficient balance for operations ✅ Transaction matchers use correct field names ✅ Exit codes match expected error conditions ✅ Message bodies are correctly formatted ✅ Time-sensitive operations account for blockchain time ​Other resources Debug Guide — Advanced debugging techniques TON Dev Wallet — Visual debugging tool Was this page helpful?YesNoSuggest editsRaise issuePreviousReferenceNext⌘IgithubxtelegramPowered by MintlifyOn this pageSandbox vs real networkSandbox limitationsWriting testsBasic test setupTest isolationUnderstanding transaction resultsTransaction matchersRunning testsCommon pitfallsDebugging checklistOther resources",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "deployment",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:33:59.714Z"
  },
  {
    "id": "docs-ton-org--tvm-tools-tvm-explorer",
    "title": "TVM Explorer",
    "url": "https://docs.ton.org/tvm/tools/tvm-explorer",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsTxTracerRetracerTVM ExplorerTON DecompilerInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationToolsTVM ExplorerTVM: TON Virtual MachineToolsTVM ExplorerCopy pageCopy pageTVM Explorer is an interactive tool for exploring TVM assembly. Use it to see how your Fift code compiles to TVM assembly. It allows examining TVM bitcode and understanding instruction behavior; seeing how Fift code translates to TVM instructions. For more modern languages use TxTracer’s Playground. Was this page helpful?YesNoSuggest editsRaise issuePreviousTON DecompilerNext⌘IgithubxtelegramPowered by Mintlify",
    "category": "infrastructure",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:34:01.947Z"
  },
  {
    "id": "docs-ton-org--foundations-actions-set-code",
    "title": "Set code",
    "url": "https://docs.ton.org/foundations/actions/set-code",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsOverviewSend messageReserve coinsSet codeChange libraryConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationActionsSet codeBlockchain foundationsActionsSet codeCopy pageCopy pageSetting a code is one of the actions that a smart contract can perform during the action phase. It can get into the out action list by: The SETCODE instruction. The POPCTR instruction. The set code action consists of a cell containing the new code of a smart contract. If there are several such actions in the action phase, the smart contract code, upon successful completion of the action phase, will be changed to the one specified in the last one. If the action phase fails, the code change will not be applied, even if the set code action was processed successfully. The only error that can happen when processing a set code action is that the action cell does not match the expected TL-B scheme. ​Serialization CopyAsk AIaction_set_code#ad4de08e new_code:^Cell = OutAction; Was this page helpful?YesNoSuggest editsRaise issuePreviousChange libraryNext⌘IgithubxtelegramPowered by MintlifyOn this pageSerialization",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:34:04.255Z"
  },
  {
    "id": "docs-ton-org--foundations-actions-change-library",
    "title": "Change library",
    "url": "https://docs.ton.org/foundations/actions/change-library",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsOverviewSend messageReserve coinsSet codeChange libraryConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationActionsChange libraryBlockchain foundationsActionsChange libraryCopy pageCopy pageChange a library is one of the actions that a smart contract can perform during the action phase. It adds libraries to or removes them from the collection of libraries of this smart contract. It can be appended to an out action list by: The SETLIBCODE instruction. The CHANGELIB instruction. The POPCTR instruction. The change library action consists of a 7-bit bitmask mode specifying the way of changing the library; a ref to a cell containing the new library code or the hash of this code as an unsigned 256-bit integer. ​Modes The mode can have the following values that can be combined together: Mode valueConvenient nameDescription0RemoveLibraryDefault mode. Removes library if it was in the collection. Otherwise, action does nothing.+1AddPrivateLibraryA library is added as a private library.+2AddPublicLibraryA library is added as a public library and becomes available to all smart contracts in all workchains if the current smart contract resides in the masterchain. If current contract is in other workchain, works as AddPrivateLibrary.+16BounceOnFailBounces the transaction if the action fails. The other values of mode are invalid and lead to an error. Simultaneous usage of the AddPrivateLibrary and AddPublicLibrary modes also leads to an error. If the library was present in the collection before, its public/private status is changed according to the mode. ​Serialization CopyAsk AIlibref_hash$0 lib_hash:bits256 = LibRef; libref_ref$1 library:^Cell = LibRef; action_change_library#26fa1dd4 mode:(## 7) libref:LibRef = OutAction; Was this page helpful?YesNoSuggest editsRaise issuePreviousCatchain & BCP visualizerInteractive visual simulation of Catchain + BCP roundsNext⌘IgithubxtelegramPowered by MintlifyOn this pageModesSerialization",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:34:06.377Z"
  },
  {
    "id": "docs-ton-org--languages-func-libraries",
    "title": "Other FunC libraries",
    "url": "https://docs.ton.org/languages/func/libraries",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCOverviewCookbookLanguageLibrariesStandard libraryOther librariesChangelogKnown issuesTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationLibrariesOther FunC librariesLanguagesFunCLibrariesOther FunC librariesCopy pageCopy page​Standard libraries stdlib: the FunC standard library mathlib: the FunC fixed-point math library ​Libraries from community continuation-team/openlib.func: reduces transaction fees in common scenarios. open-contracts/utils: utility library. open-contracts/strings: provides string manipulation functions. open-contracts/math: extends FunC arithmetic operations with additional math functions. open-contracts/tuples: collection of tuple-related functions for FunC. open-contracts/crypto: provides cryptographic operations for secp256k1 curves. toncli/test-libs: supports TL-B schema operations, including message and type parsing and generation. ston-fi/funcbox: collection of FunC snippets and utilities. Was this page helpful?YesNoSuggest editsRaise issuePreviousChangelogNext⌘IgithubxtelegramPowered by MintlifyOn this pageStandard librariesLibraries from community",
    "category": "languages",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:34:08.240Z"
  },
  {
    "id": "docs-ton-org--tvm",
    "title": "Overview",
    "url": "https://docs.ton.org/tvm",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationTVM: TON Virtual MachineOverviewTVM: TON Virtual MachineOverviewCopy pageCopy pageTON Virtual Machine (TVM) is a stack-based virtual machine which executes smart contracts on TON blockchain. TVM is invoked when a message is sent to an account that has deployed contract code, when a get method is called on an account, and in some more rare cases. Executing code on same inputs and prior state deterministically produces same outputs, so that validators can agree on whether code was executed correctly. Every instruction consumes gas. Gas exhaustion stops execution. This limit is imposed so that expensive computations (i.e. infinite loops) cannot be used to exhaust validators’ computation resources, causing denial of service. ​Data model TVM has no random-access memory. Instead it uses a stack of values as a scratchpad. There are no memory addresses. Most instructions either store their parameters directly in the code, or take them from the top of the stack. All values are immutable. Most of the data is stored as immutable tree of cells. Reading and writing of cells is done with slices and builders. There are no function addresses or function pointers. Code is executed from bitcode inside continuations. ​TVM state On incoming messages or get method call, a new instance of TVM is started, with a new state. Derivation of the initial state from the message is described in its own article. The total state of TVM consists of the following components: Stack. A regular stack data structure. The vast majority of instructions pop() operands from the top and push() results back. Control registers. A small fixed set of special registers, denoted as c0, c1, …, c5, and c7 (c6 does not exist). Gas counter. Tracks remaining computation budget. Each instruction decrements gas. When counter hits zero/negative value, an exception is raised, and the run aborts. Current continuation (cc). A special register that stores a list of the next instructions to execute. Similar to the instruction pointer in traditional architectures. Current codepage (cp). Determines how to decode the next instruction in cc. Different codepages may implement different instruction sets, allowing for adding new features to TVM without affecting old smart contracts. Currently, only codepage 0 (cp0) is implemented. Smart contract runs SETCP0 instruction to explicitly use codepage 0. ​TVM data types Values on the stack and inside of registers are of one of the following seven types: TypeDescriptionInteger257-bit signed integer. Has the special NaN value representing arithmetic faults.CellNode of a tree with bit string on it (<= 1023 bits), and up to 4 arrows (refs).SliceRead cursor over a Cell.BuilderWrite cursor to construct a new Cell.TupleList of 0..255 elements of any of seven types. Types of elements can be distinct.ContinuationExecutable Slice with TVM bitcode. Continuations are callable like functions.NullEmpty value. ​Example of a smart contract: counter Here is a sample contract, written in Fift. It implements the following logic: If an event is not an internal message, stop execution. Read 32-bit number (msg_counter) from internal message’s body. Check that it is equal to the 32-bit number stored in c4 (persistent account storage). Increment it. Save it back to c4. When an account with this code gets an internal message, TVM stack is initialized with these values: s0 (top of the stack), function selector, is 0. For other events, e.g., external messages or get method calls, selector will be non-zero. s1, message body. The example contract expects exactly 32 bits here. Three more values s2, s3, s4 are pushed by TVM onto a stack. They won’t be used in the example. After execution finishes, they’ll still be on the stack, and will be silently ignored. In Current stack comments, we represent stack at that moment of execution, keeping its top to the right (e.g., s2 s1 s0, where s0 is the top of the stack). FiftCopyAsk AI<{ // Current stack: msg_body selector // Use codepage 0. Picks the only available instruction set. SETCP0 // This instruction does not affect the stack. // Current stack: msg_body selector // Consume `selector` from the top of the stack. // Stop execution if `selector != 0`, // i.e. \"is not an internal message\". IFRET // Continue execution if we received an internal message. // Current stack: msg_body // Load (LD) unsigned (U) 32-bit integer from a slice. // This instruction pops (consumes) a slice from the stack, // pushes an integer, and then pushes a new slice with // 32 bits cut from it 32 LDU // Current stack: msg_counter msg_body' // msg_body' is a slice whose read cursor was moved by 32 bits // when we loaded a 32-bit integer. // For example, if we had slice x{00000001} on the stack and // then invoked 32 LDU, there will be integer `1` and `x{}` // (empty slice) on the stack // Assert the END of a slice (S). // These instructions consume a slice and check that it is // empty (no more data to read), otherwise it throws an // exception, because there was more data than we expected. ENDS // Current stack: msg_counter // Push c4 (persistent storage) on the stack. // `storage` is a cell c4 PUSH // Current stack: msg_counter storage // Convert Cell to a Slice, i.e. make it readable CTOS // Current stack: msg_counter storage_slice // Read 32-bit unsigned integer from `storage_slice` 32 LDU // Current stack: msg_counter storage_counter storage_slice' // Assert there is no more data in the storage ENDS // Current stack: msg_counter storage_counter // Duplicate s0 (top of stack) under two top values TUCK // Current stack: storage_counter msg_counter storage_counter // Check counters are equal EQUAL // Current stack: storage_counter msg_counter==storage_counter? // Throw an exception with code 33 if it is not equal 33 THROWIFNOT // Current stack: storage_counter // Increase counter INC // Current stack: storage_counter+1 // Create an empty Builder NEWC // Current stack: storage_counter+1 builder // Store (ST) unsigned (U) 32-bit integer `storage_counter+1` to a builder 32 STU // Current stack: builder' // Finalize Builder to a Cell ENDC // Current stack: new_storage // Save `new_storage` to c4 (persistent storage) c4 POP // Current stack: (no values) }> Was this page helpful?YesNoSuggest editsRaise issuePreviousTxTracerNext⌘IgithubxtelegramPowered by MintlifyOn this pageData modelTVM stateTVM data typesExample of a smart contract: counter",
    "category": "infrastructure",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:34:11.522Z"
  },
  {
    "id": "docs-ton-org--languages-func-statements",
    "title": "FunC statements",
    "url": "https://docs.ton.org/languages/func/statements",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCOverviewCookbookLanguageCommentsTypesLiteralsOperatorsExpressionsStatementsProgram declarationsReserved words and built-insDictionariesLibrariesChangelogKnown issuesTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationLanguageFunC statementsLanguagesFunCLanguageFunC statementsCopy pageCopy pageFunC statements can occur anywhere inside function bodies. ​Expression statements The most common type of statement is the expression statement—an expression followed by ;. See the FunC expressions article for details on the allowed expressions. ​return statement The return statement ends function execution and specifies a value to be returned to the function caller. Any statement after the return statement is not executed. In this example, the return statement instructs the function to halt execution and produce x + 1 as a result. CopyAsk AIint inc(int x) { return x + 1; } In this example, only the first return executes: CopyAsk AIint inc(int x) { return x + 1; return x; } ​Block statement A block statement is used to group zero or more statements. The block is delimited by a pair of curly braces { ... }. A block statement also defines a scope, in which variables defined in the block are accessible only in the block or in nested blocks. For example: CopyAsk AIint x = 1; int y = 2; { ;; x and y are accessible in this block. int z = x + y; { ;; x, y, and z are accessible in this block. int w = z; ;; The block declares w, ;; which is only accessible in this block. } ;; w is no longer accessible here. ;; x, y, and z are still accessible here. } ;; z is no longer accessible here, but x and y are. ​Conditional statements These statements control the flow of the code based on a condition. ​if...else statement When executing an if...else statement, first, the specified condition is evaluated. If the condition evaluates to an integer different from 0, see absence of boolean type, the block after the condition is executed. Otherwise, if the condition evaluates to 0, the optional else block is executed. If the else block is missing, nothing happens, and execution continues further. Examples: CopyAsk AI;; The condition evaluates to -1, so the block executes if (1 < 10) { do_something(); } CopyAsk AI;; The condition evaluates to 0, so the block does not execute if (11 < 10) { do_something(); } ;; No else is provided. So, execution continues here, after the block. CopyAsk AI;; The condition evaluates to 0, so the block does not execute if (11 < 10) { do_something(); } else { ;; else is provided. So, the else block executes. handle_else(); } Curly brackets {} are required in each block of an if...else statement. For example, the following code will not compile: CopyAsk AIif (1 < 10) { do_something(); } else if (2 > 1) { ;; else block must have curly brackets do_something2(); } That is because the else block must have curly brackets: CopyAsk AIif (1 < 10) { do_something(); } else { ;; else block now has curly brackets if (2 > 1) { do_something2(); } } The above example can be written in a simpler form by using the elseif keyword, to avoid the need to write several nested curly brackets in the else case: CopyAsk AIif (1 < 10) { do_something(); } elseif (2 > 1) { do_something2(); } In general, the elseif keyword is useful for stating several alternative cases: CopyAsk AIif (cond) { do_1(); } elseif (cond2) { do_2(); } elseif (cond23) { do_3(); } else { do_4(); } The alternative cases can also include the elseifnot keyword, which allows the inclusion of ifnot statements in the alternatives: CopyAsk AIif (cond) { do_1(); } elseif (cond2) { ;; if in else case do_2(); } elseifnot (cond23) { ;; ifnot in else case do_3(); } else { do_4(); } ​ifnot...else statement The ifnot...else statement is equivalent to the if...else statement but with the condition negated using the bitwise ~ operator. More specifically: CopyAsk AIifnot (cond) { do_something(); } else { handle_else(); } is equivalent to: CopyAsk AIif (~ cond) { ;; Standard if..else, with condition negated using ~ do_something(); } else { handle_else(); } In other words, if the condition in the ifnot evaluates to 0, see absence of boolean type, the block after the condition is executed. Otherwise, if the condition evaluates to an integer different from 0, the optional else block is executed. If the else block is missing, nothing happens, and execution continues further. Examples: CopyAsk AIifnot (1 > 10) { ;; The condition evaluates to 0, the block executes do_something(); } CopyAsk AIifnot (11 > 10) { ;; The condition evaluates to -1, the block does not execute do_something(); } ;; No else is provided. Execution continues here, after the block. CopyAsk AIifnot (11 > 10) { ;; The condition evaluates to -1, the block does not execute do_something(); } else { ;; else is provided. The else block executes. handle_else(); } Similarly to the if...else, it is possible to use the keyword elseifnot to add several alternative cases: CopyAsk AIifnot (cond) { do_1(); } elseifnot (cond2) { do_2(); } elseifnot (cond23) { do_3(); } else { do_4(); } The alternative cases can also include the elseif keyword, which allows the inclusion of standard if statements in the alternatives: CopyAsk AIifnot (cond) { ;; ifnot do_1(); } elseif (cond2) { ;; if in else case do_2(); } elseifnot (cond23) { ;; ifnot in else case do_3(); } else { do_4(); } ​Loops FunC supports repeat, while, and do { ... } until loops. The for loop is not supported. ​repeat loop The repeat loop executes a block of code a specified number of times. The number of repetitions should be given as a positive 32-bit integer in the inclusive range from 1 to 2^31 - 1, i.e., 2,147,483,647. If the value is greater, an error with exit code 5, Integer out of expected range, will be thrown. CopyAsk AIint x = 1; repeat(10) { ;; Repeats the block 10 times. x *= 2; ;; Each iteration multiplies x by 2. } ;; x has value 1024 CopyAsk AIint x = 1; int y = 10; repeat(y + 6) { ;; Repeats the block 16 times. x *= 2; ;; Each iteration multiplies x by 2. } ;; x has value 65536 If the specified number of repetitions is equal to 0 or any negative number in the inclusive range from -2^256 to -1, it is ignored, and the code block is not executed at all. CopyAsk AIint x = 1; repeat(-1) { ;; Block does not execute. x *= 2; } ;; x has value 1 ​while loop The while loop continues executing the block of code as long as the given condition evaluates to an integer different from 0, see absence of boolean type. CopyAsk AIint x = 5; while (x < 10) { ;; Executes the block 5 times. ;; Each iteration increases x by 1. ;; The loop stops when x becomes 10. x += 1; } ;; x has value 10 ​do...until loop The do...until loop is a post-test loop that executes the block of code at least once and then continues to execute it until the given condition evaluates to an integer different from 0, see absence of boolean type. CopyAsk AIint x = 0; do { ;; The block always executes at least once x += 3; } until (x % 9 == 0); ;; Executes the block 3 times. ;; Each iteration increases x by 3. ;; The loop stops when x becomes divisible by 9. ;; x has value 9 ​try...catch statement Available in FunC since v0.4.0 The try...catch statement consists of a try block and a catch block. The code in the try block is executed first, and if it fails, all changes made within the try block are rolled back, and the catch block is executed instead. The catch block has two arguments, which are local to the catch block: The exception parameter, which can be of any type. Used to provide extra information about the error. The error code, an integer, which identifies the kind of error. CopyAsk AItry { do_something(); } catch (x, n) { ;; x is the exception parameter ;; n is the error code handle_exception(); } Unlike many other languages, in FunC, all changes are undone if an error occurs inside the try block. These modifications include updates to local and global variables and changes to control registers. For example, c4 for storage, c5for action/messages, c7 for context, etc. Any contract storage updates and outgoing messages are also reverted. However, certain TVM state components are not rolled back, such as: Codepage settings Gas counters As a result, all gas consumed within the try block is still accounted for, and any modifications carried out by operations that change gas limits (e.g., accept_message or set_gas_limit) will remain in effect. In this example: CopyAsk AIint x = 0; try { x += 1; ;; x now has value 1 throw(100); } catch (arg, e) { ;; x is rolled back to value 0. x += 2; } ;; Here, x has value 2. although x is incremented to 1 inside the try block, the modification is rolled back due to the exception produced by the throw function. Hence, x has value 0 at the moment the catch block starts execution. However, the gas consumed inside the try block is not rolled back when the catch block starts execution. ",
    "category": "languages",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:34:13.467Z"
  },
  {
    "id": "docs-ton-org--languages-func-built-ins",
    "title": "FunC reserved words and built-ins",
    "url": "https://docs.ton.org/languages/func/built-ins",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCOverviewCookbookLanguageCommentsTypesLiteralsOperatorsExpressionsStatementsProgram declarationsReserved words and built-insDictionariesLibrariesChangelogKnown issuesTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationLanguageFunC reserved words and built-insLanguagesFunCLanguageFunC reserved words and built-insCopy pageCopy page​Reserved keywords FunC reserves the following symbols and words. These cannot be used as identifiers. ​Symbols + - * / % ? : , ; ( ) [ ] { } = _ < > & | ^ ~ == != <= >= <=> << >> ~>> ^>> ~/ ^/ ~% ^% /% += -= *= /= ~/= ^/= %= ~%= ^%= <<= >>= ~>>= ^>>= &= |= ^= -> ​Words return var repeat do while until try catch if ifnot then else elseif elseifnot int cell slice builder cont tuple type forall extern global asm impure inline inline_ref auto_apply method_id operator infix infixl infixr const #pragma #include ​Built-ins This section covers extra language constructs that are not part of the core but are still important for functionality. Although they could be implemented in stdlib.fc, keeping them as built-in features allows the FunC optimizer to work more efficiently. In addition, FunC does not allow the built-in names in this section to be used as identifiers. However, there is an exception: built-ins with non-symbolic names can be used as identifiers for local variables. ​Built-ins with symbolic names _+_ _-_ -_ _*_ _/_ _~/_ _^/_ _%_ _~%_ _^%_ _/%_ _<<_ _>>_ _~>>_ _^>>_ _&_ _|_ _^_ ~_ ^_+=_ ^_-=_ ^_*=_ ^_/=_ ^_~/=_ ^_^/=_ ^_%=_ ^_~%=_ ^_^%=_ ^_<<=_ ^_>>=_ ^_~>>=_ ^_^>>=_ ^_&=_ ^_|=_ ^_^=_ _==_ _!=_ _<_ _>_ _<=_ _>=_ _<=>_ Each one of the above names is a function wrapping the corresponding operator. For example, _+_ can be understood as wrapping the + operator: CopyAsk AIint _+_(int a, int b) { return a + b; } These functions are useful when operators need to be passed as arguments to functions, or assigned to variables. For example, in the following snippet, function apply receives as argument a function f of type (int, int) -> int and applies it on the arguments 2 and 3: CopyAsk AIint apply(((int, int) -> int) f) { return f(2, 3); } Then, it is possible to invoke apply by passing _+_: CopyAsk AIapply(_+_); ;; Returns 5 Attempting to pass the operator + directly does not compile: CopyAsk AIapply(+); ;; DOES NOT COMPILE ​Built-ins with non-symbolic names divmod ~divmod moddiv ~moddiv muldiv muldivr muldivc muldivmod true false nil Nil null? throw throw_if throw_unless throw_arg throw_arg_if throw_arg_unless load_int load_uint preload_int preload_uint store_int store_uint ~store_int ~store_uint load_bits preload_bits int_at cell_at slice_at tuple_at at touch ~touch touch2 ~touch2 ~dump ~strdump run_method0 run_method1 run_method2 run_method3 ​divmod CopyAsk AI(int, int) divmod(int dividend, int divisor) divmod takes two integers as input and returns the quotient and remainder of their division dividend / divisor. ​~divmod Same as divmod, but allows using modifying notation. Example: CopyAsk AIint a = 10; int b = 2; ;; \"mod\" stores the modulo 10 % 2 ;; and \"a\" gets updated with the quotient of 10 / 2 int mod = a~divmod(b); ;; Here, a has value 5 ;; mod has value 0 ;; b has value 2 ​moddiv CopyAsk AI(int, int) moddiv(int dividend, int divisor) moddiv takes two integers as input and returns the remainder and quotient of their division dividend / divisor. ​~moddiv Same as moddiv, but allows using modifying notation. Example: CopyAsk AIint a = 10; int b = 2; ;; \"div\" stores the quotient of 10 / 2 ;; and \"a\" gets updated with the modulo 10 % 2 int div = a~moddiv(b); ;; Here, a has value 0 ;; div has value 5 ;; b has value 2 ​muldiv CopyAsk AIint muldiv(int factor1, int factor2, int divisor) muldiv performs a multiply-then-divide operation (factor1 * factor2) / divisor, where / is the division operator. It uses a 513-bit intermediate result to prevent overflow if the final result fits within 257 bits. ​muldivr CopyAsk AIint muldivr(int factor1, int factor2, int divisor) muldivr performs a multiply-then-divide operation (factor1 * factor2) ~/ divisor, where ~/ is the rounding division operator. It uses a 513-bit intermediate result to prevent overflow if the final result fits within 257 bits. ​muldivc CopyAsk AIint muldivc(int factor1, int factor2, int divisor) muldivc performs a multiply-then-divide operation (factor1 * factor2) ^/ divisor, where ^/ is the ceiling division operator. It uses a 513-bit intermediate result to prevent overflow if the final result fits within 257 bits. ​muldivmod CopyAsk AI(int, int) muldivmod(int factor1, int factor2, int divisor) muldivmod performs a multiply-then-divide operation (factor1 * factor2) / divisor, where / is the division operator, and returns the quotient and remainder of such division. It uses a 513-bit intermediate result to prevent overflow if the final result fits within 257 bits. ​true true is an alias for -1. ​false false is an alias for 0. ​nil nil is an alias for the null value. ​Nil Nil is an alias for the empty tuple []. ​null? CopyAsk AIforall X -> int null?(X val) null? checks if the given argument is null. Returns 0 if the argument is not null, and -1 otherwise. For more info, see null values. ​throw CopyAsk AI() throw(int error) Triggers an exception, which interrupts the execution flow. throw takes only one argument, the error code. See TVM error codes for details about error codes. ​throw_if CopyAsk AI() throw_if(int error, int condition) Triggers an exception only if the provided condition is true, i.e., if the condition is -1. It receives two arguments: the error code, which defines the exception type, and the condition. See TVM error codes for details about error codes. ​throw_unless CopyAsk AI() throw_unless(int error, int condition) Triggers an exception only if the provided condition is false, i.e., if the condition is 0. It receives two arguments: the error code, which defines the exception type, and the condition. See TVM error codes for details about error codes. ​throw_arg CopyAsk AIforall X -> () throw_arg(X arg, int error) Triggers an exception, which interrupts the execution flow. The first argument can be of any type, and it is used to pass extra information about the error. This extra information can be processed in try..catch statements. Refer to the try..catch statement page for an example on how to use the first argument. The second argument is the error code. See TVM error codes for details about error codes. ​throw_arg_if CopyAsk AIforall X -> () throw_arg_if(X arg, int error, int condition) Triggers an exception only if the provided condition is true, i.e., if the condition is -1. Similarly to throw_arg, the first argument can be of any type, and it is used to pass extra information about the error. This extra information can be processed in try..catch statements, in the same way as with throw_arg. The second argument is the error code. See TVM error codes for details about error codes. The third argument is the condition to check. ​throw_arg_unless CopyAsk AIforall X -> () throw_arg_unless(X arg, int error, int condition) Triggers an exception only if the provided condition is false, i.e., if the condition is 0. Similarly to throw_arg, the first argument can be of any type, and it is used to pass extra information about the error. This extra information can be processed in try..catch statements, in the same way as with throw_arg. The second argument is the error code. See TVM error codes for details about error codes. The third argument is the condition to check. ​load_int CopyAsk AI(slice, int) load_int(slice s, int len) Reads a signed len-bit integer from slice s. Returns the modified slice and the obtained integer. ​load_uint CopyAsk AI(slice, int) load_uint(slice s, int len) Reads an unsigned len-bit integer from slice s. Returns the modified slice and the obtained unsigned integer. ​preload_int CopyAsk AIint preload_int(slice s, int len) Reads a signed len-bit integer from slice s. Returns the obtained integer. This method does not modify slice s. ​preload_uint CopyAsk AIint preload_uint(slice s, int len) Reads an unsigned len-bit integer from slice s. Returns the obtained unsigned integer. This method does not modify slice s. ​store_int CopyAsk AIbuilder store_int(builder b, int x, int len) Stores a signed len-bit integer x in builder b. Returns the modified builder. ​store_uint CopyAsk AIbuilder store_uint(builder b, int x, int len) Stores an unsigned len-bit integer x in builder b. Returns the modified builder. ​~store_int CopyAsk AI(builder, ()) ~store_int(builder b, int x, int len) Same as store_int, but adapted to use modifying notation. ​~store_uint CopyAsk AI(builder, ()) ~store_uint(builder b, int x, int len) Same as store_uint, but adapted to use modifying notation. ​load_bits CopyAsk AI(slice, slice) load_bits(slice s, int len) Loads the first len bits from slice s. It returns the modified slice ",
    "category": "languages",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:34:14.804Z"
  },
  {
    "id": "docs-ton-org--languages-func-operators",
    "title": "FunC operators",
    "url": "https://docs.ton.org/languages/func/operators",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCOverviewCookbookLanguageCommentsTypesLiteralsOperatorsExpressionsStatementsProgram declarationsReserved words and built-insDictionariesLibrariesChangelogKnown issuesTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationLanguageFunC operatorsLanguagesFunCLanguageFunC operatorsCopy pageCopy pageThis page lists all the operators in FunC in decreasing order of their precedence, with examples of usage. ​Table of operators Currently, all the unary and binary operators are integer operators. Logical operators are bitwise integer operators (cf. absence of boolean type). The following table lists operators in order of decreasing precedence, from highest to lowest. Brief descriptionOperatorsParentheses( )Unary bitwise NOT~Multiplicative* / ^/ ~/ % ^% ~% /% &Unary integer negation-Additive+ -(integer subtraction) | ^Shifts>> << ^>> ~>>Comparison and Equality> >= < <= <=> == !=Ternary?:Assignment= and all augmented assignment operators All binary operators are left-associative, with the exception of: Assignment operators (i.e., bottom row in the table), which are right-associative. Division-modulo operator /%, which is neither left associative nor right associative. Also, the ternary operator ?: is right-associative. For example: 1 - 2 + 3 parses as (1 - 2) + 3, producing 2 as result. a = b += c = 10 parses as (a = (b += (c = 10))), producing the final values c = 10, b = 11, and a = 11, under the assumption that b had value 1 initially. 0 ? a : 1 ? b : c parses as 0 ? a : (1 ? b : c), producing b as a result. 3 /% 5 /% 7 does not compile, neither (3 /% 5) /% 7 nor 3 /% (5 /% 7). In expressions, all operators should be separated from their arguments, otherwise the expression is interpreted as an identifier.For example: - x - Negates x. -x - Interpreted as a single identifier, not an operation. x + y - Adds x and y. x+y - Interpreted as a single identifier, not an operation. ​Precedence Precedence is used to determine which operator should be considered in a particular situation. Whenever ambiguity arises, FunC prefers operators with higher precedence over those with lower precedence. For example, consider this expression: CopyAsk AI10 - 6 * 2 The expression is ambiguous because it could be parsed in two different ways: CopyAsk AI(10 - 6) * 2 ;; Evaluate first 10 - 6 10 - (6 * 2) ;; Evaluate first 6 * 2 However, since the multiplication operator * has higher precedence than the subtraction operator -, FunC will prefer to evaluate the multiplication first: CopyAsk AI10 - (6 * 2) ;; Evaluate first 6 * 2 Neglecting precedence rules can often lead to confusing situations with operators. The correct order of operations can be ensured by wrapping every operation in parentheses, since parentheses have the highest precedence of all expressions and operators. ​Parentheses Parentheses (also called round brackets, ()) are more punctuation symbols than actual operators, but their precedence is higher than the precedence of any other operator. Use parentheses to override the order of operations: CopyAsk AI5 * 5 - 2; ;; 23 5 * (5 - 2); ;; 15 ​Unary operators Unary here means that they are applied only to one operand of the given expression. All unary operators are prefix operators, i.e., placed before the operand. ​Bitwise NOT, ~ The tilde (bitwise NOT) operator ~ inverts or flips each bit in the binary representation of the expression, changing each 1 to 0, and vice versa. CopyAsk AIint answer = 42; ~ answer; ;; -43 ~ (~ answer); ;; 42 ~ (~ 0); ;; 0 The ~ operator also behaves as expected on -1 and 0, which are the emulated values for true and false: CopyAsk AI~ 0; ;; -1, NOT false is true ~ (- 1); ;; 0, NOT true is false Hence, ~ can work as logical NOT when computing boolean conditions: CopyAsk AI~ (1 <= 4); ;; 0, since 1 <= 4 returns true (-1) 1 > 4; ;; 0, logically equivalent to previous ​Negation, - The minus sign (negation) operator - reverses the sign of the expression. CopyAsk AIint five = 5; - five; ;; -5 - (- five); ;; 5 - (- 1); ;; 1 ​Binary operators Binary here means that they are applied to two operands of the given expression. All binary operators are infix operators, i.e., placed in the middle of the two operands. ​Multiplication, * The asterisk (multiplication) operator * is used for multiplication of two values. Going beyond the range of the integer type will result in an error with exit code 4: Integer overflow. CopyAsk AIint five = 5; five * 2; ;; 10 five * five; ;; 25 ​Division, / The slash (division) operator / is used for integer division of two values, which truncates toward zero if the result is positive and away from zero if the result is negative. This is also called rounding down or rounding toward negative infinity. An attempt to divide by zero results in an error with exit code 4: Integer overflow. CopyAsk AI(- 1) / 5; ;; -1, rounding down away from 0 (- 1) / (- 5); ;; 0, rounding down toward zero 1 / (- 5); ;; -1, rounding down away from 0 1 / 5; ;; 0, rounding down toward 0 6 / 5; ;; 1, rounding down toward 0 (- 6) / 5; ;; -2, rounding down away from 0 ​Ceiling division, ^/ The caret-slash (ceiling division) operator ^/ is used for integer division of two values, which truncates away from zero if the result is positive and toward zero if the result is negative. This is also called rounding up or rounding toward positive infinity. An attempt to divide by zero results in an error with exit code 4: Integer overflow. CopyAsk AI(- 1) ^/ 5; ;; 0, rounding up toward 0 (- 1) ^/ (- 5); ;; 1, rounding up away from zero 1 ^/ (- 5); ;; 0, rounding up toward 0 1 ^/ 5; ;; 1, rounding up away from 0 6 ^/ 5; ;; 2, rounding up away from 0 (- 6) ^/ 5; ;; -1, rounding up toward 0 ​Rounding division, ~/ The tilde-slash (rounding division) operator ~/ is used for integer division of two values, which truncates to the nearest integer but using the following tie-breaking rule for half values: if the fractional part is 0.5, it is truncated away from zero if the result is positive, and truncated toward zero if the result is negative. This is also called rounding half up or rounding half toward positive infinity. An attempt to divide by zero results in an error with exit code 4: Integer overflow. CopyAsk AI(- 6) ~/ 5; ;; -1, rounding -1.2 to nearest integer (- 6) ~/ (- 5); ;; 1, rounding 1.2 to nearest integer 8 ~/ (- 5); ;; -2, rounding -1.6 to nearest integer 8 ~/ 5; ;; 2, rounding 1.6 to nearest integer 3 ~/ 2; ;; 2, rounding half value 1.5 away from 0 (- 3) ~/ 2; ;; -1, rounding half value -1.5 toward 0 ​Modulo, % The percent sign (modulo) operator % is used for obtaining the modulo of integer division, which is the remainder of dividing the operands with the / operator. Concretely, a % b is defined as a - (b * (a / b)), where / is the division operator, * is the multiplication operator, and - is the subtraction operator. If b in the expression a % b is 0, the result is an error with exit code 4: Integer overflow. CopyAsk AI(- 6) % 5; ;; 4, result of formula: -6 - (5 * (-6 / 5)) (- 6) % (- 5); ;; -1, result of formula: -6 - (-5 * (-6 / -5)) 8 % (- 5); ;; -2, result of formula: 8 - (-5 * (8 / -5)) 8 % 5; ;; 3, result of formula: 8 - (5 * (8 / 5)) 3 % 2; ;; 1, result of formula: 3 - (2 * (3 / 2)) (- 3) % 2; ;; 1, result of formula: -3 - (2 * (-3 / 2)) The result of % always has the same sign as the divisor (i.e., b is the divisor in the expression a % b). This means that the modulo is not the same as the remainder from Euclidean division, because in Euclidean division the remainder is always non-negative, independently of the sign of the divisor. The modulo % and the remainder from Euclidean division coincide when both operands are non-negative. If you want to compute remainders as in Euclidean division by using the % operator, the best way is to use only unsigned integers. Alternatively, consider using the abs function to ensure non-negative values: CopyAsk AIabs(-3) % abs(-4) ;; 3, same as 3 % 4 ​Ceiling modulo, ^% The caret-percent sign (ceiling modulo) operator ^% is used for obtaining the ceiling modulo of integer ceiling division, which is the remainder of dividing the operands with the ^/ operator. Concretely, a ^% b is defined as a - (b * (a ^/ b)), where ^/ is the ceiling division operator, * is the multiplication operator, and - is the subtraction operator. If b in the expression a ^% b is 0, the result is an error with exit code 4: Integer overflow. CopyAsk AI(- 6) ^% 5; ;; -1, result of formula: -6 - (5 * (-6 ^/ 5)) (- 6) ^% (- 5); ;; 4, result of formula: -6 - (-5 * (-6 ^/ -5)) 8 ^% (- 5); ;; 3, result of formula: 8 - (-5 * (8 ^/ -5)) 8 ^% 5; ;; -2, result of formula: 8 - (5 * (8 ^/ 5)) 3 ^% 2; ;; -1, result of formula: 3 - (2 * (3 ^/ 2)) (- 3) ^% 2; ;; -1, result of formula: -3 - (2 * (-3 ^/ 2)) The result of ^% always has the opposite sign of the divisor (i.e., b is the divisor in the expression a ^% b). ​Rounding ",
    "category": "languages",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:34:18.713Z"
  },
  {
    "id": "docs-ton-org--languages-func-comments",
    "title": "FunC comments",
    "url": "https://docs.ton.org/languages/func/comments",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCOverviewCookbookLanguageCommentsTypesLiteralsOperatorsExpressionsStatementsProgram declarationsReserved words and built-insDictionariesLibrariesChangelogKnown issuesTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationLanguageFunC commentsLanguagesFunCLanguageFunC commentsCopy pageCopy pageFunC supports both single-line and multi-line comments. Single-line comments start with a double semicolon ;;. For example: CopyAsk AIint x = 1; ;; assigns 1 to x Multi-line comments begin with an opening curly brace and dash {- and end with a dash and closing curly brace -}. Unlike other languages, FunC allows nested multi-line comments. Example: CopyAsk AI{- This is a multi-line comment {- This is a comment inside a comment -} -} Single-line comments ;; can also appear inside multi-line comments. They take precedence over the multi-line comments {- -}. For example, in the following snippet, const a = 10; is inside a multi-line comment and is effectively commented out: CopyAsk AI{- Start of the comment ;; This comment’s ending is itself commented out -> -} const a = 10; ;; This comment’s beginning is itself commented out -> {- End of the comment -} Was this page helpful?YesNoSuggest editsRaise issuePreviousTypesNext⌘IgithubxtelegramPowered by Mintlify",
    "category": "languages",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:34:20.510Z"
  },
  {
    "id": "docs-ton-org--languages-func-literals",
    "title": "FunC literals",
    "url": "https://docs.ton.org/languages/func/literals",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCOverviewCookbookLanguageCommentsTypesLiteralsOperatorsExpressionsStatementsProgram declarationsReserved words and built-insDictionariesLibrariesChangelogKnown issuesTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationLanguageFunC literalsLanguagesFunCLanguageFunC literalsCopy pageCopy page​Number literals FunC supports decimal and hexadecimal integer literals, including those with leading zeros: Examples of valid integer literals: 0, 123, -17, 00987, and -0. Examples of valid hexadecimal literals: 0xef, 0xEF, 0x0, -0xfFAb, 0x0001, and -0x0. ​Identifiers FunC allows a broad range of identifiers for functions and variable names. Any single-line string that meets the following conditions qualifies as a valid identifier: It does not contain special symbols: ;, ,, (, ), [, ], spaces including tabs, ~, and .. It does not start as a comment or a string literal (i.e., with \" at the beginning). It is not a number literal. It is not an underscore _. It is not a reserved keyword. It is not the name of a built-in. Additionally, function names in function definitions can start with . or ~. FunC allows an exception regarding identifiers for local variables. Local variables can use the name of a built-in with a non-symbolic name. Examples of valid identifiers: query, query', query'' elem0, elem1, elem2 CHECK _internal_value message_found? get_pubkeys&signatures dict::udict_set_builder fatal! Examples of less common, but still valid identifiers: 123validname 2+2=2*2 -alsovalidname 0xefefefhahaha {hehehe} pa{--}in\"`aaa`\" Examples of valid function names: fun_a ~fun_a? ._how123 Examples of invalid identifiers: take(first)Entry - contains parentheses ( and ) \"not_a_string - starts with a \", like a string literal msg.sender - includes a . send_message,then_terminate - contains a , _ - just an underscore, which is not valid on its own pa;;in\"`aaa`\" - contains ; {-aaa-} - it is a comment aa(bb - contains an opening parenthesis 123 - a number literal _+_ - it is a reserved builtin name Special identifiers in backticks: FunC allows identifiers enclosed in backticks `. These identifiers can contain any characters except: Newline characters \\n Backticks ` themselves, except the opening and closing ones. Examples of valid backtick identifiers: `I'm a variable identifier too` `any symbols ; ~ () are allowed here...` Identifiers in FunC usually follow these naming conventions: Apostrophe ' at the end: used when a variable is a modified version of its original value. Example: CopyAsk AIcell dict' = udict_set(dict, 100, 0, v); Here, function udict_set updates key 0 with value v in dictionary dict. The updated dictionary name is dict'. Question mark ? at the end: typically used for boolean variables or functions that return a success flag. Example: CopyAsk AI(slice v, int found?) = udict_get?(dict, 100, 0); Here, function udict_get? looks up index 0 in dictionary dict, and returns the associated value v (if found) and a flag found? which indicates whether the index was found in the dictionary. ​Constants FunC allows defining compile-time constants that are substituted and pre-computed during compilation. Syntax: CopyAsk AIconst optional-type identifier = value-or-expression; optional-type (e.g., int or slice) is optional but improves readability and ensures type correctness. value-or-expressioncan be a literal or an expression involving literals and previously defined constants. Multiple constants can be defined in the same const declaration by separating them with ,. Example usage: CopyAsk AIconst int101 = 101; ;; Numeric constant const str1 = \"const1\", str2 = \"aabbcc\"s; ;; Multiple string constants separated with , const int int240 = (int101 * 10) << 3; ;; Constant computed from an expression const slice str2r = str2; ;; Constant referencing another constant Numeric constants are replaced during compilation, which means that all optimizations and pre-computations apply efficiently. ​Compile-time built-ins FunC has a special syntax for compile-time operations that compute slices and integer hashes out of ASCII strings. These compile-time operations are invoked by enclosing the ASCII string in double quotes \", followed by a suffix representing the compile-time operation to apply on the string, like: CopyAsk AI\"this is a string\"u where the suffix u represents the compile-time operation to invoke on the ASCII string. These built-ins are evaluated during compilation time, which means that the FunC compiler replaces the built-in call anywhere it occurs with the result of the call. In particular, it is possible to use these compile-time built-ins while declaring constants: CopyAsk AIconst c = \"some string\"s; We now describe the possible string suffixes. ​String without suffix If no suffix is provided, the compiler computes a slice from the ASCII string, such that the contents of the slice is the binary code of the ASCII string. CopyAsk AIconst c = \"hello\"; ;; c has the slice x{68656c6c6f}, where 68656c6c6f ;; is the slice contents in hexadecimal, representing ;; the ASCII code of the string. ​String with suffix s Suffix s interprets the string as an hexadecimal number and produces a slice having the binary representation of the hexadecimal number. If the string is not an hexadecimal number, the compiler signals an error. CopyAsk AIconst c = \"abcdef\"s; ;; c has the slice x{abcdef}, where abcdef is the ;; slice contents in hexadecimal. ;; Note that abcdef is a valid hexadecimal number. ​String with suffix a Suffix a interprets the string as an address and creates a slice containing a MsgAddressInt structure from the address. CopyAsk AI;; c has slice x{9FE6666666666666666666666666666666666666666666666666666666666666667_} ;; The slice contents represent the MsgAddressInt structure: ;; addr_std$10 anycast:none$0 workchain_id:int8=0xFF address:bits256=0x33...33 const c = \"Ef8zMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzM0vF\"a; ​String with suffix u Suffix u produces the decimal representation of the binary code of the ASCII string. CopyAsk AIconst c = \"NstK\"u; ;; c has the integer 1316189259 ;; which is the decimal representation of the ;; ASCII code of the string ​String with suffix h Suffix h generates an integer from the first 32 bits of the string’s SHA-256 hash. CopyAsk AIconst c = \"transfer(slice, int)\"h; ;; c has the integer 2053302440 ​String with suffix H Suffix H generates an integer from the full 256-bit SHA-256 hash of the string. CopyAsk AI;; c has the integer ;; 55356924298749527416066000120313684523410504308849542670649639903159354505593 const c = \"transfer(slice, int)\"H ​String with suffix c Suffix c generates an integer from the crc32 value of the string. CopyAsk AIconst c = \"transfer(slice, int)\"c ;; c has the integer 2235694568 ​String with multiple lines Special characters like \\n are not supported in strings, but you can create multi-line strings by writing the text across multiple lines, all surrounded by triple quotes \"\"\". The triple quotes syntax also supports the previously described suffixes. For example: CopyAsk AIint a = \"\"\" hash me baby one more time .... Oh, baby, baby \"\"\"h; ;; a has value 876244482 Was this page helpful?YesNoSuggest editsRaise issuePreviousOperatorsNext⌘IgithubxtelegramPowered by MintlifyOn this pageNumber literalsIdentifiersConstantsCompile-time built-insString without suffixString with suffix sString with suffix aString with suffix uString with suffix hString with suffix HString with suffix cString with multiple lines",
    "category": "languages",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:34:22.979Z"
  },
  {
    "id": "docs-ton-org--languages-func-expressions",
    "title": "FunC expressions",
    "url": "https://docs.ton.org/languages/func/expressions",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCOverviewCookbookLanguageCommentsTypesLiteralsOperatorsExpressionsStatementsProgram declarationsReserved words and built-insDictionariesLibrariesChangelogKnown issuesTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationLanguageFunC expressionsLanguagesFunCLanguageFunC expressionsCopy pageCopy pageExpressions in FunC combine literals, variables, operators, and function calls to produce a value when evaluated. An expression in FunC can be: A number literal An identifier A compile-time builtin An operator A variable declaration A function call We focus on variable declarations and function calls, since the other kind of expressions are explained in their respective articles. As a general rule, all sub-expressions inside an expression are evaluated from left to right, except in cases where asm stack rearrangement explicitly defines the order. ​Variable declaration Local variables must be initialized at the time of declaration. Since variable declarations are expressions, the result of evaluating a declaration like: CopyAsk AItype iden = expr returns the value produced by expr, in addition to defining variable iden with value expr. For instance: (int x = 3) + x; declares x and assigns to it the value 3. The result of the expression (int x = 3) is therefore 3, which means that (int x = 3) + x evaluates to 6, since x has value 3 after the declaration. Here are further examples of variable declarations, where each line is independent from the other ones. It is possible to use the keyword var to let the type checker infer the type, see hole types. CopyAsk AIint x = 2; var x = 2; ;; Equivalent to previous, but with type inference (int, int) p = (1, 2); (int, var) p = (1, 2); ;; Equivalent to previous, but with type inference [int, var, int] t = [1, 2, 3]; In the previous examples, p and t store the entire tensor and tuple, respectively. But it is possible to deconstruct tensors and tuples and assign each component to different variables. Here are some examples that showcase different ways of deconstructing tensors and tuples: CopyAsk AI(int x, int y, int z) = (1, 2, 3); ;; Assign each tensor component to x, y, and z. (int, int, int) (x, y, z) = (1, 2, 3); ;; Equivalent to previous var (x, y, z) = (1, 2, 3); ;; Equivalent to previous, but with type inference (int x = 1, int y = 2, int z = 3); ;; Assigning each component directly [int x, int y, int z] = [1, 2, 3]; ;; Assign each tuple component to x, y, and z [int, int, int] [x, y, z] = [1, 2, 3]; ;; Equivalent to previous var [x, y, z] = [1, 2, 3]; ;; Equivalent to previous, but with type inference A variable can be redeclared in the same scope. For example, the following code is valid: CopyAsk AIint x = 2; int y = x + 1; int x = 3; In this example, the second occurrence of int x is not a new declaration but a compile-time check ensuring that x has type int. The third line is equivalent to x = 3;. The following example, which redeclares x with type (int, int) at the third line, is also valid: CopyAsk AIint x = 2; int y = x + 1; (int, int) x = (y, y + 1); After the third line, variable x has type (int, int). ​Variable redeclaration in nested scopes In nested scopes, a new variable with the same name can be declared, just like in C: CopyAsk AIint x = 0; int i = 0; while (i < 10) { (int, int) x = (i, i + 1); ;; Here x is a variable of type (int, int) i += 1; } ;; Here, x refers to the original variable of type int declared above However, global variables cannot be redeclared. See Global variables. ​Underscore The underscore _ is used when a value is not needed. For example, if foo is a function of type int -> (int, int, int), you can retrieve only the first return value while ignoring the rest: CopyAsk AI(int fst, _, _) = foo(42); ​Function call A function call in FunC follows a conventional syntax: the function name is followed by its arguments, separated by commas. However, unlike many conventional languages, FunC also treats functions as taking a single tensor argument. For example, suppose foo is a function of type (int, int, int) -> int. The following two lines are equivalent ways of calling foo: CopyAsk AIint x = foo(1, 2, 3); ;; Three arguments separated by , int x = foo((1, 2, 3)); ;; The tensor (1, 2, 3) passed as a single argument Equivalently, we could also assign tensor (1, 2, 3) to a variable, and then call foo: CopyAsk AI(int, int, int) t = (1, 2, 3); int x = foo(t); ;; Pass the tensor as a single argument ​Function composition To illustrate how function composition works in FunC, suppose that together with the previous foo function, there is also a bar function of type int -> (int, int, int). Since foo expects a single tensor argument, you can pass the entire result of bar(42) directly into foo: CopyAsk AIint x = foo(bar(42)); This is equivalent to the longer form, which decomposes the result tensor of bar(42) and then calls foo by passing all arguments separated by commas: CopyAsk AI(int a, int b, int c) = bar(42); int x = foo(a, b, c); ​Functions as first-class objects In FunC, functions are first-class objects: they can be assigned to variables, passed as arguments to other functions, and returned from functions. For example, the following function apply, receives a function f of type int -> int, and a value v of type int as arguments. Function apply invokes f with argument v and returns the result of the application, i.e., apply computes the expression f(v). CopyAsk AIint apply(int -> int f, int v) { return f(v); } Let us suppose we have an increment function: CopyAsk AIint inc(int x) { return x + 1; } We can then invoke apply by passing the increment function: CopyAsk AIapply(inc, 2); ;; produces 3, or equivalently, inc(2) It is also possible to assign the increment function to variables: CopyAsk AIvar f = inc; or return it from functions: CopyAsk AIint -> int return_inc() { return inc; } FunC does not support lambda expressions. This means that it is not possible to create anonymous functions. ​Special function call notation In addition to the standard syntax for calling a function, FunC supports two function call notations for specific situations, the non-modifying notation, and the modifying notation, which are explained next. ​Non-modifying notation In FunC, a function with at least one argument can be called using the dot . notation, also called non-modifying notation. For example, the function store_uint, which stores an unsigned integer into a cell builder and returns the modified builder, has type (builder, int, int) -> builder, where: The first argument is the builder object. The second argument is the value to store. The third argument is the unsigned integer bit length. The following way of calling store_uint: CopyAsk AIbuilder b = begin_cell(); b = store_uint(b, 239, 8); is equivalent to: CopyAsk AIbuilder b = begin_cell(); b = b.store_uint(239, 8); ;; Uses non-modifying notation The dot . notation allows the first argument of a function to be placed before the function name, simplifying the code further: CopyAsk AIbuilder b = begin_cell().store_uint(239, 8); which is equivalent to the standard syntax for calling a function: CopyAsk AIbuilder b = store_uint(begin_cell(), 239, 8); Using the . notation it is possible to chain many function calls together: CopyAsk AIbuilder b = begin_cell().store_uint(239, 8) .store_int(-1, 16) .store_uint(0xff, 10); which is equivalent to the longer form: CopyAsk AIbuilder b = begin_cell(); b = b.store_uint(239, 8); b = b.store_int(-1, 16); b = b.store_uint(0xff, 10); or to the more difficult to read form, which nests all the calls: CopyAsk AIbuilder b = store_uint( store_int( store_uint( begin_cell(), 239, 8), -1, 16), 0xff, 10 ); ​Modifying notation If a function’s first argument is of type A and its return type follows the structure (A, B), where B is an arbitrary type, the function can be called using the ~ notation, also called modifying notation. The primary purpose of the ~ notation is to automatically update the first argument in a function call. More concretely, suppose foo is a function of type (builder, int, int) -> (builder, int), then the call v = b~foo(2, 3), which uses the ~ notation, is equivalent to the standard call (b, v) = foo(b, 2, 3). The statement (b, v) = foo(b, 2, 3) reassigns (or updates) the first argument b after the call to foo finishes. The ~ notation serves as a shortcut to express this reassignment of the first argument. One possible application of the ~ notation is for working with cell slices. For example, consider a cell slice cs and the function load_uint, which has type: (slice, int) -> (slice, int). The function load_uint takes a cell slice and a number of bits to load, returning the remaining slice and the loaded unsigned integer value. The following three calls are equivalent: CopyAsk AI(cs, int x) = load_uint(cs, 8); ;; Standard function call (cs, int x) = cs.load_uint(8)",
    "category": "languages",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:34:24.951Z"
  },
  {
    "id": "docs-ton-org--contribute-snippets-aside",
    "title": "Aside component",
    "url": "https://docs.ton.org/contribute/snippets/aside",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsOverviewAsideImageFileTreeTON Docs home pageSearch...⌘KAsk AISearch...NavigationComponents and snippetsAside componentContributeComponents and snippetsAside componentCopy pageCopy pageTo display secondary information alongside a page’s main content, use the <Aside> component. Include nonessential, supplementary information in a regular <Aside>. If some information is important or might lead to bad cases when not taken into consideration, specify a different type, such as \"caution\" or \"danger\". It is a wrapper over built-in Callout components provided by Mintlify, but with a unified interface and a way to specify a title. ​Import CopyAsk AIimport { Aside } from '/snippets/aside.jsx'; ​Usage Display an aside (also known as “admonitions” or “callouts”) using the <Aside> component. An <Aside> can have an optional type attribute, which controls the aside’s color, icon, and default title. CopyAsk AIimport { Aside } from '/snippets/aside.jsx'; <Aside>Some content in an aside.</Aside> <Aside type=\"caution\">Some cautionary content.</Aside> <Aside type=\"tip\"> Other content is also supported in asides. ```js // A code snippet, for example. ``` </Aside> <Aside type=\"danger\">Do not give your password to anyone.</Aside> ​Use custom titles Override the default aside titles by using the title attribute. Watch out!CopyAsk AIimport { Aside } from '/snippets/aside.jsx'; <Aside type=\"caution\" title=\"Watch out!\"> A warning aside _with_ a custom title. </Aside> ​<Aside> props Implementation: aside.jsx The <Aside> component accepts the following props: ​type type: \"note\" | \"tip\" | \"caution\" | \"danger\" default: \"note\" The type of aside to display: note asides (the default) are blue and display an information icon. tip asides are purple and display a rocket icon. caution asides are yellow and display a triangular warning icon. danger asides are red and display an octagonal warning icon. Passing a different, unrecognized type resets the type to danger and replaces text content with the corresponding error message. ​title type: string default: \"\" (no title) The title of the aside to display. If title is not set, no title is displayed. ​icon type: string default: \"\" (corresponds to the type) The custom icon to display instead of the default one set by the type. Can be one of the following: Font Awesome icon name Lucide icon name ​iconType type: \"regular\" | \"solid\" | \"light\" | \"thin\" | \"sharp-solid\" | \"duotone\" | \"brands\" default: \"regular\" The Font Awesome icon style — only used with Font Awesome icons.Was this page helpful?YesNoSuggest editsRaise issuePreviousImageNext⌘IgithubxtelegramPowered by MintlifyOn this pageImportUsageUse custom titles<Aside> propstypetitleiconiconType",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:34:26.516Z"
  },
  {
    "id": "docs-ton-org--contribute-snippets-image",
    "title": "Image component",
    "url": "https://docs.ton.org/contribute/snippets/image",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsOverviewAsideImageFileTreeTON Docs home pageSearch...⌘KAsk AISearch...NavigationComponents and snippetsImage componentContributeComponents and snippetsImage componentCopy pageCopy pageTo display an image, use the <Image> component. It allows displaying either a single image for all themes (src) or one image per light theme (src) and one image for the dark theme (darkSrc). When an src path points to the SVG image and there is no darkSrc alternative, image colors will be inverted in the dark theme. Additionally, you can specify the href property, making an image double as a clickable link. When doing so, the target property allows to change the browsing context of the link. Making an image into a clickable link disables image zoom capabilities. Finally, to adjust image dimensions in pixels, use height or width properties. By default, all images use 16:9 aspect ratio and set height to 342px and width to 608px. ​Import CopyAsk AIimport { Image } from '/snippets/image.jsx'; ​Usage Show images using the <Image> component. CopyAsk AIimport { Image } from '/snippets/image.jsx'; {/* A single image */} <Image src=\"/resources/images/<IMAGE>\" /> {/* Image with height of 608px (max allowed). Its width will be scaled proportionally to set height and vice versa. */} <Image src=\"/resources/images/<IMAGE>\" height=\"608\" /> {/* Image variations for light or dark themes */} <Image src=\"/resources/images/<IMAGE>\" darkSrc=\"/resources/images/<IMAGE_DARK_THEME>\" /> {/* Image with all properties set */} <Image src=\"/resources/images/<IMAGE>\" alt=\"<ALT_TEXT>\" darkSrc=\"/resources/images/<IMAGE_DARK_THEME>\" darkAlt=\"<ALT_TEXT_DARK_THEME>\" href=\"<CLICKABLE_LINK>\" target=\"_blank\" height=\"100\" width={120 + 120} /> ​<Image> props Implementation: image.jsx The <Image> component accepts the following props: ​src (required) type: string The image file URL. The file path should be given either relative to the current .mdx file’s location or absolute, assuming the root of the documentation repository is the / directory. Relative links should NOT use .. in their paths to avoid discovery or security issues. Image files must be less than 20 MB uncompressed. For larger files, host them on a CDN service like Amazon S3. Examples: <Image src=\"<IMAGE>\" /> — relative path to an image placed in the same folder as the current .mdx file. <Image src=\"/resources/images/<IMAGE>\" /> — absolute path to an image in the resources/images/ sub-folder. ​alt type: string default: \"\" The textual replacement for the image. It is mandatory and incredibly useful for accessibility — screen readers read the attribute value out to their users so they know what the image means. Alt text is also displayed on the page if the image can’t be loaded for any reason, such as network errors, content blocking, or link rot. Setting this attribute to an empty string (alt=\"\") indicates that this image is not a key part of the content (it’s decoration or a tracking pixel), and that non-visual browsers may omit it from rendering. Visual browsers will also hide the broken image icon if the alt attribute is empty and the image failed to display. This attribute is also used when copying and pasting the image to text, or saving a linked image to a bookmark. See more: alt attribute on the <img> image embed element, MDN. ​darkSrc The value of this property is ignored unless the src property is set. type: string default: src value Similar to the src property, but specifies the image file URL for the dark theme only. ​darkAlt The value of this property is ignored unless the darkSrc property is set. type: string default: alt value Similar to the alt property, but specifies the image file URL for the dark theme only. ​href type: string The <a> anchor element wraps the image, making it clickable. The href property is a URL that the clickable image hyperlink points to. See more: href attribute on the <a> anchor element, MDN. ​target The value of this property is ignored unless the href property is set. type: \"_self\" | \"_blank\" | \"_parent\" | \"_top\" | \"_unfencedTop\" default: \"_self\" The <a> anchor element wraps the image, making it clickable. The target property specifies where to display the linked URL, as the name for a browsing context (a tab, window, or <iframe>). The following types have special meanings for where to load the URL: _self: the current browsing context. (Default) _blank: usually a new tab, but users can configure browsers to open a new window instead. _parent: the parent browsing context of the current one. If there is no parent, behaves as _self. _top: the topmost browsing context, i.e., the “highest” context that’s an ancestor of the current one. If there are no ancestors, behaves as _self. _unfencedTop: allows embedded fenced frames to navigate the top-level frame. See more: target attribute on the <a> anchor element, MDN. ​height type: string | number default: 342 (pixels) The intrinsic height of the image, in pixels. Must be specified without a unit and be within the inclusive range from 9 to 608. If the width property is not set, then the width of the image is adjusted according to the current aspect ratio in respect to the new set height. Examples: <Image src=\"<IMAGE>\" height=\"100\" /> — height of 100 pixels given in a string. <Image src=\"<IMAGE>\" height={50 + 50} /> — also the height of 100 pixels, but given as a number. See more: height attribute on the <img> image embed element, MDN. ​width type: string | number default: 608 (pixels) The intrinsic width of the image, in pixels. Must be specified without a unit and be within the inclusive range from 9 to 608. If the height property is not set, then the height of the image is adjusted according to the current aspect ratio in respect to the new set width. Examples: <Image src=\"<IMAGE>\" width=\"100\" /> — width of 100 pixels given in a string. <Image src=\"<IMAGE>\" width={50 + 50} /> — also the width of 100 pixels, but given as a number. See more: width attribute on the <img> image embed element, MDN.Was this page helpful?YesNoSuggest editsRaise issuePreviousFileTreeNext⌘IgithubxtelegramPowered by MintlifyOn this pageImportUsage<Image> propssrc (required)altdarkSrcdarkAlthreftargetheightwidth",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:34:28.296Z"
  },
  {
    "id": "docs-ton-org--contribute-snippets-filetree",
    "title": "FileTree component",
    "url": "https://docs.ton.org/contribute/snippets/filetree",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsOverviewAsideImageFileTreeTON Docs home pageSearch...⌘KAsk AISearch...NavigationComponents and snippetsFileTree componentContributeComponents and snippetsFileTree componentCopy pageCopy pageTo display the structure of a directory with file icons and collapsible sub-directories, use the <FileTree> component. You can open or close a sub-directory by clicking on it. Additionally, you can add notes to files and directories. ​Import CopyAsk AIimport { FileTree } from '/snippets/filetree.jsx'; ​Usage To display the file tree with file icons and collapsible sub-directories using the <FileTree> component, specify the structure of your files and directories inside the items property as a JavaScript list of objects and strings. CopyAsk AIimport { FileTree } from '/snippets/filetree.jsx'; <FileTree items={[ /* ...entries, see below... */ ]} /> ​Specify files and placeholders CopyAsk AIimport { FileTree } from '/snippets/filetree.jsx'; {/* Files and a placeholder by the end */} <FileTree items={[ \"file-name-1\", \"file-name-2\", \"file-name-3\", \"...\", // will be rendered as a … icon ]} /> ​Add notes and comments CopyAsk AIimport { FileTree } from '/snippets/filetree.jsx'; {/* Using objects to add notes or nested folders */} <FileTree items={[ \"file-name-1\", { kind: \"file\", name: \"file-name-2\", note: \"very important file\" }, { kind: \"folder\", name: \"best-folder\", note: \"not really\", open: false, // otherwise defaults to true items: [\"file-name-3-within-subfolder\"], }, ]} /> ​Specify folders and their state CopyAsk AIimport { FileTree } from '/snippets/filetree.jsx'; {/* Make all sub-folders be closed by default */} <FileTree items={[ { kind: \"folder\", name: \"folder-1\", open: true, items: [\"something1\"] }, { kind: \"folder\", name: \"folder-2\", items: [\"something2\"] }, ]} defaultOpen={false} {/* otherwise defaults to true */} /> ​<FileTree> props Implementation: filetree.jsx The <FileTree> component accepts the following props: ​items (required) type: FileTreeItem[] Hierarchy of files and folders to display. The FileTreeItem can be one of the following kinds: ... or … — both display a placeholder icon … indicating that a directory is expected to contain more items without specifying them all explicitly any string — name of the file inside the currently described directory { kind: \"file\", ...fields... } — an extended syntax for files, with the following fields: name: string — the filename note?: string — optional comment, which is displayed next to the filename { kind: \"folder\", ...fields... } — syntax for folders and directories, with the following fields: name: string — the directory name note?: string — optional comment, which is displayed next to the directory name open?: boolean — whether to open the directory, defaults to true items: FileTreeItem[] — nested files and folders Notice that folders are open by default, i.e., their open property is true unless specified otherwise. ​defaultOpen type: boolean default: true Whether to open all folders upon the page load. Can be overridden by the open property of the FileTreeItem entry.Was this page helpful?YesNoSuggest editsRaise issuePreviousImage⌘IgithubxtelegramPowered by MintlifyOn this pageImportUsageSpecify files and placeholdersAdd notes and commentsSpecify folders and their state<FileTree> propsitems (required)defaultOpen",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:34:30.616Z"
  },
  {
    "id": "docs-ton-org--ecosystem-ton-connect-walletkit-web-init",
    "title": "How to initialize the TON Connect's WalletKit on the Web platform",
    "url": "https://docs.ton.org/ecosystem/ton-connect/walletkit/web/init",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectOverviewIntegrate a dAppIntegrate a walletManifestsMessage lookupWalletKitOverviewWebInitialize the kitManage TON walletsHandle connectionsHandle other eventsiOSAndroidIntegration QA guideNative and web walletsBrowser extensions and in-wallet browsersTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationWebHow to initialize the TON Connect's WalletKit on the Web platformEcosystemTON ConnectWalletKitWebHow to initialize the TON Connect's WalletKit on the Web platformCopy pageCopy pageBefore initializing the TON Connect’s WalletKit, install it in your web project: CopyAsk AInpm i @ton/walletkit Alternatively, explore the complete demo wallet with WalletKit integration: Demo wallet, deployedDemo wallet, GitHub ​Initialization The basic kit initialization consists of creating a corresponding object by passing it a minimal set of necessary arguments. One needs to pick a TON network to operate on, provide the necessary device and wallet manifest configurations. CopyAsk AIimport { // Main class TonWalletKit, // Network constants (MAINNET/TESTNET) CHAIN, // Helper functions createDeviceInfo, createWalletManifest, } from '@ton/walletkit'; // 0. Create a kit object const kit = new TonWalletKit({ // 1. Pick a network — prefer CHAIN.TESTNET during development, // and only switch to CHAIN.MAINNET and production deployments // after rigorous testing. network: CHAIN.TESTNET, // 2. Specify core information and constraints of the given wallet. deviceInfo: createDeviceInfo({ // Version of your wallet appVersion: '0.0.1', // The rest of the params will have default values set for you, // including the features your wallet should support, // maximum supported TON Connect protocol version, // human-readable name of your wallet, // and a current platform ('browser'). }), // 3. Specify the TON Connect's wallet manifest. // The following function provides initial defaults, // but you may want to specify some custom values, // such as the human-readable name of your wallet or its icon image url. walletManifest: createWalletManifest(), }); // 4. Finally, wait for the initialization to complete await kit.waitForReady(); See also: TON Connect’s wallet manifest. Web only!The given example must be invoked in browser environments only. To run it locally with Node.js or other JS runtimes, set storage.allowMemory to true. It enables a built-in storage adapter for non-browser environments that do not have localStorage available.CopyAsk AIconst kit = new TonWalletKit({ // ...prior fields... storage: { allowMemory: true }, // ...later fields... }); Remember to disable this adapter in web environments or provide a dedicated storage adapter wrapper to switch between environments. ​Configuration parameters ​Required ​networkCHAIN.TESTNET | CHAIN.MAINNETrequiredThe TON network to use.CopyAsk AIimport { CHAIN } from '@ton/walletkit'; // Testing network of TON Blockchain. For experiments, beta tests, and feature previews. CHAIN.TESTNET; // \"-3\" // Production network of TON Blockchain. All contracts and funds are real. CHAIN.MAINNET; // \"-239\" ​deviceInfoDeviceInforequiredCore information and constraints of the given wallet.CopyAsk AIinterface DeviceInfo { // Name of the wallet. appName: string; // The platform it works on. Select 'browser' for the web wallets. platform: 'iphone' | 'ipad' | 'android' | 'windows' | 'mac' | 'linux' | 'browser'; // The current wallet version. appVersion: string; // Latest protocol version to use. maxProtocolVersion: number; // Which features are supported in the wallet. features: Feature[]; } There, Feature type is defined as:CopyAsk AItype Feature = | { // Wallet can send transactions. name: \"SendTransaction\"; // Max number of messages that can be sent in a single transaction. // Depends on the TON wallet used, because different kinds can handle // different number of messages. For example, // - ledger wallet would only handle 1 message per transaction // - wallet v4r2 handles up to 4 messages // - wallet v5r1 handles up to 255 messages maxMessages: number; // Are messages sending extra-currencies supported? extraCurrencySupported?: boolean; } | { // Wallet can sign data. name: \"SignData\"; // A type of data to sign. // Either of: \"text\", \"binary\", \"cell\". types: SignDataType[]; } The maxMessages number depends on the TON wallet used, because every wallet has its own limit on the volume of messages.For example, Ledger wallet would only handle 1 message per transaction Wallet v4r2 handles up to 4 messages Wallet v5r1 handles up to 255 messages ​walletManifestWalletInforequiredHow your wallet interacts with the TON Connect. This field is closely related to the corresponding JSON manifest file.CopyAsk AIinterface WalletInfo { /** * Human-readable name of the wallet. */ name: string; /** * ID of the wallet, equals to the `appName` property of the `deviceInfo`. */ appName: string; /** * Url to the icon of the wallet. Resolution 288×288px. On a non-transparent background, without rounded corners. PNG format. */ imageUrl: string; /** * Will be used in the protocol later. */ tondns?: string; /** * Info or landing page of your wallet. It may be useful for TON newcomers. */ aboutUrl: string; /** * List of features supported by the wallet. */ features?: Feature[]; /** * OS and browsers where the wallet could be installed */ platforms: ('ios' | 'android' | 'macos' | 'windows' | 'linux' | 'chrome' | 'firefox' | 'safari')[]; /** * Base part of the wallet universal url. The link should support TON Connect parameters: https://github.com/ton-connect/docs/blob/main/bridge.md#universal-link. */ universalLink: string; /** * Native wallet app deep link. The link should support TON Connect parameters: https://github.com/ton-connect/docs/blob/main/bridge.md#universal-link. */ deepLink?: string; /** * Url of the wallet's implementation of the HTTP bridge: https://github.com/ton-connect/docs/blob/main/bridge.md#http-bridge. */ bridgeUrl: string; // JS-injectable wallet information /** * If the wallet handles JS Bridge connection, specifies the binding for the bridge object accessible through window. Example: the key \"tonkeeper\" means the bridge can be accessed as window.tonkeeper. */ jsBridgeKey: string; /** * Indicates if the wallet currently is injected to the webpage. */ injected: boolean; /** * Indicates if the dapp is opened inside this wallet's browser. */ embedded: boolean; } See all 68 lines ​Optional ​apiClientobject | ApiClientWhich API or RPC provider to use to interact with TON Blockchain.CopyAsk AI// Either a small object: const _: { // Defaults to \"https://toncenter.com\". url?: string; // A key to access higher RPS limits. key?: string; } // Or a complete ApiClient interface implementation. ​bridgeBridgeConfigConnectivity options: either an HTTP or JavaScript bridge setup. The former’s bridgeUrl points to the publicly exposed bridge URL, while the latter’s jsBridgeKey points to the property name within the window object on the same web page.Bridges are used for dApp communication — if the dApp exists in the same web environment as the wallet, then the JavaScript bridge is enough. Otherwise, use an HTTP bridge setup.For HTTP bridge setups, use a publicly available and production-ready bridge deployed at https://connect.ton.org/bridge.CopyAsk AIinterface BridgeConfig { // Defaults to `walletInfo`'s `bridgeUrl`, if it exists bridgeUrl?: string; // Defaults to true if `walletInfo`'s `jsBridgeKey` exists enableJsBridge?: boolean; // Defaults to `walletInfo`'s `jsBridgeKey`, if it exists jsBridgeKey?: string; // Defaults to false disableHttpConnection?: boolean; // Settings for bridge-sdk heartbeatInterval?: number; reconnectInterval?: number; maxReconnectAttempts?: number; } ​storageStorageConfig | StorageAdapterHow to store intermediate events.CopyAsk AI// Either a small object: interface StorageConfig { prefix?: string; cacheTimeout?: number; maxCacheSize?: number; allowMemory?: boolean; } // Or a complete StorageAdapter interface implementation: interface StorageAdapter { get(key: string): Promise<string | null>; set(key: string, value: string): Promise<void>; remove(key: string): Promise<void>; clear(): Promise<void>; } ​eventProcessorEventProcessorConfigHow TON Connect events are processed. This is useful for background scripts in browser extensions that process incoming events and log them, but do so outside a queue.CopyAsk AIinterface EventProcessorConfig { disableEvents?: boolean; } ​analyticsAnalyticsConfigCollect and gather analytical data.CopyAsk AIinterface AnalyticsConfig { enabled?: boolean; // A web URL to send analytics data to. endpoint?: string; } ​devobjectExtra configuration used when developing WalletKit itself. Irrelevant in other cases. ​Next steps Manage TON wallets ​See also WalletKit overview TON Connect’s wallet manifest TON Connect overview Was this page helpful?YesNoSuggest editsRaise issuePreviousManage TON w",
    "category": "integration",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "dapp",
      "api",
      "sdk",
      "testnet",
      "mainnet",
      "transaction",
      "deployment",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:34:32.729Z"
  },
  {
    "id": "docs-ton-org--ecosystem-ton-connect-walletkit-web-wallets",
    "title": "How to manage TON wallets with WalletKit on the Web platform",
    "url": "https://docs.ton.org/ecosystem/ton-connect/walletkit/web/wallets",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectOverviewIntegrate a dAppIntegrate a walletManifestsMessage lookupWalletKitOverviewWebInitialize the kitManage TON walletsHandle connectionsHandle other eventsiOSAndroidIntegration QA guideNative and web walletsBrowser extensions and in-wallet browsersTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationWebHow to manage TON wallets with WalletKit on the Web platformEcosystemTON ConnectWalletKitWebHow to manage TON wallets with WalletKit on the Web platformCopy pageCopy pageInitialize the WalletKit before using examples on this page. The basic configuration earlier is enough to outline necessary wallet information and initialize the WalletKit, but it isn’t enough for deeper interactions with the blockchain. For that, you need to set up at least one TON wallet contract. ​Initialization First, obtain the signer. It can be instantiated from a mnemonic, from a private key, or be made custom. Then, select a wallet adapter — it’s an implementation of the WalletInterface type for a particular TON wallet contract. Currently, WalletKit provides two: WalletV5R1Adapter (recommended) and WalletV4R2Adapter. Adapter takes in a signer from the previous step and a number of options, namely: network — TON Blockchain network, either CHAIN.MAINNET or CHAIN.TESTNET. client — API client to communicate with TON Blockchain. In most cases, the client of the initialized kit via kit.getApiClient() would suffice. walletId — identifier of the new wallet, which is used to make its smart contract address unique. workchain — either 0 for the basechain (default), or -1 for the masterchain. TypeScriptCopyAsk AIimport { // Network constants (MAINNET/TESTNET) CHAIN, // Latest wallet version (recommended) WalletV5R1Adapter, defaultWalletIdV5R1, // Legacy wallet version WalletV4R2Adapter, defaultWalletIdV4R2, } from '@ton/walletkit'; const walletAdapter = await WalletV5R1Adapter.create(signer, { network: CHAIN.TESTNET, client: kit.getApiClient(), // Either 0 for the basechain (default), // or -1 for the masterchain workchain: 0, // Specify an ID for this wallet when you plan // on adding more than one wallet to the kit // under the same mnemonic or private key. // // In such cases, ID is used to make wallet addresses unique, // because the same ID for the same mnemonic results in wallets // with the same address, i.e., the same smart contract. walletId: defaultWalletIdV5R1, // 2147483409 }); Finally, pass the adapter to the addWallet() method of the kit to complete the wallet initialization process: TypeScriptCopyAsk AI // Notice that addWallet() method returns an initialized TON wallet, // which can be used on its own elsewhere. const wallet = await kit.addWallet(walletAdapter); console.log('Wallet address:', wallet.getAddress()); See the complete example for each signer kind: MnemonicPrivate keyCustom signer ​From mnemonic To initialize a TON wallet from an existing BIP-39 or TON-specific mnemonic seed phrase, the signer should be instantiated with the fromMnemonic() method of the utility Signer class of the WalletKit. Never specify the mnemonic phrase directly in your code. It is a “password” to your wallet and all its funds.Instead, prefer sourcing the seed phrase from a secure storage, backend environment variables, or a special .env file that is Git-ignored and handled with care. TypeScriptCopyAsk AIimport { // Handles cryptographic signing Signer, // Latest wallet version (recommended) WalletV5R1Adapter, // Network constants (MAINNET/TESTNET) CHAIN, } from '@ton/walletkit'; // 1. const signer = await Signer.fromMnemonic( // (REQUIRED) // A 12 or 24-word seed phrase obtained with general BIP-39 or TON-specific derivation. // The following value assumes a corresponding MNEMONIC localStorage entry // that contains 24 space-separated seed phrase words as a single string: localStorage.getItem('MNEMONIC')!.split(' '), // list of 24 strings { // Type of derivation used to produce a mnemonic. // If you've used a pure BIP-39 derivation, specify 'bip-39'. // Otherwise, specify 'ton'. // Defaults to: 'ton' type: 'ton', }, ); // 2. const walletAdapter = await WalletV5R1Adapter.create(signer, { network: CHAIN.TESTNET, client: kit.getApiClient(), }); // 3. const wallet = await kit.addWallet(walletAdapter); See all 33 lines If you don’t yet have a mnemonic for an existing TON wallet or you want to create a new one, you can generate a TON-specific mnemonic with the CreateTonMnemonic() function. However, it’s crucial to use that function only once per wallet and then save it securely.You must NOT invoke this function amidst the rest of your project code.The following is an example of a simple one-off standalone script to produce a new mnemonic that then should be saved somewhere private:CopyAsk AIimport { CreateTonMnemonic } from '@ton/walletkit'; console.log(await CreateTonMnemonic()); // word1, word2, ..., word24 ​From private key To initialize a TON wallet from an existing private key, the signer should be instantiated with the fromPrivateKey() method of the utility Signer class of the WalletKit. If there is a mnemonic, one can convert it to an Ed25519 key pair with public and private key by using the MnemonicToKeyPair() function. Private keys are sensitive data!Handle private keys carefully. Use test keys, keep them in a secure keystore, and avoid logs or commits. TypeScriptCopyAsk AIimport { // Handles cryptographic signing Signer, // Latest wallet version (recommended) WalletV5R1Adapter, // Conversion function MnemonicToKeyPair, // Network constants (MAINNET/TESTNET) CHAIN, } from '@ton/walletkit'; // 1. const signer = await Signer.fromPrivateKey( // Private key as a hex-encoded string or Uint8Array of bytes. // The following value assumes a corresponding PRIVATE_KEY localStorage entry // that contains the private key as a hex-encoded string: localStorage.getItem('PRIVATE_KEY')!, ); // 2. const walletAdapter = await WalletV5R1Adapter.create(signer, { network: CHAIN.TESTNET, client: kit.getApiClient(), }); // 3. const wallet = await kit.addWallet(walletAdapter); See all 27 lines ​From custom signer To provide a custom signing mechanism as an alternative to using a mnemonic phrase or a private key, create an object of type WalletSigner and then pass it to the target wallet adapter’s create() method. The signer object has to have two fields: Signing function of type ISigner, which takes an iterable bytes object, such as array, Uint8Array, or Buffer, and asynchronously produces an Ed25519-encoded signature of the input as Hex. The Hex type is a string containing a hexadecimal value that starts with an explicit 0x prefix. TypeScriptCopyAsk AItype ISigner = (bytes: Iterable<number>) => Promise<Hex>; Relevant Ed25519 public key of type Hex. TypeScriptCopyAsk AItype Hex = `0x${string}`; A custom signer is useful to maintain complete control over the signing process, such as when using a hardware wallet or signing data on the backend. TypeScriptCopyAsk AIimport { // Network constants (MAINNET/TESTNET) CHAIN, // Latest wallet version (recommended) WalletV5R1Adapter, // Conversion function MnemonicToKeyPair, // Utility function to convert an array of bytes into a string of type Hex Uint8ArrayToHex, // Utilify function to obtain an Ed25519 signature DefaultSignature, // Handles cryptographic signing type WalletSigner, // String with a hexadecimal value, which starts with the `0x` prefix type Hex, } from '@ton/walletkit'; // A Ed25519 key pair from a mnemonic const keyPair = await MnemonicToKeyPair( // The following value assumes a corresponding MNEMONIC localStorage entry // that contains 24 space-separated seed phrase words as a single string: localStorage.getItem('MNEMONIC')!.split(' '), 'ton', ); // 1. const signer: WalletSigner = { // The following is a simple demo of a signing function. // Make sure to replace it with a production-ready one! sign: async (bytes: Iterable<number>): Promise<Hex> => { return DefaultSignature(Uint8Array.from(bytes), keyPair.secretKey); }, // Public key as a Hex publicKey: Uint8ArrayToHex(keyPair.publicKey), }; // 2. const walletAdapter = await WalletV5R1Adapter.create(signer, { network: CHAIN.TESTNET, client: kit.getApiClient(), }); // 3. const wallet = await kit.addWallet(walletAdapter); See all 45 lines ​Multiple wallets You can add multiple TON wallets to WalletKit and switch between them as needed. TypeScriptCopyAsk AIconst wallet1 = await kit.addWallet(walletAdapter1); const wallet2 = await kit.addWallet(walletAdapter2); // ... const walletN = await kit.addWallet(walletAdapterN); Providing the same wallet adapter to the kit multiple times will return the wallet that was already added in the first attempt. ​Methods ​Get a single wallet To get a single wallet by its address, use the getWallet() method of the initialized kit. TypeScriptCopyAsk AIconst wallet: IWallet = kit.getWallet(walletAdapter.getAddress()); console.log('TON ",
    "category": "integration",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "dapp",
      "backend",
      "api",
      "sdk",
      "testnet",
      "mainnet",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:34:35.199Z"
  },
  {
    "id": "docs-ton-org--ecosystem-ton-connect-walletkit-web-connections",
    "title": "How to handle connections with WalletKit on the Web platform",
    "url": "https://docs.ton.org/ecosystem/ton-connect/walletkit/web/connections",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectOverviewIntegrate a dAppIntegrate a walletManifestsMessage lookupWalletKitOverviewWebInitialize the kitManage TON walletsHandle connectionsHandle other eventsiOSAndroidIntegration QA guideNative and web walletsBrowser extensions and in-wallet browsersTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationWebHow to handle connections with WalletKit on the Web platformEcosystemTON ConnectWalletKitWebHow to handle connections with WalletKit on the Web platformCopy pageCopy pageInitialize the WalletKit and set up at least one TON wallet before using examples on this page. To use a wallet service for initiating blockchain transactions and signing data, dApps need to set up a connection over the bridge first. Connection is established via connect requests and terminated via disconnect requests. ​Connection flow Standard flow looks as follows: User clicks a “Connect wallet” button in the dApp, selecting the desired wallet service WalletKit processes the connection URL and triggers the onConnectRequest() method There, WalletKit instructs the wallet service to show a connection request preview, waiting for the user’s approval User approves or rejects a connection The flow can started by scanning a QR code from a dApp in the wallet service, or by pressing a deep link in the wallet service. In both cases, WalletKit will process the URL via the handleTonConnectUrl() method, then fire a connect event for the onConnectRequest() method to handle. If the connection was approved, the dApp could proceed to send various transaction or data sign requests. If it was rejected, the dApp can repeat the flow. If a user decides to disconnect a wallet at any point, the disconnect request will be issued and the onDisconnect() method of the WalletKit will handle it. ​Handlers To work with connection-specific requests, the WalletKit offers three methods which expect processing functions as callbacks: The onConnectRequest() method processes connection requests The onDisconnect() method processes disconnection requests The onRequestError() method allows to handle errors arising in any of the requests ​Handle onConnectRequest When a user wants to connect a TON wallet from the dApp, the dApp fires the connect request over the bridge. The wallet service then handles it with the onConnectRequest method of the WalletKit. On the dApp side, this flow is often initiated by pressing the “Connect a wallet” button, followed by selecting the user’s wallet service. Additionally, a dApp can produce a QR code or a deep link, which initiate the connection flow from within the wallet service. TypeScriptCopyAsk AIkit.onConnectRequest(async (event) => { try { const wallets = kit.getWallets(); if (wallets.length === 0) { // Make sure to present a message to the user. console.log('No wallets available'); await kit.rejectConnectRequest(event, 'No wallets available'); return; } const dappName = event.preview.manifest?.name || 'Unknown dApp'; const dappUrl = event.preview.manifest?.url || 'Unknown URL'; // Show the connection confirmation UI to the user of the wallet service if (confirm(`Connect to ${dappName} from ${dappUrl}?`)) { // Set wallet address on the request before approving event.walletAddress = wallets[0].getAddress(); await kit.approveConnectRequest(event); console.log('Connected to:', dappName); } else { await kit.rejectConnectRequest(event, 'User rejected'); console.log('Connection rejected by a user'); } } catch (error) { console.error('Connection handler error:', error); await kit.rejectConnectRequest(event, 'Fatal error in the connection handler'); } }); ​Wallet selection When there are several TON wallets added, ask the user to select one before approving the connection request. TypeScriptCopyAsk AIkit.onConnectRequest(async (event) => { try { const wallets = kit.getWallets(); if (wallets.length === 0) { // Make sure to present a message to the user. console.log('No wallets available'); await kit.rejectConnectRequest(event, 'No wallets available'); return; } // Selecting the 1st TON wallet by default let selectedWallet = { ok: true, wallet: wallets[0] }; // Yet, asking the user to pick one if there are many if (wallets.length > 1) { // Here, uiSelectWallet() is assumed to be implemented elsewhere: // it takes the list of wallets and provides the user with a choice // to pick one from the list, then returns with the picked option // or a rejection if there was none. selectedWallet = await uiSelectWallet(wallets); } if (!selectedWallet.ok) { // Make sure to present a message to the user. console.log('No wallet selected'); await kit.rejectConnectRequest(event, 'No wallet selected'); return; } const dappName = event.preview.manifest?.name || 'Unknown dApp'; const dappUrl = event.preview.manifest?.url || 'Unknown URL'; // Show the connection confirmation UI to the user of the wallet service if (confirm(`Connect to ${dappName} from ${dappUrl}?`)) { // Set wallet address on the request before approving event.walletAddress = selectedWallet.wallet.getAddress(); await kit.approveConnectRequest(event); console.log('Connected to:', dappName); } else { await kit.rejectConnectRequest(event, 'User rejected'); console.log('Connection rejected by a user'); } } catch (error) { console.error('Connection handler error:', error); await kit.rejectConnectRequest(event, 'Fatal error in the connection handler'); } }); ​QR codes and deep links The handleTonConnectUrl() method of the WalletKit parses a TON Connect link and creates a new connection request event. Usually, this link comes from a QR code generated on the dApp side, but it can also be provided within the mobile dApp as a deep link. TypeScriptCopyAsk AIasync function handleQrCode(content: string) { try { // On success, this will fire the onConnectRequest handler: await kit.handleTonConnectUrl(content); } catch (error) { console.error('Invalid QR code:', error); // Make sure to present an error to the user. throw new Error('Failed to process TON Connect QR code'); } } async function handleDeepLink(url: string) { if (url.startsWith('tc://') || url.includes('ton-connect')) { try { // On success, this will fire the onConnectRequest handler: await kit.handleTonConnectUrl(url); } catch (error) { console.error('Invalid link:', error); // Make sure to present an error to the user. throw new Error('Failed to process TON Connect deep link'); } } } ​Handle onDisconnect When a user disconnects a wallet service and its TON wallet from the dApp, the dApp fires the disconnect request over the bridge. The wallet service then handles it with the onDisconnect method of the WalletKit. TypeScriptCopyAsk AIkit.onDisconnect(async (event) => { // Clean up any UI state related to this connection. console.log(`Disconnected from a dApp that used this TON wallet: ${event.walletAddress}`); }); ​Next steps Handle other events ​See also WalletKit overview TON Connect overview Was this page helpful?YesNoSuggest editsRaise issuePreviousHandle other eventsNext⌘IgithubxtelegramPowered by MintlifyOn this pageConnection flowHandlersHandle onConnectRequestWallet selectionQR codes and deep linksHandle onDisconnectNext stepsSee also",
    "category": "integration",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "dapp",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:34:36.682Z"
  },
  {
    "id": "docs-ton-org--ecosystem-ton-connect-walletkit-web-events",
    "title": "How to handle other events with WalletKit on the Web platform",
    "url": "https://docs.ton.org/ecosystem/ton-connect/walletkit/web/events",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectOverviewIntegrate a dAppIntegrate a walletManifestsMessage lookupWalletKitOverviewWebInitialize the kitManage TON walletsHandle connectionsHandle other eventsiOSAndroidIntegration QA guideNative and web walletsBrowser extensions and in-wallet browsersTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationWebHow to handle other events with WalletKit on the Web platformEcosystemTON ConnectWalletKitWebHow to handle other events with WalletKit on the Web platformCopy pageCopy pageInitialize the WalletKit, set up at least one TON wallet and handle connection requests before using examples on this page. In total, there are five distinct kinds of incoming requests from the TON Connect bridge. They form the corresponding events and their handlers: Incoming requestWalletKit method to listen and process the requestconnectonConnectRequest()disconnectonDisconnect()transactiononTransactionRequest()signDataonSignDataRequest()restoreConnectionNone — this is a connection health check of the JS bridgeAny event erroronRequestError() ​Handle onTransactionRequest If a dApp is connected to the wallet service, the former can request to initiate a blockchain transaction, which fires the transaction request over the bridge. The wallet service then handles it with the onTransactionRequest method of the WalletKit. On TON, transactions are initiated by sending an external message to the TON wallet contract, which then processes it and sends internal messages as requested. To estimate money flows for planned transactions, WalletKit uses emulation via the configured API client, if supported. The API client in use is determined by the optional apiClient configuration parameter during WalletKit initialization. By default, the TON Center APIs are used, which provide rich emulation capabilities. TypeScriptCopyAsk AIkit.onTransactionRequest(async (event) => { try { if (event.preview.result === 'success') { // If the emulation was successful, // show net asset changes to the user for a confirmation. // There, positive amounts mean incoming transfers, // and negative mean outgoing ones. console.log(event.preview.moneyFlow.ourTransfers); } else { // Transaction emulation was not successful, // but you can still allow a user to proceed — with a warning. console.log('Transaction emulation failed'); } if (confirm('Do you confirm this transaction?')) { await kit.approveTransactionRequest(event); } else { await kit.rejectTransactionRequest(event, 'User rejected'); } } catch (error) { console.error('Transaction handler error:', error); await kit.rejectTransactionRequest(event, 'Fatal error in the connection handler'); } }); ​Handle onSignDataRequest If a dApp is connected to the wallet service, the former can request to sign data with the private key used by the selected TON wallet, which fires the signData request over the bridge. The wallet service then handles it with the onSignDataRequest method of the WalletKit. The data to sign can be of several kinds: text, binary, or a raw cell. TypeScriptCopyAsk AIkit.onSignDataRequest(async (event) => { try { // Data to be signed can be of three distinct types. // Depending on a type, show it to the user for a confirmation. switch (event.request.type) { case 'text': console.log(event.request.text); break; case 'binary': console.log(event.request.bytes); break; case 'cell': // The `request.cell` contains a hex-encoded string with a serialized cell // and the `request.schema` describes a TL-B schema to parse the `request.cell` console.log(event.request.cell); console.log(event.request.schema); break; } if (confirm('Do you confirm this data sign request?')) { try { // Sign the data receiver with the user's approval const result = await kit.signDataRequest(event); console.log('Signed successfully:', result); } catch (error) { console.error('Signing failed:', error); } } else { await kit.rejectTransactionRequest(event, 'User rejected'); } } catch (error) { console.error('Data sign handler error:', error); await kit.rejectTransactionRequest(event, 'Fatal error in the data sign handler'); } }); ​Handle request errors Upon any error in any of the requests, the onRequestError() method is invoked. Provide it with a callback function that would handle arbitrary errors and display useful information to the user. TypeScriptCopyAsk AIawait kit.onRequestError(async (event) => { // To distinguish incoming events, look for their corresponding type: console.error(event.incomingEvent.method); // Event's .method can be one of the following: // - connect (failure in onConnectRequest) // - disconnect (failure in onDisconnect) // - transaction (failure in onTransactionRequest) // - signData (failure in onSignDataRequest) // - restoreConnection (JS bridge failures) // - none (generic request errors) console.error(event.incomingEvent); // The result is a following object: // { // id: string, // error: { // code: number, // message: string, // data?: unknown, // } // } console.error(event.result); }); ​See also WalletKit overview TON Connect overview Was this page helpful?YesNoSuggest editsRaise issuePreviousInstall the kitNext⌘IgithubxtelegramPowered by MintlifyOn this pageHandle onTransactionRequestHandle onSignDataRequestHandle request errorsSee also",
    "category": "integration",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "dapp",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:34:38.092Z"
  },
  {
    "id": "docs-ton-org--ecosystem-ton-connect-walletkit-android-webview",
    "title": "How to inject TON's WalletKit into WebView on Android platform",
    "url": "https://docs.ton.org/ecosystem/ton-connect/walletkit/android/webview",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectOverviewIntegrate a dAppIntegrate a walletManifestsMessage lookupWalletKitOverviewWebiOSAndroidInstall the kitInit the kitManage TON walletsReceiving informationHandle eventsTransactionsWebView injectionIntegration QA guideNative and web walletsBrowser extensions and in-wallet browsersTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationAndroidHow to inject TON's WalletKit into WebView on Android platformEcosystemTON ConnectWalletKitAndroidHow to inject TON's WalletKit into WebView on Android platformCopy pageCopy pageInitialize the WalletKit before injecting it into WebView. See the initialization guide for details. Injecting WalletKit into WebView allows integrating the wallet service with a dApp running in a native WebView and handling its events. To do so, enable JavaScript in the WebView and inject TonConnect. CopyAsk AIimport android.webkit.WebView import io.ton.walletkit.ITONWalletKit import io.ton.walletkit.extensions.injectTonConnect val webView = WebView(context) webView.settings.javaScriptEnabled = true webView.injectTonConnect(walletKit) webView.loadUrl(/* dApp URL */) After the injection is complete, handle dApp events from a custom events handler.Was this page helpful?YesNoSuggest editsRaise issuePreviousIntegration QA guideNext⌘IgithubxtelegramPowered by Mintlify",
    "category": "integration",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "dapp",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:34:40.037Z"
  },
  {
    "id": "docs-ton-org--ecosystem-tma-overview",
    "title": "Overview",
    "url": "https://docs.ton.org/ecosystem/tma/overview",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsOverviewTMA create CLITelegram UIMateAnalyticsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationTMA: Telegram Mini AppsOverviewEcosystemTMA: Telegram Mini AppsOverviewCopy pageCopy pageTelegram Mini Apps (TMAs) are web applications that run within the Telegram messenger. They are built using web technologies — HTML, CSS, and JavaScript. Your browser does not support the <video> tag. Mini Apps run within Telegram and are instantly accessible — without the need for installation or redirects. ​TMA developer tools TMA create CLI Telegram UI Kit Mate Analytics Was this page helpful?YesNoSuggest editsRaise issuePreviousTMA create CLINext⌘IgithubxtelegramPowered by MintlifyOn this pageTMA developer tools",
    "category": "tma",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:34:42.486Z"
  },
  {
    "id": "docs-ton-org--ecosystem-node-mytonctrl-integrating-with-prometheus",
    "title": "Integrate MyTonCtrl with Prometheus",
    "url": "https://docs.ton.org/ecosystem/node/mytonctrl/integrating-with-prometheus",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeOverviewRun a node with MyTonCtrlRun a validatorIntegrate MyTonCtrl with PrometheusSetting up a local blockchain using MyLocalTonMyTonCtrl referenceStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationBlockchain nodeIntegrate MyTonCtrl with PrometheusEcosystemBlockchain nodeIntegrate MyTonCtrl with PrometheusCopy pageCopy pageMyTonCtrl pushes metrics to a Prometheus Pushgateway so Prometheus (and Grafana, if used) can scrape them without exposing the node directly. ​Prerequisites Docker and Docker Compose are installed on the host that runs Prometheus. MyTonCtrl installed and running on the node that emits metrics. ​Deploy Prometheus and Pushgateway In an empty directory, create docker-compose.yml: CopyAsk AIservices: pushgateway: image: prom/pushgateway:v1.4.0 restart: unless-stopped ports: - \"9091:9091\" prometheus: image: prom/prometheus:v2.52.0 restart: unless-stopped volumes: - ./prometheus.yml:/etc/prometheus/prometheus.yml:ro command: - \"--config.file=/etc/prometheus/prometheus.yml\" ports: - \"9090:9090\" Create prometheus.yml alongside it: CopyAsk AIglobal: scrape_interval: 15s scrape_configs: - job_name: \"mytonctrl_pushgateway\" static_configs: - targets: [\"pushgateway:9091\"] Start the stack and confirm the container status: CopyAsk AIdocker compose up -d docker compose ps ​Configure MyTonCtrl to push metrics Open the MyTonCtrl console: CopyAsk AImytonctrl Enable Prometheus mode: CopyAsk AIMyTonCtrl> enable_mode prometheus Point MyTonCtrl to the Pushgateway (include a job name): CopyAsk AIMyTonCtrl> set prometheus_url http://<PUSHGATEWAY_HOST>:9091/metrics/job/<JOB_NAME> <PUSHGATEWAY_HOST> — host running the Pushgateway (use 127.0.0.1 when MyTonCtrl and Docker run on the same machine). <JOB_NAME> — unique label for this node, for example validator1. Use unique job namesDo not reuse the same JOB_NAME across nodes when scraped by one Prometheus instance, or metrics collide. ​Verify metrics Pushgateway: open http://<PUSHGATEWAY_HOST>:9091 and confirm metrics appear under <JOB_NAME>. Prometheus targets: open http://<PROMETHEUS_HOST>:9090/targets and check that mytonctrl_pushgateway shows UP. Prometheus graph: query mytonctrl_synced or other MyTonCtrl metrics at http://<PROMETHEUS_HOST>:9090/graph. Was this page helpful?YesNoSuggest editsRaise issuePreviousSetting up a local blockchain using MyLocalTonInstall MyLocalTon to spin up a self-contained TON network for development and testing.Next⌘IgithubxtelegramPowered by MintlifyOn this pagePrerequisitesDeploy Prometheus and PushgatewayConfigure MyTonCtrl to push metricsVerify metrics",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:34:46.043Z"
  },
  {
    "id": "docs-ton-org--ecosystem-tma-create-mini-app",
    "title": "TMA create CLI",
    "url": "https://docs.ton.org/ecosystem/tma/create-mini-app",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsOverviewTMA create CLITelegram UIMateAnalyticsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationTMA: Telegram Mini AppsTMA create CLIEcosystemTMA: Telegram Mini AppsTMA create CLICopy pageCopy page@telegram-apps/create-mini-app is a CLI tool designed to scaffold your new mini application on the Telegram Mini Apps platform. It generates a project with pre-configured libraries and template files, allowing you to customize the content based on your specific requirements. ​Usage To run the tool, use one of the following scripts depending on your package manager. npmCopyAsk AInpx @telegram-apps/telegram-apps-tools@latest ​Creating a new application The above command executes a script that guides you through the creation of your application by sequentially prompting for the following information: ​Project directory name Prompt: Enter the name of the folder where the project files will be located. Default: mini-app The script will create a subfolder with the specified name in the current directory. ​Preferred technologies ​TMA SDKs tma.js @telegram-apps/sdk – A TypeScript library for seamless communication with Telegram Mini Apps functionality. Telegram SDK @twa-dev/sdk – This package allows you to work with the SDK as an npm package. ​Frameworks React.js template Next.js template Solid.js template Vue.js template ​Git remote repository URL Enter the git remote repository URL. This value will be used to connect the created project with your remote git repository. It should be either an HTTPS link or an SSH connection string. ​Build configuration Projects created with create-mini-app are configured to use the Vite bundler. The project includes a vite.config.js file, which you can customize to adjust the build settings according to your needs.Was this page helpful?YesNoSuggest editsRaise issuePreviousOverviewNext⌘IgithubxtelegramPowered by MintlifyOn this pageUsageCreating a new applicationProject directory namePreferred technologiesTMA SDKsFrameworksGit remote repository URLBuild configuration",
    "category": "tma",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "react",
      "vue",
      "nextjs",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:34:48.131Z"
  },
  {
    "id": "docs-ton-org--ecosystem-tma-analytics-supported-events",
    "title": "Supported events",
    "url": "https://docs.ton.org/ecosystem/tma/analytics/supported-events",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsOverviewTMA create CLITelegram UIMateAnalyticsTelegram analyticsSupported eventsPreparationsInstallation via script tagInstallation via NPM packageAPI EndpointsManaging integrationFAQBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationAnalyticsSupported eventsEcosystemTMA: Telegram Mini AppsAnalyticsSupported eventsCopy pageCopy pageEvents from TON Connect will be sent only if @tonconnect/[email protected], @tonconnect/[email protected] or @tonconnect/[email protected] and higher versions packages are used. Event nameDescriptionTON Connect required app-initConnection attempts and their initiationfalseapp-hideHiding the app from the screenfalsecustom-eventThe event specified by the userfalseconnection-startedThe user starts connecting the wallettrueconnection-completedSuccessful connection to a wallettrueconnection-errorErrors in connection specifying reasons (e.g., user canceled)trueconnection-restoring-completedThe connection was restored successfullytrueconnection-restoring-errorConnection restoration failedtruetransaction-sent-for-signatureThe user submits the transaction for signaturetruetransaction-signedThe user successfully signs the transactiontruetransaction-signing-failedThe user cancels the transaction signature or an error occurs during the signing processtruedisconnection user-initiatedDisconnection events, specifying scope (dApp or wallet)true Was this page helpful?YesNoSuggest editsRaise issuePreviousPreparationsNext⌘IgithubxtelegramPowered by Mintlify",
    "category": "tma",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "dapp",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:35:16.938Z"
  },
  {
    "id": "docs-ton-org--ecosystem-tma-analytics-preparation",
    "title": "Preparations",
    "url": "https://docs.ton.org/ecosystem/tma/analytics/preparation",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsOverviewTMA create CLITelegram UIMateAnalyticsTelegram analyticsSupported eventsPreparationsInstallation via script tagInstallation via NPM packageAPI EndpointsManaging integrationFAQBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationAnalyticsPreparationsEcosystemTMA: Telegram Mini AppsAnalyticsPreparationsCopy pageCopy page​Connect the TON Connect SDK Web3 events for the Telegram Mini Apps Analytics SDK are supported by the @tonconnect/ui and @tonconnect/ui-react libraries since version 2.0.3, @tonconnect/sdk since version 3.0.3. Read more about TON Connect integration Don’t worry if your app doesn’t use TON Connect; the analytics SDK will still work and collect non-Web3 events. ​Get the token with TON Builders Register your project on TON Builders and go to the Analytics tab. Enter your Telegram Bot URL and mini app domain to receive an API key for SDK initialization. You can also manage your existing keys from the same section. Enter your Telegram Bot URL and mini app domain to receive a token for SDK initialization. ​Initialize SDK Now you can initialize the SDK in your application. There are two ways to do this: Install with script tag Install with NPM package Was this page helpful?YesNoSuggest editsRaise issuePreviousInstallation via script tagNext⌘IgithubxtelegramPowered by MintlifyOn this pageConnect the TON Connect SDKGet the token with TON BuildersInitialize SDK",
    "category": "tma",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "react",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:35:20.210Z"
  },
  {
    "id": "docs-ton-org--ecosystem-tma-analytics-install-via-script",
    "title": "Installation via script tag",
    "url": "https://docs.ton.org/ecosystem/tma/analytics/install-via-script",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsOverviewTMA create CLITelegram UIMateAnalyticsTelegram analyticsSupported eventsPreparationsInstallation via script tagInstallation via NPM packageAPI EndpointsManaging integrationFAQBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationAnalyticsInstallation via script tagEcosystemTMA: Telegram Mini AppsAnalyticsInstallation via script tagCopy pageCopy page​How to install it? ​1.Add Telegram Mini Apps Analytics to your project** Include the Telegram Mini Apps Analytics script in the header of your HTML document. This script will allow you to track and analyze user interactions effectively. CopyAsk AI<!-- Add Telegram Analytics script to HTML head --> <script async src=\"https://tganalytics.xyz/index.js\" onload=\"initAnalytics()\" type=\"text/javascript\" ></script> Alternative solution (not recommended) CopyAsk AI<!-- Add Telegram Analytics script to HTML head --> <script async src=\"https://unpkg.com/@telegram-apps/analytics@latest/dist/index.js\" onload=\"initAnalytics()\" type=\"text/javascript\" ></script> ​2. Initialize the Telegram Mini Apps Analytics SDK Once you have your unique access token and analytics identifier (if not, see Preparations (TO DO link) page), you can initialize the Telegram Analytics SDK in your code. This step is crucial for enabling the tracking of events without repeatedly transferring the token. CopyAsk AI<script> function initAnalytics() { window.telegramAnalytics.init({ token: 'YOUR_TOKEN', appName: 'ANALYTICS_IDENTIFIER', }); } </script> ​Supported events After initializing the Telegram Analytics, you are all set to transfer the data, gain insights, and improve user engagement. (99% of them will be tracked automatically without manual control) Supported events Was this page helpful?YesNoSuggest editsRaise issuePreviousInstallation via NPM packageNext⌘IgithubxtelegramPowered by MintlifyOn this pageHow to install it?1.Add Telegram Mini Apps Analytics to your project**2. Initialize the Telegram Mini Apps Analytics SDKSupported events",
    "category": "tma",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:35:21.489Z"
  },
  {
    "id": "docs-ton-org--ecosystem-tma-analytics-install-via-npm",
    "title": "Installation via NPM package",
    "url": "https://docs.ton.org/ecosystem/tma/analytics/install-via-npm",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsOverviewTMA create CLITelegram UIMateAnalyticsTelegram analyticsSupported eventsPreparationsInstallation via script tagInstallation via NPM packageAPI EndpointsManaging integrationFAQBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationAnalyticsInstallation via NPM packageEcosystemTMA: Telegram Mini AppsAnalyticsInstallation via NPM packageCopy pageCopy page​How to install it? 1. Install the NPM package in your project CopyAsk AInpm install @telegram-apps/analytics CopyAsk AIyarn add @telegram-apps/analytics CopyAsk AIpnpm add @telegram-apps/analytics 2. Add Telegram Mini Apps Analytics in code Once you have your unique access token (if not, see Preparations page) and installed the NPM package, you can initialize the Telegram Analytics SDK in your code. To ensure that all events are collected correctly, you must initialize the SDK before the application starts rendering. For example, in React applications, before calling the render() function CopyAsk AIimport TelegramAnalytics from '@telegram-apps/analytics' TelegramAnalytics.init({ token: 'YOUR_TOKEN', appName: 'ANALYTICS_IDENTIFIER', }); ​Supported events After initializing the Telegram analytics, you are all set to transfer the data, gain insights, and improve user engagement. (99% of them will be tracked automatically without manual control) Supported events Was this page helpful?YesNoSuggest editsRaise issuePreviousAPI EndpointsNext⌘IgithubxtelegramPowered by MintlifyOn this pageHow to install it?Supported events",
    "category": "tma",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "react",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:35:23.739Z"
  },
  {
    "id": "docs-ton-org--ecosystem-tma-analytics-api-endpoints",
    "title": "API Endpoints",
    "url": "https://docs.ton.org/ecosystem/tma/analytics/api-endpoints",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsOverviewTMA create CLITelegram UIMateAnalyticsTelegram analyticsSupported eventsPreparationsInstallation via script tagInstallation via NPM packageAPI EndpointsManaging integrationFAQBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationAnalyticsAPI EndpointsEcosystemTMA: Telegram Mini AppsAnalyticsAPI EndpointsCopy pageCopy pageHere, you can view information about existing endpoints and how to make requests for them. ​API URL URL for POST requests: /events ​POST events This request is needed to record an event in the database. ​Body The request body may contain an array rather than a single event. The main thing is that all events in the array satisfy the scheme below. ​Required FieldTypeDescription user_idnumberUnique identifier for the user.event_namestringThe name of the event from the supported events.session_idstringSession identifier for tracking user sessions. Must be UUID.app_namestringThe name of the application that you specified when creating the token ​Optional FieldTypeDescription is_premiumbooleanIf the user has a premium account, by default - falseis_successbooleanIndicates whether a wallet is connected or the transaction was successful, by default - falseerror_messagestringError message if the wallet connection or transaction is unsuccessfulerror_codenumberDescription: error code if the wallet connection or transaction is unsuccessfulwallet_addressstringWallet address involved in the eventwallet_typestringType of the walletwallet_versionstringVersion of the wallet softwareauth_typeenumType of authorization used. 0 - ton_addr, 1 - ton_proof.valid_untilstringTimestamp until when a transaction offer is validfromstringWallet address initiating the transactionmessages{ address: string; amount: string }List of transactions {to, amount} involved in the eventcustom_dataobjectObject to store custom event details as neededclient_timestampstringThe time when the event occurred on the clientplatformstringThe platform from which the MiniApp was openedlocalestringUser language codestart_paramstringtgWebAppStartParamurl_refererstringThe URL of the web application from which the request was sentscopestringEvent scope ​Request body example: CopyAsk AI[ { \"event_name\": \"app-init\", \"session_id\": \"10c574d9-6d2c-4e6d-a141-ce6da141ce6d\", \"user_id\": 111111111, \"app_name\": \"docs\", \"is_premium\": true, \"platform\": \"tdesktop\", \"locale\": \"en\", \"client_timestamp\": \"1743503599534\" } ] CopyAsk AI[ { \"event_name\": \"connection-started\", \"custom_data\": { \"ton_connect_sdk_lib\": \"3.0.3\", \"ton_connect_ui_lib\": \"2.0.5\" }, \"session_id\": \"10c574d9-6d2c-4e6d-a141-ce6da141ce6d\", \"user_id\": 111111111, \"app_name\": \"docs\", \"is_premium\": true, \"platform\": \"tdesktop\", \"locale\": \"en\", \"client_timestamp\": \"1743503647541\" } ] CopyAsk AI[ { \"event_name\": \"connection-error\", \"is_success\": false, \"error_message\": \"Connection was cancelled\", \"error_code\": null, \"custom_data\": { \"ton_connect_sdk_lib\": \"3.0.3\", \"ton_connect_ui_lib\": \"2.0.5\" }, \"session_id\": \"10c574d9-6d2c-4e6d-a141-ce6da141ce6d\", \"user_id\": 111111111, \"app_name\": \"docs\", \"is_premium\": true, \"platform\": \"tdesktop\", \"locale\": \"en\", \"client_timestamp\": \"1743503683701\" } ] ​Headers Instead of YOUR_TOKEN, you need to specify the token received using the managing integration. (TO DO link) CopyAsk AI{ \"TGA-Auth-Token\": \"YOUR_TOKEN\", \"Content-Type\": \"application/json\" } ​Responses ​HTTP201 Description: The event has been successfully recorded Content: CopyAsk AI{ \"message\": \"Success record.\" } ​HTTP400 Description: The event was not recorded due to server issues Content: CopyAsk AI{ \"message\": \"Failed to record\" } ​HTTP400 Description: The token was entered incorrectly or in the wrong format Content: CopyAsk AI{ \"message\": \"The token is not specified in the headers or is specified incorrectly.\" } ​HTTP400 Description: The entered token is invalid (was not created through a Data Chief bot) Content: CopyAsk AI{ \"message\": \"Token is invalid.\" } ​HTTP400 Description: The request body contains the application name that does not match the token Content: CopyAsk AI{ \"message\": \"Invalid app_name is specified.\" } ​HTTP400 Description: the body specified in the request was not validated (for example, the type of one of the fields does not match) Content: CopyAsk AI{ \"status\": 400, \"message\": \"VALIDATION_MISMATCH_REPORT\" } ​HTTP403 Description: an attempt to use the API on a domain name that does not match the token Content: CopyAsk AI{ \"message\": \"The domain name does not match.\" } ​HTTP429 Description: too many requests from the client in a certain amount of time Content: CopyAsk AI{ \"message\": \"Too many requests. Try again later.\" } Was this page helpful?YesNoSuggest editsRaise issuePreviousManaging integrationNext⌘IgithubxtelegramPowered by MintlifyOn this pageAPI URLPOST eventsBodyRequiredOptionalRequest body example:HeadersResponsesHTTP201HTTP400HTTP400HTTP400HTTP400HTTP400HTTP403HTTP429",
    "category": "tma",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:35:26.058Z"
  },
  {
    "id": "docs-ton-org--ecosystem-tma-analytics-managing-integration",
    "title": "Managing integration",
    "url": "https://docs.ton.org/ecosystem/tma/analytics/managing-integration",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsOverviewTMA create CLITelegram UIMateAnalyticsTelegram analyticsSupported eventsPreparationsInstallation via script tagInstallation via NPM packageAPI EndpointsManaging integrationFAQBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationAnalyticsManaging integrationEcosystemTMA: Telegram Mini AppsAnalyticsManaging integrationCopy pageCopy pageTON Builders helps you manage your SDK keys and participate in various support programs from TON Foundation. Register your project and go to the Analytics tab. Enter your Telegram Bot URL and mini app domain to receive an API key for SDK initialization. You can also manage your existing keys from the same section.Was this page helpful?YesNoSuggest editsRaise issuePreviousFAQNext⌘IgithubxtelegramPowered by Mintlify",
    "category": "tma",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:35:28.303Z"
  },
  {
    "id": "docs-ton-org--languages-tolk-features-message-sending",
    "title": "Sending messages",
    "url": "https://docs.ton.org/languages/tolk/features/message-sending",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedOverviewBasic syntaxIdioms and conventionsType systemSyntax detailsLanguage featuresHandling messagesContract storageContract gettersSending messagesAutomatic serializationLazy loadingPayload in jettonsStandard libraryAssembler functionsCompiler optimizationsMigrating from FunCChangelogTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationLanguage featuresSending messagesLanguagesTolkLanguage featuresSending messagesCopy pageCopy pageTolk provides a high-level function createMessage, which is followed by send: CopyAsk AIval reply = createMessage({ bounce: BounceMode.NoBounce, value: ton(\"0.05\"), dest: senderAddress, body: RequestedInfo { ... } }); reply.send(SEND_MODE_REGULAR); ​Union types in contracts interaction When handling a message, some values can be represented in multiple valid forms. Union types allow expressing these alternatives explicitly, so the same message-handling logic can accept and correctly process any of them. ​Message value The message value consists of a Toncoin amount: CopyAsk AIvalue: someTonAmount When extra currencies are required, the message value includes both Toncoin and a dictionary: CopyAsk AIvalue: (someTonAmount, extraDict) This is possible because the value field is defined as a union: CopyAsk AI// how it is declared in stdlib struct CreateMessageOptions<TBody> { // ... value: coins | (coins, ExtraCurrenciesMap) } Then, the compiler selects the matching representation and serializes it accordingly. ​Message destination Message destinations are defined using the same union-based approach. CopyAsk AIdest: someAddress, dest: (workchain, hash) The destination field accepts multiple representations: CopyAsk AIstruct CreateMessageOptions<TBody> { // ... dest: address | // either just send a message to some address builder | // ... or a manually constructed builder with a valid address (int8, uint256) | // ... or to workchain + hash (also known as accountID) AutoDeployAddress // ... or \"send to stateInit\" aka deploy (address auto-calculated) } Each option represents a valid way to specify the message destination. The selected form is resolved at compile time. ​Deployment and StateInit Consider a contract that deploys another contract. For example, a jetton minter deploying a jetton wallet. The wallet code and its initial data are known: CopyAsk AIval walletInitialState: ContractState = { code: ..., // probably, kept in minter's storage data: ..., // initial wallet's storage }; When sending a message to the wallet, it may not yet exist on-chain. In this case, the message must include the wallet’s code and initial data. The message destination is therefore defined by the wallet’s StateInit. CopyAsk AI// address auto-calculated, code+data auto-attached dest: { stateInit: walletInitialState } For more advanced scenarios, configure additional fields: CopyAsk AIdest: { workchain: ..., // default: 0 (basechain) stateInit: ..., // either code+data OR a ready cell toShard: ..., // default: null (no sharding) } ​Shard-based deployment The createMessage interface supports deploying contracts into a specific shard. For example, in sharded jettons, a jetton wallet must be deployed into the same shard as the owner’s wallet. This is expressed as follows: A jetton wallet is deployed close to the owner’s wallet; This closeness is defined by shard_prefix. The example below uses shard_prefix is 8: TitleAddress hashCommentcloseTo owner address01010101...xxxowner’s walletshardPrefix01010101first 8 bits of closeTostateInitHashyyyyyyyy...yyyderived from code and dataresult jetton wallet address01010101...yyyjetton wallet in the same shard as owner Deployment with shard targeting is configured as follows: CopyAsk AIdest: { stateInit: walletInitialState, toShard: { closeTo: ownerAddress, fixedPrefixLength: 8 } } Shard prefix is part of StateInit together with code and data and is required for correct contract initialization in the blockchain. The compiler embeds it automatically. But semantically, on its own shard prefix is not meaningful. For this reason, shard prefix and closeTo are treated as a single entity. ​Message body A message is a cell. Its body can either be embedded into the same cell or placed into a separate cell and referenced. When creating a message, the body should be provided. The compiler determines how the body is stored. CopyAsk AIcreateMessage({ // ... body: RequestedInfo { ... } }); ​Inline or referenced body If body is small, it is embedded directly into the message cell. If body is large or has unpredictable size, it is stored as a ref. The decision is made at compile time. No runtime checks are involved. This is implemented using generics: CopyAsk AIfun createMessage<TBody>( options: CreateMessageOptions<TBody> ): OutMessage; struct CreateMessageOptions<TBody> { // ... body: TBody; } Each createMessage() call has its own TBody, allowing the compiler to estimate the body size: if the maximum size is less than 500 bits and 2 refs, the body is embedded; if the size is 500 bits or more, or requires more than 2 refs, the body is stored as a ref; if the body contains builder or slice, its size is considered unpredictable, and it is stored as a ref. If the body is large or unpredictable, it can be force-inlined by wrapping it into a special type: CopyAsk AI// maximum 620 bits (if all coins are billions of billions) // by default, the compiler will make a ref struct ProbablyLarge { a: (coins, coins, coins, coins, coins) } fun demo(contents: ProbablyLarge) { // but you are sure: coins are small; // so, you take the risks and force \"no ref\" createMessage({ body: UnsafeBodyNoRef { forceInline: contents, }, // ... }); // btw, here TBody = UnsafeBodyNoRef<ProbablyLarge> } If body is already a cell, it is stored as a ref: CopyAsk AIcreateMessage({ body: someCell, // ok, just a cell, keep it as a ref // ... }); Therefore, do not pass body: obj.toCell(). Pass body: obj, and the compiler will choose the optimal and correct encoding. ​Non-struct body body is not limited to structs. For example: CopyAsk AIval excessesMsg = createMessage({ // ... body: (0xd53276db as int32, input.queryId) }); excessesMsg.send(mode); The call is inferred as createMessage<(int32, uint64)>(...) and encoded accordingly. ​Empty body If no body is needed, it can be omitted entirely: CopyAsk AIcreateMessage({ bounce: BounceMode.NoBounce, dest: somewhere, value: remainingBalance }); In this example, the body type is void. A struct is declared as CreateMessageOptions<TBody = void>. By convention, fields of type void may be omitted in object literals. ​Sending modes A message created with createMessage() is typically sent using msg.send(mode). ​ContractState and StateInit StateInit contains more fields than code and data. For this reason, the code and data pair is defined as ContractState: CopyAsk AI// in stdlib struct ContractState { code: cell data: cell } While a field stateInit: ContractState | cell is named as stateInit, emphasizing that a full StateInit can be automatically initialized from ContractState. ​createExternalLogMessage createExternalLogMessage follows the same general model as createMessage. External outgoing messages do not support bounce behavior, attached Toncoin, or related options, so the set of available fields is different. External messages are used only for emitting logs intended for indexers. Example: CopyAsk AIval emitMsg = createExternalLogMessage({ dest: createAddressNone(), body: DepositEvent { ... } }); emitMsg.send(SEND_MODE_REGULAR); Only dest and body are available for external outgoing messages: CopyAsk AIstruct CreateExternalLogMessageOptions<TBody = void> { /// destination is either an external address or a pattern to calculate it dest: any_address | // either some valid external/none address (not internal) builder | // ... or a manually constructed builder with a valid external address ExtOutLogBucket; // ... or encode topic/eventID in destination /// body is any serializable object (or just miss this field for empty body) body: TBody; } The compiler automatically determines whether body fits into the same cell or must be stored as a reference. UnsafeBodyNoRef is also supported. Example of emitting an external log: CopyAsk AIstruct DepositData { amount: coins; ... } val emitMsg = createExternalLogMessage({ dest: ExtOutLogBucket { topic: 123 }, // for indexers body: DepositData { ... } }); emitMsg.send(SEND_MODE_REGULAR); Example of emitting an external log: CopyAsk AIstruct (0x12345678) DepositEvent { amount: coins; ... } createExternalLogMessage({ dest: createAddressNone(), body: DepositEvent { ... } // 0x12345678 for indexers }); ExtOutLogBucket represents a custom external address for emitting logs to the outer world. It includes a numeric topic that defines the message body format. In the example above, a deposit event is emitted using topic: 123. Such logs can be indexed by destin",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "deployment",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:35:30.131Z"
  },
  {
    "id": "docs-ton-org--languages-tolk-syntax-imports",
    "title": "Imports and name resolution",
    "url": "https://docs.ton.org/languages/tolk/syntax/imports",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedOverviewBasic syntaxIdioms and conventionsType systemSyntax detailsVariablesConditions and loopsExceptionsFunctions and methodsStructures and fieldsPattern matchingMutabilityOperatorsImportsLanguage featuresMigrating from FunCChangelogTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationSyntax detailsImports and name resolutionLanguagesTolkSyntax detailsImports and name resolutionCopy pageCopy pageIn practice, contract code is split across multiple files. Projects with multiple contracts share a single codebase, including messages, storage layouts, and related logic. Symbols defined in one file can be used in another by importing that file. After an import, all its public symbols are available to the importing file. ​Importing files Error codes are commonly placed in a separate file, for example errors.tolk: CopyAsk AIconst ERR_ZERO_BALANCE = 123 // ... To use these constants in parse.tolk, the file must be imported explicitly: CopyAsk AIimport \"errors\" fun validate(balance: coins) { assert (balance > 0) throw ERR_ZERO_BALANCE; } When selecting items from auto-completion, IDE inserts imports automatically. This works in both JetBrains-based and VSCode-based IDEs. ​Name uniqueness All top-level symbols must have unique names. There is no export const ... or export fun ... declarations needed. All constants, functions, and other top-level declarations are visible by default. No module‑private symbols exist. As a result, all top-level symbols across imported files must have unique names. Declaring fun log() in multiple files causes a duplicate declaration error when both files are imported. Techniques to avoid name collisions: Use long, descriptive names for top-level symbols, especially in multi‑contract projects. Good: ReturnExcessesBack, WalletStorage. Bad: Excesses, Storage. Group integer constants to enums. Prefer methods to global-scope functions. ​Repeated symbols across contracts When developing multiple contracts, each contract has its own file, compilation target. Contract files do not import one another; therefore, the following declarations do not conflict across different contracts: onInternalMessage and onExternalMessage; get fun; other contract entrypoints. CopyAsk AI// file: a-contract.tolk import \"storage\" import \"errors\" fun onInternalMessage(in: InMessage) { // ... } get fun name() { return \"a\" } CopyAsk AI// file: b-contract.tolk import \"storage\" import \"errors\" fun onInternalMessage(in: InMessage) { // ... } get fun name() { return \"b\" } Get methods conceptually belong to the scope of a specific contract. In a multi-contract project, each contract file typically contains only: its entrypoints, optionally, a union of allowed messages, and contract-specific logic. The remaining codebase is shared. For instance, a struct SomeMessage outgoing for one contract and incoming for another. When one contract deploys another, both must share the storage struct. As a guideline, group messages, errors, utils, etc. in shared files, and use only minimal declarations inside each contract.tolk.Was this page helpful?YesNoSuggest editsRaise issuePreviousHandling messagesNext⌘IgithubxtelegramPowered by MintlifyOn this pageImporting filesName uniquenessRepeated symbols across contracts",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:35:31.563Z"
  },
  {
    "id": "docs-ton-org--languages-tolk-features-auto-serialization",
    "title": "Automatic serialization",
    "url": "https://docs.ton.org/languages/tolk/features/auto-serialization",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedOverviewBasic syntaxIdioms and conventionsType systemSyntax detailsLanguage featuresHandling messagesContract storageContract gettersSending messagesAutomatic serializationLazy loadingPayload in jettonsStandard libraryAssembler functionsCompiler optimizationsMigrating from FunCChangelogTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationLanguage featuresAutomatic serializationLanguagesTolkLanguage featuresAutomatic serializationCopy pageCopy pageAll data in TON, such as messages, storage, etc., is represented as cells. The Tolk type system is designed to express cell contents, enabling auto-serialization through fromCell and toCell: CopyAsk AIstruct Point { x: int8 y: int8 } fun demo() { var value: Point = { x: 10, y: 20 }; // makes a cell containing \"0A14\" (hex) var c = value.toCell(); // back to { x: 10, y: 20 } var p = Point.fromCell(c); } ​Type serialization A struct can define a serialization prefix. 32-bit prefixes are commonly used as opcodes for incoming and outgoing messages: CopyAsk AIstruct (0x7362d09c) TransferNotification { queryId: uint64 // ... } A prefix is not required to be 32 bits: 0x000F is a 16-bit prefix, and 0b010 is a 3-bit one. ​Cell references and its types Fields of a struct are serialized one by one. The compiler does not reorder fields or insert implicit references. When data should be stored in a ref, it is done explicitly. A developer controls exactly when each ref is loaded. There are two types of references – typed and untyped: Cell<T> – typed reference; the cell has a known internal structure; cell – untyped reference; the cell content is not described. CopyAsk AIstruct NftStorage { ownerAddress: address nextItemIndex: uint64 content: cell // untyped ref royalty: Cell<RoyaltyParams> // typed ref } struct RoyaltyParams { numerator: uint16 // ... } A call NftCollectionStorage.fromCell() is processed as follows: read address; read uint64; read two refs without unpacking them – only their pointers are loaded. ​Cell<T> Cell<T> must be loaded to get T. Consider the royalty field: CopyAsk AIstruct NftStorage { // ... royalty: Cell<RoyaltyParams> } Since it is a cell, storage.royalty.numerator is not valid: CopyAsk AI// error: `Cell<RoyaltyParams>` has no field `numerator` storage.royalty.numerator; ^^^^^^^^^ To access numerator and other fields, load the reference: CopyAsk AIval royalty = storage.royalty.load(); // Cell<T> to T // or, alternatively val royalty = RoyaltyParams.fromCell(storage.royalty); // works royalty.numerator; When composing an instance, assign a cell, not an object: CopyAsk AIval storage: NftStorage = { // error royalty: RoyaltyParams{ ... } // correct royalty: RoyaltyParams{ ... }.toCell() } Summary: CopyAsk AIpCell = point.toCell(); // `Point` to `Cell<Point>` point = pCell.load(); // `Cell<Point>` to `Point` Cell<address> or Cell<int32 | int64> is supported, T is not restricted to structures. ​Custom serializers for custom types Type aliases allow overriding serialization behavior when the required encoding cannot be represented using existing types: CopyAsk AItype MyString = slice fun MyString.packToBuilder(self, mutate b: builder) { // custom logic } fun MyString.unpackFromSlice(mutate s: slice) { // custom logic } This mechanism applies only to type aliases. It does not work for structures, enums, etc. ​Behavior with corrupted input Point.fromCell(c) throws an exception if the cell does not contain the required data. The function expects at least 16 bits. CopyAsk AIstruct Point { x: int8 y: int8 } fun demo() { Point.fromCell(createEmptyCell()); } Typical failure cases include: not enough bits or refs, unless lazy fromCell is used; extra data after the expected fields; can be enabled; address has an invalid format; enum has an invalid value; a mismatched struct prefix; other format inconsistencies. Common exception codes: 9 – cell underflow; 5 – out of range. Some behaviors are configurable. For example, to allow extra data: CopyAsk AIMyMsg.fromSlice(s, { assertEndAfterReading: false }) ​Cell packing and unpacking options Behavior of fromCell and toCell can be controlled by an option object: CopyAsk AIMyMsg.fromCell(c, { // options object }) For deserialization, there are two options: CopyAsk AIMyMsg.fromCell(c, { // call `assertEnd` to ensure no remaining data left; // (in other words, the struct describes all data) assertEndAfterReading: true, // default: true // this errCode is thrown if opcode doesn't match, // e.g. for `struct (0x01) A` given input \"88...\", // or for a union type, none of the prefixes match throwIfOpcodeDoesNotMatch: 63, // default: 63 }) For serialization, there is one option: CopyAsk AIobj.toCell({ // for `bits128` and similar (a slice under the hood), // insert the checks (bits == 128 and refs == 0); // turn off to save gas if you guarantee input is valid; // `intN` are always validated, it's only for `bitsN` skipBitsNValidation: false, // default: false }); ​Functions Functions such as fromCell(), fromSlice(), etc., are designed to integrate with low-level features. For deserialization, each of the functions can be controlled by UnpackOptions: T.fromCell(c) parses a cell using c.beginParse() + fromSlice: CopyAsk AIvar storage = NftStorage.fromCell(contract.getData()); T.fromSlice(s) parses a slice; the slice is not mutated: CopyAsk AIvar msg = CounterIncrement.fromSlice(s); slice.loadAny<T>() mutates the slice: CopyAsk AIvar storage = s.loadAny<NftStorage>(); var nextNum = s.loadAny<int32>(); // also ok options.assertEndAfterReading is ignored because the function reads from the middle of the slice. slice.skipAny<T>(), such as skipBits() and similar: CopyAsk AIs.skipAny<Point>(); // skips 16 bits For serialization, each of the functions can be controlled by PackOptions. T.toCell() works as beginCell() + serialize + endCell(): CopyAsk AIcontract.setData(storage.toCell()); builder.storeAny<T>(v), such as storeUint() and similar: CopyAsk AIvar b = beginCell() .storeUint(32) .storeAny(msgBody) // T=MyMsg here .endCell(); ​RemainingBitsAndRefs RemainingBitsAndRefs is a built-in type to get remaining part of a slice when reading. Example: CopyAsk AIstruct JettonMessage { // ... some fields forwardPayload: RemainingBitsAndRefs } After JettonMessage.fromCell, forwardPayload contains everything left in the slice after reading the preceding fields. It is an alias for a slice that the compiler treats specially: CopyAsk AItype RemainingBitsAndRefs = slice ​What if data exceeds 1023 bits? The Tolk compiler issues a warning if a serializable struct may exceed 1023 bits. This can happen because many types have variable size. For example, int8? can be 1 or 9 bits, coins can range from 4 to 124 bits, etc. Consider a struct: CopyAsk AIstruct MoneyInfo { fixed: bits800 wallet1: coins wallet2: coins } Serializing this struct produces a compiler error: CopyAsk AIstruct `MoneyInfo` can exceed 1023 bits in serialization (estimated size: 808..1048 bits) ... (and some instructions) Consider one of the following actions: Suppress the error. If coins values are expected to be relatively small and the struct will fit in practice, suppress the error using an annotation: CopyAsk AI@overflow1023_policy(\"suppress\") struct MoneyInfo { ... } Reorganize the struct by splitting into multiple cells. If coins values are expected to be relatively large and the data may exceed 1023 bits, extract some fields into a separate cell. For example, store 800 bits as a ref or extract the other two fields: CopyAsk AI// extract the first field struct MoneyInfo { fixed: Cell<bits800> wallet1: coins wallet2: coins } // or extract the other two fields struct WalletsBalances { wallet1: coins wallet2: coins } struct MoneyInfo { fixed: bits800 balances: Cell<WalletsBalances> } Frequently used fields should remain in the struct; less-frequent fields can be moved to a nested ref. ​What if serialization is unavailable? A common mistake is using int. It cannot be serialized; instead, use int32, uint64, etc. CopyAsk AIstruct Storage { owner: address lastTime: int // mistake is here } fun errDemo() { Storage.fromSlice(\"\"); } The compiler reports: CopyAsk AIauto-serialization via fromSlice() is not available for type `Storage` because field `Storage.lastTime` of type `int` can't be serialized because type `int` is not serializable, it doesn't define binary width hint: replace `int` with `int32` / `uint64` / `coins` / etc. ​Integration with message sending Auto-serialization can be applied when sending messages to other contracts: CopyAsk AIval reply = createMessage({ // ... body: RequestedInfo { // auto-serialized // ... } }); reply.send(SEND_MODE_REGULAR); ​lazy for deserialization Tolk provides a special keyword lazy for use with auto-deserialization. The compiler loads only the requested fields, rather than the entire struct. CopyAsk AIstruct Storage { isSignatureAllowed: bool seqno: uint32",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:35:34.830Z"
  },
  {
    "id": "docs-ton-org--languages-tolk-syntax-structures-fields",
    "title": "Structures and fields",
    "url": "https://docs.ton.org/languages/tolk/syntax/structures-fields",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedOverviewBasic syntaxIdioms and conventionsType systemSyntax detailsVariablesConditions and loopsExceptionsFunctions and methodsStructures and fieldsPattern matchingMutabilityOperatorsImportsLanguage featuresMigrating from FunCChangelogTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationSyntax detailsStructures and fieldsLanguagesTolkSyntax detailsStructures and fieldsCopy pageCopy pageTolk supports structures — similar to TypeScript classes. ​Structure syntax CopyAsk AIstruct Demo { allowExotic: bool = false customData: tuple } Every field has a required type and an optional default value. Fields are separated by newlines, which are preferred, or by commas or semicolons. Fields can be private and readonly. ​Object creation Use { ... } when the type is clear, or StructName { ... } explicitly. CopyAsk AIfun demo() { // the type is clear from the assignment var o1: Demo = { customData: someTuple }; o1.someMethod(); // alternatively, `Demo { ... }` Demo{customData: someTuple}.someMethod(); } ​Shorthand object syntax The shorthand { a, b } expands to { a: a, b: b }. This syntax is similar to object shorthand in TypeScript. CopyAsk AIfun createDemo(allowExotic: bool, customData: tuple) { return Demo { allowExotic, customData } } ​Methods for structures Methods are declared separately as extension functions: CopyAsk AIfun Demo.hasData(self): bool { return self.customData.size() != 0 } ​Empty structures A structure without fields is used as a grouping construct for static methods. For example, standard functions such as blockchain.now() are declared this way: CopyAsk AIstruct blockchain fun blockchain.now(): int asm \"NOW\" fun blockchain.logicalTime(): int asm \"LTIME\" These methods are static because they do not accept self. ​Default values for fields Fields with default values may be missed out of a literal: CopyAsk AIstruct DefDemo { f1: int = 0 f2: int? = null f3: (int, coins) = (0, ton(\"0.05\")) } fun demo() { var d: DefDemo = {}; // ok var d: DefDemo = { f2: 5 }; // ok } ​Private and readonly fields private – accessible only within methods. readonly – immutable after object creation. CopyAsk AIstruct PositionInTuple { private readonly t: tuple currentIndex: int } fun PositionInTuple.create(t: tuple): PositionInTuple { return { t, currentIndex: 0 } } fun PositionInTuple.next(mutate self) { // self.t cannot be modified: it is readonly self.currentIndex += 1; } fun demo() { var p = PositionInTuple.create(someTuple); // p.t is unavailable here: it is private } An object with a private field can only be constructed by a static method or an assembler function. ​Generic structs Generics exist only at the type level and incur no runtime cost. CopyAsk AIstruct Nullable<T> { value: T? } ​Methods for generic structs When parsing the receiver in fun <receiver>.f(), the compiler treats unknown symbols as type parameters: CopyAsk AIfun Nullable<T>.isNull(self) { return self.value == null } It’s a generalization. For example, fun T.copy() is valid for any receiver. Method overloading or partial specialization is also allowed: CopyAsk AIfun Nullable<map<K, V>>.isNull(self) { return self.value.isEmpty() } ​Serialization prefixes and opcodes The syntax struct (PREFIX) Name { ... } specifies a serialization prefix for the structure. For messages, 32-bit prefixes are typically called opcodes. CopyAsk AIstruct (0x7362d09c) TransferNotification { queryId: uint64 // ... } An outgoing message starts with the hex number: CopyAsk AI// message will be '0x7362d09c0000000000000000' + ... createMessage({ // ... body: TransferNotification { queryId: 0, // ... } }); Prefixes are not restricted to 32 bits: 0x000F — 16-bit hexadecimal prefix, value 15. 0b010 — 3-bit binary prefix, value 2. Non‑32‑bit prefixes are useful for controlling union types when expressing TL‑B’s multiple constructors.Was this page helpful?YesNoSuggest editsRaise issuePreviousPattern matchingNext⌘IgithubxtelegramPowered by MintlifyOn this pageStructure syntaxObject creationShorthand object syntaxMethods for structuresEmpty structuresDefault values for fieldsPrivate and readonly fieldsGeneric structsMethods for generic structsSerialization prefixes and opcodes",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:35:36.669Z"
  },
  {
    "id": "docs-ton-org--languages-tolk-syntax-functions-methods",
    "title": "Functions and methods",
    "url": "https://docs.ton.org/languages/tolk/syntax/functions-methods",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedOverviewBasic syntaxIdioms and conventionsType systemSyntax detailsVariablesConditions and loopsExceptionsFunctions and methodsStructures and fieldsPattern matchingMutabilityOperatorsImportsLanguage featuresMigrating from FunCChangelogTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationSyntax detailsFunctions and methodsLanguagesTolkSyntax detailsFunctions and methodsCopy pageCopy pageTolk allows declaring functions and methods: fun f(<params>) — a function fun <receiver>.f(<params>) — a method: fun <receiver>.f(self, ...) — an instance method fun <receiver>.f(...) — a static method (no self) All features are identical except for the receiver. Most examples below use functions, but all concepts equally apply to methods. ​Types for parameters are required CopyAsk AI// invalid: fun sum(a, b) {} // valid: fun sum(a: int, b: bool) {} ​The return type is auto-inferred if omitted Either specify return type manually: CopyAsk AIfun demo(): int { // ... } or it is inferred from the return statements, similar to TypeScript: CopyAsk AIfun demo() { // auto-infer `int` // ... return 10; } If various returns have different types, the compiler will fire an error instead of inferring a union type, because this typically indicates a bug. ​Default values for parameters Default values are placed after the type, allowing constant expressions: CopyAsk AIfun plus(value: int, delta: int = 1) { return value + delta } fun demo() { plus(10); // 11 plus(10, 5); // 15 } ​Methods: for any type, including structures A method is declared as an extension function, similar to Kotlin. If the first parameter is self, it’s an instance method. Otherwise, it’s a static method. CopyAsk AIstruct Point { x: int y: int } // no `self` — static method fun Point.createZero(): Point { return { x: 0, y: 0 } } // has `self` — instance method fun Point.sumCoords(self) { return self.x + self.y } Instance methods are invoked via obj.method(), whereas static methods — on a type: CopyAsk AIfun demo() { val p = Point.createZero(); return p.sumCoords(); // 0 } Methods are not limited to structures. They may exist for any receiver, including unions, aliases, and primitives: CopyAsk AIfun int.one() { return 1 } fun int.negate(self) { return -self } fun demo() { return int.one().negate() // -1 } All standard methods are declared this way: fun cell.hash(self), etc. The type of self is determined by the receiver. All parameters after should have their types set. The return type is inferred if omitted. CopyAsk AIfun Point.equalTo(self, r: Point) { // auto-infer `bool` return self.x == r.x && self.y == r.y } ​self is immutable by default To allow modifications, declare mutate self explicitly. For details, see mutability. CopyAsk AI// mind `mutate` — to allow modifications fun Point.reset(mutate self) { self.x = 0; self.y = 0; } ​return self makes a chainable method To make a method chainable, declare it as fun (...): self. For instance, all methods for builder return self, which allows b.storeXXX().storeXXX(): CopyAsk AIfun builder.myStoreInt32(mutate self, v: int): self { self.storeInt(v, 32); return self; } fun demo() { return beginCell() .storeAddress(SOME_ADDR) .myStoreInt32(123) .endCell(); } ​Small functions are automatically inlined Create one-liner methods without any worries. The compiler automatically inlines them in-place, targeting zero overhead. For example, this program CopyAsk AIfun int.zero() { return 0 } fun int.inc(mutate self, byValue: int = 1): self { self += byValue; return self; } fun main() { return int.zero().inc().inc() } is reduced to “return 2” in assembler: CopyAsk AImain() PROC:<{ 2 PUSHINT }> For details, see compiler optimizations. ​@attributes A function or method may be preceded by one or several attributes: CopyAsk AI@noinline @custom(\"any contents here\") fun slowSum(a: int, b: int) { return a + b } The following attributes are allowed: @inline — Forces a function to be inlined in-place. Typically unnecessary, as the compiler performs inlining automatically. @inline_ref — Turns on a special version of inlining: its body will be embedded as a child cell reference in the resulting bytecode. @noinline — Disables inlining for a function. For example, if it’s a “slow path”. @method_id(<number>) — Low-level annotation to manually override TVM method_id. @pure — Indicates that a function does not modify global state (including TVM one). If its result is unused, a call could be deleted. Typically used in assembler functions. @deprecated — A function is not recommended for use and exists only for backwards compatibility. @custom(<anything>) — A custom expression, not analyzed by the compiler. ​Assembler functions Tolk supports declaring low-level assembler functions with embedded Fift code: CopyAsk AI@pure fun minMax(x: int, y: int): (int, int) asm \"MINMAX\" It’s a low-level feature and requires deep knowledge of Fift and TVM. See assembler functions. ​Anonymous functions (lambdas) Tolk supports first-class functions: they can be passed as callbacks. Both named functions and function expressions may be referenced: CopyAsk AIfun customRead(reader: (slice) -> int) { // ... } fun demo() { customRead(fun(s) { return s.loadUint(32) }) } See callables. ​Generic functions A function declared as fun f<T>(...) is a generic one. T is called a “type parameter”. CopyAsk AIfun duplicate<T>(value: T): (T, T) { var copy: T = value; return (value, copy); } When calling a generic function, the compiler automatically infers type arguments: CopyAsk AIfun demo() { duplicate(1); // duplicate<int> duplicate(somePoint); // duplicate<Point> duplicate((1, 2)); // duplicate<(int, int)> } Type arguments may also be specified explicitly using f<...>(args): CopyAsk AIfun demo() { duplicate<int32>(1); duplicate<Point?>(null); // two nullable points } Functions may declare multiple type parameters: CopyAsk AI// returns `(tensor.0 || defA, tensor.1 || defB)` fun replaceNulls<T1, T2>(tensor: (T1?, T2?), defA: T1, defB: T2): (T1, T2) { var (a, b) = tensor; return (a == null ? defA : a, b == null ? defB : b); } Since Tolk supports first-class functions, various custom invokers for general-purpose frameworks can be expressed: CopyAsk AIfun customInvoke<TArg, R>(f: TArg -> R, arg: TArg) { return f(arg); } Default type parameters are supported, like fun f<T1, T2 = int>, but they cannot reference one another currently. Although type parameters are usually inferred from the arguments, there are edge cases where T cannot be inferred because it does not depend on them. For example, tuples. A tuple may have anything inside it, that’s why invoking tuple.get lacks without T: CopyAsk AI// a method `tuple.get` is declared this way in stdlib: fun tuple.get<T>(self, index: int): T; fun demo(t: tuple) { var mid = t.get(1); // error, can not deduce T // correct is: var mid = t.get<int>(1); // or var mid: int = t.get(1); } A generic function may be assigned to a variable, but T must be specified explicitly because this is not a call: CopyAsk AIfun genericFn<T>(v: T) { // ... } fun demo() { var callable = genericFn<builder>; callable(beginCell()); } ​Generic methods Declaring a method for a generic type does not differ from declaring any other method. The compiler treats unknown symbols as type parameters while parsing the receiver: CopyAsk AIstruct Pair<T1, T2> { first: T1 second: T2 } // both <T1,T2>, <A,B>, etc. work: any unknown symbols fun Pair<A, B>.create(f: A, s: B): Pair<A, B> { return { first: f, second: s, } } // instance method with `self` fun Pair<A, B>.compareFirst(self, rhs: A) { return self.first <=> rhs } Generic methods can be also used as first-class functions: CopyAsk AIvar callable = Pair<int, slice>.compareFirst; callable(somePair, 123); // pass somePair as self Methods for generic structures can themselves be generic: CopyAsk AIfun Pair<A, B>.createFrom<U, V>(f: U, s: V): Pair<A, B> { return { first: f as A, second: s as B, } } fun demo() { return Pair<int?, int?>.createFrom(1, 2); } ​Methods for “any receiver” Any unknown symbol (typically T) may be used to define a method applicable to any type: CopyAsk AI// any receiver fun T.copy(self): T { return self } // any nullable receiver fun T?.isNull(self): bool { return self == null } Note that “any receivers” do not conflict with specific ones. CopyAsk AIfun T.someMethod(self) { ... } fun int.someMethod(self) { ... } fun demo() { 42.someMethod(); // (2) address(\"...\").someMethod(); // (1) with T=address } This is known as “overloading” or “partial specialization”. ​Partial specialization of generic methods Specializing generic methods allows some logic to work differently for predefined types or patterns. Consider the following example. Suppose, there is an iterator over a tuple of slices, each slice contains encoded T. CopyAsk AIstruct TupleIterator<T> { data: tuple // [slice, slice, ...] nextIndex: int } fun TupleIterator<T>.",
    "category": "languages",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:35:37.925Z"
  },
  {
    "id": "docs-ton-org--languages-tolk-syntax-variables",
    "title": "Variables",
    "url": "https://docs.ton.org/languages/tolk/syntax/variables",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedOverviewBasic syntaxIdioms and conventionsType systemSyntax detailsVariablesConditions and loopsExceptionsFunctions and methodsStructures and fieldsPattern matchingMutabilityOperatorsImportsLanguage featuresMigrating from FunCChangelogTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationSyntax detailsVariablesLanguagesTolkSyntax detailsVariablesCopy pageCopy page Use val for immutable variables and var for mutable variables. Use const or global outside functions. ​Declaration val declares a variable that is assigned exactly once: CopyAsk AIfun demo() { val coeff = 5; // cannot change its value, `coeff += 1` is an error } var declares a variable that can be reassigned: CopyAsk AIfun demo() { var x = 5; x += 1; // now 6 } ​Explicit types A variable may declare its type explicitly. If the type is not specified, it is inferred from the initial assignment: CopyAsk AIfun demo() { var x = 5; // inferred `int` x = null; // error, cannot assign var y: int? = 5; // specified nullable y = null; // ok } Explicit types also can be used with structures: CopyAsk AIfun demo() { var p1: Point = { x: 10, y: 20 }; // without an explicit type, use `Point { ... }` var p2 = Point { x: 10, y: 20 }; } ​Unassigned variables A variable may be declared without an initial value, but it must be assigned before its first use: CopyAsk AIfun demo(mode: int) { var result: int; // not assigned at declaration if (mode == MODE_SLOW) { result = doSlowCalc(); } else if (mode == MODE_FAST) { result = doFastCalc(); } else { throw ERR_INVALID_MODE; } return result; // ok, it's definitely assigned } ​Multiple variables Declaring multiple variables at once is tensor destructuring: CopyAsk AIfun demo() { var (a, b) = (1, \"\"); // with explicit types var (c: int, d: slice) = (1, \"\"); } ​Nested scope A block { ... } introduces a nested scope: CopyAsk AIfun demo() { val x = 10; if (smth) { val x = 50; // this is a different `x` } // x is 10 } ​Function parameters Function parameters behave the same as local variables. They can be reassigned, but the reassignment does not affect the caller’s state: CopyAsk AIfun analyze(userId: int?) { if (userId == null) { userId = DEFAULT_ID; } // ... } fun demo() { var id = null as int?; analyze(id); // id remains `null` } To make updates to userId visible in demo, declare the parameter with mutate: mutate userId. ​Constants Global-scope constants are declared with const outside functions: CopyAsk AIconst SLEEP_TIME_SEC = 5 The right-hand side must be a constant expression: numbers, const literals, compile-time functions, etc. CopyAsk AI// ok const FLAG_JANUARY = 1 << 10 const OP_TRANSFER = stringCrc32(\"transfer\") // error: not a constant expression const CUR_TIME = blockchain.now() The type is inferred unless explicitly specified: CopyAsk AIconst MODE_NORMAL: uint32 = 0 Constants are not limited to integers: CopyAsk AI// type `address` const ADMIN_ADDR = address(\"UQ...\") // type `coins` const MINIMAL_COST = ton(\"0.05\") // even objects with constant fields const ZERO_POINT: Point = { x: 0, y: 0 } To calculate CRC32 and similar values at compile time, use stringCrc32(\"...\") and similar. To group integer constants, use enums. ​Global variables Use the global keyword to declare variables outside functions: CopyAsk AIglobal runtimeCalls: tuple A global must have an explicit type and cannot be initialized at the point of declaration. Initialization is done manually at some point in a program. A contract has several entry points, such as get fun, onInternalMessage, and others. A global must be initialized along the execution path where it is required. CopyAsk AIglobal runtimeCalls: tuple fun execute() { runtimeCalls.push(\"start execute\"); // ... } get fun devTrace() { runtimeCalls = createEmptyTuple(); // initialize val result = execute(); return (result, runtimeCalls); } In Tolk, avoid globals when possible. Use auto-serialization and lazy loading. Use globals with care. Until initialized, a global holds TVM NULL, and any invalid access leads to a runtime failure.Was this page helpful?YesNoSuggest editsRaise issuePreviousConditions and loopsNext⌘IgithubxtelegramPowered by MintlifyOn this pageDeclarationExplicit typesUnassigned variablesMultiple variablesNested scopeFunction parametersConstantsGlobal variables",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:35:40.764Z"
  },
  {
    "id": "docs-ton-org--languages-tolk-types-enums",
    "title": "Enums",
    "url": "https://docs.ton.org/languages/tolk/types/enums",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedOverviewBasic syntaxIdioms and conventionsType systemList of typesNumbersBooleansAddressCells, slices, buildersStringsStructuresType aliasesGenericsEnumsNullable typesUnion typesTensorsTuplesMapsCallablesVoid and neverType checks and castsOverall: TVM stackOverall: serializationSyntax detailsLanguage featuresMigrating from FunCChangelogTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationType systemEnumsLanguagesTolkType systemEnumsCopy pageCopy pageTolk supports enums, similar to TypeScript and C++ enums. In the TVM (virtual machine) all enums are integers. From the compiler’s point of view, it’s a distinct type. CopyAsk AI// will be 0 1 2 enum Color { Red Green Blue } ​Enum members Values can be specified manually. Otherwise, auto-calculated as +1. CopyAsk AIenum Mode { Foo = 256, Bar, // implicitly 257 } ​Enums are distinct types, not integers Color.Red is Color, not int, although it holds the value 0 at runtime. CopyAsk AIfun isRed(c: Color) { return c == Color.Red } fun demo() { isRed(Color.Blue); // ok isRed(1); // error, pass `int` to `Color` } Since enums are types, they can be: used as variable and parameters, extended with methods for an enum, used in struct fields, unions, generics, and other type contexts: CopyAsk AIstruct Gradient { from: Color to: Color? = null } fun Color.isRed(self) { return self == Color.Red } var g: Gradient = { from: Color.Blue }; g.from.isRed(); // false Color.Red.isRed(); // true match (g.to) { null => ... Color => ... } ​match for enums is exhaustive Pattern matching on enums requires coverage of all cases: CopyAsk AImatch (someColor) { Color.Red => {} Color.Green => {} // error: Color.Blue is missing } Alternatively, use else to handle remaining values: CopyAsk AImatch (someColor) { Color.Red => {} else => {} } Operator == compares values directly: CopyAsk AIif (someColor == Color.Red) {} else {} ​Enums are integers under the hood At the TVM level, every enum is represented as int. Casting between the enum and int is allowed: Color.Blue as int evaluates to 2 2 as Color evaluates to Color.Blue Operator as can produce invalid values: 100 as Color. Then operator == will return false, and exhaustive match will throw 5 (“out of range”). During deserialization with fromCell(), the compiler performs checks to ensure that encoded integers correspond to valid enum values. Enums in Tolk differ from Rust. In Rust, each enum member can have a distinct structure. In Tolk, union types provide that capability, so enums are only integers. ​Enums are allowed in throw and assert CopyAsk AIenum Err { InvalidId = 0x100 TooHighId } fun validate(id: int) { assert (id < 1000) throw Err.TooHighId; // excno = 257 } ​Stack layout and serialization Every enum is backed by TVM INT. Serialized as (u)intN where N is: specified manually: enum Role: int8 { ... } or calculated automatically to fit all values For details, follow TVM representation and Serialization.Was this page helpful?YesNoSuggest editsRaise issuePreviousNullable typesNext⌘IgithubxtelegramPowered by MintlifyOn this pageEnum membersEnums are distinct types, not integersmatch for enums is exhaustiveEnums are integers under the hoodEnums are allowed in throw and assertStack layout and serialization",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:35:42.442Z"
  },
  {
    "id": "docs-ton-org--languages-tolk-syntax-mutability",
    "title": "Mutability",
    "url": "https://docs.ton.org/languages/tolk/syntax/mutability",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedOverviewBasic syntaxIdioms and conventionsType systemSyntax detailsVariablesConditions and loopsExceptionsFunctions and methodsStructures and fieldsPattern matchingMutabilityOperatorsImportsLanguage featuresMigrating from FunCChangelogTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationSyntax detailsMutabilityLanguagesTolkSyntax detailsMutabilityCopy pageCopy pageTolk follows value semantics: function arguments are copied by value. There are no pointers or object references. The mutate keyword, used both at declaration and invocation, allows a function to modify the argument. ​Value semantics Function arguments are copied by value: calls do not modify the original data. CopyAsk AIfun someFn(x: int) { x += 1; } fun demo() { var origX = 0; someFn(origX); // origX remains 0 } This also applies to slices, cells, and other types: CopyAsk AIfun readFlags(cs: slice) { return cs.loadInt(32); } fun onInternalMessage(in: InMessage) { var flags = readFlags(in.body); // body is NOT modified // `in.body.loadInt(32)` reads the same flags } ​mutate parameter The mutate keyword makes a parameter mutable. To prevent unintended modifications, mutate must also be specified at the call site. CopyAsk AIfun increment(mutate x: int) { x += 1; } fun demo() { // correct: var origX = 0; increment(mutate origX); // origX becomes 1 // these are compiler errors increment(origX); // error, unexpected mutation increment(10); // error, not lvalue } This also applies to slices and other types: CopyAsk AIfun readFlags(mutate cs: slice) { return cs.loadInt(32); } fun onInternalMessage(in: InMessage) { var flags = readFlags(mutate in.body); // `in.body.loadInt(32)` reads the next integer } A function can define multiple mutate parameters: CopyAsk AIfun incrementXY(mutate x: int, mutate y: int, delta: int) { x += delta; y += delta; } fun demo() { var (a, b) = (5, 8); incrementXY(mutate a, mutate b, 10); // a = 15, b = 18 } This behavior is similar to passing by reference, but since ref is already used in TON for cells and slices, the keyword mutate is chosen. ​self in methods Instance methods are declared as fun <receiver>.f(self). By default, self is immutable: CopyAsk AIfun slice.readFlags(self) { return self.loadInt(32); // error, a mutating method } fun slice.preloadFlags(self) { return self.preloadInt(32); // ok, a read-only method } ​mutate self mutate self allows modifying the receiver: CopyAsk AIfun slice.readFlags(mutate self) { return self.loadInt(32); } Thus, when calling someSlice.readFlags(), the object is mutated. Methods for structures are declared in the same way: CopyAsk AIstruct Point { x: int y: int } fun Point.reset(mutate self) { self.x = self.y = 0 } A mutating method can modify another variable: CopyAsk AIfun Point.resetAndRemember(mutate self, mutate sum: int) { sum = self.x + self.y; self.reset(); } fun demo() { var (p, sumBefore) = (Point { x: 10, y: 20 }, 0); p.resetAndRemember(mutate sumBefore); return (p, sumBefore); // { 0, 0 } and 30 } ​How does mutate work? Tolk code is executed by TVM – a stack-based virtual machine. Mutations work by implicitly returning new values through the stack. CopyAsk AI// transformed to: \"returns (int, void)\" fun increment(mutate x: int): void { x += 1; // a hidden \"return x\" is inserted } fun demo() { var x = 5; // transformed to: (newX, _) = increment(x); x = newX increment(mutate x); } Mutating methods work the same: CopyAsk AI// transformed to: (newS, flags) = loadInt(s, 32); s = newS flags = s.loadInt(32); ​T.fromSlice(s) does not modify s Auto-serialization with fromSlice follows the same mutability rules. Passing an argument without mutate never modifies the original variable. In a call f(anyVariable), the variable remains unchanged. If a function needs to modify its argument, the call must explicitly use mutate: f(mutate anyVariable). The same rule applies to AnyStruct.fromSlice(s). The slice is not mutated, and its internal pointer is not shifted. So, calling s.assertEnd() does not check “nothing is left after loading AnyStruct”. CopyAsk AIstruct Point { x: int8 y: int8 } fun demo(s: slice) { // want to check that \"0102\" is ok, \"0102FF\" is wrong // but this is NOT correct var p = Point.fromSlice(s); s.assertEnd(); // because s is not mutated } To check that a slice does not contain excess data, no special actions are required, because fromCell and fromSlice automatically ensure the slice ends after reading. For input 0102FF, an exception 9 is thrown. This behavior can be turned off with an option: CopyAsk AIPoint.fromSlice(s, { assertEndAfterReading: false // true by default }) Was this page helpful?YesNoSuggest editsRaise issuePreviousOperatorsNext⌘IgithubxtelegramPowered by MintlifyOn this pageValue semanticsmutate parameterself in methodsmutate selfHow does mutate work?T.fromSlice(s) does not modify s",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:35:44.711Z"
  },
  {
    "id": "docs-ton-org--languages-tolk-syntax-conditions-loops",
    "title": "Conditions and loops",
    "url": "https://docs.ton.org/languages/tolk/syntax/conditions-loops",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedOverviewBasic syntaxIdioms and conventionsType systemSyntax detailsVariablesConditions and loopsExceptionsFunctions and methodsStructures and fieldsPattern matchingMutabilityOperatorsImportsLanguage featuresMigrating from FunCChangelogTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationSyntax detailsConditions and loopsLanguagesTolkSyntax detailsConditions and loopsCopy pageCopy pageTolk provides constructs for controlling contract flow. Use if, assert, and loops for conditional logic. Use match expression for pattern matching. ​if statement if statement works as in most languages. else if and else blocks are optional. CopyAsk AIif (condition) { // ... } else { // ... } A condition must be a boolean or an integer. If not equals 0, then true: CopyAsk AIif (someInt) { // means \"someInt != 0\" // ... } The body of if and else must be enclosed in { ... }: CopyAsk AI// invalid if (condition) someFn(); // valid if (condition) { someFn(); } ​assert statement assert throws an exceptions if a condition is false. CopyAsk AIassert (condition) throw ERR_CODE; It is equivalent to the following form: CopyAsk AIif (!condition) { throw ERR_CODE; } ​match expression match is used to perform different actions for different values of a variable. A common use case is routing values of a union type: CopyAsk AIfun demo(v: A | B | C) { match (v) { A => { // use `v.aField` etc. } B => { /* ... */ } C => { /* ... */ } } } The match is equivalent to a series of if-else checks: CopyAsk AIfun demo(v: A | B | C) { if (v is A) { // use `v.aField` etc. } else if (v is B) { /* ... */ } else { /* ... */ } } The match can also be used for expressions, switch-like behavior: CopyAsk AIfun invertNumber(curValue: int) { return match (curValue) { 1 => 0, 0 => 1, else => throw ERR_UNEXPECTED, }; } ​Ternary operator The ternary form condition ? when_true : when_false is available: CopyAsk AIfun myAbs(v: int) { return v < 0 ? -v : v } If the types of when_true and when_false differ, the result becomes a union type. In most cases this is unintended, so the compiler reports an error. CopyAsk AIfun demo(a: int32, b: int64) { // instead of inferring result1 as `int32 | int64`, // an error \"probably it's not what you expected\" val result1 = a > b ? a : b; // correct: specify the type manually val result2: int = a > b ? a : b; // also correct, types are compatible val result3 = a > b ? a as int64 : b; } ​while loops while and do-while loops repeatedly execute their bodies while the condition remains true. while checks the condition first and may not execute the body at all, whereas do-while runs the body first. CopyAsk AIfun demoWhile(i: int) { while (i > 0) { debug.print(i); i -= 1; } } fun demoDoWhile() { var rand: int; do { rand = random.uint256(); } while (rand % 2 == 0); return rand; // an odd number } while is used to iterate over maps: CopyAsk AIfun iterateOverMap(m: map<int32, Point>) { var r = m.findFirst(); while (r.isFound) { // ... r = m.iterateNext(r); } } ​repeat loop The repeat (N) statement executes its block N times: CopyAsk AIrepeat (5) { // executed 5 times } N may be either a constant or a variable. ​break and continue The keywords break and continue are not supported.Was this page helpful?YesNoSuggest editsRaise issuePreviousExceptionsNext⌘IgithubxtelegramPowered by MintlifyOn this pageif statementassert statementmatch expressionTernary operatorwhile loopsrepeat loopbreak and continue",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:35:46.723Z"
  },
  {
    "id": "docs-ton-org--languages-tolk-types-unions",
    "title": "Union types",
    "url": "https://docs.ton.org/languages/tolk/types/unions",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedOverviewBasic syntaxIdioms and conventionsType systemList of typesNumbersBooleansAddressCells, slices, buildersStringsStructuresType aliasesGenericsEnumsNullable typesUnion typesTensorsTuplesMapsCallablesVoid and neverType checks and castsOverall: TVM stackOverall: serializationSyntax detailsLanguage featuresMigrating from FunCChangelogTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationType systemUnion typesLanguagesTolkType systemUnion typesCopy pageCopy pageTolk supports union types T1 | T2 | ... similar to TypeScript. They allow a value to belong to one of several possible types. Pattern matching over unions is essential for message handling. A special case T | null is written as T? and called “nullable”. CopyAsk AIstruct (0x12345678) Increment { /* ... */ } struct (0x23456789) Reset { /* ... */ } type IncomingMsg = Increment | Reset fun handle(m: IncomingMsg) { match (m) { Increment => { /* here m is `Increment` */ } Reset => { /* here m is `Reset` */ } } } ​Not only structures: arbitrary types All these types are valid: int | slice address | Point | null Increment | Reset | coins int8 | int16 | int32 | int64 Union types are automatically flattened: CopyAsk AItype Int8Or16 = int8 | int16 struct Demo { t1: Int8Or16 | int32? // int8 | int16 | int32 | null t2: int | int // int } Union types support assignment based on subtype relations. For instance, B | C can be passed/assigned to A | B | C | D: CopyAsk AIfun take(v: bits2 | bits4 | bits8 | bits16) {} fun demo() { take(someSlice as bits4); // ok take(anotherV); // ok for `bits2 | bits16` } ​match must cover all cases In other words, it must be exhaustive. CopyAsk AIfun errDemo(v: int | slice | Point) { match (v) { slice => { v.loadAddress() } int => { v * 2 } // error: missing `Point` } } match can be used for nullable types, since T? is T | null. It may also be used as an expression: CopyAsk AIfun replaceNullWith0(maybeInt: int?): int { return match (maybeInt) { null => 0, int => maybeInt, } } See pattern matching for syntax details. ​Auto-inference of a union results in an error What if match arms result in different types, what is the resulting type? CopyAsk AIvar a = match (...) { ... => beginCell(), ... => 123, }; Formally, the type of a is inferred as builder | int, but this is most likely not what is intended and typically indicates an error in the code. In such situations, the compiler emits a message: CopyAsk AIerror: type of `match` was inferred as `builder | int`; probably, it's not what you expected assign it to a variable `var a: <type> = match (...) { ... }` manually So, either explicitly declare a as a union, or fix contract’s code if it’s a misprint. The same applies to other situations: CopyAsk AIfun f() { if (...) { return someInt64 } else { return someInt32 } } The result is inferred as int32 | int64, which is valid, but in most cases a single integer type is expected. The compiler shows an error, just explicitly declare a return type: CopyAsk AIfun f(): int { if (...) { return someInt64 } else { return someInt32 } } Anyway, declaring return types is good practice, and following it resolves any ambiguity. ​Operators is and !is Besides match, unions can also be tested using is: CopyAsk AIfun demo(v: A | B) { if (v is A) { v.aMethod(); } else { v.bMethod(); } } ​Lazy match for unions In all examples of message handling, unions are parsed with lazy: CopyAsk AIfun onInternalMessage(in: InMessage) { val msg = lazy MyUnion.fromSlice(in.body); match (msg) { // ... } } This pattern is called “lazy match”: No union is allocated on the stack upfront; loading is deferred until needed. match operates by inspecting the slice prefix (opcode), not by typeid on the stack. This approach is significantly more efficient, although unions continue to function correctly without lazy and comply with all type-system rules. Read about lazy loading. ​Stack layout and serialization Unions have a complex stack layout, commonly named as “tagged unions”. Enums in Rust work the same way. Serialization depends on whether the it’s a union of structures with manual serialization prefixes: if yes (struct (0x1234) A), those prefixes are used if no, the compiler auto-generates a prefix tree; for instance, T1 | T2 is called “Either”: ‘0’+T1 or ‘1’+T2 For details, follow TVM representation and Serialization.Was this page helpful?YesNoSuggest editsRaise issuePreviousTensorsNext⌘IgithubxtelegramPowered by MintlifyOn this pageNot only structures: arbitrary typesmatch must cover all casesAuto-inference of a union results in an errorOperators is and !isLazy match for unionsStack layout and serialization",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:35:48.810Z"
  },
  {
    "id": "docs-ton-org--languages-tolk-syntax-exceptions",
    "title": "Exceptions in Tolk",
    "url": "https://docs.ton.org/languages/tolk/syntax/exceptions",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedOverviewBasic syntaxIdioms and conventionsType systemSyntax detailsVariablesConditions and loopsExceptionsFunctions and methodsStructures and fieldsPattern matchingMutabilityOperatorsImportsLanguage featuresMigrating from FunCChangelogTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationSyntax detailsExceptions in TolkLanguagesTolkSyntax detailsExceptions in TolkCopy pageCopy pageTolk supports exceptions and handling them with try catch. If an exception is not caught, the program terminates with errCode. In TVM, exceptions are numbers. There is no Error class or exception hierarchy, only exit codes. ​Error codes A simple pattern is to define a constant for each exception that a contract may produce: CopyAsk AIconst ERR_LOW_BALANCE = 200 const ERR_SIGNATURE_MISMATCH = 201 Yet, this pattern should not be used in production environments, as it does not scale. Instead, use an enum — they are easier to maintain and reference, as enumerations come with exhaustive checks from the compiler: CopyAsk AIenum ErrCode { LowBalance = 200, SignatureMismatch, // implicitly 201 } Use these constants in throw and related statements described on this page. Use error codes between 64 and 2048Lower values are reserved by TVM. Larger ones are more gas-expensive. ​throw statement To throw an exception unconditionally: CopyAsk AIthrow ERR_CODE; Non-constant expressions such as throw someVariable are supported but not recommended. It works, but the compiler cannot determine possible error codes and therefore cannot provide a correct ABI for external callers. An exception can carry an argument: CopyAsk AIthrow (ERR_CODE, errArg); The argument is available in catch and must be a TVM primitive, not a tuple nor a tensor. ​assert statement An assert is a shorthand for “throw if a condition is not satisfied”. It is commonly used when parsing user input: CopyAsk AIassert (msg.seqno == storage.seqno) throw E_INVALID_SEQNO; assert (msg.validUntil > blockchain.now()) throw E_EXPIRED; The long form assert (condition) throw ERR_CODE is preferred. The short form assert (condition, ERR_CODE) exists but is not recommended. The condition must be either a boolean or an integer, where non-zero integers are treated as true and all other integer values as false. An assert statement is equivalent to: CopyAsk AIif (!condition) { throw ERR_CODE; } ​TVM implicit throws During contract execution, TVM may throw runtime exceptions. For example: slice.loadInt(8) will fail when the slice is empty. builder.storeRef(cell) will fail when the builder has 4 references already. tuple.push(value) will fail when the tuple has 255 elements already. etc. Additionally, an out-of-gas exception may occur at any point, and it cannot be caught using a catch block. It can only be prevented by writing exhaustive testing suites. ​try catch statement The catch block is used to handle most runtime errors within the try block, except for out-of-gas exceptions: CopyAsk AItry { // ... } catch (errCode) { // errCode is `int` } Use the short form catch { ... } when errCode is not needed. Use the long form catch (errCode, arg) when the exception may carry an argument produced by throw (errCode, arg). If the exception was thrown as throw errCode, the argument is null. CopyAsk AItry { throw (ERR_LOW_BALANCE, 555); } catch (errCode, arg) { val data = arg as int; // 555 } Any error inside a try block reverts all changes made within. TVM restores local variables and control registers to the state they had before entering try.However, gas counters and TVM codepage settings are not rolled back. Gas is always spent.Was this page helpful?YesNoSuggest editsRaise issuePreviousFunctions and methodsNext⌘IgithubxtelegramPowered by MintlifyOn this pageError codesthrow statementassert statementTVM implicit throwstry catch statement",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:35:50.330Z"
  },
  {
    "id": "docs-ton-org--languages-tolk-types-maps",
    "title": "Maps (key-value)",
    "url": "https://docs.ton.org/languages/tolk/types/maps",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedOverviewBasic syntaxIdioms and conventionsType systemList of typesNumbersBooleansAddressCells, slices, buildersStringsStructuresType aliasesGenericsEnumsNullable typesUnion typesTensorsTuplesMapsCallablesVoid and neverType checks and castsOverall: TVM stackOverall: serializationSyntax detailsLanguage featuresMigrating from FunCChangelogTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationType systemMaps (key-value)LanguagesTolkType systemMaps (key-value)Copy pageCopy pageTolk supports map<K, V> — a high‑level type that encapsulates TVM dictionaries: Any serializable keys and values. Natural syntax for iterating forwards, backwards, or starting from a specified key. Zero overhead compared to low-level approach. ​Create an empty map CopyAsk AIvar m: map<int8, int32> = createEmptyMap(); // or var m = createEmptyMap<int8, int32>(); A map is a dedicated type, it may be used in parameters, fields, etc.: CopyAsk AIstruct Demo { m: map<int64, Point> } fun create(): Demo { return { m: createEmptyMap() } } ​Add values to a map Use m.set(k, v) and other methods suggested by an IDE after a dot (a full list is available below): CopyAsk AIvar m: map<int8, int32> = createEmptyMap(); m.set(1, 10); m.addIfNotExists(2, -20); m.replaceIfExists(2, 20); m.delete(2); // now: [ 1 => 10 ] m.exists(1); // true m.exists(2); // false ​Get a value by key m.get(key) returns isFound + loadValue(): CopyAsk AIvar r = m.get(1); if (r.isFound) { val v = r.loadValue(); // 10 } Note: check not r == null, but r.isFound. In other words, map.get(key) returns not V?, but a special result. Also use m.mustGet(key) that returns V and throws if the key is missing: CopyAsk AIm.mustGet(1); // 10 m.mustGet(100500); // runtime error ​Iterate forward and backward There is no dedicated foreach syntax. Iteration follows this pattern: define the starting key: r = m.findFirst() or r = m.findLast() while r.isFound: use r.getKey() and r.loadValue() move the cursor: r = m.iterateNext(r) or r = m.iteratePrev(r) Example: iterate all keys forward CopyAsk AI// suppose there is a map [ 1 => 10, 2 => 20, 3 => 30 ] // this function will print \"1 10 2 20 3 30\" fun iterateAndPrint<K, V>(m: map<K, V>) { var r = m.findFirst(); while (r.isFound) { debug.print(r.getKey()); debug.print(r.loadValue()); r = m.iterateNext(r); } } Example: iterate backwards from keys ≤ 2 CopyAsk AI// suppose `m` is `[ int => address ]` and already populated // for every key<=2, print addr.workchain fun printWorkchainsBackwards(m: map<int32, address>) { var r = m.findKeyLessOrEqual(2); while (r.isFound) { val a = r.loadValue(); // it's `address` debug.print(a.getWorkchain()); r = m.iteratePrev(r); } } ​Check if a map is empty CopyAsk AIm.isEmpty() // not `m == null` For experienced readersAt the TVM level, an empty map is stored as TVM NULL. But since map is a dedicated type, it must be checked with isEmpty().Nullable maps are valid, then m may be null or may hold either an empty map or a non‑empty map. ​Allowed types for K and V All the following key and value types are valid: CopyAsk AImap<int32, Point?> map<address, address> map<Point, map<int3, bool>> map<uint256, Cell<SnakeData>> map<bits18, slice> Some types are not allowed. General rules: Keys must be fixed-width and contain zero references Valid: int32, address, bits256, Point Invalid: int, coins, cell Values must be serializable Valid: coins, AnyStruct, Cell<AnyStruct> Invalid: int, builder In practice, keys are most commonly intN, uintN, or address. Values can be any serializable type. ​Available methods for maps An IDE suggests available methods after a dot. Most methods are self-explanatory. createEmptyMap<K, V>(): map<K, V> Returns an empty typed map. Equivalent to PUSHNULL since TVM NULL represents an empty map. createMapFromLowLevelDict<K, V>(d: dict): map<K, V> Converts a low-level TVM dictionary to a typed map. Accepts an optional cell and returns the same optional cell. Mismatched key or value types result in failures when calling map.get or related methods. m.toLowLevelDict(): dict Converts a high-level map to a low-level TVM dictionary. Returns the same optional cell. m.isEmpty(): bool Checks whether a map is empty. Use m.isEmpty() instead of m == null. m.exists(key: K): bool Checks whether a key exists in a map. m.get(key: K): MapLookupResult<V> Gets an element by key. Returns isFound = false if key does not exist. m.mustGet(key: K, throwIfNotFound: int = 9): V Gets an element by key and throws if it does not exist. m.set(key: K, value: V): self Sets an element by key. Since it returns self, calls may be chained. m.setAndGetPrevious(key: K, value: V): MapLookupResult<V> Sets an element and returns the previous element. If no previous element, isFound = false. m.replaceIfExists(key: K, value: V): bool Sets an element only if the key exists. Returns whether an element was replaced. m.replaceAndGetPrevious(key: K, value: V): MapLookupResult<V> Sets an element only if the key exists and returns the previous element. m.addIfNotExists(key: K, value: V): bool Sets an element only if the key does not exist. Returns true if added. m.addOrGetExisting(key: K, value: V): MapLookupResult<V> Sets an element only if the key does not exist. If exists, returns an old value. m.delete(key: K): bool Deletes an element by key. Returns true if deleted. m.deleteAndGetDeleted(key: K): MapLookupResult<V> Deletes an element by key and returns the deleted element. If not found, isFound = false. m.findFirst(): MapEntry<K, V> m.findLast(): MapEntry<K, V> Finds the first (minimal) or last (maximal) element. For integer keys, returns minimal (maximal) integer. For addresses or complex keys (represented as slices), returns lexicographically smallest (largest) key. Returns isFound = false when the map is empty. m.findKeyGreater(pivotKey: K): MapEntry<K, V> m.findKeyGreaterOrEqual(pivotKey: K): MapEntry<K, V> m.findKeyLess(pivotKey: K): MapEntry<K, V> m.findKeyLessOrEqual(pivotKey: K): MapEntry<K, V> Finds an element with key compared to pivotKey. m.iterateNext(current: MapEntry<K, V>): MapEntry<K, V> m.iteratePrev(current: MapEntry<K, V>): MapEntry<K, V> Iterates over a map in ascending (descending) order. ​Augmented hashmaps and prefix dictionaries These structures are rarely used and are not part of the Tolk type system. Prefix dictionaries: import @stdlib/tvm-dicts and use assembly functions. Augmented hashmaps and Merkle proofs: implement interaction manually. ​Keys are auto-serialized At the TVM level, keys can be numbers or slices. Complex keys, such as Point, are automatically serialized and deserialized by the compiler. CopyAsk AIstruct Point { x: int8 y: int8 } fun demo(m: map<Point, V>) { // a key is automatically packed to a 16-bit slice m.set({x: 10, y: 20}, 123); // and unpacked back to `Point` return m.findFirst().key; } If a key is a struct with a single intN field, it behaves like a number. CopyAsk AIstruct UserId { v: int32 } struct Demo { // equal to K=int32 without extra serialization m: map<UserId, V> } ​How to emulate Set<T> with maps Use an “empty tensor” as a type for V: CopyAsk AItype Set<T> = map<T, ()> It will work, a bit noisy. Lots of methods for maps are just inapplicable to sets, so its “public interface” is wrong. Sets have a much simpler API, literally 4 functions. It’s better to create a simple wrapper: CopyAsk AIstruct Set<T> { private m: map<T, ()> } fun Set<T>.add(self, value: T) { /* ... */ } // etc. ​Low-level: why “isFound” but not “optional value”? There are two reasons for this design: Gas consumption (zero overhead) Nullable values can be supported, like map<int32, address?> or map<K, Point?>. Returning V?, makes it impossible to distinguish between “key exists but value is null” and “key does not exist”. Low-level content below, not required for using maps TVM dictionaries store binary data. Having a map<K, int32> and doing m.set(k, 10), this “10” is actually 0x0000000A (automatically packed by the compiler). All TVM instructions for reading return slices, so at some point, those bits should be decoded back to “10”. TVM instructions put two values on a stack: (slice -1) or (null 0). If a choice is to return V?, the compiler needs to do something like CopyAsk AIIF stack[0] == -1: decode stack[1] to V transform V to V? ELSE: drop stack[1] transform null to V? Then, at usage, it’s compared null: CopyAsk AIval v = m.get(k); // internally, IF ELSE: for decoding if (v != null) { // one more IF: for checking ... } So, it results in two runtime checks and three TVM continuations. That’s why instead of V?, a special struct is returned: CopyAsk AIfun map<K, V>.get(self, key: K): MapLookupResult<V>; struct MapLookupResult<TValue> { private readonly rawSlice: slice? isFound: bool } fun MapLookupResult<TValue>.loadValue(self): TValue { return TValue.fromSlice(self.rawSlice!) } This struct directly maps onto the TVM stack: (slice -1)",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:35:52.317Z"
  },
  {
    "id": "docs-ton-org--languages-tolk-features-contract-getters",
    "title": "Contract getters",
    "url": "https://docs.ton.org/languages/tolk/features/contract-getters",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedOverviewBasic syntaxIdioms and conventionsType systemSyntax detailsLanguage featuresHandling messagesContract storageContract gettersSending messagesAutomatic serializationLazy loadingPayload in jettonsStandard libraryAssembler functionsCompiler optimizationsMigrating from FunCChangelogTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationLanguage featuresContract gettersLanguagesTolkLanguage featuresContract gettersCopy pageCopy pageContract getters or get methods are declared using get fun xxx(). They typically return data extracted from storage: CopyAsk AIget fun currentOwner() { val storage = lazy Storage.load(); return storage.ownerAddress; } ​Return type The return type is inferred when omitted. Get methods follow the same behavior as functions and methods. Specifying the return type explicitly is recommended: CopyAsk AIget fun currentOwner(): address { // ... } ​Custom name Use camelCase for naming. Recommended: get fun currentOwner() Not recommended: get fun get_current_owner() This convention may be overridden when matching standard TEPs. For example, a jetton wallet should expose a method get_wallet_data, as it was named in implementations. In such cases, using get fun get_wallet_data is appropriate, even if it does not follow the camelCase convention. ​Structures When a getter returns multiple values, define a structure and return it. Using a structure is acceptable even for a single return. Field names provide explicit metadata for client wrappers, making the structure self-descriptive. CopyAsk AIstruct JettonWalletDataReply { jettonBalance: coins ownerAddress: address minterAddress: address jettonWalletCode: cell } get fun get_wallet_data(): JettonWalletDataReply { val storage = lazy WalletStorage.load(); return { jettonBalance: storage.jettonBalance, ownerAddress: storage.ownerAddress, minterAddress: storage.minterAddress, jettonWalletCode: contract.getCode(), } } ​lazy loading Use lazy loading for contract storage. Prefer lazy loadStorage() instead of loadStorage(). Unreferenced fields are skipped automatically. ​Parameters Get methods can accept parameters. Parameters use the same syntax as regular functions: CopyAsk AIget fun get_wallet_address(ownerAddress: address): address { // ... } ​Stack-based execution Any function in TVM takes its arguments from the stack and pushes return values onto it; get methods differ only in that they can be invoked off-chain. When called off-chain, a get method does not persist state changes. A getter can return int, which is not serializable unlike intN. Returning a structure pushes each field onto the stack as a separate value. Client libraries such as Blueprint parse get method responses using a tuple reader. Get methods do not store their names. They are identified by a method_id = crc16(name) | 0x10000, avoiding the need to store additional strings on-chain.Was this page helpful?YesNoSuggest editsRaise issuePreviousSending messagesNext⌘IgithubxtelegramPowered by MintlifyOn this pageReturn typeCustom nameStructureslazy loadingParametersStack-based execution",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:35:54.667Z"
  },
  {
    "id": "docs-ton-org--languages-tolk-from-func-tolk-vs-tlb",
    "title": "Tolk vs TL-B",
    "url": "https://docs.ton.org/languages/tolk/from-func/tolk-vs-tlb",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedOverviewBasic syntaxIdioms and conventionsType systemSyntax detailsLanguage featuresMigrating from FunCTolk vs FunCTolk vs TL-BStandard librariesConverterChangelogTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationMigrating from FunCTolk vs TL-BLanguagesTolkMigrating from FunCTolk vs TL-BCopy pageCopy pageExperienced developers coming from FunC tend to ask questions like: “What’s the analogue of XXX in TL-B?” “How to generate a TL-B schema for a Tolk structure?” etc. Such questions lead in the wrong direction — because the Tolk type system is designed as a replacement for TL-B. ​Stop thinking in TL-B terms Tolk type system replaces TL-BThere is no need to “provide a TL-B schema for a contract”. Every Tolk struct is already a schema. Why is TL-B so widely used in TON today? Because contracts written in FunC are not declarative. They are low-level imperative programs that manually parse cells and slices. TL-B exists to compensate for this — to provide a declarative description: which inputs are valid, which shape is expected, how storage is structured, etc. In Tolk, messages and storage are described directly in structs. This description is exactly what TL-B used to provide — but serialized automatically. In the near future, ABI and TypeScript wrappers will be generated automatically as well. These features rely entirely on the type system. Surprisingly, source maps and debugger integration will also rely on the same core. TL-B is not involved in any of these processes. Moreover, TL-B and the Tolk type system are not equivalent, even if they look similar at first glance. Similarities include: intN, uintN, bitsN Maybe (nullable), Either (a two-component union) multiple constructors (declared structs + prefixes + unions) cells and typed cells But the differences are essential. TL-B supports the following (not expressible in Tolk): ~tilde {conditions} dynamic ## n Tolk supports the following (not expressible in TL-B): type aliases enums inline unions (auto-generated prefix trees) tensors custom packToBuilder and unpackFromSlice address? as “internal or none” (not “maybe T”) further language improvements, such as namespaces or modules The conclusion is simple: all the tooling around Tolk will not involve TL-B. TL-B is excellent for describing blockchain internals like block.tlb — but not for contracts APIs or interaction models. The page Overall serialization describes how each Tolk type relates to TL-B. Notice the presence of imperative serialization rules there — fundamentally different from declarative TL-B schemas.Was this page helpful?YesNoSuggest editsRaise issuePreviousStandard librariesNext⌘IgithubxtelegramPowered by MintlifyOn this pageStop thinking in TL-B terms",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:35:56.485Z"
  },
  {
    "id": "docs-ton-org--languages-tolk-features-lazy-loading",
    "title": "Lazy loading",
    "url": "https://docs.ton.org/languages/tolk/features/lazy-loading",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedOverviewBasic syntaxIdioms and conventionsType systemSyntax detailsLanguage featuresHandling messagesContract storageContract gettersSending messagesAutomatic serializationLazy loadingPayload in jettonsStandard libraryAssembler functionsCompiler optimizationsMigrating from FunCChangelogTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationLanguage featuresLazy loadingLanguagesTolkLanguage featuresLazy loadingCopy pageCopy pageTolk uses the lazy keyword – the compiler tracks which fields are accessed and loads only those fields, skipping the rest. In practice, prefer lazy T.fromCell() over T.fromCell(). ​lazy usage Consider a Storage struct in a wallet: CopyAsk AIstruct Storage { isSignatureAllowed: bool seqno: uint32 subwalletId: uint32 publicKey: uint256 extensions: cell? } fun Storage.load() { return Storage.fromCell(contract.getData()) } Storage.load() unpacks the cell, loads all fields, performs consistency checks, etc. lazy Storage.load() does not load all fields. Unused fields are skipped: CopyAsk AIget fun publicKey() { val st = lazy Storage.load(); // <-- here \"skip 65 bits, preload uint256\" is inserted return st.publicKey } The compiler tracks all control-flow paths, inserts load points when required, and groups unused fields to skip. This works for any type and any combination of fields. ​lazy usage of referenced cells Consider the NFT collection: CopyAsk AIstruct NftCollectionStorage { adminAddress: address nextItemIndex: uint64 content: Cell<CollectionContent> // ... } struct CollectionContent { metadata: cell minIndex: int32 commonKey: uint256 } To read content and then get commonKey from it: CopyAsk AIval storage = lazy NftCollectionStorage.load(); // <-- here just \"preload ref\" is inserted val contentCell = storage.content; Skipping address and uint64 is unnecessary. Accessing a reference does not require skipping preceding fields. To read commonKey from content, load the cell with lazy. CopyAsk AIval storage = lazy NftCollectionStorage.load(); // <-- \"preload ref\" inserted — to get `content` // Cell<T>.load() unpacks a cell and returns T val content = lazy storage.content.load(); // <-- \"skip 32 bits, preload uint256\" - to get commonKey return content.commonKey; p: Cell<Point> does not allow direct access to p.x. The cell must be loaded first using either Point.fromCell(p) or p.load(). Both work with lazy. ​lazy matching A union type such as an incoming message can be read with lazy: CopyAsk AIstruct (0x12345678) CounterIncrement { /* ... */ } struct (0x23456789) CounterReset { /* ... */ } type MyMessage = CounterIncrement | CounterReset fun onInternalMessage(in: InMessage) { val msg = lazy MyMessage.fromSlice(in.body); match (msg) { CounterReset => { assert (something) throw 403; // <-- here \"load msg.initial\" is inserted storage.counter = msg.initial; } // ... } } With lazy applied to unions: No union is allocated on the stack upfront; matching and loading are deferred until needed. match operates by inspecting the slice prefix (opcode). Within each branch, the compiler inserts loading points and skips unused fields, as it does for structs. lazy matching avoids unnecessary stack operations. ​lazy matching and else match with lazy on a union operates by inspecting the prefix. Any unmatched case falls into the else branch. CopyAsk AIval msg = lazy MyMessage.fromSlice(in.body); match (msg) { CounterReset => { /* ... */ } // ... handle all variants of the union // else - when nothing matched; // even input less than 32 bits, no \"underflow\" thrown else => { // for example throw 0xFFFF } } Without an explicit else, unpacking throws error 63 by default, which is controlled by the throwIfOpcodeDoesNotMatch option in fromSlice. The else branch allows inserting any custom logic. else in a type-based match is allowed only with lazy because matching uses prefixes. Without lazy, the union is matched normally and an else branch is not allowed. ​Partial updating The lazy keyword also applies when writing data back. Example: Load a storage, use its fields for assertions, update one field, and save it back: CopyAsk AIvar storage = lazy Storage.load(); assert (storage.validUntil > blockchain.now()) throw 123; assert (storage.seqno == msg.seqno) throw 456; // ... storage.seqno += 1; contract.setData(storage.toCell()); // <-- magic toCell() does not save all fields of the storage since only seqno is modified. Instead, after loading seqno, the compiler saves an immutable tail and reuses it when writing back: CopyAsk AIvar storage = lazy Storage.load(); // actually, what was done: // - load isSignatureAllowed, seqno // - save immutable tail // - load validUntil, etc. // ... use all fields for reading storage.seqno += 1; storage.toCell(); // actually, what was done: // - store isSignatureAllowed, seqno // - store immutable tail The compiler can also group unmodified fields located in the middle, load them as a slice, and preserve that slice on write-back. ​How does lazy skip unused fields? When several consecutive fields are unused, the compiler tries to group them. This works for fixed-size types such as intN or bitsN: CopyAsk AIstruct Demo { isAllowed: bool // always 1 bit queryId: uint64 // always 64 bits crc: bits32 // always 32 bits next: RemainingBitsAndRefs } fun demo() { val obj = lazy Demo.fromSlice(someSlice); // <-- skip 1+64+32 = 97 bits obj.next; } In Fift assembler, “skip 97 bits” becomes: CopyAsk AI97 LDU NIP Variable-width fields, such as coins, cannot be grouped and cannot be skipped with one instruction – TVM has no instruction for that. The only option is to load the value and ignore it. The same applies to address. Even though it occupies 267 bits, the value should be validated even when unused; otherwise, binary data could be decoded incorrectly. For these types, lazy does only “load and ignore”. In practice, intN types are common, so grouping has an effect. The trick “access a ref without skipping any data” also works. ​What are the disadvantages of lazy? In terms of gas consumption, lazy fromSlice is equal to or cheaper than regular fromSlice. When all fields are accessed, it loads them one by one, the same way as the non-lazy version. There is a difference unrelated to gas consumption: If a slice is small or contains extra data, fromSlice throws. lazy picks only the requested fields and handles partially invalid input. For example: CopyAsk AIstruct Point { x: int8 y: int8 } fun demo(s: slice) { val p = lazy Point.fromSlice(s); return p.x; } Since only p.x is accessed, an input of FF (8 bits) is acceptable even though y is missing. Similarly, FFFF0000 (16 bits of extra data) is also acceptable, as lazy ignores any data that is not requested.Was this page helpful?YesNoSuggest editsRaise issuePreviousPayload in jettonsNext⌘IgithubxtelegramPowered by MintlifyOn this pagelazy usagelazy usage of referenced cellslazy matchinglazy matching and elsePartial updatingHow does lazy skip unused fields?What are the disadvantages of lazy?",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:35:58.074Z"
  },
  {
    "id": "docs-ton-org--languages-tolk-types-overall-serialization",
    "title": "Overall: serialization",
    "url": "https://docs.ton.org/languages/tolk/types/overall-serialization",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedOverviewBasic syntaxIdioms and conventionsType systemList of typesNumbersBooleansAddressCells, slices, buildersStringsStructuresType aliasesGenericsEnumsNullable typesUnion typesTensorsTuplesMapsCallablesVoid and neverType checks and castsOverall: TVM stackOverall: serializationSyntax detailsLanguage featuresMigrating from FunCChangelogTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationType systemOverall: serializationLanguagesTolkType systemOverall: serializationCopy pageCopy pageA consolidated summary of how each Tolk type is serialized into TL-B–compatible binary data. Low-level detailsThis page assumes prior knowledge of TL-B and TVM. It is intended as a concise low‑level reference page. ​int Not serializable; use intN or other numeric types instead. ​intN fixed N-bit signed integer TL-B intN stored via {N} STI loaded via {N} LDI ​uintN fixed N-bit unsigned integer TL-B uintN stored via {N} STU loaded via {N} LDU ​coins alias to varuint16 TL-B VarUInteger 16 stored via STGRAMS loaded via LDGRAMS ​varintN for N = 16 or N = 32 variadic signed integer: 4/5 bits for len + 8*len bit number TL-B VarInteger {N} stored via STVARINT{N} loaded via LDVARINT{N} ​varuintN for N = 16 or N = 32 variadic unsigned integer: 4/5 bits for len + 8*len bit number TL-B VarUInteger {N} stored via STVARUINT{N} loaded via LDVARUINT{N} ​bool one bit: ‘0’ or ‘1’ TL-B Bool stored via 1 STI loaded via 1 LDI resulting in 0 or -1 ​address standard (internal) address; 267 bits: 0b100 + workchain + hash TL-B addr_std stored via STSTDADDR loaded via LDSTDADDR ​address? (nullable) internal or none address; 2 or 267 bits: null -> ‘00’, otherwise -> address TL-B addr_none or addr_std stored via STOPTSTDADDR loaded via LDOPTSTDADDR ​any_address any valid TL-B address, from 2 to 523 bits TL-B MsgAddress stored via STSLICE loaded via LDMSGADDR ​cell and Cell<T> a reference TL-B ^Cell / ^T stored via STREF loaded via LDREF ​cell? and Cell<T>? (nullable) maybe reference (‘0’ or ‘1’+ref) TL-B Maybe ^Cell / Maybe ^T stored via STOPTREF loaded via LDOPTREF ​bitsN just N bits TL-B bitsN stored via STSLICE, preceded by a runtime check that the slice contains exactly N bits and zero references; this check can be disabled using skipBitsNValidation = false. loaded via LDSLICE / LDSLICEX (for N > 256) ​RemainingBitsAndRefs the remainder of a slice when reading, and a raw slice when writing TL-B Cell stored via STSLICE loaded by copying current slice and assigning current to an empty one ​builder and slice Can be used for writing, not for reading. Not recommended, because they do not reveal internal structure and have unpredictable size. Auto-generated TypeScript wrappers are not able to parse them. ​Structures If a struct has a prefix, it’s written first. Then its fields are serialized sequentially. CopyAsk AIstruct (0x12345678) A { a: int8 b: cell? } fun demo() { val a: A = { a: 123, b: createEmptyCell(), }; // 41 bits and 1 ref: opcode + int8 + '1' + empty ref a.toCell() } ​32-bit prefixes (opcodes) By convention, all messages (incoming and outgoing) use 32-bit prefixes: CopyAsk AIstruct (0x7362d09c) TransferNotification { queryId: uint64 // ... } ​Not only 32-bit prefixes Declaring messages with opcodes does not differ from declaring any other structs. Prefixes can be of any width: 0x000F — 16-bit prefix 0x0F — 8-bit prefix 0b010 — 3-bit prefix 0b00001111 — 8-bit prefix Example. Let’s express the following TL-B scheme: CopyAsk AIasset_simple$001 workchain:int8 ptr:bits32 = Asset; asset_booking$1000 order_id:uint64 = Asset; // ... In Tolk, use structures and union types: CopyAsk AIstruct (0b001) AssetSimple { workchain: int8 ptr: bits32 } struct (0b1000) AssetBooking { orderId: uint64 } type Asset = AssetSimple | AssetBooking // | ... When deserializing, Asset will follow manually provided prefixes, see “union types” below. If a structure has a prefix, it is used consistently in all contexts (both standalone and within unions): CopyAsk AIAssetBooking.fromSlice(s) // expecting '1000...' (binary) AssetBooking{...}.toCell() // '1000...' ​Type aliases A type alias is identical to its underlying type unless a custom serializer is defined. Example. Need to implement a “variadic string” encoded as “len + data”: CopyAsk AIlen: (## 8) // 8 bits of len data: (bits len) // 0..255 bits of data To express this, create a type and define a custom serializer: CopyAsk AItype ShortString = slice fun ShortString.packToBuilder(self, mutate b: builder) { val nBits = self.remainingBitsCount(); b.storeUint(nBits, 8); b.storeSlice(self); } fun ShortString.unpackFromSlice(mutate s: slice) { val nBits = s.loadUint(8); return s.loadBits(nBits); } And just use ShortString as a regular type — everywhere: CopyAsk AItokenName: ShortString fullDomain: Cell<ShortString> Method names packToBuilder and unpackFromSlice are reserved for this purpose, their signatures must match exactly as shown. ​Enums The serialization type can be specified manually: CopyAsk AI// `Role` will be (un)packed as `int8` enum Role: int8 { Admin, User, Guest, } struct ChangeRoleMsg { ownerAddress: address newRole: Role // int8: -128 <= V <= 127 } Otherwise, it is calculated automatically. For Role above, uint2 is sufficient to fit values 0, 1, 2: CopyAsk AI// `Role` will (un)packed as `uint2` enum Role { Admin, User, Guest, } Input values are validated during deserialization. For enum Role: int8 any (input<0 || input>2) triggers exception 5 (integer out of range). Non-range values are also validated: CopyAsk AIenum OwnerHashes: uint256 { id1 = 0x1234, id2 = 0x2345, ... } // on serialization, just \"store uint256\" // on deserialization, \"load uint256\" + throw 5 if v not in [0x1234, 0x2345, ...] ​Nullable types T? (except address?) often called “Maybe”; ‘0’ or ‘1’+T TL-B (Maybe T) asm 1 STI + IF … asm 1 LDI + IF … The exception: address? is serialized as “internal or none” (2/267 bits): null -> ‘00’, otherwise -> address. ​Union types T1 | T2 | ... Rules for union type serialization: T | null is TL/B Maybe T (‘0’ or ‘1’+T) if all T_i have prefixes struct (0x1234) A, they are used otherwise, a compiler auto-generates a prefix tree ​Manual serialization prefixes If all T_i have manual prefixes, they are used: CopyAsk AIstruct (0b001) AssetSimple { /* body1 */ } struct (0b1000) AssetBooking { /* body2 */ } struct (0b01) AssetNothing {} struct Demo { // '001'+body1 OR '1000'+body2 e: AssetSimple | AssetBooking // '001'+body1 OR '1000'+body2 OR '01' f: AssetSimple | AssetBooking | AssetNothing } If a prefix exists for A but not for B, the union A | B cannot be serialized: it seems like a bug in code. ​Auto-generated prefix tree If T_i don’t have manual prefixes, the compiler generates a prefix tree. A two-component union T1 | T2 is TL/B Either (prefixes 0/1). For example, int32 | int64 becomes (‘0’+int32 or ‘1’+int64). Multi-component unions have longer prefixes. For example int32 | int64 | int128 | int256 forms a tree 00/01/10/11. General rules: if null exists, it’s 0, all others are 1+tree (“maybe others”) example: A|B|C|D|null => 0 | 100+A | 101+B | 110+C | 111+D if no null, just distributed sequentially example: A|B|C => 00+A | 01+B | 10+C CopyAsk AIstruct WithUnion { f: int8 | int16 | int32 } This field will be packed as: ‘00’+int8 OR ‘01’+int16 OR ‘10’+int32. On deserialization, the same format is expected (prefix ‘11’ will throw an exception). Same for structs without a manual prefix: CopyAsk AIstruct A { ... } // 0x... prefixes not specified struct B { ... } struct C { ... } struct WithUnion { // auto-generated prefix tree: 00/01/10 f: A | B | C // with null, like Maybe<A|B>: 0/10/11 g: A | B | null // even this works; when '11', a ref exists h: A | int32 | C | cell } ​Tensors (T1, T2, ...) Tensor components are serialized sequentially, in the same manner as structure fields. ​tuple and typed tuples Tuples cannot be serialized; serialization is not implemented for tuples. But tuples can be returned from get methods, since contract getters work via the stack, not serialization. ​map<K, V> maybe reference: ‘0’ (empty) or ‘1’+ref (dict contents) TL-B HashmapE n X (follow hashmaps in TL-B) stored via STDICT loaded via LDDICT ​Callables (...ArgsT) -> ResultT Callables cannot be serialized. Lambdas may be used within contract logic but cannot be serialized for off‑chain responses. ​See also Overall: TVM stack representation Type system overview Automatic serialization Was this page helpful?YesNoSuggest editsRaise issuePreviousVariablesNext⌘IgithubxtelegramPowered by MintlifyOn this pageintintNuintNcoinsvarintN for N = 16 or N = 32varuintN for N = 16 or N = 32booladdressaddress? (nullable)any_addresscell and Cell<T>cell? and Cell<T>? (nullable)bitsNRemainingBitsAndRefsbuilder and sliceStructures32-bit prefixes (opcodes)Not only 32-bit prefixesType aliasesEnumsNullable types T? (except address?)Union types T1 | T2 | ...",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:36:00.187Z"
  },
  {
    "id": "docs-ton-org--languages-tolk-features-contract-storage",
    "title": "Contract storage",
    "url": "https://docs.ton.org/languages/tolk/features/contract-storage",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedOverviewBasic syntaxIdioms and conventionsType systemSyntax detailsLanguage featuresHandling messagesContract storageContract gettersSending messagesAutomatic serializationLazy loadingPayload in jettonsStandard libraryAssembler functionsCompiler optimizationsMigrating from FunCChangelogTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationLanguage featuresContract storageLanguagesTolkLanguage featuresContract storageCopy pageCopy pageContract storage is not “something special”. It is a regular struct, serialized into persistent blockchain data. Tolk does not impose strict rules, although several common guidelines are helpful in practice. For convenience, keep the struct and its methods in a separate file, e.g., storage.tolk. When developing multiple projects, consistent file structure improves navigation. ​Common pattern: Storage, load(), and save() A storage a regular structure. It is convenient to add load and store methods: CopyAsk AIstruct Storage { counterValue: int64 } fun Storage.load() { return Storage.fromCell(contract.getData()) } fun Storage.save(self) { contract.setData(self.toCell()) } Then, at any point in a program, it can be easily accessed or modified: CopyAsk AIget fun currentCounter() { var storage = lazy Storage.load(); return storage.counterValue; } fun demoModify() { var storage = lazy Storage.load(); storage.counterValue += 100; storage.save(); } Concepts used: struct behaves similarly to a TypeScript class. See structures. fun Storage.f(self) defines an instance method. See functions. T.fromCell() deserializes a cell into T, and obj.toCell() packs it back into a cell. See automatic serialization. lazy operator does this parsing on demand. See lazy loading. contract.getData() fetches persistent data. See standard library. ​Set default values to fields In TON, the contract’s address depends on its initial storage, when a contract is created on-chain. A good practice is to assign default values to fields that must have defined values at deployment: CopyAsk AIstruct WalletStorage { // these fields must have these values when deploying // to make the contact's address predictable jettonBalance: coins = 0 isFrozen: bool = false // these fields must be manually assigned for deployment ownerAddress: address minterAddress: address } Therefore, to calculate an initial address, only two fields are required to be provided. ​Multiple contracts in a project When developing multiple contracts simultaneously (for example, a jetton minter and a jetton wallet), every contract has its own storage shape described by a struct. Give these structs reasonable names — for example, MinterStorage and WalletStorage. It’s better to place them in a single file (storage.tolk) together with their methods. Contracts often deploy each other, and initial storage must be provided during deployment. For example, a minter deploys a wallet, so WalletStorage becomes accessible via a simple import: CopyAsk AI// all symbols from imported files become visible import \"storage\" fun deploy(ownerAddress: address, minterAddress: address) { val emptyWalletStorage: WalletStorage = { ownerAddress, minterAddress, // the other two use their defaults }; // ... } See sending messages for examples of deployment. ​Storage that changes its shape Another pattern for address calculation and for security is: when a contract is deployed, it has fields a,b,c (uninitialized storage) followed by a message supplying d,e — it becomes a,b,c,d,e It’s not about nullable types — nullables like int8? or cell?, being serialized as null, are encoded as ‘0’ bit. It’s about the absence of fields at all — no extra bits in serialization. Such patterns are common in NFTs. Initially, an NFT has only itemIndex and collectionAddress, nothing more (an uninitialized NFT). Upon initialization, fields ownerAddress and content are appended to a storage. How can such logic be implemented? Since arbitrary imperative code is allowed, the suggested approach is: describe two structures: “initialized” and “uninitialized” storage start loading contract.getData() detect whether storage is initialized based on its bits/refs counts parse into one or another struct A long demo with detailed comments: CopyAsk AI// two structures representing different storage states struct NftItemStorage { itemIndex: uint64 collectionAddress: address ownerAddress: address content: cell } struct NftItemStorageNotInitialized { itemIndex: uint64 collectionAddress: address } // instead of the usual `load()` method — `startLoading()` fun NftItemStorage.startLoading() { return NftItemStorageLoader.fromCell(contract.getData()) } fun NftItemStorage.save(self) { contract.setData(self.toCell()) } // this helper detects shape of a storage struct NftItemStorageLoader { itemIndex: uint64 collectionAddress: address private rest: RemainingBitsAndRefs } // when `rest` is empty, `collectionAddress` is the last field fun NftItemStorageLoader.isNotInitialized(self) { return self.rest.isEmpty() } // `endLoading` continues loading when `rest` is not empty fun NftItemStorageLoader.endLoading(mutate self): NftItemStorage { return { itemIndex: self.itemIndex, collectionAddress: self.collectionAddress, ownerAddress: self.rest.loadAny(), content: self.rest.loadAny(), } } Usage in onInternalMessage: CopyAsk AIvar loadingStorage = NftItemStorage.startLoading(); if (loadingStorage.isNotInitialized()) { // ... probably, initialize and save return; } var storage = loadingStorage.endLoading(); // and the remaining logic: lazy match, etc. Different shapes with missing fields may also be expressed using generics and the void type. A powerful, but harder to understand solution.Was this page helpful?YesNoSuggest editsRaise issuePreviousContract gettersNext⌘IgithubxtelegramPowered by MintlifyOn this pageCommon pattern: Storage, load(), and save()Set default values to fieldsMultiple contracts in a projectStorage that changes its shape",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "deployment",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:36:01.565Z"
  },
  {
    "id": "docs-ton-org--languages-tolk-syntax-pattern-matching",
    "title": "Pattern matching",
    "url": "https://docs.ton.org/languages/tolk/syntax/pattern-matching",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedOverviewBasic syntaxIdioms and conventionsType systemSyntax detailsVariablesConditions and loopsExceptionsFunctions and methodsStructures and fieldsPattern matchingMutabilityOperatorsImportsLanguage featuresMigrating from FunCChangelogTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationSyntax detailsPattern matchingLanguagesTolkSyntax detailsPattern matchingCopy pageCopy pageTolk supports a match expression for pattern matching. It works both on types and on expressions. ​match for union types Pattern matching on union types is used in message handling. CopyAsk AItype IncomingMessage = | CounterIncBy | CounterReset // ... // ... after parsing a message match (msg) { CounterIncBy => { newCounter = curCounter + msg.byValue } CounterReset => { newCounter = 0 } // ... } This is a general mechanism compatible with any union type: CopyAsk AIfun processValue(value: int | slice) { match (value) { int => { value * 2 } slice => { value.loadUint(8) } } } A match on a union must be exhaustive: all alternatives must be covered. CopyAsk AIfun errDemo(v: int | slice | Point) { match (v) { slice => { v.loadAddress() } int => { v * 2 } // error: missing `Point` } } else is not allowed for unions, but is permitted for a lazy match. ​Syntax details After =>, one of the following is allowed: a block: A => { ... }; an expression: A => 123; a return statement: A => return SOME_EXPR; a throw statement: A => throw ERR_CODE. A comma is: optional after a block: A => { ... } B => { ... }; required in all other cases: A => 1, B => 2. A match can be used as an expression: return match (v) { ... }. Variable declarations are allowed inside: match (val v = ...). ​match as expression match can be used in expression position. In this form, it can be: assigned to a variable: var smth = match (v) { ... }; returned from a function: return match (v) { ... }. CopyAsk AItype Pair2 = (int, int) type Pair3 = (int, int, int) fun getLast(tensor: Pair2 | Pair3) { return match (tensor) { Pair2 => tensor.1, Pair3 => tensor.2, } } ​Variables declaration A variable may be declared directly in the match expression. CopyAsk AIfun getPair2Or3(): Pair2 | Pair3 { // ... } fun demo() { match (val v = getPair2Or3()) { Pair2 => return v.0 + v.1, Pair3 => throw v.0 + v.1 + v.2, } } ​match for expressions match can be used with constant expressions, similar to switch: CopyAsk AIval nextValue = match (curValue) { 1 => 0, 0 => 1, else => -1 }; Rules: Only constant expressions are allowed before =>. else is required when match is used as an expression. else is optional when match is used as a statement. CopyAsk AI// statement form match (curValue) { 1 => { nextValue = 0 } 0 => { nextValue = 1 } -1 => throw NEGATIVE_NOT_ALLOWED } // expression form, `else` required val nextValue = match (curValue) { // ... else => 1 + 2 } All comparable types are supported, including addresses and enums. ​match for enums Pattern matching on enums requires exhaustive coverage of all cases: CopyAsk AImatch (someColor) { Color.Red => {} Color.Green => {} // error: Color.Blue is missing } Alternatively, use else to handle the remaining values: CopyAsk AImatch (someColor) { Color.Red => {} else => {} } Was this page helpful?YesNoSuggest editsRaise issuePreviousMutabilityNext⌘IgithubxtelegramPowered by MintlifyOn this pagematch for union typesSyntax detailsmatch as expressionVariables declarationmatch for expressionsmatch for enums",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:36:03.804Z"
  },
  {
    "id": "docs-ton-org--languages-tolk-features-jetton-payload",
    "title": "Forward payload in jettons",
    "url": "https://docs.ton.org/languages/tolk/features/jetton-payload",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedOverviewBasic syntaxIdioms and conventionsType systemSyntax detailsLanguage featuresHandling messagesContract storageContract gettersSending messagesAutomatic serializationLazy loadingPayload in jettonsStandard libraryAssembler functionsCompiler optimizationsMigrating from FunCChangelogTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationLanguage featuresForward payload in jettonsLanguagesTolkLanguage featuresForward payload in jettonsCopy pageCopy pageA jetton transfer may include a forwardPayload to provide custom data for the transaction recipient. This is a convention, not a language feature. ​Jetton payload schema By definition, the TL-B format is (Either Cell ^Cell): one bit plus the corresponding data depending on the bit: bit 0 indicates inline payload: all subsequent bits and references; bit 1 indicates ref payload: the next reference. When inline, the payload is positioned at the end of a message. Some existing jetton implementations do not follow the schema: Some allow empty data, no bits at all, which is invalid because at least one bit must exist. An empty payload should be encoded as bit 0 – empty inline payload. Some do not verify that no extra data remains after bit 1. Error codes vary across implementations. ​Canonical payload typing TL-B (Either X Y) is a union type X | Y in Tolk. This can be defined as: CopyAsk AIstruct Transfer { // ... forwardPayload: RemainingBitsAndRefs | cell } It is parsed and serialized according to the schema: either bit 0 + inline data, or bit 1 + ref. This approach can be used for assignment and client metadata. Trade-offs include: consumes more gas due to runtime branching (IF bit 0); does not verify that no extra data remains after bit 1. ​Payload typing cases The approach to representing a jetton forwardPayload depends on the intended usage and validation requirements. ​Proxy data without validation To proxy any data as-is, use RemainingBitsAndRefs: CopyAsk AIstruct Transfer { // ... forwardPayload: RemainingBitsAndRefs } ​Canonical union with validation To validate a canonical union RemainingBitsAndRefs | cell, ensure that no extra data remains after a ref payload: CopyAsk AIstruct Transfer { // ... forwardPayload: RemainingBitsAndRefs | cell mustBeEmpty: RemainingBitsAndRefs } fun Transfer.validatePayload(self) { // if extra data exists, throws 9 self.mustBeEmpty.assertEnd() // if no bits at all, failed with 9 beforehand, // because the union could not be loaded } ​Validation with slices If gas consumption is critical but validation is required, avoid allocating unions on the stack. Instead, validate a slice and keep it for further serialization: CopyAsk AIstruct Transfer { // ... forwardPayload: ForwardPayload } type ForwardPayload = RemainingBitsAndRefs // validate TL/B `(Either Cell ^Cell)` fun ForwardPayload.checkIsCorrectTLBEither(self) { var mutableCopy = self; // throw 9 if no bits at all (\"maybe ref\" loads one bit) if (mutableCopy.loadMaybeRef() != null) { // if ^Cell, throw 9 if other data exists mutableCopy.assertEnd() } } ​Custom error codes To throw custom error codes instead of an error with exit code 9, calling loadMaybeRef() is discouraged. CopyAsk AItype ForwardPayload = RemainingBitsAndRefs struct (0b0) PayloadInline { data: RemainingBitsAndRefs } struct (0b1) PayloadRef { refData: cell rest: RemainingBitsAndRefs } type PayloadInlineOrRef = PayloadInline | PayloadRef // validate TL/B `(Either Cell ^Cell)` fun ForwardPayload.checkIsCorrectTLBEither(self) { val p = lazy PayloadInlineOrRef.fromSlice(self); match (p) { PayloadInline => { // okay, valid } PayloadRef => { // valid if nothing besides ref exists assert (p.rest.isEmpty()) throw ERR_EXTRA_BITS } else => { // both not bit '0' and not bit '1' — empty throw ERR_EMPTY_PAYLOAD_FIELD } } } ​Dynamic assignment Keeping a remainder reduces gas usage and enables validation, but it is less convenient when a payload must be assigned dynamically. The remainder is a plain slice containing an encoded union. For example, creating a ref payload from a cell requires manual construction. CopyAsk AIfun createRefPayload(ref: cell) { // not like this, mismatched types val err1 = ref; // not like this, incorrect logic val err2 = ref.beginParse(); // but like this: '1' + ref val payload = beginCell() .storeBool(true).storeRef(ref) .asSlice(); } Using RemainingBitsAndRefs | cell remains convenient for assignment but may incur additional gas costs.Was this page helpful?YesNoSuggest editsRaise issuePreviousStandard libraryNext⌘IgithubxtelegramPowered by MintlifyOn this pageJetton payload schemaCanonical payload typingPayload typing casesProxy data without validationCanonical union with validationValidation with slicesCustom error codesDynamic assignment",
    "category": "tokens",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:36:05.242Z"
  },
  {
    "id": "docs-ton-org--languages-tolk-types-address",
    "title": "Address",
    "url": "https://docs.ton.org/languages/tolk/types/address",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedOverviewBasic syntaxIdioms and conventionsType systemList of typesNumbersBooleansAddressCells, slices, buildersStringsStructuresType aliasesGenericsEnumsNullable typesUnion typesTensorsTuplesMapsCallablesVoid and neverType checks and castsOverall: TVM stackOverall: serializationSyntax detailsLanguage featuresMigrating from FunCChangelogTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationType systemAddressLanguagesTolkType systemAddressCopy pageCopy pageEvery smart contract has an address used for all on-chain interactions. Tolk provides the following types for working with addresses: address — a standard address; also called “internal address”. address? — nullable address, i.e., either a standard address or null; also called “internal or none”. any_address — any kind of address, including external addresses. ​Components A standard, internal address consists of: a int8 workchain — currently, there are only two: masterchain (-1) and basechain (0); a uint256 hash — a 256-bit account ID. address has methods to retrieve these components: CopyAsk AIfun checkAddress(addr: address, expectHash: uint256) { val (wc, hash) = addr.getWorkchainAndHash(); assert (wc == 0) throw 123; assert (hash == expectHash) throw 456; } When serialized, values of address type occupy 267 bits: 3 bits for the standard address prefix — 0b100 8-bit workchain 256-bit hash During deserialization from a cell, the values of type address are automatically validated at runtime: if parsing succeeds, the resulting address is guaranteed to be valid. ​Comparison Compare addresses using == or !=. Internally, an address is represented as a raw slice without references, so == and != test for bits equality. CopyAsk AIstruct Storage { owner: address // ... } fun onInternalMessage(in: InMessage) { var st = Storage.load(); // process a message only from owner if (in.senderAddress == st.owner) { // ... } } ​Embedding Embed a constant value of type address using the address() function: CopyAsk AIconst REFUND_ADDR = address(\"EQCRDM9h4k3UJdOePPuyX40mCgA4vxge5Dc5vjBR8djbEKC5\") ​Nullable address A nullable address often represents a potentially absent value: There might be an adminAddress in the contract’s storage, but it may be unset. There might be an sendExcessesTo field in a message: if exists, send surplus there; if not, keep it. Thus, type address? represents a “none address”: either an internal address or none. Check for null before usage: CopyAsk AI// May have no admin fun send(adminAddress: address?) { if (adminAddress == null) { return; } // send a message to adminAddress, it's not null } When a value of type address? is serialized and is not null, it occupies 267 as the standard address. If it is null, then it occupies only 2 zero bits, a so-called addr_none. The “none” address can be created using createAddressNone(). ​Any address All external messages from outside world to blockchain contracts, such as wallet contracts, come from external addresses. To represent internal and external addresses, as well as nullable addresses, use any_address: CopyAsk AIstruct CrossBridgeMessage { destination: any_address } ​Casts To manually operate on the bits of an address, cast it to a slice: CopyAsk AIval s = someAddr as slice; s.loadUint(3); // 0b100 — internal address tag s.loadInt(8); // workchain Since an address is represented as a slice at the TVM level, such cast is permitted and is safe. Conversely, the cast in another direction is unsafe, because no validation is performed at runtime and any further use might fail: CopyAsk AIvar b = beginCell() .storeUint(0b01) // addr_extern ...; var s = b.endCell().beginParse(); return s as any_address; Was this page helpful?YesNoSuggest editsRaise issuePreviousCells, slices, buildersNext⌘IgithubxtelegramPowered by MintlifyOn this pageComponentsComparisonEmbeddingNullable addressAny addressCasts",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:36:07.028Z"
  },
  {
    "id": "docs-ton-org--languages-tolk-features-standard-library",
    "title": "Standard library",
    "url": "https://docs.ton.org/languages/tolk/features/standard-library",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedOverviewBasic syntaxIdioms and conventionsType systemSyntax detailsLanguage featuresHandling messagesContract storageContract gettersSending messagesAutomatic serializationLazy loadingPayload in jettonsStandard libraryAssembler functionsCompiler optimizationsMigrating from FunCChangelogTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationLanguage featuresStandard libraryLanguagesTolkLanguage featuresStandard libraryCopy pageCopy pageTolk provides a standard library or stdlib that includes commonly used functions. IDEs provide auto-completion and navigation to definitions and inline documentation using Cmd+Click or Ctrl+Click. ​Compile-time calculations and embedding Constant values can be embedded into a contract using dedicated functions. ​address() The address() function embeds a constant address: CopyAsk AIconst REFUND_ADDR = address(\"EQCRDM9h4k3UJdOePPuyX40mCgA4vxge5Dc5vjBR8djbEKC5\") ​String-based compile-time functions Several functions, such as stringCrc32(), operate on string literals. They require constant inputs and are evaluated to an int at compile time. CopyAsk AI// calculates crc32 of a string const crc32 = stringCrc32(\"some_str\") // = 4013618352 = 0xEF3AF4B0 // calculates crc16 (XMODEM) of a string const crc16 = stringCrc16(\"some_str\") // = 53407 = 0xD09F // calculates sha256 of a string and returns 256-bit integer const hash = stringSha256(\"some_crypto_key\") // calculates sha256 of a string and takes the first 32 bits const minihash = stringSha256_32(\"some_crypto_key\") // interprets an N-chars ascii string as a number in base 256 const base256 = stringToBase256(\"AB\") // = 16706 (65*256 + 66) ​ton() Calculates nanotoncoins at compile time. CopyAsk AIconst ONE_TON = ton(\"1\"); // `coins`, value: 1000000000 fun calcCost() { val cost = ton(\"0.05\"); // `coins`, value: 50000000 return ONE_TON + cost; } ​Common functions All functions in this section are available everywhere. They are defined in @stdlib/common.tolk, which is auto-imported. ​Tuples Tuple-related functions allow interacting with tuple types, which are dynamic containers of up to 255 elements. ​createEmptyTuple Creates a tuple with zero elements. ​tuple.push, tuple.get, etc. An IDE suggests available methods after a dot .: CopyAsk AIfun demo() { var t = createEmptyTuple(); t.push(123); return t.get<int>(0); // 123 } ​T.toTuple and T.fromTuple Packs an object from the stack into a tuple and converts it back. If a value occupies N stack slots, the resulting tuple has size N. CopyAsk AIstruct Point { x: int y: int } fun demo() { var p: Point = { x: 1, y: 2 }; var t = p.toTuple(); // [ 1 2 ] p = Point.fromTuple(t); // restored t.get<int>(0); // 1 } ​Mathematical primitives These functions accept and return integers unless stated otherwise. All integers are 257-bit. ​min(x, y) Returns the minimum of two integers. ​max(x, y) Returns the maximum of two integers. ​minMax(x, y) Returns (int, int) – a tensor (smallest, largest). ​abs(x) Returns the absolute value of an integer. ​sign(x) Returns the sign of an integer value: -1 if x < 0; 0 if x == 0; 1 if x > 0. ​divMod(x, y) Returns (int, int) — the quotient and remainder of x / y. Example: divMod(112, 3) = (37, 1). ​modDiv(x, y) Returns (int, int) — the remainder and quotient of x / y. Example: modDiv(112, 3) = (1, 37). ​mulDivFloor(x, y, z) Computes multiple-then-divide: floor(x * y / z). The intermediate result is stored in a 513-bit integer to prevent precision loss. ​mulDivRound(x, y, z) Similar to mulDivFloor, but rounds the result: round(x * y / z). ​mulDivCeil(x, y, z) Similar to mulDivFloor, but ceils the result: ceil(x * y / z). ​mulDivMod(x, y, z) Returns (int, int) — the quotient and remainder of (x * y / z). Example: mulDivMod(112, 3, 10) = (33, 6). ​Global getters and setters of current contract state All functions in this section are methods of the empty struct contract. ​contract.getAddress Returns address — the internal address of the current smart contract. It can be further parsed using address.getWorkchain and others. ​contract.getOriginalBalance Returns coins — the balance of the smart contract in nanotoncoins at the start of the compute phase. ​contract.getOriginalBalanceWithExtraCurrencies Returns [coins, ExtraCurrenciesMap] — similar to contract.getOriginalBalance, but also returns extra currencies. ​contract.getData Returns cell — the persistent contract storage cell. Typically, its result is used as Storage.fromCell(). ​contract.setData(cell) Sets the persistent contract storage. Typically, the argument is storageObject.toCell(). ​contract.getCode Returns cell — the smart contract code stored in TVM register c7. ​contract.setCodePostponed(newCodeCell) Creates an output action that updates the smart contract code after successful termination of the current execution. ​Global getters of the blockchain (environment) state Most functions in this section are methods of the empty struct blockchain. ​blockchain.now Returns int — the current Unix timestamp in seconds. ​blockchain.logicalTime Returns int — the logical time of the current transaction. ​blockchain.currentBlockLogicalTime Returns int — the starting logical time of the current block. ​blockchain.configParam(i) Returns cell? — the value of the global configuration parameter with integer index i, or null if not exists. ​commitContractDataAndActions Commits the current state of TVM registers c4 persistent data and c5 actions, so the current execution is considered successful with these values even if an exception is thrown later during the compute phase. ​Signature checks, hashing, cryptography Functions and methods for hashing, signature verification, and randomization. ​cell.hash Returns uint256 — the representation hash of a cell. Useful for signing and checking signatures of arbitrary entities represented by a tree of cells. ​slice.hash Returns uint256 — the hash of data in a slice. The same as cell.hash for a cell containing data and references from this slice. ​builder.hash Returns uint256 — the hash of the data in a builder. Equivalent to converting the builder to a cell and hashing it, without creating a cell. ​slice.bitsHash Returns uint256 — the SHA-256 hash of the data bits in a slice, excluding references. If the bit length is not divisible by eight, throws a cell underflow exception. ​isSignatureValid(hash, signatureSlice, publicKey) Verifies an Ed25519 signature. Checks signatureSlice against hash using publicKey, both of type uint256. The signature must contain at least 512 data bits; only the first 512 bits are used. Returns bool. ​isSliceSignatureValid(dataSlice, signatureSlice, publicKey) Similar to isSignatureValid, but accepts a slice instead of a precomputed hash. If the bit length of data is not divisible by eight, throws a cell underflow exception. ​random.uint256 Returns uint256 — a new pseudo-random value. Call random.initialize to make randomization unpredictable. ​random.range(limit) Returns int — a new pseudo-random integer z in the range 0..limit−1 or limit..−1 if negative. More precisely, an unsigned random value x is generated, then z := x * limit / 2^256 is computed. Call random.initialize to make randomization unpredictable. ​random.getSeed Returns uint256 — the current random seed used to generate pseudo-random numbers. ​random.setSeed(newSeed) Sets the random seed to the provided value. ​random.initializeBy(mixSeedWith) Mixes the random seed with the provided value. ​random.initialize Initializes the seed with current time to make randomization unpredictable. Call this function once before using random.uint256 or random.range. ​Size computation primitives Can be useful for computing storage fees of user-provided data. ​cell.calculateSize(maxCells) Returns (x, y, z, -1) or (null, null, null, 0). Recursively computes the count of distinct cells x, data bits y, and cell references z in a tree of cells. The total count of visited cells x cannot exceed non-negative maxCells; otherwise a zero flag is returned to indicate failure. ​slice.calculateSize(maxCells) Similar to cell.calculateSize, but accepting a slice instead of a cell. The returned value x includes the cell that contains the slice. ​cell.calculateSizeStrict(maxCells) A non-quiet version of cell.calculateSize that throws a cell overflow exception on failure. ​slice.calculateSizeStrict(maxCells) A non-quiet version of slice.calculateSize that throws a cell overflow exception on failure. ​cell.depth Returns int — the depth of a cell: 0 if no references, otherwise 1 + maximum of depths of all references. ​slice.depth Returns int — the depth of a slice, equivalent to cell.depth. ​builder.depth Returns int — the depth of a builder, equivalent to cell.depth. ​sizeof<T>(anyVariable) Returns int — the number of stack slots occupied by anyVariable occupies; works at compile-time. ​Debug primitives Only work for local TVM execution with debug–",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:36:08.147Z"
  },
  {
    "id": "docs-ton-org--languages-tolk-types-strings",
    "title": "Strings (actually, slices)",
    "url": "https://docs.ton.org/languages/tolk/types/strings",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedOverviewBasic syntaxIdioms and conventionsType systemList of typesNumbersBooleansAddressCells, slices, buildersStringsStructuresType aliasesGenericsEnumsNullable typesUnion typesTensorsTuplesMapsCallablesVoid and neverType checks and castsOverall: TVM stackOverall: serializationSyntax detailsLanguage featuresMigrating from FunCChangelogTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationType systemStrings (actually, slices)LanguagesTolkType systemStrings (actually, slices)Copy pageCopy pageThe TVM (virtual machine) has only SLICE (binary data). There are no usual “strings” (likewise, no floating-point numbers). However, several techniques exist to store and return string-like data on-chain. ​Embedding addresses as strings Use address(\"...\") to insert a constant standard address: CopyAsk AIconst REFUND_ADDR = address(\"EQCRDM9h4k3UJdOePPuyX40mCgA4vxge5Dc5vjBR8djbEKC5\") Its type is address, it has workchain and hash, but internally it’s a TVM SLICE, with 267 bits and 0 refs. To return a human‑readable address, just address. Client‑side libraries reconstruct and display addresses according to their own formatting rules. ​Raw string literals The syntax val s = \"abcd\" is valid, but it does not produce a string; it produces a binary slice: each character is encoded with its ASCII char no. CopyAsk AI// `slice` with 4 bytes: 97,98,99,100 (0x61626364) const SLICE1 = \"abcd\" Literals cannot exceed 127 ASCII characters, because a cell can contain up to 1023 bits. ​Hex string literals Use stringHexToSlice(\"...\") to embed hexadecimal binary data: CopyAsk AI// `slice` with 2 bytes: 16,32 (0x1020) const SLICE2 = stringHexToSlice(\"1020\") ​Concatenating string literals An example for \"ab\" and \"cd\". Because they are slices, concatenation is performed by via a builder: CopyAsk AIval concat = beginCell() .storeSlice(\"ab\") .storeSlice(\"cd\") .asSlice(); // builder-to-slice ​How to return a string from a contract A plain slice cannot be deserialized directly. Like int — use int32 / coins / etc. to specify encoding. Similarly, string‑like data must use an explicit encoding to be stored on‑chain. ​Way #1: fixed-size strings via bitsN If a response always contains 4 bytes of text, fixed‑size encodings may be used: bits32 or bytes4. CopyAsk AIstruct Response1 { someData: uint8 str: bits32 } fun generateResponse(): Response1 { return { someData: 0xFF, str: \"abcd\" as bits32, } } ​Way #2: “snake string”, or “tail string” “Snake strings” (also called “tail strings”) are a standard encoding for arbitrary‑length strings, including those exceeding 127 characters. Snake encoding is: store portion of data → store rest in a ref cell. Here is a string xxxxyyyyzzzz split into 3 parts: CopyAsk AI\"xxxx\".ref(\"yyyy\".ref(\"zzzz\")) Such a chaining can easily be implemented: CopyAsk AIstruct Response2 { someData: int8 str: MyTailString } fun slice.ref(self, other: slice): slice { return beginCell() .storeSlice(self).storeSlice(other).asSlice(); } fun generateResponse(): Response2 { return { someData: 0xFF, str: \"xxxx\".ref(\"yyyy\".ref(\"zzzz\")), } } Then a cell will be \"FFxxxx\".ref(...). So, it’s named “a tail string” because it goes after existing data up to the end. MyTailString can be described in the simplest form as the remainder of a slice — RemainingBitsAndRefs (mentioned in an article about cells). CopyAsk AItype MyTailString = RemainingBitsAndRefs When decoding on‑chain, no reference iteration is required. Client‑side tooling can reconstruct and display the full string. ​Way #3: variable-length encoding Variable‑length encodings may also be implemented manually. For example, short strings like “abcd” can be stored like 8 bits for N = string length N bits of data This can be implemented using custom serializers: CopyAsk AItype ShortString = slice fun ShortString.packToBuilder(self, mutate b: builder) { val nBits = self.remainingBitsCount(); b.storeUint(nBits, 8); b.storeSlice(self); } fun ShortString.unpackFromSlice(mutate s: slice) { val nBits = s.loadUint(8); return s.loadBits(nBits); } Then use it like a regular type: CopyAsk AIstruct Response3 { someData: int8 str: ShortString } fun generateResponse(): Response3 { return { someData: 0xFF, str: \"abcd\", } } ​Calculate hex / crc32 / etc. at compile-time There are several functions operating on strings: stringCrc32(\"some_str\") stringCrc16(\"some_str\") stringSha256(\"some_crypto_key\") stringSha256_32(\"some_crypto_key\") stringToBase256(\"AB\") For examples, see standard library, they are at the top.Was this page helpful?YesNoSuggest editsRaise issuePreviousStructuresNext⌘IgithubxtelegramPowered by MintlifyOn this pageEmbedding addresses as stringsRaw string literalsHex string literalsConcatenating string literalsHow to return a string from a contractWay #1: fixed-size strings via bitsNWay #2: “snake string”, or “tail string”Way #3: variable-length encodingCalculate hex / crc32 / etc. at compile-time",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:36:10.158Z"
  },
  {
    "id": "docs-ton-org--languages-tolk-features-compiler-optimizations",
    "title": "Compiler optimizations",
    "url": "https://docs.ton.org/languages/tolk/features/compiler-optimizations",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedOverviewBasic syntaxIdioms and conventionsType systemSyntax detailsLanguage featuresHandling messagesContract storageContract gettersSending messagesAutomatic serializationLazy loadingPayload in jettonsStandard libraryAssembler functionsCompiler optimizationsMigrating from FunCChangelogTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationLanguage featuresCompiler optimizationsLanguagesTolkLanguage featuresCompiler optimizationsCopy pageCopy pageThe Tolk compiler generates bitcode from clear, idiomatic code. Extracting variables or simple methods should not increase gas consumption. ​Constant folding Tolk compiler evaluates constant variables and conditions at compile-time: CopyAsk AIfun calcSecondsInAYear() { val days = 365; val minutes = 60 * 24 * days; return minutes * 60; } All these computations are done statically, resulting in: CopyAsk AI31536000 PUSHINT It works for conditions as well. If an if condition is statically known to be false, only the else body remains. If an assert is statically proven to fail, the corresponding throw remains. CopyAsk AIfun demo(s: slice) { var flags = s.loadUint(32); // definitely >= 0 if (flags < 0) { // always false // ... } return s.remainingBitsCount(); } The compiler removes the entire IF construct — both the condition evaluation and its bodies — when the branch is provably unreachable. During compile-time evaluation, arithmetic operations are emulated as they would be at runtime. The compiler also tracks flags such as “this value is even or non-positive”, which allows it to remove unreachable code. This applies not only to plain variables but also to struct fields, tensor items, and across inlining. It runs after the high-level syntax tree is transformed to a low-level intermediate representation. ​Merging constant builder.storeInt When building cells manually, there is no need to group the constant storeUint into a single number. CopyAsk AI// no need for manual grouping anymore b.storeUint(4 + 2 + 1, 1 + 4 + 4 + 64 + 32 + 1 + 1 + 1); builder.storeInt are merged automatically: CopyAsk AIb.storeUint(0, 1) // prefix .storeUint(1, 1) // ihr_disabled .storeUint(1, 1) // bounce .storeUint(0, 1) // bounced .storeUint(0, 2) // addr_none Compiles to: CopyAsk AIb{011000} STSLICECONST It works together with constant folding — with variables and conditions — when they turn out to be constant: CopyAsk AIfun demo() { var x = 0; var b = beginCell(); b.storeUint(x, 4); x += 12; if (x > 0) { x += x; } b.storeUint(x + 2, 8); return b; } Compiles to: CopyAsk AINEWC x{01a} STSLICECONST The same applies to structures and their fields: CopyAsk AIstruct Point { x: uint32 y: uint32 } fun demo() { var p: Point = { x: 10, y: 20 }; return p.toCell(); } Compiles to: CopyAsk AINEWC x{0000000a00000014} STSLICECONST ENDC For unions, createMessage is lightweight. The compiler generates all IF-ELSE and STU, but during compile-time analysis, these instructions resolve to constants because all types are known at compile time. The resulting code flattens into PUSHINT and STSLICECONST. ​Auto-inline functions Tolk inlines functions at the compiler level: CopyAsk AIfun Point.create(x: int, y: int): Point { return {x, y} } fun Point.getX(self) { return self.x } fun sum(a: int, b: int) { return a + b } fun main() { var p = Point.create(10, 20); return sum(p.getX(), p.y); } Compiles to: CopyAsk AImain PROC:<{ 30 PUSHINT }> The compiler automatically determines which functions to inline and also provides manual control. ​How does auto-inline work? Simple, small functions are always inlined. Functions called only once are always inlined. For every function, the compiler calculates a “weight” and the number of usages: if weight < THRESHOLD, the function is always inlined. if usages == 1, the function is always inlined. otherwise, an empirical formula determines inlining. Inlining works with stack operations and supports arguments of any width. It applies to functions and methods, except recursive functions or functions with return in the middle. Utility methods can be created without affecting gas consumption, they are zero-cost. ​How to control inlining manually? @inline forces inlining for large functions. @noinline prevents inlining. @inline_ref preserves an inline reference, suitable for rarely executed paths. ​What cannot be auto-inlined? A function is NOT inlined, even if marked with @inline, if: contains return in the middle; multiple return points are unsupported; participates in a recursive call chain, e.g., f -> g -> f; is used as a non-call; e.g., as a reference val callback = f. Example of function that cannot be inlined due to return in the middle: CopyAsk AIfun executeForPositive(userId: int) { if (userId <= 0) { return; } // ... } Check preconditions out of the function and keep body linear. ​Peephole and stack optimizations After the code is analyzed and transformed into IR, the compiler repeatedly replaces some assembler combinations with equivalent, cheaper ones. Examples include: stack permutations: DUP + DUP -> 2DUP, SWAP + OVER -> TUCK; N LDU + NIP -> N PLDU; SWAP + N STU -> N STUR, SWAP + STSLICE -> STSLICER; SWAP + EQUAL -> EQUAL and other symmetric like MUL, OR; 0 EQINT + N THROWIF -> N THROWIFNOT and vice versa; N EQINT + NOT -> N NEQINT and other xxx + NOT. Other transformations occur semantically in advance when safe: replace a ternary operator to CONDSEL; evaluate arguments of asm functions in the desired stack order; evaluate struct fields of a shuffled object literal to fit stack order. ​lazy loading The lazy keyword loads only the required fields from a cell or slice: CopyAsk AIstruct Storage { // ... } get fun publicKey() { val st = lazy Storage.load(); // fields before are skipped; publicKey preloaded return st.publicKey } The compiler tracks exactly which fields are accessed and unpacks only those fields, skipping the rest. ​Manual optimizations The compiler does substantial work automatically, but the gas usage can be reduced. To do it, change the evaluation order to minimize stack manipulations. The compiler does not reorder code blocks unless they’re constant expressions or pure calls. Example: CopyAsk AIfun demo() { // variable initialization, grouped val v1 = someFormula1(); val v2 = someFormula2(); val v3 = someFormula3(); // use them in calls, assertions, etc. someUsage(v1); anotherUsage(v2); assert(v3) throw 123; } After the first block, the stack is (v1 v2 v3). Since v1 is used first, the stack must be rearranged with SWAP, ROT, XCPU, etc. Reordering assignments or usages—for example, moving assert(v3) upper—will pop the topmost element. Automatic reordering is unsafe and prohibited, but in some cases business logic might be still valid. Another option is using bitwise & and | instead of logical && and ||. Logical operators are short-circuit: the right operand is evaluated only if required. They are implemented using runtime conditional branches. In some cases, evaluating both operands directly uses fewer runtime instructions than a dynamic IF. The last option is using low-level Fift code for certain independent tasks that cannot be expressed imperatively. This includes using TVM instructions such as NULLROTRIFNOT or IFBITJMP, and overriding the top-level Fift dictionary for method_id routing. These techniques are applicable only in a limited set of scenarios, primarily for specialized exercises rather than for real-world use. Avoid micro-optimizations. Small manual attempts to reduce gas typically yield minimal gains and can reduce code readability. Use Tolk as intended. ​Fift assembler The Tolk compiler outputs the Fift assembler. Fift generates the bitcode. Projects built on Blueprint use tolk-js, which invokes Tolk and then Fift. For command-line users, the Fift assembler is the compiler output. For Blueprint users, it is an intermediate result that can be accessed in the build directory. To view Fift assembler in Blueprint, run npx blueprint build in the project. After compilation, the build/ directory is created, containing a folder build/ContractName/ with a .fif file. Was this page helpful?YesNoSuggest editsRaise issuePreviousTolk vs FunCNext⌘IgithubxtelegramPowered by MintlifyOn this pageConstant foldingMerging constant builder.storeIntAuto-inline functionsHow does auto-inline work?How to control inlining manually?What cannot be auto-inlined?Peephole and stack optimizationslazy loadingManual optimizationsFift assembler",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:36:11.756Z"
  },
  {
    "id": "docs-ton-org--languages-tolk-from-func-stdlib-comparison",
    "title": "Standard libraries comparison",
    "url": "https://docs.ton.org/languages/tolk/from-func/stdlib-comparison",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedOverviewBasic syntaxIdioms and conventionsType systemSyntax detailsLanguage featuresMigrating from FunCTolk vs FunCTolk vs TL-BStandard librariesConverterChangelogTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationMigrating from FunCStandard libraries comparisonLanguagesTolkMigrating from FunCStandard libraries comparisonCopy pageCopy pageTolk provides a standard library that evolved from FunC’s standard library. Therefore, many functions from stdlib.fc can be mapped to Tolk, and most of these functions were converted into methods. ​Functions vs methods Tolk supports declaring methods, including primitives. Consequently, many FunC global-scope functions are now methods, e.g., cell.hash(), tuple.size(), etc. CopyAsk AI@pure fun cell.hash(self): uint256 asm \"HASHCU\" In FunC, x.f() works equally to f(x). For instance, someTuple.tuple_size() and tuple_size(someTuple). In Tolk, someTuple.size() is the only valid notation. ​Renamed and removed functions For load_xxx, store_xxx, and skip_xxx, use automatic serialization. Methods slice.loadXXX, builder.storeXXX, and slice.skipXXX are available for manual cell parsing, but their use is not recommended. For idict_xxx, udict_xxx, and dict_xxx, use native maps. Dictionaries remain available in the file @stdlib/tvm-dicts, but their is not recommended. Other functions: FunC nameTolk nameempty_tuplecreateEmptyTuplet~tpush(v)t.push(v)first(t) or t.first()t.first()at(t,i) or t.at(i)t.get(i) or dot-access t.{i}touch(v)v.stackMoveToTop()impure_touch(deleted)single(deleted)unsingle(deleted)pair(deleted)unpair(deleted)triple(deleted)untriple(deleted)tuple4(deleted)untuple4(deleted)second(deleted)third(deleted)fourth(deleted)pair_first(deleted)pair_second(deleted)triple_first(deleted)triple_second(deleted)triple_third(deleted)minmaxminMaxnowblockchain.nowmy_addresscontract.getAddressget_balance + pair_firstcontract.getOriginalBalancecur_ltblockchain.logicalTimeblock_ltblockchain.currentBlockLogicalTimecell_hash(c)c.hash()slice_hash(s)s.hash()string_hash(s)s.bitsHash()check_signatureisSignatureValidcheck_data_signatureisSliceSignatureValidcompute_data_size(c)c.calculateSizeStrict()slice_compute_data_size(s)s.calculateSizeStrict()compute_data_size?(c)c.calculateSize()slice_compute_data_size?(s)s.calculateSize()~dumpdebug.print~strdumpdebug.printStringdump_stackdebug.dumpStackget_datacontract.getDataset_datacontract.setDataget_c3getTvmRegisterC3set_c3setTvmRegisterC3blesstransformSliceToContinuationaccept_messageacceptExternalMessageset_gas_limitsetGasLimitbuy_gas(deleted)commitcommitContractDataAndActionsdivmoddivModmoddivmodDivmuldivmulDivFloormuldivrmulDivRoundmuldivcmulDivCeilmuldivmodmulDivModbegin_parsebeginParseend_parse(s)s.assertEnd()first_bits(s)s.getFirstBits()skip_last_bits(s)s.removeLastBits()slice_last(s)s.getLastBits()cell_depth(c)c.depth()slice_refs(s)s.remainingRefsCount()slice_bits(s)s.remainingBitsCount()slice_bits_refs(s)s.remainingBitsAndRefsCount()slice_empty?(s)s.isEmpty()slice_data_empty?(s)s.isEndOfBits()slice_refs_empty?(s)s.isEndOfRefs()slice_depth(s)s.depth()equal_slice_bits(a,b)a.bitsEqual(b)builder_refs(b)b.refsCount()builder_bits(b)b.bitsCount()builder_depth(b)b.depth()begin_cellbeginCellend_cellendCellparse_addr(deleted)parse_std_addruse address typeparse_var_addr(deleted)config_paramblockchain.configParamraw_reservereserveToncoinsOnBalanceraw_reserve_extrareserveExtraCurrenciesOnBalancesend_raw_messageuse createMessageset_codecontract.setCodePostponedrandomrandom.uint256randrandom.rangeget_seedrandom.getSeedset_seedrandom.setSeedrandomizerandom.initializeByrandomize_ltrandom.initializedumpdebug.printstrdumpdebug.printStringdump_stkdebug.dumpStackempty_listcreateEmptyListconslistPrependunconslistSplitlist_nextlistNextcarlistGetHeadcdrlistGetTailnew_dictcreateEmptyMapdict_empty?(d)m.isEmptypfxdict_get?prefixDictGetpfxdict_set?prefixDictSetpfxdict_delete?prefixDictDelete Lisp-style lists require an explicit import; IDEs usually add the import automatically. CopyAsk AIimport \"@stdlib/lisp-lists\" ​Mutating functions In FunC, x~method mutates, whereas x.method returns a copy. In Tolk, methods are called with dot . and may mutate the object. FunCTolkint n = cs~load_uint(32);var n = cs.loadUint(32);var (cs2, n) = cs.load_uint(32);var cs2 = cs; var n = cs2.loadUint(32); If cs~load_uint(…) was used, cs.loadUint(…) behaves identically. If cs.load_uint(…) was used to obtain a copy, a different approach is required. ​Added functions Tolk provides functions out of the box. The standard library is split into multiple files. Functions from common.tolk are always available, and most FunC analogues are included. Functions from other files must be explicitly imported: CopyAsk AIimport \"@stdlib/gas-payments\" // now `calculateGasFee()` and other symbols are visible Was this page helpful?YesNoSuggest editsRaise issuePreviousConverterNext⌘IgithubxtelegramPowered by MintlifyOn this pageFunctions vs methodsRenamed and removed functionsMutating functionsAdded functions",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:36:14.464Z"
  },
  {
    "id": "docs-ton-org--languages-tolk-types-numbers",
    "title": "Numbers",
    "url": "https://docs.ton.org/languages/tolk/types/numbers",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedOverviewBasic syntaxIdioms and conventionsType systemList of typesNumbersBooleansAddressCells, slices, buildersStringsStructuresType aliasesGenericsEnumsNullable typesUnion typesTensorsTuplesMapsCallablesVoid and neverType checks and castsOverall: TVM stackOverall: serializationSyntax detailsLanguage featuresMigrating from FunCChangelogTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationType systemNumbersLanguagesTolkType systemNumbersCopy pageCopy pageAt runtime, there are only 257-bit signed integers. They are represented by the Tolk’s general int type. However, at the start and end of each execution, the contract’s state is deserialized and serialized, respectively. To optimize space and reduce storage costs, it is possible to encode integer values using fewer bits. Tolk provides additional integer types to accommodate (de)serialization: NameInclusive rangeSpace takenExamplesSigned intN-2N-1 to 2N-1-1N bits, where N is between 1 and 257int32, int257, int7Unsigned uintN0 to 2N-1N bits, where N is between 1 and 256uint16, uint256, uint119 There are also types of variable bit-width: NameInclusive rangeSpace takenNotesUnsigned coins0 to 2120-1Between 4 and 124 bitsThey represent nanoToncoin, where 109 nanoToncoin equals 1 ToncoinUnsigned varuint16Same as coinsSame as coinsRarely usedUnsigned varuint320 to 2248-1Between 5 and 253 bitsRarely usedSigned varint16-2119 to 2119-1Same as coinsRarely usedSigned varint32-2247 to 2247-1Between 5 and 253 bitsRarely used All these types are 257-bit integers at runtime. Overflows can occur at runtime, but they are more likely during serialization.For example, subtracting 300300300 from a variable of type uint8 does not cause a runtime overflow. Yet, attempting to store the result back to the same variable triggers exit code 5: integer out of expected range. ​Literals All the following constants are of int type: CopyAsk AI// Binary literal const TEN = 0b1010; // Hex literal const MAX_UINT8 = 0xFF; // Allowed values range from -2^256 to 2^256-1 const MAX_INT = 115792089237316195423570985008687907853269984665640564039457584007913129639935; ​First-class types All integer types can be nullable, combined within a union, and otherwise used in structural or multi-valued types: CopyAsk AIstruct Demo { f1: int32? // nullable f2: int32 | uint64 // union pair: (int8, coins) } fun demo(d: Demo) { if (d.f1 != null) { d.f1 // smart cast to `int32` } d.pair.1 // `coins` } ​No floating-point numbers The virtual machine supports only signed 257-bit integers. Floating-point numbers do not exist. Represent monetary, Toncoin values with coins: CopyAsk AI// 1.23 Toncoin or 1,230,000,000 nanoToncoin const MIN_BALANCE = ton(\"1.23\") ​Serialization Serialization works as follows: int — not serializable; use intN and other types. intN — a fixed N-bit signed integer. uintN — a fixed N-bit unsigned integer. coins — an alias to varuint16. varint16 — 4 bits of length followed by an 8 * length-bit number. varuint16 — unsigned version of varint16. varint32 — 5 bits of length followed by an 8 * length-bit number. varuint32 — unsigned version of varint32. ​intN describes serialization, int does not To automatically parse binary data, the compiler must load and store integers correctly. When designing a contract schema, fields are described in terms such as “queryID is unsigned 64-bit” and “counterValue is 32-bit”. This is translates directly in Tolk: CopyAsk AIstruct IncMessage { queryID: uint64 counterValue: int32 } As a result, IncMessage can be serialized to a cell and decoded back. The general-purpose type int represents an integer with no serialization information. Consider this struct: CopyAsk AIstruct Point { x: int y: int } It is valid and it is possible to create a variable p of type Point. However, a call p.toCell() would produce the following error: CopyAsk AIerror: auto-serialization via toCell() is not available for type `Point` because field `Point.x` of type `int` can't be serialized because type `int` is not serializable, it doesn't define binary width hint: replace `int` with `int32` / `uint64` / `coins` / etc. To make the struct serializable, replace int with a specific integer type: CopyAsk AIstruct Point { x: int8 y: int8 } ​Overflow occurs only at serialization Consider the following code: CopyAsk AIvar v: uint8 = 255; v += 1; // 256 The variable v there would neither overflow nor be clamped at runtime. Instead, it would be equal to 256 during subsequent execution steps. There are no runtime bounds checks, and overflows of all integer types occur only during serialization, except for the general int type, which can overflow when doing arithmetic. CopyAsk AIstruct Resp { outValue: uint8 } fun demo(resp: Resp) { // 256, no errors yet resp.outValue = v; // A runtime overflow error that is caused by serialization // of the struct containing an uint8 to a cell. resp.toCell(); } ​Generic int implicitly casts to and from any intN All arithmetic operations on intN degrade to int and all numeric literals are of type int. To prevent further errors, Tolk disallows direct assignments between intN and intM types, when N and M are not equal. CopyAsk AIfun takeAnyInt(a: int) { /* ... */ } fun getAnyInt(): int { return 42 } fun f(op: int32, qid: uint64) { op = qid; // error op = qid as int32; // ok op + query_id; // ok, int if (op == qid) {} // ok, not assignment takeAnyInt(op); // ok op = getAnyInt(); // ok var amount: int32 = 1000; var percent: uint8 = 50; // ok, int var new = amount * percent / 100; // ok, int auto-casts to int32 amount = new; } ​Type coins and function ton(\"0.05\") Similar to int32, Tolk has a dedicated coins type representing nanoToncoin values. The coins type has special serialization rules. It’s serialized as variadic integer: small values consume fewer, large values consume more. Arithmetic with coins degrades to int, similar to intN, except for addition or subtraction operations, where the coins type is preserved. Values of type int can be cast back to coins, following the same rules as intN. There is a ton built-in function, which calculates nanoToncoin values at compile-time. It accepts only constants and literals, e.g., ton(some_variable) is invalid. CopyAsk AIconst ONE_TON = ton(\"1\"); // `coins`, value: 1000000000 fun calcCost() { val cost = ton(\"0.05\"); // `coins`, value: 50000000 return ONE_TON + cost; } Was this page helpful?YesNoSuggest editsRaise issuePreviousBooleansNext⌘IgithubxtelegramPowered by MintlifyOn this pageLiteralsFirst-class typesNo floating-point numbersSerializationintN describes serialization, int does notOverflow occurs only at serializationGeneric int implicitly casts to and from any intNType coins and function ton(\"0.05\")",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:36:15.553Z"
  },
  {
    "id": "docs-ton-org--languages-tolk-types-booleans",
    "title": "Booleans",
    "url": "https://docs.ton.org/languages/tolk/types/booleans",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedOverviewBasic syntaxIdioms and conventionsType systemList of typesNumbersBooleansAddressCells, slices, buildersStringsStructuresType aliasesGenericsEnumsNullable typesUnion typesTensorsTuplesMapsCallablesVoid and neverType checks and castsOverall: TVM stackOverall: serializationSyntax detailsLanguage featuresMigrating from FunCChangelogTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationType systemBooleansLanguagesTolkType systemBooleansCopy pageCopy pageTolk has a bool type which can have two values: true or false. The TVM (virtual machine) has only INT. Booleans are represented as -1 or 0. Not 1! But -1. CopyAsk AIfun isGreater10(v: int): bool { return v > 10 } Operators == >= && || ... return bool. Many standard library functions also return bool values: CopyAsk AIvar valid = isSignatureValid(...); // bool var end = someSlice.isEmpty(); // bool ​Logical operators accept both int and bool operator !x supports both bool and int the condition of if and similar statements accepts both bool and int (!= 0) logical && || accept both bool and int; for example, a && b evaluates to true when both operands are true, and for integers when both operands are non-zero Arithmetic operators are restricted to integers. CopyAsk AIvalid && end; // ok valid & end; // ok, bitwise & | ^ also work if both are bools if (!end) // ok valid + end; // error 8 & valid; // error, int & bool not allowed ​Logical vs bitwise operators Tolk has both bitwise & ^ | and logical && || operators. Both can be used for booleans and integers. The main difference is that logical are short-circuit: the right operand is evaluated only if required to. ExpressionBehaviorcondition & f()f() is called alwayscondition && f()f() is called only if condition is truecondition | f()f() is called alwayscondition || f()f() is called only if condition is false The compiler does some optimizations for booleans. Example: !x for int results in asm 0 EQINT, but !x for bool results in asm NOT. Bitwise operators may sometimes be used instead of logical operators to avoid generating conditional branches at runtime. For example, (a > 0) && (a < 10), being replaced with bitwise, consumes less gas. Future versions of the compiler may perform such transformations automatically, although this is non-trivial. ​Casting to int via as operator CopyAsk AIvar i = boolValue as int; // -1 / 0 There are no runtime transformations: bool is guaranteed to be -1/0 at the TVM level. ​Q: Why are booleans -1, not 1? In TVM, there are only integers. When all bits in a signed integer are set to 1, it equals -1 in a decimal representation. This makes bitwise operations more intuitive — for example, NOT 0 naturally becomes -1. true = -1 — all bits set to 1 false = 0 — all bits set to 0 It is consistent across TVM instructions. For example, operator a > b is asm GREATER, which returns -1 or 0. ​Stack layout and serialization A boolean is backed by TVM INT (-1 or 0). Serialized as a single bit. For details, follow TVM representation and Serialization.Was this page helpful?YesNoSuggest editsRaise issuePreviousAddressNext⌘IgithubxtelegramPowered by MintlifyOn this pageLogical operators accept both int and boolLogical vs bitwise operatorsCasting to int via as operatorQ: Why are booleans -1, not 1?Stack layout and serialization",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:36:18.750Z"
  },
  {
    "id": "docs-ton-org--languages-tolk-types-nullable",
    "title": "Nullable types, null safety",
    "url": "https://docs.ton.org/languages/tolk/types/nullable",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedOverviewBasic syntaxIdioms and conventionsType systemList of typesNumbersBooleansAddressCells, slices, buildersStringsStructuresType aliasesGenericsEnumsNullable typesUnion typesTensorsTuplesMapsCallablesVoid and neverType checks and castsOverall: TVM stackOverall: serializationSyntax detailsLanguage featuresMigrating from FunCChangelogTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationType systemNullable types, null safetyLanguagesTolkType systemNullable types, null safetyCopy pageCopy pageTolk supports nullable types T?, a shorthand for T | null. Any type can be made nullable: primitive types, structures, and other composites. null cannot be assigned to a non-nullable type. ​Null safety The compiler enforces null safety: nullable values cannot be accessed without an explicit null check. CopyAsk AIvar value = x > 0 ? 1 : null; // int? value + 5; // error b.storeInt(value); // error A check for value != null is required before: CopyAsk AIif (value != null) { // value is `int` inside value + 5; // ok b.storeInt(value); // ok } When a variable has no explicit type, its type is inferred from the initial assignment and does not change. Therefore, a variable must be declared explicitly as nullable when required: CopyAsk AIvar i = 0; i = null; // error, can't assign `null` to `int` i = maybeInt; // error, can't assign `int?` to `int` // correct form: var i: int? = 0; i = null; // ok Similarly, when the initial value is null, its type must be specified: CopyAsk AIvar i: int? = null; // or var i = null as int?; ​Smart casts After a null check, the compiler automatically narrows the type. This feature is known as “smart casts”. It exists in TypeScript and Kotlin, and makes working with nullable types more natural. Examples: CopyAsk AIif (lastCell != null) { // here lastCell is `cell`, not `cell?` } CopyAsk AIif (lastCell == null || prevCell == null) { return; } // both lastCell and prevCell are `cell` CopyAsk AIvar x: int? = ...; if (x == null) { x = random(); } // here x is `int` CopyAsk AIwhile (lastCell != null) { lastCell = lastCell.beginParse().loadMaybeRef(); } // here lastCell is definitely null Smart casts apply to local variables, structure fields, and tensor/tuple indices. CopyAsk AIstruct HasOpt { optionalId: int? } fun demo(obj: HasOpt) { if (obj.optionalId != null) { // obj.optionalId is `int` here } } Smart casts also work for initial values. Even if a variable declared as int? but initialized with a number, it’s a safe non-null integer: CopyAsk AIvar idx: int? = -1; // idx is `int` When a variable is definitely null, its type becomes null, meaning it can be safely passed to any nullable type: CopyAsk AIfun takeOptSlice(s: slice?) {} fun demo() { var i: int? = getOptInt(); if (i == null) { takeOptSlice(i); // ok: pass `null` to `slice|null` } } ​Operator ! (non-null assertion) The ! operator in Tolk is similar to ! in TypeScript and !! in Kotlin. It allows bypassing the compiler’s check: CopyAsk AIfun doSmth(c: cell) {} fun analyzeStorage(nCells: int, lastCell: cell?) { if (nCells > 0) { // then lastCell is 100% not null doSmth(lastCell!); // use ! for this fact } } Sometimes “a developer knows better than the compiler”. For example: CopyAsk AI// this key 100% exists, so force `cell` instead of `cell?` val mainValidators = blockchain.configParam(16)!; Unlike local variables, global variables cannot be smart-cast. The ! operator is the only way to drop nullability from globals: CopyAsk AIglobal gLastCell: cell? fun demo() { // we are sure that a global is set, convert to `cell` doSmth(gLastCell!); } Therefore, ! is useful when non-nullability is guaranteed by conditions outside the code itself. ​Stack layout and serialization Atomics like int? or cell? / etc. are backed by either TVM NULL or a value. Non-atomics are tagged unions. Serialized as: null -> ‘0’, otherwise -> ‘1’+T, but address? is serialized specially. For details, follow TVM representation and Serialization.Was this page helpful?YesNoSuggest editsRaise issuePreviousUnion typesNext⌘IgithubxtelegramPowered by MintlifyOn this pageNull safetySmart castsOperator ! (non-null assertion)Stack layout and serialization",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:36:20.839Z"
  },
  {
    "id": "docs-ton-org--languages-tolk-features-asm-functions",
    "title": "Assembler functions",
    "url": "https://docs.ton.org/languages/tolk/features/asm-functions",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedOverviewBasic syntaxIdioms and conventionsType systemSyntax detailsLanguage featuresHandling messagesContract storageContract gettersSending messagesAutomatic serializationLazy loadingPayload in jettonsStandard libraryAssembler functionsCompiler optimizationsMigrating from FunCChangelogTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationLanguage featuresAssembler functionsLanguagesTolkLanguage featuresAssembler functionsCopy pageCopy pageFunctions in Tolk may be defined using assembler code. It’s a low-level feature that requires deep understanding of stack layout, Fift, and TVM. ​Standard functions are actually asm wrappers Many functions from stdlib are translated to Fift assembler directly. For example, TVM has a HASHCU instruction: “calculate hash of a cell”. It pops a cell from the stack and pushes an integer in the range 0 to 2^256-1. Therefore, the method cell.hash is defined this way: CopyAsk AI@pure fun cell.hash(self): uint256 asm \"HASHCU\" The type system guarantees that when this method is invoked, a TVM CELL will be the topmost element (self). ​Custom functions are declared in the same way CopyAsk AI@pure fun incThenNegate(v: int): int asm \"INC\" \"NEGATE\" A call incThenNegate(10) will be translated into those commands. A good practice is to specify @pure if the body does not modify TVM state or throw exceptions. The return type for asm functions is mandatory (for regular functions, it’s auto-inferred from return statements). The list of assembler commands can be found here: TVM instructions. ​Multi-line asm To embed a multi-line command, use triple quotes: CopyAsk AIfun hashStateInit(code: cell, data: cell): uint256 asm \"\"\" DUP2 HASHCU ... ONE HASHEXT_SHA256 \"\"\" It is treated as a single string and inserted as-is into Fift output. In particular, it may contain // comments inside (valid comments for Fift). ​Stack order for multiple slots When calling a function, arguments are pushed in a declared order. The last parameter becomes the topmost stack element. If an instruction results in several slots, the resulting type should be a tensor or a struct. For example, write a function abs2 that calculates abs() for two values at once: abs2(-5, -10) = (5, 10). Stack layout (the right is the top) is written in comments. CopyAsk AIfun abs2(v1: int, v2: int): (int, int) asm // v1 v2 \"ABS\" // v1 v2_abs \"SWAP\" // v2_abs v1 \"ABS\" // v2_abs v1_abs \"SWAP\" // v1_abs v2_abs ​Rearranging arguments on the stack Sometimes a function accepts parameters in an order different from what a TVM instruction expects. For example, GETSTORAGEFEE expects the order “cells bits seconds workchain”. But for more clear API, workchain should be passed first. Stack positions can be reordered via the asm(...) syntax: CopyAsk AIfun calculateStorageFee(workchain: int8, seconds: int, bits: int, cells: int): coins asm(cells bits seconds workchain) \"GETSTORAGEFEE\" Similarly for return values. If multiple slots are returned, and they must be reordered to match typing, use asm(-> ...) syntax: CopyAsk AIfun asmLoadCoins(s: slice): (slice, int) asm(-> 1 0) \"LDVARUINT16\" Both the input and output sides may be combined: asm(... -> ...). Reordering is mostly used with mutate variables. ​mutate and self in assembler functions The mutate keyword (see mutability) works by implicitly returning new values via the stack — both for regular and asm functions. For better understanding, let’s look at regular functions first. The compiler does all transformations automatically: CopyAsk AI// transformed to: \"returns (int, void)\" fun increment(mutate x: int): void { x += 1; // a hidden \"return x\" is inserted } fun demo() { // transformed to: (newX, _) = increment(x); x = newX increment(mutate x); } How to implement increment() via asm? CopyAsk AIfun increment(mutate x: int): void asm \"INC\" The function still returns void (from the type system’s perspective it does not return a value), but INC leaves a number on the stack — that’s a hidden “return x” from a manual variant. Similarly, it works for mutate self. An asm function should place newSelf onto the stack before the actual result: CopyAsk AI// \"TPUSH\" pops (tuple) and pushes (newTuple); // so, newSelf = newTuple, and return `void` (syn. \"unit\") fun tuple.push<X>(mutate self, value: X): void asm \"TPUSH\" // \"LDU\" pops (slice) and pushes (int, newSlice); // with `asm(-> 1 0)`, we make it (newSlice, int); // so, newSelf = newSlice, and return `int` fun slice.loadMessageFlags(mutate self): int asm(-> 1 0) \"4 LDU\" To return self for chaining, just specify a return type: CopyAsk AI// \"STU\" pops (int, builder) and pushes (newBuilder); // with `asm(op self)`, we put arguments to correct order; // so, newSelf = newBuilder, and return `void`; // but to make it chainable, `self` instead of `void` fun builder.storeMessageOp(mutate self, op: int): self asm(op self) \"32 STU\" ​asm is compatible with structures Methods for structures may also be declared as assembler ones knowing the layout: fields are placed sequentially. For instance, a struct with one field is identical to this field. CopyAsk AIstruct MyCell { private c: cell } @pure fun MyCell.hash(self): uint256 asm \"HASHCU\" Similarly, a structure may be used instead of tensors for returns. This is widely practiced in map<K, V> methods over TVM dictionaries: CopyAsk AIstruct MapLookupResult<TValue> { private readonly rawSlice: slice? isFound: bool } @pure fun map<K, V>.get(self, key: K): MapLookupResult<V> builtin // it produces `DICTGET` and similar, which push // (slice -1) or (null 0) — the shape of MapLookupResult ​Generics in asm should be single-slot Take tuple.push as an example. The TPUSH instruction pops (tuple, someVal) and pushes (newTuple). It should work with any T: int, int8, slice, etc. CopyAsk AIfun tuple.push<T>(mutate self, value: T): void asm \"TPUSH\" A reasonable question: how should t.push(somePoint) work? The stack would be misaligned, because Point { x, y } is not a single slot. The answer: this would not compile. CopyAsk AIdev.tolk:6:5: error: can not call `tuple.push<T>` with T=Point, because it occupies 2 stack slots in TVM, not 1 // in function `main` 6 | t.push(somePoint); | ^^^^^^ Only regular and built-in generics may be instantiated with variadic type arguments, asm cannot. ​Do not use asm for micro-optimizations Introduce assembler functions only for rarely-used TVM instructions that are not covered by stdlib. For example, when manually parsing merkle proofs or calculating extended hashes. However, attempting to micro-optimize with asm instead of writing straightforward code is not desired. The compiler is smart enough to generate optimal bytecode from consistent logic. For instance, it automatically inlines simple functions, so create one-liner methods without any worries about gas: CopyAsk AIfun builder.storeFlags(mutate self, flags: int): self { return self.storeUint(32, flags); } The function above is better than “manually optimized” as 32 STU. Because: it is inlined automatically for constant flags, it’s merged with subsequent stores into STSLICECONST See compiler optimizations.Was this page helpful?YesNoSuggest editsRaise issuePreviousCompiler optimizationsNext⌘IgithubxtelegramPowered by MintlifyOn this pageStandard functions are actually asm wrappersCustom functions are declared in the same wayMulti-line asmStack order for multiple slotsRearranging arguments on the stackmutate and self in assembler functionsasm is compatible with structuresGenerics in asm should be single-slotDo not use asm for micro-optimizations",
    "category": "languages",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:36:22.138Z"
  },
  {
    "id": "docs-ton-org--languages-tolk-types-cells",
    "title": "Cells, slices, builders",
    "url": "https://docs.ton.org/languages/tolk/types/cells",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedOverviewBasic syntaxIdioms and conventionsType systemList of typesNumbersBooleansAddressCells, slices, buildersStringsStructuresType aliasesGenericsEnumsNullable typesUnion typesTensorsTuplesMapsCallablesVoid and neverType checks and castsOverall: TVM stackOverall: serializationSyntax detailsLanguage featuresMigrating from FunCChangelogTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationType systemCells, slices, buildersLanguagesTolkType systemCells, slices, buildersCopy pageCopy pageIn TON, all data is stored in cells. Cells opened for reading are called slices. Cells being constructed are called builders. Having a builder, only writing is possible. Having a slice, only reading is possible. Tolk provides low-level capabilities to construct and parse cells manually, as well as automatic packing structures to/from cells. ​Cells A cell is the fundamental data structure in TON. It’s a container that holds up to 1023 bits of data and up to 4 references to other cells. Everything in TON (contracts, messages, storage) is represented using cells. They are read-only and immutable once created. Read more about cells. In Tolk, the basic type cell describes “some cell”. CopyAsk AIstruct SomeMessage { // ... customPayload: cell } ​Typed cells: Cell<T> Besides “some cell”, Tolk has a “cell with known shape” Cell<T>. Since one cell can store only 1023 bits, when storage exceeds this limit, the solution is to split it into multiple cells, so they become referencing each other. CopyAsk AIstruct Demo { ref1: cell // untyped ref ref2: Cell<Inner> // typed ref ref3: Cell<int256>? // maybe ref } Yes, point.toCell() really gives A typed cell can be assigned to cell implicitly. ​Slices: cells opened for reading To manually read data from a cell, use beginParse() to get a slice: CopyAsk AIvar s = cell.beginParse(); Then load data incrementally: integers, coins, sub-slices, references, etc. CopyAsk AIval mode = s.loadUint(8); val dest = s.loadAddress(); val firstRef = s.loadRef(); // cell if (s.remainingBitsCount()) { // ... } An IDE will suggest applicable methods after a dot. ​Builders: cells at the moment of writing To manually construct a cell, create a builder, write some data, and finalize this builder: CopyAsk AIvar b = beginCell(); b.storeUint(123, 8); b.storeAddress(dest); val c = b.endCell(); Since methods storeXXX return self, these calls can be chained: CopyAsk AIval c = beginCell() .storeUint(123, 8) .storeAddress(dest) .endCell(); ​How to read from a builder The only way to access already written bits is to convert a builder into a slice: CopyAsk AIvar s = b.asSlice(); // or (absolutely the same) var s = b.endCell().beginParse(); Constructing a cell is generally expensive in terms of gas, but b.endCell().beginParse() is optimized to a cheap asm instruction BTOS without intermediate cell creation. ​Auto packing to/from cells Tolk type system is designed to avoid cumbersome manual work with slices and builders. Almost every practical use case can be represented with an auto-serializable structure. CopyAsk AIstruct Something { // ... } fun parseAndModify(c: cell): cell { var smth = Something.fromCell(c); // ... return smth.toCell(); } Having Cell<T>, just call load() to get T: CopyAsk AIfun parsePoint(c: Cell<Point>) { // same as `Point.fromCell(c)` var p = c.load(); } Read a detailed article automatic serialization. Internally, fromCell() does beginParse() and reads data from a slice. ​Auto packing to/from builders/slices A struct can be parsed not only from a cell but also from a slice: CopyAsk AIval smth = Something.fromSlice(s); Auto-serialization works at low-level also: by analogy with loadUint() and others, there is a loadAny<T>() method: CopyAsk AIval smth = s.loadAny<Something>(); // or even val smth: Something = s.loadAny(); // T=Something deduced By analogy, a call doSmth(s), does not change s, whereas s.loadAddress() shifts its internal pointer. See mutability. Similarly, storeAny<T>() for a builder accepts any serializable value: CopyAsk AIbeginCell() .storeAddress(dest) .storeAny(smth) // T=Something deduced .storeUint(123, 8); Furthermore, it works not only with structures but also with arbitrary types. CopyAsk AIs.loadAny<int32>(); // same as loadInt(32) s.loadAny<(coins, bool?)>(); // read a pair (a tensor) b.storeAny(someAddress); // same as storeAddress b.storeAny(0xFF as uint8); // same as storeUint(0xFF, 8) This approach allows both low-level and high-level intentions to be expressed uniformly. ​Builders and slices can NOT be serialized Builders and slices are low-level primitives used for constructing and parsing cells. They contain raw binary data. For this reason, attempting to read an arbitrary slice from another slice is impossible: how many bits should be read? CopyAsk AIstruct CantBeRead { before: int8 s: slice after: int8 } An attempt to call CantBeRead.fromCell(c) will fire an error “Can not be deserialized, because CantBeRead.s is slice”. Express shape of data using the type system to make serialization distinct. For example, s: bits100 if it’s exactly 100 bits. ​Type bitsN: fixed-size slices By analogy: int can not be serialized, but int32 and int64 can. The same: slice can not be serialized, but bits32 and bytes8 can. At runtime, bitsN is a TVM SLICE, like int32 is a TVM INT. CopyAsk AIstruct OkayToRead { before: int8 s: bits100 after: int8 } fun read(c: cell) { // a cell `c` is expected to be 116 bits val r = OkayToRead.fromCell(c); // on the stack: INT, SLICE, INT } To cast slice to bitsN, use the unsafe as operator. It’s intentional, because slices may have refs, so explicit casting forces a programmer to think whether this transformation is valid. At runtime, it’s no-op. CopyAsk AIfun calcHash(raw: bits512) { // ... } fun demo() { calcHash(someSlice); // error calcHash(someSlice as bits512); // ok someBytes.loadAddress(); // error (someBytes as slice).loadAddress(); // ok } ​”The remaining” slice when reading A common pattern is to read a portion of data and then retrieve the remainder. With manual parsing, it happens naturally: CopyAsk AIval ownerId = s.loadUint(32); val dest = s.loadAddress(); // `s` contains all bits/refs still unread val payload = s; To express the same with the type system use a special type RemainingBitsAndRefs: CopyAsk AIstruct WithPayload { ownerId: uint32 dest: address payload: RemainingBitsAndRefs } Then, obj = WithPayload.fromSlice(s) will return an object, where obj.payload contains “all bits/refs left”. This is a special type: CopyAsk AI// declared in stdlib, handled specially by the compiler type RemainingBitsAndRefs = slice Naturally, such a field must appear last in a struct: no more data exists after reading it. ​Embedding constant slices into a contract A string literal is represented as a slice: CopyAsk AI// `slice` with 4 bytes: 97,98,99,100 (0x61626364) const SLICE1 = \"abcd\" Also, use stringHexToSlice(\"...\") to embed hexadecimal binary data: CopyAsk AI// `slice` with 2 bytes: 16,32 (0x1020) const SLICE2 = stringHexToSlice(\"1020\") TVM does not have string types; it operates solely on slices. Read about emulating strings. ​Stack layout and serialization Both cell and Cell<T> are backed by TVM CELL. Serialized as a reference; nullable are “maybe reference”. The primitive types builder and slice cannot be serialized. Use bitsN and RemainingBitsAndRefs. For details, follow TVM representation and Serialization.Was this page helpful?YesNoSuggest editsRaise issuePreviousStringsNext⌘IgithubxtelegramPowered by MintlifyOn this pageCellsTyped cells: Cell<T>Slices: cells opened for readingBuilders: cells at the moment of writingHow to read from a builderAuto packing to/from cellsAuto packing to/from builders/slicesBuilders and slices can NOT be serializedType bitsN: fixed-size slices”The remaining” slice when readingEmbedding constant slices into a contractStack layout and serialization",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:36:24.828Z"
  },
  {
    "id": "docs-ton-org--languages-tolk-types-structures",
    "title": "Structures",
    "url": "https://docs.ton.org/languages/tolk/types/structures",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedOverviewBasic syntaxIdioms and conventionsType systemList of typesNumbersBooleansAddressCells, slices, buildersStringsStructuresType aliasesGenericsEnumsNullable typesUnion typesTensorsTuplesMapsCallablesVoid and neverType checks and castsOverall: TVM stackOverall: serializationSyntax detailsLanguage featuresMigrating from FunCChangelogTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationType systemStructuresLanguagesTolkType systemStructuresCopy pageCopy pageTolk supports structures. CopyAsk AIstruct Point { x: int y: int } fun calcMaxCoord(p: Point) { return p.x > p.y ? p.x : p.y } fun demo() { // declared using object-literal syntax var p: Point = { x: 10, y: 20 }; calcMaxCoord(p); // constructed using object-literal syntax calcMaxCoord({ x: 10, y: 20 }); } ​Distinct structure types Structures with identical fields are not assignable to each other: CopyAsk AIstruct SomeA { v: int } struct SomeB { v: int } fun acceptA(a: SomeA) {} fun demo(a: SomeA, b: SomeB) { b = a; // error, can not assign `SomeA` to `SomeB` acceptA(b); // error, can not pass `SomeB` to `SomeA` } Even though SomeA and SomeB have identical layouts, they represent distinct types. ​Contextual type inference The compiler infers types from context. In the example below, the compiler determines that { ... } has type StoredInfo based on the parameter type: CopyAsk AIfun store(info: StoredInfo) { // ... } fun demo() { store({ counterValue: ..., ownerAddress: ..., }); } The same applies to return values and assignments: CopyAsk AIfun loadData(): StoredInfo { return { counterValue: ..., ownerAddress: ..., } } fun demo() { var s: StoredInfo = { counterValue, ... }; var s: (int, StoredInfo) = (0, { counterValue, ... }); } ​Explicit type hints Explicit type hints are available. In addition to the plain { ... } syntax, the form StructName { ... } can be used. The snippet below is equivalent to the previous example: CopyAsk AIfun loadData() { return StoredInfo { counterValue: ..., ownerAddress: ..., } } fun demo() { var s = StoredInfo { counterValue, ... }; var s = (0, StoredInfo { counterValue, ... }); } When neither contextual information nor an explicit type hint is available, the type cannot be inferred and an error is produced. CopyAsk AIval o = { x: 10, y: 20 }; // error, what type is it? ​Methods Methods are declared as extension functions: CopyAsk AIfun Point.calcSquare(self) { return self.x * self.y } Without self parameter, a method will be static. By default, self is immutable. The form mutate self enables mutation. ​Serialization prefixes Serialization prefixes do not affect typing or layout. The syntax struct (PREFIX) Name { ... } specifies a serialization prefix. The prefix affects only the binary representation; all other aspects remain unchanged. CopyAsk AIstruct (0x12345678) CounterIncrement { byValue: uint32 } fun demo(inc: CounterIncrement) { // `inc` has one field; the prefix is not a property inc.byValue // `inc` is still one TVM `INT` on the stack } ​Structure syntax Structure syntax includes: shorthand field syntax { x, y }; default field values (a: int32 = 10); private and readonly fields; serialization prefixes (opcodes). ​Stack layout and serialization Fields are placed on the stack sequentially and are serialized in the same order. If a struct has a prefix, it is written first.Was this page helpful?YesNoSuggest editsRaise issuePreviousType aliasesNext⌘IgithubxtelegramPowered by MintlifyOn this pageDistinct structure typesContextual type inferenceExplicit type hintsMethodsSerialization prefixesStructure syntaxStack layout and serialization",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:36:27.052Z"
  },
  {
    "id": "docs-ton-org--languages-tolk-types-aliases",
    "title": "Type aliases",
    "url": "https://docs.ton.org/languages/tolk/types/aliases",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedOverviewBasic syntaxIdioms and conventionsType systemList of typesNumbersBooleansAddressCells, slices, buildersStringsStructuresType aliasesGenericsEnumsNullable typesUnion typesTensorsTuplesMapsCallablesVoid and neverType checks and castsOverall: TVM stackOverall: serializationSyntax detailsLanguage featuresMigrating from FunCChangelogTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationType systemType aliasesLanguagesTolkType systemType aliasesCopy pageCopy pageTolk supports type aliases, similar to TypeScript and Rust. An alias creates a new name for an existing type and remains fully interchangeable with it. CopyAsk AItype UserId = int32 type MaybeOwnerHash = bytes32? fun calcHash(id: UserId): MaybeOwnerHash { // ... } ​Aliases are interchangeable with underlying types UserId and int32 from the above are fully equivalent: id + 1 is okay, will be int someF(id) is okay if someF accepts int32 or int methods for int32 can be called having UserId and vice versa (and for int also, because int32 is assignable to int) a union UserId | int32 makes no sense, it is simply int32 CopyAsk AIfun demo() { var id: UserId = 1; // ok var num: int = id; // ok var h = calcHash(id); if (h != null) { h as slice; // bytes32 as slice } } To obtain a “strict alias”, which defines a distinct type, use a struct with one field: CopyAsk AIstruct UniqueId { value: int32 } Such a struct has no overhead over int32, but it becomes a distinct type with its own methods and semantics. ​Two equal aliases are considered different If two aliases share the same underlying type, CopyAsk AItype AssetsDict = dict type BalanceDict = dict Then they are not assignable to each other. It allows them to have identical methods: CopyAsk AIfun AssetsDict.validate(self) { /* ... */ } fun BalanceDict.validate(self) { /* ... */ } fun demo(a: AssetsDict, b: BalanceDict) { a.validate(); // ok, method 1 b.validate(); // ok, method 2 a = b; // error, can not assign } This reminds intN types: int32 is assignable to int and back, int64 also, but assigning int32 to int64 is something strange. Assignment can be done with explicit casting: b as AssetsDict, see operator as. ​Type aliases can be generic CopyAsk AItype Wrapper<T> = Nothing | Container<T> Read about generic structs and aliases. ​Stack layout and serialization An alias is identical to its underlying type. Serialization can be overloaded with custom serializers. This is useful in tricky cases where binary encoding cannot be expressed using existing types. CopyAsk AItype MyString = slice fun MyString.packToBuilder(self, mutate b: builder) { // custom logic } fun MyString.unpackFromSlice(mutate s: slice) { // custom logic } For details, follow TVM representation and Serialization.Was this page helpful?YesNoSuggest editsRaise issuePreviousGenericsNext⌘IgithubxtelegramPowered by MintlifyOn this pageAliases are interchangeable with underlying typesTwo equal aliases are considered differentType aliases can be genericStack layout and serialization",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:36:28.222Z"
  },
  {
    "id": "docs-ton-org--languages-tolk-types-generics",
    "title": "Generic structs and aliases",
    "url": "https://docs.ton.org/languages/tolk/types/generics",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedOverviewBasic syntaxIdioms and conventionsType systemList of typesNumbersBooleansAddressCells, slices, buildersStringsStructuresType aliasesGenericsEnumsNullable typesUnion typesTensorsTuplesMapsCallablesVoid and neverType checks and castsOverall: TVM stackOverall: serializationSyntax detailsLanguage featuresMigrating from FunCChangelogTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationType systemGeneric structs and aliasesLanguagesTolkType systemGeneric structs and aliasesCopy pageCopy pageGeneric structs and type aliases exist only at the type level and incur no runtime cost. CopyAsk AIstruct Container<T> { element: T? } struct Nothing type Wrapper<T> = Nothing | Container<T> Example usage: CopyAsk AIfun checkElement<T>(c: Container<T>) { return c.element != null; } fun demo() { var c: Container<int32> = { element: null }; var n: Wrapper<int> = Nothing {}; var i: Wrapper<int32> = Container { element: 0 }; } ​Type arguments must be specified When referencing a generic Container, T must be provided explicitly: CopyAsk AIfun getItem(c: Container) // error fun getItem(c: Container<int>) // ok fun getItem<T>(c: Container<T>) // ok For generic functions, type arguments can be inferred from the call site: CopyAsk AIfun doSmth<T>(value: Container<T>) { // ... } fun demo() { doSmth({ element: 123 }); // T = int doSmth({ element: cellOrNull }); // T = cell? } ​Default type arguments A type parameter can have a default type: <T = xxx>. Such type parameters may be omitted at use sites. CopyAsk AIstruct StrangeUnion<T1, T2 = null> { item: T1 | T2 } fun demo() { var m1: StrangeUnion<int> = { item: 10 }; var m2: StrangeUnion<int, bool> = { item: 20 }; // m1.item is `int?` // m2.item is `int | bool` } Type arguments cannot currently reference one another; expressions such as T2 = T1 are invalid. ​Not only structs, but also type aliases The following example demonstrates a generic type alias Response<TResult, TError>: CopyAsk AIstruct Ok<TResult> { result: TResult } struct Err<TError> { err: TError } type Response<R, E> = Ok<R> | Err<E> fun loadNextRef(mutate s: slice): Response<cell, int32> { return s.remainingRefsCount() ? Ok { result: s.loadRef() } : Err { err: ERR_NO_MORE_REFS } } fun demo() { match (val r = loadNextRef(mutate parsedSlice)) { Ok => { r.result } // cell Err => { r.err } // int32 } } ​Methods for generic types Methods for generics are declared exactly as for regular structures. In this form, the compiler treats T (unknown symbol) as a type parameter: CopyAsk AIfun Container<T>.getElement(self) { return self.element } Notice the first self parameter. Without it, a method will be static. See Functions and methods for examples.Was this page helpful?YesNoSuggest editsRaise issuePreviousEnumsNext⌘IgithubxtelegramPowered by MintlifyOn this pageType arguments must be specifiedDefault type argumentsNot only structs, but also type aliasesMethods for generic types",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:36:30.347Z"
  },
  {
    "id": "docs-ton-org--languages-tolk-types-tensors",
    "title": "Tensors (not tuples!)",
    "url": "https://docs.ton.org/languages/tolk/types/tensors",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedOverviewBasic syntaxIdioms and conventionsType systemList of typesNumbersBooleansAddressCells, slices, buildersStringsStructuresType aliasesGenericsEnumsNullable typesUnion typesTensorsTuplesMapsCallablesVoid and neverType checks and castsOverall: TVM stackOverall: serializationSyntax detailsLanguage featuresMigrating from FunCChangelogTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationType systemTensors (not tuples!)LanguagesTolkType systemTensors (not tuples!)Copy pageCopy pageIn Tolk, a tensor is (T1, T2, ...). For example, (int, slice) — two values one by one. Large tensors are generally impractical; structures are typically more suitable. Essentially, structures are named tensors. In most languages, (v1, v2, ...) is called a tuple. However, in TON, a “tuple” refers to a specific TVM primitive. For this reason, (v1, v2, ...) in Tolk is called “a tensor”. Read about tuples. ​Syntax tensorVar.{i} Access tensor components for reading and writing: CopyAsk AI// v is `(int, int, builder)` var v = (1, 2, beginCell()); // read v.0; // 1 // modify v.1 = 123; v.2.storeInt(v.0, 16); // v is now (1, 123, builder \"0x0001\") v.100500 // compilation error It also works for nested tensors: CopyAsk AIfun getNested(): (int, (bool, coins)) { // ... } fun demo() { val v = getNested(); v.1.0 // bool } ​Structures as named tensors Struct User below and a tensor (int, slice) have identical stack layouts and serialization rules: CopyAsk AIstruct User { id: int name: slice } Furthermore, obj.{field} is equivalent to tensorVar.{i}: CopyAsk AIstruct Storage { lastUpdated: int owner: User } fun demo(s: Storage) { s.lastUpdated; // s.0 s.owner.id; // s.1.0 } ​Destructuring at assignment The following syntax is valid: CopyAsk AIvar (i, j) = (10, 20); Actually, it’s a 2-component tensor (10, 20) assigned to two variables: CopyAsk AIvar tensor = (10, 20); var (i, j) = tensor; // more complex example var (str, (i, j)) = (\"abcd\", (10, 20)); A special placeholder _ can be used on the left side: CopyAsk AIvar (_, j) = (10, 20); // j = 20 ​Empty tensors are also valid values CopyAsk AIval empty = (); This is analogous to creating an instance of an empty struct. In some languages, an empty value is called “unit”, and functions that return no value conceptually return a “unit” value. In Tolk, a special type “void” is used for that (like in TypeScript). void and () are not compatible, although they both hold no value. ​Tensors vs tuples A tuple is a special TVM primitive: it is a dynamic container capable of holding multiple values within a single stack slot. For example, a tensor (int, int, int) is “3 integers on the stack”, whereas a tuple with 3 integers is “one tuple on the stack”. Tolk supports the tuple type. Read about tuples. ​Stack layout and serialization Values are placed on the stack sequentially and serialized in the same order. For details, follow TVM representation and Serialization.Was this page helpful?YesNoSuggest editsRaise issuePreviousTuplesNext⌘IgithubxtelegramPowered by MintlifyOn this pageSyntax tensorVar.{i}Structures as named tensorsDestructuring at assignmentEmpty tensors are also valid valuesTensors vs tuplesStack layout and serialization",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:36:31.795Z"
  },
  {
    "id": "docs-ton-org--languages-tolk-types-tuples",
    "title": "Tuples (not tensors!)",
    "url": "https://docs.ton.org/languages/tolk/types/tuples",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedOverviewBasic syntaxIdioms and conventionsType systemList of typesNumbersBooleansAddressCells, slices, buildersStringsStructuresType aliasesGenericsEnumsNullable typesUnion typesTensorsTuplesMapsCallablesVoid and neverType checks and castsOverall: TVM stackOverall: serializationSyntax detailsLanguage featuresMigrating from FunCChangelogTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationType systemTuples (not tensors!)LanguagesTolkType systemTuples (not tensors!)Copy pageCopy pageIn TVM (the virtual machine), a tuple is a dynamic container that stores from 0 to 255 elements in a single stack slot. Tolk supports two tuple forms: tuple — a dynamic tuple with unknown shape [T1, T2, ...] — TVM tuple with known shape In most languages, (v1, v2, ...) denotes a tuple. In TON, however, a “tuple” is a specific TVM primitive. For this reason, (v1, v2, ...) in Tolk is called “a tensor”. Read about tensors. ​tuple: dynamic tuples A TVM tuple allows storing from 0 to 255 elements in one stack slot. Push elements into a tuple: CopyAsk AIfun demo(): tuple { var t = createEmptyTuple(); t.push(10); t.push(beginCell()); t.push(null); t.size(); // 3 return t; } When calling t.get(idx), the type must be provided explicitly or inferred: CopyAsk AIval first = t.get<int>(0); // or val first: int = t.get(0); // T=int auto-inferred The syntax tupleVar.{i} is also permitted when the type is evident: CopyAsk AIval first: int = t.0; The method set() does not create new elements; it only updates existing ones. If idx is out of bounds in get() or set(), an exception is thrown. CopyAsk AIt.set(value, 100500); // throws errCode=5 t.100500 = value; // throws errCode=5 The following methods are available — last(), set(), pop(), etc. IDE will suggest them after a dot. ​Only primitives can be placed into a tuple An attempt to call t.push(somePoint) will raise an error: only single‑slot values can be added and retrieved. CopyAsk AIt.push(somePoint); // error t.push(somePoint.x); // ok (int) ​Convert an object to a tuple and back Tolk provides built-in generic methods T.toTuple() and T.fromTuple(). If a value occupies N stack slots, the resulting tuple has size N. CopyAsk AIstruct Point3d { x: int y: int z: int } fun demo(p: Point3d) { val t = p.toTuple(); // a tuple with 3 elements t.get<int>(2); // z p = Point3d.fromTuple(t); // back to a struct } ​Typed tuples [T1, T2, ...] Use this syntax to describe a tuple with a known shape: CopyAsk AI// its type is `[int, int, builder]` val t = [1, 2, beginCell()]; // read t.0; // 1 // modify t.1 = 123; t.2.storeInt(t.0, 16); // t is now (1, 123, builder \"0x0001\") t.100500 // compilation error This syntax is similar to a tensor (T1, T2, ...), but all values are stored in a single stack slot. Non-primitive values are also not permitted. A typed tuple may be destructured into multiple variables: CopyAsk AIfun sumFirstTwo(t: [int, int, builder]) { val [first, second, _] = t; return first + second; } ​Lisp-style lists Lisp-style lists are nested two-element tuples: [1, [2, [3, null]]] represents the list [1, 2, 3]. An empty list is conventionally represented as null. From the type‑system perspective, it’s tuple? with dynamic contents, not a special type. It was a common pattern in old contracts, but now it’s almost unused. Its primary remaining use case is to return more than 255 elements. Lisp‑style lists can be processed using the following stdlib module: CopyAsk AIimport \"@stdlib/lisp-lists\" ​Tuples vs tensors A tensor is (T1, T2, ...) — multiple values in parentheses. The primary distinction is the stack layout: a tuple is a single stack slot, whereas tensor components are placed one by one. For example, (coins, builder, int?) occupies 3 slots, but [coins, builder, int?] — only one. Accessing tupleVar.{i} produces TVM asm {i} INDEX, but tensorVar.{i} is just stack shuffling. Read about tensors. ​Stack layout and serialization Tuples are backed by TVM TUPLE. Serialization is not implemented, but tuples may be returned from get methods, because contract getters operate via the stack rather than serialization. For details, follow TVM representation and Serialization.Was this page helpful?YesNoSuggest editsRaise issuePreviousMapsNext⌘IgithubxtelegramPowered by MintlifyOn this pagetuple: dynamic tuplesOnly primitives can be placed into a tupleConvert an object to a tuple and backTyped tuples [T1, T2, ...]Lisp-style listsTuples vs tensorsStack layout and serialization",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:36:35.290Z"
  },
  {
    "id": "docs-ton-org--languages-tolk-types-callables",
    "title": "Callables",
    "url": "https://docs.ton.org/languages/tolk/types/callables",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedOverviewBasic syntaxIdioms and conventionsType systemList of typesNumbersBooleansAddressCells, slices, buildersStringsStructuresType aliasesGenericsEnumsNullable typesUnion typesTensorsTuplesMapsCallablesVoid and neverType checks and castsOverall: TVM stackOverall: serializationSyntax detailsLanguage featuresMigrating from FunCChangelogTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationType systemCallablesLanguagesTolkType systemCallablesCopy pageCopy pageTolk has first-class functions: they can be passed as callbacks. Such values have callable types: (...ArgsT) -> ReturnT. ​First-class functions Pass a function as a callback: CopyAsk AIfun invokeMath(fn: (int, int) -> int) { return fn(10, 20); } fun myPlus(a: int, b: int) { return a + b; } fun demo() { invokeMath(myPlus); // 30 } A function myPlus has the type (int, int) -> int. A function demo, for example, is () -> void. Assigning functions to variables also works: CopyAsk AIfun demo() { val callback = myPlus; callback(5, 5); // 10 // or, with explicit type: val fn: (int, int) -> int = myPlus; } Functions with mutate parameters cannot be used in such a way. Mutations are not part of the type system currently. ​Lambda functions Tolk supports lambda functions: CopyAsk AIfun demo() { invokeMath(fun(a, b) { return a * b }); // 200 } Lambda parameter types may be omitted when they can be inferred. In the example above, both a and b are int, inferred from invokeMath declaration. If they cannot be inferred, the parameter types must be specified: CopyAsk AI// error: param's type cannot be inferred here: val doubleFn = fun(param) { return param * 2 }; // correct is: val doubleFn = fun(param: int) { return param * 2 }; As first-class functions, lambdas can even be returned: CopyAsk AIfun createFinalizer() { return fun(b: builder) { b.storeUint(0xFFFFFFFF, 32); return b.toSlice(); } } fun demo() { val f = createFinalizer(); // (builder) -> slice f(beginCell()); // slice with 32 bits } While lambdas are uncommon in smart contracts, they are useful in general‑purpose tooling. They can be combined with generics of any level and may be nested without restrictions. CopyAsk AIstruct HasCallback<TResult> { arg: int fn: (int -> TResult)? } fun HasCallback<TResult>.invoke(self): TResult { assert (self.fn != null) throw ERR_CALLBACK_UNSET; return self.fn(self.arg) } Note that lambdas are not closures: capturing outer variables is not supported. CopyAsk AIfun outer(x: int) { return fun(y: int) { return x + y; // error: undefined symbol `x` } } ​Low-level TVM continuations Continuations are executable cells representing TVM bytecode. A callable is effectively a typed continuation. Tolk has a type continuation type for low-level purposes. For example, TVM register c3 contains current smart contract code. Some functions are available in stdlib: CopyAsk AIimport \"@stdlib/tvm-lowlevel\" ​Stack layout and serialization A callable is backed by TVM CONT. It cannot be serialized. For details, follow TVM representation and Serialization.Was this page helpful?YesNoSuggest editsRaise issuePreviousVoid and neverNext⌘IgithubxtelegramPowered by MintlifyOn this pageFirst-class functionsLambda functionsLow-level TVM continuationsStack layout and serialization",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:36:37.499Z"
  },
  {
    "id": "docs-ton-org--languages-tolk-types-void-never",
    "title": "Void and never types",
    "url": "https://docs.ton.org/languages/tolk/types/void-never",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedOverviewBasic syntaxIdioms and conventionsType systemList of typesNumbersBooleansAddressCells, slices, buildersStringsStructuresType aliasesGenericsEnumsNullable typesUnion typesTensorsTuplesMapsCallablesVoid and neverType checks and castsOverall: TVM stackOverall: serializationSyntax detailsLanguage featuresMigrating from FunCChangelogTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationType systemVoid and never typesLanguagesTolkType systemVoid and never typesCopy pageCopy pageTolk supports the types void and never, similar to TypeScript. Both represent the absence of a value, but in different ways. ​A function that returns nothing is void Both functions below return void: CopyAsk AIfun demo1() { debug.print(globalVar); } fun demo2() { if (random.uint256() == 0) { return; } globalVar = 123; } When the return type of a function is not specified, it is inferred from the return statements. A return without a value means “void”. Explicitly specifying fun(...): void behaves identically: CopyAsk AIfun demo1(): void { // ... } In some languages, an empty value is called “unit”, and a function that returns nothing, actually returns “unit”. In Tolk, “void” is used for that, like in TypeScript. But to some extent, they are equivalent. ​Special fields with void type If a structure field is void, it indicates that the field does not exist at all. This technique is used in combination with generics <T = void>, allowing structures to express optional fields. CopyAsk AIstruct WithOptionalField<T> { a: int b: T c: slice } type OnlyAC = WithOptionalField<void> fun demo() { // field `b` may be omitted val v: OnlyAC = { a: 10, c: \"\" }; } ​A function that never returns is never An always-throwing function is an example: CopyAsk AIfun accessDenied(): never { throw 403 } fun validate(userId: int) { if (userId > 0) { return userId; } accessDenied(); // no `return` statement is needed } In a match expression, branches that never return are also of type never: CopyAsk AIval result = match (ownerKey) { ADMIN_KEY => true, // `bool` else => throw 403, // `never` }; // result is `bool` ​Implicit never in unreachable conditions The never type occurs implicitly when a condition is impossible to satisfy. More precisely, it means that no value of such a type can exist; no possible data can produce such a value: CopyAsk AIfun demo(v: int | slice) { if (v is builder) { // v is `never` } } Another case arises when a non-nullable type is checked against null: CopyAsk AIfun demo(v: int) { if (v == null) { // v is `never` v + 10; // error, can not apply `+` `never` and `int` } // v is `int` again } Encountering never in a compilation error typically indicates an issue in the preceding code. ​Stack layout and serialization Both mean “absence of a value” and occupy zero stack slots and zero bits. For example, a void function does not place any value onto the stack. For details, follow TVM representation and Serialization.Was this page helpful?YesNoSuggest editsRaise issuePreviousType checks and castsNext⌘IgithubxtelegramPowered by MintlifyOn this pageA function that returns nothing is voidSpecial fields with void typeA function that never returns is neverImplicit never in unreachable conditionsStack layout and serialization",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:36:38.710Z"
  },
  {
    "id": "docs-ton-org--languages-tolk-types-type-checks-and-casts",
    "title": "Type checks and casts",
    "url": "https://docs.ton.org/languages/tolk/types/type-checks-and-casts",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedOverviewBasic syntaxIdioms and conventionsType systemList of typesNumbersBooleansAddressCells, slices, buildersStringsStructuresType aliasesGenericsEnumsNullable typesUnion typesTensorsTuplesMapsCallablesVoid and neverType checks and castsOverall: TVM stackOverall: serializationSyntax detailsLanguage featuresMigrating from FunCChangelogTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationType systemType checks and castsLanguagesTolkType systemType checks and castsCopy pageCopy pageDifferent types may be converted to one another — either automatically or using the unsafe as operator. ​Non-assignable types give a compilation error Assignable types may be passed as arguments, assigned to fields, etc. This behavior follows conventional type-system rules. CopyAsk AIfun takeOptInt(v: int?) {} fun main() { takeOptInt(100); // ok, `int` to `int?` takeOptInt(null); // ok, `null` to `int?` } Some conversions are performed automatically: int to intN, AliasForT and T, Cell<T> to cell. CopyAsk AIfun demo() { var number: int32 = 100; // auto cast `int` to `int32` } Non-assignable types give a type checker error: CopyAsk AIfun main() { var number: int = true; } CopyAsk AIfile.tolk:2:23: error: can not assign `bool` to variable of type `int` hint: use `as` operator for UNSAFE casting: `<some_expr> as int` // in function `main` 2 | var number: int = true; | ^^^^ In cases where non-trivial type transformations are disallowed, the unsafe operator as may be used to override the restriction. ​Unsafe operator as For example, bool is not assignable to int, but a boolean is backed by TVM INT (-1 or 0), making the cast valid: CopyAsk AIvar number: int = true as int; // -1 Similarly, operator as can be used to convert types that have equal TVM representation. Using as explicitly forces a developer to verify that the transformation is correct. No additional runtime instructions are inserted — it is purely a type cast. Some examples: address is TVM SLICE, so someAddr as slice is valid conversely, someSlice as address bits123 is TVM SLICE, so someSlice as bits123 is valid intN is TVM INT, so someInt64 as int32 is valid bool is TVM INT, so someBool as int and someBool as int32 are valid, resulting in -1 or 0 an enum is TVM INT, so someColor as int is valid and similar conversions apply. When a cast using as is appropriate, the compiler indicates this in diagnostic messages, as shown above. Not all transformations are possible. For example, someInt as cell is invalid. Operator `as` is unsafeThe as operator locally skips typechecking and does no validation at runtime. For example, someSlice as address — if someSlice holds invalid address, the program execution may become undefined. ​Operator ! (non-null assertion) The ! operator is similar to ! in TypeScript and !! in Kotlin. It allows bypassing the compiler’s nullability check: CopyAsk AIfun doSmth(c: cell) {} fun analyzeStorage(nCells: int, lastCell: cell?) { if (nCells) { // then lastCell 100% not null doSmth(lastCell!); // use ! for this fact } } ​Smart casts Once a variable is checked, the compiler automatically narrows its type. CopyAsk AIif (lastCell != null) { // here lastCell is `cell`, not `cell?` } Smart casts operate similarly to those in TypeScript and Kotlin. They are described in nullables and null safety. ​Operator is for union types Given a union type T1 | T2 | ..., the operator is performs a runtime type test. CopyAsk AIfun demo(v: int | Point | cell) { if (v is Point) { return v.x + v.y; } // v is `int | cell` here } The as operator does not apply to unions: v as Point is incorrect. Use is and smart casts. Operators is, !is, and match are described in union types.Was this page helpful?YesNoSuggest editsRaise issuePreviousOverall: TVM stackNext⌘IgithubxtelegramPowered by MintlifyOn this pageNon-assignable types give a compilation errorUnsafe operator asOperator ! (non-null assertion)Smart castsOperator is for union types",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:36:40.361Z"
  },
  {
    "id": "docs-ton-org--languages-tolk-types-overall-tvm-stack",
    "title": "Overall: TVM stack representation",
    "url": "https://docs.ton.org/languages/tolk/types/overall-tvm-stack",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedOverviewBasic syntaxIdioms and conventionsType systemList of typesNumbersBooleansAddressCells, slices, buildersStringsStructuresType aliasesGenericsEnumsNullable typesUnion typesTensorsTuplesMapsCallablesVoid and neverType checks and castsOverall: TVM stackOverall: serializationSyntax detailsLanguage featuresMigrating from FunCChangelogTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationType systemOverall: TVM stack representationLanguagesTolkType systemOverall: TVM stack representationCopy pageCopy pageA consolidated summary of how each Tolk type is represented on the stack. Low-level detailsThis page assumes prior knowledge of the Tolk type system and TVM. It is intended as a concise low-level reference page. ​int, intN, coins All numeric types are backed by TVM INT. A reminder: intN uses full 257‑bit precision, so any integer value fits into it. Overflow happens only at serialization. ​bool Type bool is backed by TVM INT with value -1 or 0 at runtime. The unsafe cast someBool as int is valid and produces -1 or 0. ​address and any_address Addresses are backed by TVM SLICE values containing raw binary data. A nullable address? is either TVM NULL or SLICE. The unsafe cast someAddr as slice and back is valid. ​cell Type cell is backed by TVM CELL. The unsafe cast someCell as Cell<T> is valid. ​Cell<T> Type Cell<T> is also backed by TVM CELL. The type parameter T is purely compile‑time metadata. ​slice Type slice is backed by TVM SLICE. ​bitsN Type bitsN is backed by TVM SLICE. The unsafe cast someSlice as bitsN and back is valid. ​RemainingBitsAndRefs Type “remaining” is backed by TVM SLICE. It’s actually an alias for slice, handled specially at deserialization. ​builder Type builder is backed by TVM BUILDER. Note that already written bits cannot be read. The only possible way to access builder’s data is converting it to a slice. ​Structures Fields of a structure are placed sequentially on the stack. For example, Point occupies two stack slots, and Line — four: CopyAsk AIstruct Point { x: int y: int } struct Line { start: Point end: Point } When constructing a Line value, four integers are placed onto the stack: CopyAsk AIfun generateLine() { val l: Line = { start: { x: 10, y: 20 }, end: { x: 30, y: 40 }, }; // on a stack: 10 20 30 40 return l; } Therefore, single‑field structures have no overhead compared to plain values. ​Enums Every enum is backed by TVM INT. Tolk supports integer enums only (not addresses, for example). ​Nullable types T? Atomics like int? / address? / cell? / etc. occupy a single stack slot: it holds either TVM NULL or a value. CopyAsk AIfun demo(maybeAddr: address?) { // maybeAddr is one stack slot: `NULL` or `SLICE` } A nullable structure with one primitive non-nullable field can be also optimized this way: CopyAsk AIstruct MyId { value: int32 } fun demo(maybeId: MyId?) { // maybeId is one stack slot: `NULL` or `INT` } Nullable values of multi‑slot types (e.g., Point or a tensor (bool, cell)) occupy N+1 slots: the last is used for typeid. CopyAsk AIstruct Point { x: int y: int } fun demo(maybeP: Point?) { // maybeP is 3 stack slots: // when null: \"NULL, NULL, INT (0)\" // when not: \"INT (x), INT (y), INT (4567)\" } For every nullable type, the compiler assigns a unique typeid (e.g., 4567 for Point). That typeid is stored in an extra slot. Typeid for null is 0. Expressions such as p == null or p is Point check that typeid slot. A tricky example. A struct below, being nullable, requires an extra stack slot: CopyAsk AIstruct Tricky { opt: int? } fun demo(v: Tricky?) { // v occupies 2 stack slots, // because either `v == null` or `v.opt == null`: // when v == null: \"NULL, INT (0)\" // when v != null: \"INT/NULL, INT (2345)\" } ​Union types T1 | T2 | ... Unions are represented as “tagged unions”: each alternative type is assigned a unique typeid (e.g., 1234 for int) the union occupies N+1 stack slots, where N is the maximum size of T_i (N+1)-th slot contains typeid of the current value Thus, match is implemented as a comparison of the (N+1)-th slot, and passing/assigning a value is a bit of stack juggling. CopyAsk AIfun complex(v: int | slice | (int, int)) { // `v` is 3 stack slots: // - int: (NULL, 100, 1234) // - slice: (NULL, CS{...}, 2345) // - (int, int): (200, 300, 3456) } fun demo(someOf: int | slice) { // `someOf` is 2 stack slots: value and type-id // - int: (100, 1234) // - slice: (CS{...}, 2345) match (someOf) { int => { // IF TOP == 1234 // slot1 is TVM `INT`, can be used in arithmetics } slice => { // ELSE // slot1 is TVM `SLICE`, can be used to loadInt() } } complex(v); // passes (NULL, v.slot1, v.typeid) complex(5); // passes (NULL, 5, 1234) } An extra stack slot for typeid is called “tagged union”. Union types in Tolk, enum in Rust, std::variant in C++ — they all are tagged unions. T | null is called “nullable” and optimized for atomics: int? use a single slot. Non-atomics are handled generally, with typeid=0. ​Tensors (T1, T2, ...) Tensor components are placed sequentially, identical to struct fields. For example, (coins, Point, int?) occupies 4 slots: “INT (coins), INT (p.x), INT (p.y), INT/NULL”. CopyAsk AItype MyTensor = (coins, Point, int?) fun demo(t: MyTensor) { // t is 4 stack slots val p = t.1; // p is 2 stack slots } ​tuple Type tuple is backed by TVM TUPLE — one stack slot regardless of the number of elements in it (up to 255). ​Typed tuple [T1, T2, ...] A typed tuple is also TVM TUPLE. Its shape is known at compile-time, but at runtime it’s the same tuple. CopyAsk AIfun demo(t: [int, [int, int]]) { // t is one stack slot (TVM `TUPLE`) // t.0 is TVM `INT` // t.1 is TVM `TUPLE` return t.1.0; // asm \"1 INDEX\" + \"0 INDEX\" } ​map<K, V> Every map is one stack slot: either TVM NULL or CELL. Non‑empty maps (cells) have a non‑trivial bit‑level layout (follow hashmaps in TL/B). ​Callables (...ArgsT) -> ResultT A callable and continuation is backed by TVM CONT. ​void and never Both represent the absence of a value and occupy zero stack slots. For example, a void function does not place any value onto the stack. ​See also Overall: serialization to binary data Type system overview Was this page helpful?YesNoSuggest editsRaise issuePreviousOverall: serializationNext⌘IgithubxtelegramPowered by MintlifyOn this pageint, intN, coinsbooladdress and any_addresscellCell<T>slicebitsNRemainingBitsAndRefsbuilderStructuresEnumsNullable types T?Union types T1 | T2 | ...Tensors (T1, T2, ...)tupleTyped tuple [T1, T2, ...]map<K, V>Callables (...ArgsT) -> ResultTvoid and neverSee also",
    "category": "infrastructure",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:36:42.293Z"
  },
  {
    "id": "docs-ton-org--languages-func-asm-functions",
    "title": "Assembler functions",
    "url": "https://docs.ton.org/languages/func/asm-functions",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCOverviewCookbookLanguageCommentsTypesLiteralsOperatorsExpressionsStatementsProgram declarationsOverviewFunctionsReserved functionsAssembler functionsGlobal variablesCompiler directivesReserved words and built-insDictionariesLibrariesChangelogKnown issuesTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationProgram declarationsAssembler functionsLanguagesFunCLanguageProgram declarationsAssembler functionsCopy pageCopy page​Assembler function definition In FunC, functions can be defined directly using assembler code. This is done by declaring the function body using the asm keyword, followed by one or more assembler commands written inside double quotes \", and finalizing with the symbol ;. For example, the following function increments an integer and then negates it: CopyAsk AIint inc_then_negate(int x) asm \"INC\" \"NEGATE\"; Calls to inc_then_negate are translated to 2 assembler commands INC and NEGATE. Alternatively, the function can be written as: CopyAsk AIint inc_then_negate'(int x) asm \"INC NEGATE\"; Here, INC NEGATE is treated as a single assembler command by FunC, but the Fift assembler correctly interprets it as two separate commands. The list of assembler commands can be found here: TVM instructions. ​Multi-line asms Multi-line assembler commands, including Fift code snippets, can be defined using triple-quoted strings \"\"\". For instance: CopyAsk AIslice hello_world() asm \"\"\" \"Hello\" \" \" \"World\" $+ $+ $>s PUSHSLICE \"\"\"; ​Stack calling conventions The syntax for arguments and returns is the same as for standard functions, but there is one caveat - argument values are pushed onto the stack before the function body is executed, and the return type is what is captured from the stack afterward. ​Arguments When calling an asm function, the first argument is pushed onto the stack first, the second one second, and so on, so that the first argument is at the bottom of the stack and the last one at the top. CopyAsk AIbuilder storeCoins(builder b, int value) asm \"STVARUINT16\"; ;; | | ;; | Pushed last, sits on top of the stack ;; | ;; Pushed first, sits at the bottom of the stack ;; The instruction \"STVARUINT16\" stores ;; integer \"value\" into builder \"b\", ;; by taking the builder from the bottom of the stack ;; and the integer from the top of the stack, ;; producing a new builder at the top of the stack. ​Returns An assembler function’s return type attempts to grab relevant values from the resulting stack after the function execution and any result rearrangements. Specifying an atomic type, such as an int, cell, or builder, will make the assembler function capture the top value from the stack. For example, in the following function: CopyAsk AIbuilder storeCoins(builder b, int value) asm \"STVARUINT16\"; the instruction STVARUINT16 produces a final builder at the top of the stack, which is returned by the storeCoins function. Specifying a tensor type as a return type, such as (int, int), will cause the assembler function to take as many elements from the stack as the number of components in the tensor type. If the tensor type has nested tensor types, like ((int, int), int), it is interpreted as if it was the flattened tensor type (int, int, int). For example, this function duplicates its input, so that if the input is 5, it returns the tensor (5, 5): CopyAsk AI(int, int) duplicate(int a) asm \"DUP\"; ;; ;; DUP reads the value at the top of the stack ;; and pushes a copy. ;; ;; Since the return type is (int, int), ;; the function takes the first two values in the stack ;; and returns them. ​Stack registers The so-called stack registers are a way of referring to the values at the top of the stack. In total, there are 256 stack registers, i.e., values held on the stack at any given time. Register s0 is the value at the top of the stack, register s1 is the value immediately after it, and so on, until we reach the bottom of the stack, represented by s255, i.e., the 256th stack register. When a value x is pushed onto the stack, it becomes the new s0. At the same time, the old s0 becomes the new s1, the old s1 becomes the new s2, and so on. CopyAsk AIint takeSecond(int a, int b) asm \"SWAP\" \"DROP\"; ;; ↑ ↑ ;; | Pushed last, sits on top of the stack ;; Pushed first, sits second from the top of the stack ;; SWAP interchanges s0 (top of the stack) with s1 (second-to-top) ;; ;; Before │ After ;; ───────┼─────── ;; s0 = b │ s0 = a ;; s1 = a │ s1 = b ;; Then, DROP pops the value from the top of the stack and throws it away ;; ;; Before │ After ;; ───────┼─────── ;; s0 = a │ s0 = b ;; s1 = b │ s1 is now either some value deeper or just blank ;; At the end, we have only one value on the stack, which is b ;; Thus, it is captured by the return type `int`: int showcase() { return takeSecond(5, 10); ;; 10, i.e., b } ​Rearranging stack entries When manually rearranging arguments, they are evaluated in the new order. To overwrite this behavior see #pragma compute-asm-ltr. Sometimes, the order in which function arguments are passed may not match the expected order of an assembler command. Similarly, the returned values may need to be arranged differently. While this can be done manually using stack manipulation primitives, FunC has special syntax to handle this. Considering arrangements, the evaluation flow of the assembly function can be thought of in these 5 steps: The function takes arguments in the order specified by the parameters. If an argument arrangement is present, arguments are reordered before being pushed onto the stack. The function body is executed. If a result arrangement is present, resulting values are reordered on the stack. The resulting values are captured (partially or fully) by the return type of the function. The argument arrangement has the syntax asm(arg2 arg1), where arg1 and arg2 are some arguments of the function arranged in the order we want to push them onto the stack: arg1 will be pushed first and placed at the bottom of the stack, while arg2 will be pushed last and placed at the top of the stack. Arrangements are not limited to two arguments and operate on all parameters of the function: CopyAsk AI;; Changing the order of arguments to match the STDICT signature: ;; `c` will be pushed first and placed at the bottom of the stack, ;; while `b` will be pushed last and placed at the top of the stack builder asmStoreDict(builder b, cell c) asm(c b) \"STDICT\"; The return arrangement has the syntax asm(-> 1 0), where 1 and 0 represent a left-to-right reordering of stack registers s1 and s0, respectively. The contents of s1 will be at the top of the stack, followed by the contents of s0. Arrangements are not limited to two return values and operate on captured values: CopyAsk AI;; Changing the order of return values of LDVARUINT16 instruction, ;; since originally it would place the modified Slice on top of the stack (slice, int) asmLoadCoins(slice s) asm(-> 1 0) \"LDVARUINT16\"; ;; ↑ ↑ ;; | Value of the stack register 0, ;; | which is the topmost value on the stack ;; Value of the stack register 1, ;; which is the second-to-top value on the stack Both argument and return arrangement can be combined together and written as follows: asm(arg2 arg1 -> 1 0). CopyAsk AI;; Changing the order of return values compared to the stack ;; and switching the order of arguments as well (slice, int) asmLoadInt(int len, slice s) asm(s len -> 1 0) \"LDIX\"; ;; ↑ ↑ ;; | Value of the stack register 0, ;; | which is the topmost value on the stack ;; Value of the stack register 1, ;; which is the second-to-top value on the stack Was this page helpful?YesNoSuggest editsRaise issuePreviousGlobal variablesNext⌘IgithubxtelegramPowered by MintlifyOn this pageAssembler function definitionMulti-line asmsStack calling conventionsArgumentsReturnsStack registersRearranging stack entries",
    "category": "languages",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:36:44.308Z"
  },
  {
    "id": "docs-ton-org--languages-func-global-variables",
    "title": "Global variables",
    "url": "https://docs.ton.org/languages/func/global-variables",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCOverviewCookbookLanguageCommentsTypesLiteralsOperatorsExpressionsStatementsProgram declarationsOverviewFunctionsReserved functionsAssembler functionsGlobal variablesCompiler directivesReserved words and built-insDictionariesLibrariesChangelogKnown issuesTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationProgram declarationsGlobal variablesLanguagesFunCLanguageProgram declarationsGlobal variablesCopy pageCopy page​Definition A global variable is a variable that can be read and assigned at any function in the entire program, including functions declared in other .fc files, as long as those .fc files are imported after the global variable declaration. It is possible to use global variables imported from other .fc files. Global variables are useful for remembering values across functions, without the need to pass those values as arguments to every single function in the program. Under the hood, global variables in FunC are stored inside the tuple of the c7 TVM control register, with a maximum limit of 31 variables. ​Declaration Global variables are declared using the global keyword, followed by the variable’s type and name. For example: CopyAsk AIglobal ((int, int) -> int) op; This defines global variable op of type (int, int) -> int. In other words, op can store a function that receives two arguments and returns an integer. Here is an example that uses global variable op: CopyAsk AIglobal ((int, int) -> int) op; int check_commutative(int a, int b) { return op(a, b) == op(b, a); } int add(int a, int b) { return a + b; } int main() { op = add; return check_commutative(2, 3); } The example defines two auxiliary functions: check_commutative and add, in addition to the program entry point main. Function check_commutative checks if the operator stored in the global variable op satisfies the commutative property for the specified inputs a and b. Function add, adds its two inputs. Function main assigns the addition function add to the global variable op. Then, it verifies the commutativity of addition for the specific values: 2, 3. In FunC, you can omit the type of global variables. In this case, the compiler determines the type based on how the variable is used. Equivalently, instead of declaring the type, you can use the var keyword as a replacement for the type. For example, in the previous program you can declare the variable op as: CopyAsk AIglobal op; or as: CopyAsk AIglobal var op; FunC allows declaring global variable multiple times, as long as all the declarations have the same type. The declarations can even happen in different .fc files. For example, the following does not compile, because the second declaration changes the type of A from int to cell: CopyAsk AIglobal int A; int foo() { return 0; } global cell A; ;; DOES NOT COMPILE, cell should be int Global variables do not allow initialization during declaration, contrary to local variables, which must be initialized during declaration. For example,CopyAsk AIglobal int a = 5; ;; DOES NOT COMPILE Reading a global variable that has not been assigned, will result in the null value. Global variables do not survive after the TVM finishes execution. They are reset every time the TVM initializes. Use permanent storage to remember values between TVM executions by using the set_data function.For example, in the following code, you should not expect that global variable prev_value will remember the message value msg_value of the previously received internal message. Because every time the contract receives an internal message, the TVM initializes.CopyAsk AIglobal int prev_value; () recv_internal(int msg_value, cell in_msg_cell, slice in_msg) { ;; ... ;; ... if (prev_value > 123456) { ;; prev_value will NOT have the value ;; do something ;; of the previously received message } prev_value = msg_value; ;; Use permanent storage instead } ​Multiple declarations FunC allows users to declare multiple global variables using a single global keyword. The following example: CopyAsk AIglobal int A; global cell B; global C; is equivalent to this: CopyAsk AIglobal int A, cell B, C; ​Restrictions on declarations A local variable cannot have the same name of a previously declared global variable but only if their types differ. The following example does not compile, because the local variable C of type int has the same name as the global variable C of type cell, and int and cell are different types. CopyAsk AIglobal cell C; int main() { int C = 3; ;; DOES NOT COMPILE return C; } However, if the local variable and the global variable have the same type and the same name, the declaration of the local variable actually means assignment to the global variable. For example, CopyAsk AIglobal int C; int main() { int C = 3; return C; } In this case, int C = 3; is not declaring a new local variable, but instead assigning value 3 to the global variable C.Was this page helpful?YesNoSuggest editsRaise issuePreviousCompiler directivesNext⌘IgithubxtelegramPowered by MintlifyOn this pageDefinitionDeclarationMultiple declarationsRestrictions on declarations",
    "category": "languages",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:36:45.720Z"
  },
  {
    "id": "docs-ton-org--languages-func-special-functions",
    "title": "Reserved functions",
    "url": "https://docs.ton.org/languages/func/special-functions",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCOverviewCookbookLanguageCommentsTypesLiteralsOperatorsExpressionsStatementsProgram declarationsOverviewFunctionsReserved functionsAssembler functionsGlobal variablesCompiler directivesReserved words and built-insDictionariesLibrariesChangelogKnown issuesTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationProgram declarationsReserved functionsLanguagesFunCLanguageProgram declarationsReserved functionsCopy pageCopy pageFunC, or more specifically, the Fift assembler, reserves several function names with predefined IDs: recv_internal and main have id = 0 recv_external has id = -1 run_ticktock has id = -2 split_prepare has id = -3 split_install has id = -4 Every program must include a function with id = 0, meaning it must define either recv_internal or main, but not both. ​Receive internal The recv_internal function is invoked when a smart contract receives an inbound internal message. Any of the following recv_internal declarations can be used: CopyAsk AI() recv_internal(int balance, int msg_value, cell in_msg_cell, slice in_msg_body) () recv_internal(int msg_value, cell in_msg_cell, slice in_msg_body) () recv_internal(cell in_msg_cell, slice in_msg_body) () recv_internal(slice in_msg_body) () recv_internal() There, balance is the smart contract balance in nanotons after adding the amount msg_value in the inbound message. It is an integer. msg_value is the amount in nanotons included in the inbound message. It is an integer. in_msg_cell is the inbound message, given as a cell. in_msg_body is the inbound message body, equal to the body field in in_msg_cell. The body is given as a cell slice. ​Main main is an alias for recv_internal. If the intention of the code is to handle inbound internal messages, it is preferable to use recv_internal over main, since recv_internal states more clearly the intention of the code. ​Receive external The recv_external function handles inbound external messages. It allows declarations similar to those for recv_internal: CopyAsk AI() recv_external(int balance, int msg_value, cell in_msg_cell, slice in_msg_body) () recv_external(int msg_value, cell in_msg_cell, slice in_msg_body) () recv_external(cell in_msg_cell, slice in_msg_body) () recv_external(slice in_msg_body) () recv_external() The only difference is that msg_value is always 0, since external messages cannot carry coins, as they are created outside the blockchain. The behavior of the stack is identical to the behavior described for recv_internal. ​Run ticktock The run_ticktock triggers at inbound tick and tock messages. It allows the following possible declarations: CopyAsk AI() run_ticktock(int balance, int address, int is_tock) () run_ticktock(int address, int is_tock) () run_ticktock(int is_tock) () run_ticktock() There: balance is the smart contract balance in nanotons. It is an integer. address is the address of the current account inside the masterchain. It is an unsigned 256-bit integer. is_tock a flag that indicates if it is a tock message (-1) or a tick message (0). The behavior of the stack is identical to the behavior described for recv_internal. ​Split prepare The split_prepare triggers for inbound split prepare messages. Even though the split_prepare name is currently reserved, split prepare messages are currently not in use. ​Split install The split_install triggers for inbound split install messages. Even though the split_install name is currently reserved, split install messages are currently unavailable.Was this page helpful?YesNoSuggest editsRaise issuePreviousAssembler functionsNext⌘IgithubxtelegramPowered by MintlifyOn this pageReceive internalMainReceive externalRun ticktockSplit prepareSplit install",
    "category": "languages",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:36:47.455Z"
  },
  {
    "id": "docs-ton-org--languages-func-compiler-directives",
    "title": "FunC compiler directives",
    "url": "https://docs.ton.org/languages/func/compiler-directives",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCOverviewCookbookLanguageCommentsTypesLiteralsOperatorsExpressionsStatementsProgram declarationsOverviewFunctionsReserved functionsAssembler functionsGlobal variablesCompiler directivesReserved words and built-insDictionariesLibrariesChangelogKnown issuesTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationProgram declarationsFunC compiler directivesLanguagesFunCLanguageProgram declarationsFunC compiler directivesCopy pageCopy pageCompiler directives are keywords that begin with #, instructing the compiler to perform specific actions, enforce checks, or modify parameters. These directives can only be used at the outermost level of a source file and cannot be placed inside function definitions. ​#include The #include directive enables the inclusion of another FunC source file parsed in place of the directive. Syntax: CopyAsk AI#include \"<path_to_filename>\"; where <path_to_filename> is the path to the FunC source file to include. Files are automatically checked for multiple inclusions. By default, the compiler will ignore redundant inclusions if the same file is included more than once. This also applies to inclusions along a path of nested inclusions. A warning will be issued if the verbosity level is 2 or higher. For example, suppose that main.fc contains the main function. Suppose also that main.fc includes a file A.fc, which in turn includes a file B.fc, which in turn includes main.fc. When main.fc is compiled, the inclusion of main.fc in B.fc will be ignored. If an error occurs while parsing an included file, the compiler displays an inclusion stack, showing the locations of each file in the inclusion chain. ​#pragma The #pragma directive provides additional information to the compiler beyond what the language conveys. ​#pragma version The #pragma version directive enforces using a specific FunC compiler version when compiling the file. Syntax: CopyAsk AI#pragma version <op><sem_version>; where <op> is an optional version operator that allows to specify a constraint, and <sem_version> is specified in semantic versioning (semver) format: a.b.c, where: a is the major version b is the minor version c is the patch version Example: CopyAsk AI#pragma version 2.3.4; #pragma version >2.3.4; The first example does not use an operator and it means that the compiler must have exactly version 2.3.4. The second uses the greater than operator >, and it means that the compiler must have a version greater than 2.3.4 (see precedence and operators below for details). ​Equality and precedence Two versions are equal if their respective major, minor, and patch numbers are equal. Two versions are not equal if at least one of those numbers differ. Example: 1.2.3 is equal to 1.2.3 3.4.5 is not equal to 3.1.5 Precedence of two versions a.b.c and d.e.f is determined the following way: If a is smaller than d, then a.b.c precedes d.e.f If a is equal to d, and b is smaller than e, then a.b.c precedes d.e.f If a is equal to d, and b is equal to e, and c is smaller than f, then a.b.c precedes d.e.f If a.b.c precedes d.e.f, then it is said that a.b.c is smaller than d.e.f, or equivalently, that d.e.f is greater than a.b.c. Example: 1.0.0 precedes 2.0.0. Equivalently: 1.0.0 is smaller than 2.0.0 or 2.0.0 is greater than 1.0.0. 2.0.0 precedes 2.1.0. Equivalently: 2.0.0 is smaller than 2.1.0 or 2.1.0 is greater than 2.0.0. 2.1.0 precedes 2.1.1. Equivalently: 2.1.0 is smaller than 2.1.1 or 2.1.1 is greater than 2.1.0. ​Operators Developers can specify version constraints using the following operators: a.b.c or =a.b.c - Requires exactly version a.b.c of the compiler >a.b.c - Requires the compiler version to be greater than a.b.c. >=a.b.c - Requires the compiler version to be greater than or equal to a.b.c <a.b.c - Requires the compiler version to be less than a.b.c <=a.b.c - Requires the compiler version to be less than or equal to a.b.c ^a.b.c - Requires the major part of the compiler version to be equal to the a part, the minor to be equal to the b part, and the patch to be no lower than the c part ^a.b - Requires the major compiler version to be equal to the a part and the minor to be no lower than the b part ^a - Requires the major compiler version to be no lower than the a part For the comparison operators =, >, >=, <, <=, omitted parts default to zero. For example: >a.b is equivalent to >a.b.0 <=a is equivalent to <=a.0.0 For the operator ^, omitted parts do not default to zero. For example: ^a.b is not equivalent to ^a.b.0 ^a is not equivalent to ^a.0.0 Here are some examples of constraints: ^5.1.2 matches compiler version 5.1.3 because patch 3 is no lower than patch 2. ^5.1.2 does not match compiler version 5.2.3 because minor 2 does not equal minor 1. ^5.1.2 does not match compiler version 5.1.1 because patch 1 is lower than patch 2. ^5.1 matches compiler version 5.1.3 because minor 1 is no lower than minor 1. ^5.1 matches compiler version 5.2.3 because minor 2 is no lower than minor 1. ^5.1 matches compiler version 5.1.0 because minor 1 is no lower than minor 1. ^5.1 does not match compiler version 5.0.2 because minor 0 is lower than minor 1. ^5 matches compiler version 5.1.0 because major 5 is no lower than major 5. ^5 does not match compiler version 4.1.0 because major 4 is lower than major 5. >5.1.2 matches compiler version 5.1.3 because patch 3 is bigger than patch 2. >5.1.2 matches compiler version 5.2.0 because minor 2 is bigger than minor 1. >5.1.2 matches compiler version 6.0.0 because major 6 is bigger than major 5. =5.1.2 does not match compiler version 5.2.2 because minor 2 is not equal to minor 1. The #pragma version directive can be used multiple times, and the compiler must satisfy all specified constraints. ​#pragma not-version The #pragma not-version is similar to #pragma version, but it fails if the specified condition is met. Syntax: CopyAsk AI#pragma not-version <op><sem_version>; where <op> is an optional version operator that allows to specify a constraint, and <sem_version> is identical as in #pragma version. This directive is useful for blocking specific compiler versions known to have issues. Here are some examples: CopyAsk AI#pragma not-version >2.1.3; #pragma not-version ^3.4; #pragma not-version 1.2.3; In the first example, not-version >2.1.3 matches any compiler version that is not bigger than 2.1.3, like 2.1.2, 2.0.5 and even 2.1.3 itself. In the second example, not-version ^3.4 matches any compiler version that does not match ^3.4, like 3.3.1, 4.4.0, and 3.3.9 In the third example, not-version 1.2.3 matches any compiler version different from 1.2.3. ​#pragma allow-post-modification Introduced in FunC v0.4.1 In Func, using a variable before it is modified within the same expression is prohibited by default. For example, the following code will not compile, because ds is used before it is modified in ds~load_uint(8). See modifying notation for more details on using symbol ~. CopyAsk AI(x, y) = (ds, ds~load_uint(8)); However, this version is valid, since ds is used after it is modified: CopyAsk AI(x, y) = (ds~load_uint(8), ds) To override this restriction, use #pragma allow-post-modification. This allows variables to be modified after usage in mass assignments and function calls while sub-expressions are still computed left to right. In the following example, x will contain the initial value of ds, while y the modified value of ds: CopyAsk AI#pragma allow-post-modification (x, y) = (ds, ds~load_bits(8)); #pragma allow-post-modification works only for code after the pragma. ​#pragma compute-asm-ltr Introduced in FunC v0.4.1 asm declarations can override the order of argument evaluation. For example, in the following expression: CopyAsk AIidict_set_ref(ds~load_dict(), ds~load_uint(8), ds~load_uint(256), ds~load_ref()) The evaluation order of the call arguments is: load_ref() load_uint(256) load_dict() load_uint(8) This happens due to the corresponding asm declaration: CopyAsk AIcell idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETREF\"; Here, the asm(value index dict key_len) notation dictates a rearrangement of arguments. To ensure strict left-to-right computation order of the arguments, use #pragma compute-asm-ltr. With this directive enabled, the same function call: CopyAsk AI#pragma compute-asm-ltr ;; ... idict_set_ref(ds~load_dict(), ds~load_uint(8), ds~load_uint(256), ds~load_ref()); will evaluate its arguments in the following order: load_dict() load_uint(8) load_uint(256) load_ref() and only after the evaluation of all these arguments, the asm rearrangement will occur. #pragma compute-asm-ltr works only for code after the pragma.Was this page helpful?YesNoSuggest editsRaise issuePreviousReserved words and built-insNext⌘IgithubxtelegramPowered by MintlifyOn this page#include#pragma#pragma versionEquality and precedenceOperators#pragma not-version#pragma",
    "category": "languages",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:36:51.190Z"
  },
  {
    "id": "docs-ton-org--languages-func-declarations-overview",
    "title": "Program declarations",
    "url": "https://docs.ton.org/languages/func/declarations-overview",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCOverviewCookbookLanguageCommentsTypesLiteralsOperatorsExpressionsStatementsProgram declarationsOverviewFunctionsReserved functionsAssembler functionsGlobal variablesCompiler directivesReserved words and built-insDictionariesLibrariesChangelogKnown issuesTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationProgram declarationsProgram declarationsLanguagesFunCLanguageProgram declarationsProgram declarationsCopy pageCopy pageA FunC program is a list of: Function declarations and definitions Global variable declarations Compiler directives Was this page helpful?YesNoSuggest editsRaise issuePreviousFunctionsNext⌘IgithubxtelegramPowered by Mintlify",
    "category": "languages",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:36:52.544Z"
  },
  {
    "id": "docs-ton-org--standard-wallets-preprocessed-v2-specification",
    "title": "Preprocessed Wallet V2 — specification",
    "url": "https://docs.ton.org/standard/wallets/preprocessed-v2/specification",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsHow they workMnemonicsComparisonPerformance benchmarkHow to interactHistoryV4V5Highload WalletsLockup walletPreprocessed Wallet V2SpecificationHow to interact with Preprocessed Wallet V2Restricted walletTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationPreprocessed Wallet V2Preprocessed Wallet V2 — specificationStandard contractsWalletsPreprocessed Wallet V2Preprocessed Wallet V2 — specificationCopy pageCopy pageCommunity implementationThis wallet is a community-created implementation. Use at your own risk. Always test thoroughly on testnet before using with real funds. This page provides a complete technical specification for Preprocessed Wallet V2, covering storage structure, message formats, replay protection, limitations, and implementation details. ​Objective Understand the internal architecture, data structures, and operational mechanics of Preprocessed Wallet V2. This reference page explains how the wallet processes batch transactions efficiently with minimal gas consumption. For practical usage, see How-to guides. ​What is Preprocessed Wallet V2? Preprocessed Wallet V2 is a wallet smart contract designed for efficiency with minimal code complexity. It provides low transaction costs while maintaining the ability to send up to 255 actions in a single transaction. Key difference from standard wallets: Preprocessed V2 enables batch transaction processing with up to 255 actions per message, making it suitable for services that need to send multiple payments efficiently. Optimization focus: Preprocessed V2 prioritizes gas efficiency and simplicity, making it suitable for applications that need batch processing with minimal overhead. Gas consumption: The wallet consumes 1537 gas units per transaction. ​TL-B schema TL-B (Type Language - Binary) is a domain-specific language designed to describe data structures in TON. The schemas below define the binary layout of the contract’s storage and external messages. ​Storage structure CopyAsk AIstorage$_ pub_key:bits256 seq_no:uint16 = Storage; ​External message structure CopyAsk AI_ {n:#} valid_until:uint64 seq_no:uint16 actions:^(OutList n) { n <= 255 } = MsgInner n; msg_body$_ {n:#} sign:bits512 ^(MsgInner n) = ExtInMsgBody n; The canonical TL-B schemas are maintained in the ton-preprocessed-wallet-v2 repository. Below, each field is explained in detail. ​Storage structure The Preprocessed Wallet V2 contract stores two persistent fields: ​pub_key (256 bits) Purpose: An Ed25519 public key is used to verify signatures on incoming external messages. How it works: When the wallet receives an external message, it verifies that the 512-bit signature was created by the holder of the private key corresponding to this public key. The public key is not the wallet address. The address is derived from the contract’s StateInit. ​seq_no (16 bits) Purpose: Prevents replay attacks by ensuring each message has a unique sequence number. How it works: Each external message must contain the correct seq_no that matches the current value stored in the contract. After successful processing, the sequence number is incremented (with modulo 2^16 to prevent overflow). Range: 0 to 65535 (wraps from 65535 to 0) Size optimization: The sequence number is limited to 16 bits (instead of 32 bits used in other wallets) to minimize storage size and message size, reducing gas costs. Protection mechanism: Even if an attacker intercepts an old message, they cannot replay it because the sequence number will no longer match the current value in storage. Wrap‑around note: See Replay protection mechanism for guidance on wrap‑around and valid_until windows. ​External message structure External messages sent to Preprocessed Wallet V2 have a specific layout. ​Message layout CopyAsk AIsign:bits512 ^[ valid_until:uint64 seq_no:uint16 actions:^(OutList n) ] Key point: The signature is in the root cell (512 bits); all other parameters are in a reference cell (MsgInner). Gas optimizationThis structure saves gas units during signature verification. If the signature were in the same cell as the message body, the contract would need to use slice_hash() (which rebuilds the cell internally, costing extra gas) instead of simply taking cell_hash() of the reference. ​sign (512 bits) Type: Ed25519 signature (512 bits). What is signed: The hash of the reference cell (MsgInner) containing valid_until, seq_no, and actions. Validation: The contract verifies the signature using: CopyAsk AIcheck_signature(hash(ref_cell), signature, public_key) On failure: Exit code 35. Link: Ed25519 signature scheme ​valid_until (64 bits) Purpose: Unix timestamp (seconds) when the external message expires. Validation: The contract performs a single check: CopyAsk AInow() > valid_until // Message expired On failure: Exit code 34. Why it matters: Prevents replay of expired messages. If now() > valid_until, the message is considered expired and rejected. Recommendation: Set valid_until to 1 minute (60 seconds) from message creation time. ​seq_no (16 bits) Purpose: Expected sequence number for this message. Validation: Must match the current seq_no stored in contract storage. On mismatch: Exit code 33. ​actions (reference cell) Structure: A serialized OutList containing up to 255 actions to execute. Validation: No validation. Supported actions: All standard TVM actions are supported without restrictions: action_send_msg — Send messages action_set_code — Update contract code action_reserve_currency — Reserve currency action_change_library — Change library Critical security warningPreprocessed Wallet V2 does not protect against action_set_code actions. If you accidentally include a set_code action in your message, the wallet contract code will be changed, potentially making your funds inaccessible. Always verify your action lists before sending. Maximum actions: 255 (maximum number of out actions in TON) ​Replay protection mechanism Preprocessed Wallet V2 uses sequence numbers and time-based expiration to prevent replay attacks. ​Sequence number protection How it works: Each message must contain the correct seq_no After successful processing, seq_no is incremented Old messages with incorrect sequence numbers are rejected Overflow protection: Uses modulo 2^16 operation: (seq_no + 1) % 65536 Wraps from 65535 to 0 ​Time-based expiration How it works: Each message includes valid_until timestamp Messages are rejected if now() > valid_until Prevents replay of expired messages Recommended expiration: 1 minute (60 seconds) for most use cases Shorter for high-frequency operations Longer for batch operations with network delays ​Wrap‑around and validity window When seq_no wraps (65535 → 0), previously sent messages that used the same numeric seq_no remain non‑applicable if their valid_until has already expired. Safety relies on the dual check: current seq_no equality and unexpired valid_until. Do not set valid_until excessively far in the future. A very long validity window increases the chance that, after wrap‑around, an old message with the same seq_no is still valid. Keep the window short (for example, ≤ 60 seconds) unless you have a specific operational reason. ​Signature verification How it works: All messages must be signed with the wallet’s private key Signature covers the entire message content (hash of MsgInner) Prevents unauthorized message creation ​Exit codes Exit codeNameDescriptionHow to fix0SuccessMessage processed successfully—33Incorrect sequence numberThe seq_no in the message does not match storageUse the correct seq_no from contract storage34Message expiredThe valid_until timestamp has passedEnsure valid_until >= now() when creating the message35Invalid signatureEd25519 signature verification failedCheck that the private key is correct and the message hash is computed properly ​Limitations and constraints ​Maximum actions per transaction Limitation: Each external message can trigger up to 255 actions. Why this limitation? 255 is the maximum number of out actions supported by TON blockchain. This is a fundamental limitation of the TVM execution environment. Impact: Suitable for batch operations with up to 255 actions per transaction. Sequential processingPreprocessed Wallet V2 uses sequential seq_no processing. This means you must wait for each transaction to complete before sending the next one. ​Implementation ​Source code Repository: - pyAndr3w/ton-preprocessed-wallet-v2 ​See also How to interact with Preprocessed Wallet V2 Was this page helpful?YesNoSuggest editsRaise issuePreviousHow to interact with Preprocessed Wallet V2Next⌘IgithubxtelegramPowered by MintlifyOn this pageObjectiveWhat is Preprocessed Wallet V2?TL-B schemaStorage structureExternal message structureStorage structurepub_key (256 bits)seq_no (16 bits)External message structureMessage layoutsign (512 bits)valid_until (64 bits)seq_no (16 bits)actions (reference cell)Replay",
    "category": "wallets",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "testnet",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:36:54.977Z"
  },
  {
    "id": "docs-ton-org--standard-wallets-preprocessed-v2-interact",
    "title": "How to interact with Preprocessed Wallet V2",
    "url": "https://docs.ton.org/standard/wallets/preprocessed-v2/interact",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsHow they workMnemonicsComparisonPerformance benchmarkHow to interactHistoryV4V5Highload WalletsLockup walletPreprocessed Wallet V2SpecificationHow to interact with Preprocessed Wallet V2Restricted walletTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationPreprocessed Wallet V2How to interact with Preprocessed Wallet V2Standard contractsWalletsPreprocessed Wallet V2How to interact with Preprocessed Wallet V2Copy pageCopy pageCommunity implementationThis wallet is a community-created implementation. Use at your own risk. Always test thoroughly on testnet before using with real funds. Funds at riskThis guide sends real TON. Test on testnet first. Double-check recipient addresses — blockchain transactions cannot be reversed. This guide shows how to deploy Preprocessed Wallet V2 and send transfers. For technical details, see Preprocessed Wallet V2 specification. ​Objective By the end of this guide, you will: Create a Preprocessed Wallet V2 instance from scratch Deploy the wallet on-chain Send single and batch transfers ​Prerequisites Node.js 18+ or TypeScript environment @ton/ton, @ton/core, @ton/crypto packages installed Preprocessed Wallet V2 wrapper and compiled contract code This guide uses TypeScript with the official wrapper. The same logic applies to other SDKs (Go/Python): generate or load a mnemonic, derive a keypair, and calculate the address. ​Step 1: Set up dependencies Install required packages: CopyAsk AInpm install @ton/ton @ton/core @ton/crypto Copy the wrapper and contract code from the official repository: CopyAsk AI# Clone the repository or download this file: # - typescript/wrappers/PreprocessedWalletV2.ts Why copy wrappers?The official @ton/ton SDK does not include Preprocessed Wallet V2 wrappers yet. Copy PreprocessedWalletV2.ts from the repository until SDK support is added. ​Step 2: Generate or load a mnemonic A mnemonic is your wallet’s master secret. It derives the private key used to sign all transactions. ​Generate a new mnemonic CopyAsk AIimport { mnemonicNew } from '@ton/crypto'; const mnemonic = await mnemonicNew(24); // Array of 24 words ​Load an existing mnemonic CopyAsk AIconst mnemonic = 'word1 word2 word3 ... word24'.split(' '); Protect your mnemonicAnyone with access to your mnemonic can control your wallet and all funds. Store it securely (password manager, hardware wallet, encrypted storage). Never commit it to version control. ​Step 3: Derive the keypair Convert the mnemonic to an Ed25519 keypair: CopyAsk AIimport { mnemonicToPrivateKey } from '@ton/crypto'; const keyPair = await mnemonicToPrivateKey(mnemonic); // keyPair.publicKey — used in contract state // keyPair.secretKey — used to sign external messages ​Step 4: Create the wallet instance Create a Preprocessed Wallet V2 contract instance: CopyAsk AIimport { TonClient } from '@ton/ton'; import { Cell } from '@ton/core'; import { Wallet, walletCode } from './wrappers/PreprocessedWalletV2'; // Compiled contract code (BoC) const CODE = walletCode; // Already included in the wrapper const client = new TonClient({ endpoint: 'https://testnet.toncenter.com/api/v2/jsonRPC', // This is TESTNET endpoint // apiKey: 'your-api-key' // Optional: get from @tonapibot or @tontestnetapibot }); const wallet = client.open( Wallet.createFromPublicKey(keyPair.publicKey) ); ​Step 5: Get the wallet address Calculate the wallet’s address: CopyAsk AI// Get non-bounceable address for funding const address = wallet.address.toString({ bounceable: false, testOnly: true }); console.log('Wallet address:', address); // Example (truncated): 0Q... (non-bounceable, testnet) This address is deterministic: it depends only on CODE and publicKey. The same parameters always produce the same address. Why non-bounceable?When funding a nonexist account, use the non-bounceable format to prevent funds from bouncing back if the account doesn’t exist yet. See Address formats for details. Account status: nonexist The calculated address exists only as a deterministic value. No account exists on the blockchain yet — no balance, no code, no data. ​Step 6: Fund the wallet Funds at riskYou will send TON to this address. Test on testnet first. Verify the wallet address carefully — blockchain transactions cannot be reversed. Required before deployment: Send TON to your wallet address (from Step 5) to prepare it for deployment. External messages (which deploy the wallet) require gas to execute. By funding the address, you transition the account from nonexist to uninit status and provide the balance needed for deployment. See Account statuses for details on how account states work. Send TON using a faucet (testnet) or from another wallet (mainnet). After funding, the account transitions to uninit status — it has a balance and can accept external messages, but no code or data yet. ​Step 7: Send messages Automatic deploymentThe wallet will auto-deploy on the first external message. No separate deployment step is needed. ​Send single transfers CopyAsk AIimport { Address, toNano } from '@ton/ton'; import { beginCell } from '@ton/core'; // Get current sequence number const currentSeqno = Number(await wallet.getSeqno()); // Send a single transfer await wallet.sendTransfers(keyPair, [{ to: Address.parse('EQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM9c'), // Zero address for testing value: toNano('0.01'), bounce: false }], currentSeqno); console.log('Transfer sent'); ​Send batch transfers CopyAsk AIimport { Address, toNano, comment } from '@ton/ton'; // Get current sequence number const currentSeqno = Number(await wallet.getSeqno()); // Create multiple transfers with similar structure const transfers = []; for (let i = 0; i < 5; i++) { transfers.push({ to: Address.parse('EQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM9c'), value: toNano('0.01'), body: comment(`#${i}`) }); } // Send batch transfers await wallet.sendTransfers(keyPair, transfers, currentSeqno); console.log('Batch transfers sent'); Maximum actionsreprocessed Wallet V2 supports up to 255 actions per transaction. This is the maximum number of out actions supported by TON blockchain.Was this page helpful?YesNoSuggest editsRaise issuePreviousRestricted walletNext⌘IgithubxtelegramPowered by MintlifyOn this pageObjectivePrerequisitesStep 1: Set up dependenciesStep 2: Generate or load a mnemonicGenerate a new mnemonicLoad an existing mnemonicStep 3: Derive the keypairStep 4: Create the wallet instanceStep 5: Get the wallet addressStep 6: Fund the walletStep 7: Send messagesSend single transfersSend batch transfers",
    "category": "wallets",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "testnet",
      "mainnet",
      "transaction",
      "deployment",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "python",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:36:56.654Z"
  },
  {
    "id": "docs-ton-org--languages-tl-b-complex-and-non-trivial-examples-mdx",
    "title": "Page not found",
    "url": "https://docs.ton.org/languages/tl-b/complex-and-non-trivial-examples.mdx",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationPage Not Found404Page not foundMaybe you were looking for one of these pages below?Complex and non-trivial examplesPreprocessed Wallet V2 — specificationHighload Wallet v2 — specification⌘I",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:36:58.634Z"
  },
  {
    "id": "docs-ton-org--v3-concepts-dive-into-ton-ton-ecosystem-blockchain-tech",
    "title": "Web3 services",
    "url": "https://docs.ton.org/v3/concepts/dive-into-ton/ton-ecosystem/blockchain-tech",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationBlockchain foundationsWeb3 servicesBlockchain foundationsWeb3 servicesCopy pageCopy pageAlthough many people refer to TON only as a blockchain, The Open Network is a combination of the following components: A flexible multi-blockchain platform with Turing-complete smart contracts (TON Blockchain) A peer-to-peer network used by Blockchain Nodes (TON Network) A distributed file storage technology (TON Storage) A network proxy/anonymizer layer (TON Proxy) A Kademlia-like distributed hash table (TON DHT) A service for assigning human-readable names to accounts, smart contracts, services, and network nodes (TON DNS) A platform for micro-payments (TON Payments) This article provides a general overview of TON Services, beyond the blockchain. ​TON Network TON Network is a peer-to-peer network used for accessing the TON Blockchain, sending transactions, and receiving updates. Also, it can support arbitrary distributed services, blockchain-related or not. The cornerstone in TON networking is the ADNL protocol, built on top of the TCP/UDP stack. The TON Distributed Hash Table (DHT) plays a crucial role in the networking component of the TON Project, as it is used to locate other nodes in the network. You can think of it as a big, persistent key-value data storage. The keys of the TON DHT are simply 256-bit integers. In most cases, they are computed as sha256 hashes of a TL-serialized objects. The values assigned to these 256-bit keys are essentially arbitrary byte strings of limited length. ​TON Storage TON Storage allows users to share and store files using The Open Network. Since storing files on-chain isn’t practical, TON Storage only stores Merkle proofs for file content on-chain. It uses TON DHT to find the nodes that have a copy of a required file (e.g., a snapshot of the state of a shardchain, or an old block). Then, one might essentially create a torrent for this file and use TON DHT as a “distributed torrent tracker” for this torrent. ​TON Proxy TON Proxy provides a protocol where nodes wishing to offer their services (with or without compensation) as tunnels for ADNL network traffic can register. Those needing them can then choose one of these nodes based on the price, latency, and bandwidth offered. Since ADNL traffic is encrypted, Proxy can’t access tunneled data, meaning that this protocol is secure. Running TON Proxy allows you to visit TON Sites (HTTP over ADNL). This can be combined with TON DNS and other TON Services, forming together what is called “Open Network”. ​TON DNS TON DNS is a service that translates human-readable domain names like test.ton or mysite.temp.ton into TON smart contract addresses, ADNL addresses used by services on the TON Network such as TON Sites, and more. The standard is implemented using smart contracts and config parameters. TON Domain names are well-established in the ecosystem - various wallet applications and explorers recognize them. TON Domains can be assigned to any ADNL address, meaning that it is possible to assign names to TON Storage files (bags). ​TON Payments TON Payments platform enables “instant payments” - a way to transfer monetary values without the need to commit all transactions to the blockchain. This protocol is built on top of TON Blockchain, using a system of smart contracts. The core idea for such a “lightning network” is point-to-point payment channels. Two parties create a shared “money pool” and then update the balance inside it. The overall overhead of such instant payments is so small that one can use them for micro-payments. For example, a TON file-storing service might charge the user for every 128 KiB of downloaded data, or a paid TON Proxy might require some tiny micro-payment for every 128 KiB of traffic relayed.Was this page helpful?YesNoSuggest editsRaise issuePreviousOverviewNext⌘IgithubxtelegramPowered by MintlifyOn this pageTON NetworkTON StorageTON ProxyTON DNSTON Payments",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:37:17.632Z"
  },
  {
    "id": "docs-ton-org--v3-concepts-security-measures",
    "title": "Security audits",
    "url": "https://docs.ton.org/v3/concepts/security-measures",
    "content": "Skip to main contentDeprecated! Please, visit the new documentation at docs.ton.org Deprecated, go to new docs!On this pageSecurity audits The security of TON Ecosystem is of utmost importance. Below is a summary of completed audits conducted by independent auditing firms for key components of TON Blockchain. TON Blockchain​ Various auditing firms audited core blockchain modules to ensure their robustness and security. Audit firms: Trail of Bits, SlowMist, CertiK Audit reports: Trail of Bits: TON Blockchain Audit Report SlowMist: TON Blockchain Audit Report CertiK: TON Blockchain Audit Report CertiK: TON Masterchain Contracts Formal Verification TON Blockchain library (tonlib)​ Zellic conducted a security assessment for TON. During this engagement, Zellic reviewed tonlib’s code for security vulnerabilities, design issues, and general weaknesses in security posture. Audit firm: Zellic Audit report: Zellic: Audit Report TVM and Fift​ Security audit of the TON Virtual Machine and the Fift programming language. Audit firm: Trail of Bits Audit report: Trail of Bits: TVM & Fift Audit Report TVM upgrade Jul 2023​ Security audit of the TVM upgrade (Jul 2023). Audit firm: Trail of Bits Audit report: Trail of Bits: TVM upgrade (Jul 2023) Audit Report Bug bounty program​ To further enhance the security of the TON ecosystem, we encourage security researchers and developers to participate in the TON security bug bounty program. Was this article useful?YesNoEdit this pageLast updated on Sep 5, 2025 by Anthony TsivarevTON BlockchainTON Blockchain library (tonlib)TVM and FiftTVM upgrade Jul 2023Bug bounty programUseGet a WalletGet ToncoinStakeAccept PaymentsApps & ServicesDomainsUSDT on TONCross-Chain BridgesLearnTON ConceptDecentralized NetworkRoadmapTonStatHistory of MiningToncoinValidatorsWhite PaperBrand AssetsSustainabilityFor BuildersTON Builders PortalGetting StartedDocumentationTelegram Mini AppsDev ChatsBug BountyFind a JobFind a TalentUse CasesGameFiMemecoins & TokensCommunity ToolsTON SitesCommunityCommunitiesBlogCareers",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tvm",
      "wallet",
      "telegram",
      "mini app",
      "builder",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:37:24.973Z"
  },
  {
    "id": "docs-ton-org--v3-concepts-educational-resources",
    "title": "Other resources",
    "url": "https://docs.ton.org/v3/concepts/educational-resources",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationOther resourcesOther resourcesCopy pageCopy pageThis page collects additional learning resources beyond this documentation. You’ll find a mix of official content not hosted in this documentation and community-created materials to help you continue your journey. Whether you prefer structured courses, in-depth articles, video tutorials, or real code examples, there is something here to match your learning style and current skill level. ​Courses ​Blockchain basics with TON Deprecated This course introduces blockchain basics, focusing on practical skills in the TON ecosystem. You will understand how blockchain functions and its diverse applications. This course is for junior developers, people new to crypto, non-technical IT professionals, and anyone curious about blockchains. English Chinese Russian ​TON & Telegram Blockchain development Deprecated The course is aimed at developers and IT specialists interested in gaining practical knowledge about the technologies and concepts of the TON Blockchain, such as FunC, dApps, decentralization, smart contracts, contract testing, as well as the creation of Mini Apps within Telegram. English Chinese Russian ​Articles Introductory: How a Blockchain Can Help You on a Deserted Island Beginner-friendly: What is Blockchain? What is a Smart Contract? What is Gas? ​”Hello World” guide series A step-by-step tutorial series that starts with creating a new TON wallet and ends with a working, test-covered, and deployed smart contract, along with a Telegram Mini App frontend for it. Part 1: Working with your first TON wallet Part 2: Writing your first smart contract Part 3: Building your first web client Part 4: Testing your first smart contract ​Videos Introductory: Crypto Networks and Why They Matter ​Playlists Beginner-friendly: TON Development with Tact ​Interactive learning ​Code playgrounds TxTracer - Trace and analyze TON Blockchain transactions with tools to visualize execution, inspect and debug smart contracts with a code editor and user-friendly interface. Assembly Playground - Experiment with TVM assembly code directly in your browser. Write, test, and debug assembly instructions with real-time execution. Code Explorer - Compile FunC or Tolk code to assembly and explore the generated bytecode to understand how your smart contracts work under the hood. TVM Instruction table - Browse the TVM instruction reference with detailed descriptions, opcodes, stack effects, and control flow information for every instruction. Sandbox - Inspect transactions produced by your local tests using the @ton/sandbox package. Visualize messages, transaction info, VM logs and exit codes with an interactive UI. ​Challenges and exercises Hack the TON - TON-based wargame inspired by The Ethernaut, played in the TON Virtual Machine. Each level is a smart contract that needs to be hacked. Our goal is to help you to learn how to develop safe TON smart contracts and build a thriving community around this craft. ​Smart contract examples Examples of smart contracts on TON include wallets, electors (which manage validator elections on TON), multi-signature wallets, and many more. They can serve as an excellent reference for those studying on real projects. Tolk benchmark contracts - Tolk vs. FunC gas benchmarks and, simultaneously, reference Tolk contracts. ​Join the community All TON communities Telegram Dev chats Was this page helpful?YesNoSuggest editsRaise issuePreviousOld documentationNext⌘IgithubxtelegramPowered by MintlifyOn this pageCoursesBlockchain basics with TONTON & Telegram Blockchain developmentArticles”Hello World” guide seriesVideosPlaylistsInteractive learningCode playgroundsChallenges and exercisesSmart contract examplesJoin the community",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "dapp",
      "frontend",
      "api",
      "sdk",
      "transaction",
      "testing",
      "tutorial",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:37:29.659Z"
  },
  {
    "id": "docs-ton-org--v3-concepts-glossary",
    "title": "Glossary",
    "url": "https://docs.ton.org/v3/concepts/glossary",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationBlockchain foundationsGlossaryBlockchain foundationsGlossaryCopy pageCopy page​A ​Airdrop a free distribution of tokens among specific participants. ​Altcoin all cryptocurrencies, except Bitcoin, are called altcoins. ​Application Programming Interface (API) a mechanism that allows two programs to interact with each other through a series of protocols. ​Annual Percentage Yield (APY) a calculated yearly interest rate for a given asset. ​B ​Bearish the term “bearish” is used when the price of an asset has declined due to investors selling. (The term is often used to describe the overall market sentiment.) ​Binance a major cryptocurrency exchange. Website. ​Bitcoin (BTC) the preeminent cryptocurrency and the first decentralized network with open-source code, which laid the groundwork for the proliferation of blockchain technology. Wikipedia. ​Blockchain a distributed ledger of data in the form of a chain of blocks recording transaction information for every event on the network. ​Bag of Cells (BoC) serialization format for cells. Commonly used in code. Article. ​Bot a program written for two ecosystems to interact with each other — e.g., The Open Network and the Telegram messenger. On Telegram, bots are accounts in the messenger operated by software. ​Bridge a program connecting various blockchains to transfer tokens and data from one network to another. Article. ​Bullish the term “bullish” is used to describe an asset whose value is appreciating. (“Bullish” is the opposite of “bearish” — i.e., when the market’s overall value is increasing.) ​Burning the act of permanently removing tokens from circulating and total supply. ​C ​Centralized exchange (CEX) a centralized cryptocurrency exchange to trade tokens. ​CoinMarketCap (CMC) a crypto information aggregator that closely follows changes in token prices and market capitalization. Website. ​Coinbase a major cryptocurrency exchange based in the United States. Website. ​Cryptobot a peer-to-peer (P2P) bot service for buying, trading, and selling Toncoin and other cryptocurrencies. ​Custodial a type of crypto wallet where a third party stores cryptocurrencies, and not their true owner. ​D ​Decentralized application (dApp) applications run on-chain and rely on smart contracts for computation, storage, and communication. ​Dollar-cost averaging (DCA) an investment strategy whereby investors buy a fixed amount at regular intervals regardless of price to reduce timing risk. ​Decentralization one of the main tenets behind TON and other blockchains. Without decentralization, Web3 would be impossible to achieve; therefore, every element of the TON ecosystem revolves around maximizing decentralization. ​DeFi the decentralized analog to traditional finance; it includes accessible financial services and applications based on smart contracts. ​Decentralized exchange (DEX) an exchange where users can trade cryptocurrencies without any intermediaries. The online entity needed to guarantee safe transactions is the blockchain itself. ​Diamond hands a colloquial term describing an investor who has no intention of selling their assets regardless of the state of the market — even if there’s a crash or the market is bearish. ​Domain Name System (DNS) a technology that translates human-readable domain names (e.g. ton.org) to machine-readable IP addresses (e.g. 192.0.2.44). ​Dolphin an investor who has relatively small capital but has an influence on the community. ​Donate a bot service on Telegram through which people can donate money, and content creators can monetize their channels and services in Toncoin. ​Dump rapidly selling a cryptocurrency or asset, often causing a price decline. ​Durov Pavel Durov, a Russian entrepreneur who is famous for having founded the VK social network and Telegram messenger. Nikolai Durov is Pavel’s brother, who helped develop VK, Telegram, and TON. ​Do Your Own Research (DYOR) the process by which you do research on a project, company or cryptocurrency before deciding to invest. ​E ​Ethereum Virtual Machine (EVM) a machine behaving like a decentralized computer, it computes the state of the Ethereum blockchain after each new block and executes smart contracts. ​Exchange a place for trading and using other market instruments. ​F ​Farming lending your crypto assets to receive rewards. ​Fiat regular money issued by central banks or financial authorities. ​Fear of missing out (FOMO) a psychological state that consumes some investors when the idea of losing potential gains from an opportunity is present. It usually appears during a bull market and when traders don’t do their due diligence analyzing a particular project. ​Fungible tokens cryptocurrencies that carry the same value as any other token of the same kind at any given moment. ​FUD “fear, uncertainty, and doubt,” market sentiments based on many factors. ​Full node a computer on blockchain that synchronizes and copies the entire blockchain. ​FunC the smart contract language on TON. ​G ​Gas the fee paid for transactions on the blockchain. ​GitHub a platform for hosting code and collaborating via Git repositories. ​H ​Hackathon a collaborative event where programmers and builders develop software projects. ​Hash a fixed-size digest computed from data using a hashing algorithm. ​Hash rate the indication of how much computational power is being used on a network for crypto mining. ​Hold saving — i.e., not selling — an asset or assets from your portfolio. ​I ​Initial Coin Offering (ICO) a method for crypto projects to attract capital in the early stages. ​Initial Decentralized exchange Offering (IDO) a method of attracting capital when launching a cryptocurrency or token on a decentralized exchange. ​Inflation the process when the value of a currency — e.g., U.S. dollar or the euro — decreases. Toncoin has predictable issuance and a low inflation rate. ​K ​Know Your Customer (KYC) the process by which a user verifies their identity when creating an account for a crypto service. ​L ​Launchpad a platform for crypto startups that brings investors and projects together. ​Liquidity pool grouping together crypto assets and freezing them in a smart contract. Liquidity pools are used for decentralized trading, loans, and other endeavors. ​M ​Mainnet the main network of a blockchain. ​Market capitalization (market cap) the total market value of a cryptocurrency’s circulating supply. ​Masterchain the main chain that references shard and workchain blocks; a shard block is finalized once a Masterchain block references it. ​Metaverse a digital universe similar to a video game where users create avatars and interact with the digital representations of other people or users. ​Moon a crypto term that describes a crypto asset’s vertical trajectory on a price chart — i.e., it quickly gains value. ​N ​”Not financial advice” (NFA) acronym used as a disclaimer to avoid liability or responsibility when investors discuss cryptocurrencies or projects with other people. ​Non-fungible token (NFT) a unique digital token on a blockchain that cannot be duplicated or minted more than once. ​Nominator those who provide financial resources to validators so the latter can confirm blocks on TON blockchain. ​Non-custodial a kind of crypto wallet that gives full control over assets to the owner/user. ​O ​Off-ramp ways to convert cryptocurrencies into fiat money. ​On-ramp ways to convert (buy) cryptocurrency by spending fiat money. ​Onion routing a technology similar to Tor that allows anonymous interactions on a network. All messages are encrypted in various layers akin to an onion. TON Proxy applies such a technique. ​P ​Paper hands an investor who’s inclined to panic-sell — an inexperienced investor. ​Proof-of-stake a consensus mechanism to process transactions in new blocks on the blockchain. ​Proof-of-work a consensus algorithm where one party proves to another that a specific amount of computational work was spent. By expending a little energy, a party can verify this. ​Proxy a service on a computer network that allows clients to establish indirect network connections with other network services. ​Pump artificially inflating the price of a cryptocurrency or asset. ​Peer-to-peer (P2P) transactions among users without the help of a third party or intermediary. ​R ​Roadmap a project’s strategic plan that displays when its products, services, updates, etc. will be released. ​Return on investment (ROI) the profits made from investments. ​S ​Soulbound token (SBT) an NFT that can never be transferred because it contains information about its owner and their accomplishments. ​Scalability the ability of a blockchain network to process complex transactions as well as a large number of them. ​Securities and Exchange Commission (SEC) a financial regulator in the United States. Website. ​Shard a mecha",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "dapp",
      "api",
      "sdk",
      "testnet",
      "mainnet",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:37:32.282Z"
  },
  {
    "id": "docs-ton-org--v3-concepts-dive-into-ton-ton-ecosystem-explorers-in-ton-",
    "title": "Overview",
    "url": "https://docs.ton.org/v3/concepts/dive-into-ton/ton-ecosystem/explorers-in-ton/",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersOverviewUsing TonviewerSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationExplorersOverviewEcosystemExplorersOverviewCopy pageCopy pageExplorers are web tools for reading blockchain data. They let you look up accounts, transactions, blocks, and smart contracts, making it easy to verify activity and debug issues. ​Explorer A blockchain explorer is a website that indexes on‑chain data and presents it in a searchable user interface (UI). In TON, explorers commonly show account balances, recent transactions, jettons and non‑fungible tokens (NFTs), contract code and state, and links to related blocks and messages. ​What explorers show Balances and assets: TON, jettons, and NFTs held by an address Transactions and messages: history, fees, phases, and traces Blocks and validators: block contents, masterchain and shardchain details Smart contracts: code, state, disassembly, and known contract type Analytics: top entities, volumes, gas, fees, and network health ​Indexers Indexers continuously read blocks from nodes, parse messages and transactions, and store them in a database optimized for queries. Explorers rely on these indexers to provide fast search, traces, higher‑level events, and historical views beyond what a single node exposes by default. ​Explorers comparison ExplorerTypeMainnetTestnetOfficial TonviewerGeneral‑purposetonviewer.comTestnetNoTonscan.orgGeneral‑purposetonscan.orgTestnetNoTonscan.comGeneral‑purposetonscan.com-NoTON ExplorerLow‑level/coreexplorer.toncoin.orgTestnetYes Official: maintained by the TON Foundation or an affiliated team The verifier tool powers contract code verification.Was this page helpful?YesNoSuggest editsRaise issuePreviousUsing TonviewerNext⌘IgithubxtelegramPowered by MintlifyOn this pageExplorerWhat explorers showIndexersExplorers comparison",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "testnet",
      "mainnet",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:37:33.441Z"
  },
  {
    "id": "docs-ton-org--v3-documentation-smart-contracts-contracts-specs-wallet-contracts-",
    "title": "Comparison",
    "url": "https://docs.ton.org/v3/documentation/smart-contracts/contracts-specs/wallet-contracts/",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsHow they workMnemonicsComparisonPerformance benchmarkHow to interactHistoryV4V5Highload WalletsLockup walletPreprocessed Wallet V2Restricted walletTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationWalletsComparisonStandard contractsWalletsComparisonCopy pageCopy pageUnlike some other blockchains, wallets in TON are represented as distinct smart contracts. They handle transaction signing, replay protection, and even gasless transfers. Different wallet versions implement different custom logic, suitable for various use cases. This article will cover the differences between these wallets and identify the best pick for each task. ​Comparison table FeatureV4V5HighloadPreprocessedMultisigSeqno1 based✅ Yes✅ Yes❌ No (query_id based)✅ Yes🟡 Has boolean flag that turns off seqno +1 incremental checkMessages throughputUp to 4 per requestUp to 255 per requestUp to 2 billion per timeoutUp to 255 per requestUp to 255 per voteMulti-owner❌ Single owner❌ Single owner❌ Single owner❌ Single owner✅ Multiple ownersMessage costStandardStandardLowerLowestHigher (multiple signatures)Support plugins✅ Yes✅ Yes❌ No❌ No❌ NoSupport gasless2❌ No✅ Yes❌ No❌ No❌ NoSubwallet ID✅ Yes✅ Yes✅ Yes❌ No❌ No 1 Seqno means “sequential number” - a persistent unsigned integer variable, which is incremented by 1 for each valid transaction submission. Also, sometimes it’s called “nonce”. It is a common way to implement replay protection. 2 “Gasless” is the kind of a transaction that doesn’t require native currency to pay network fees. There is also a separate gas and performance comparison. ​Use cases ​Retail users If you are new to TON and want to create your first wallet to engage with the ecosystem, v4 and v5 are your best choices. All major wallet apps support both standards and implement secure cryptography to ensure users’ funds are safe. It is recommended to use the v5 wallet standard, since it’s the latest and most powerful implementation to date. It supports gasless transactions and up to 255 out messages per one signed external request. Use for: Buying stablecoins: Purchase USDT and other stable assets Trading Jettons: Swap tokens on DEXes and participate in DeFi Daily payments: Send and receive TON for everyday transactions NFT collecting: Buy, sell, and store digital collectibles Staking: Participate in TON validation and earn rewards DApp interactions: Connect to games, social apps, and other TON applications Savings: Store cryptocurrency for long-term holding Key benefits: Simple setup with any major TON wallet app Low transaction fees for everyday use Battle-tested security with millions of users Full ecosystem compatibility Read more: Recommended: Wallet v5 Wallet v4 ​Shared custody For experienced institutional managers and fund operators with high security demands, Multisig wallets are your best choice when managing institutional funds, treasury assets, or any situation requiring shared custody. Multisig wallets provide the highest level of security through distributed control: Shared responsibility: No single person can move funds alone Configurable thresholds: Set up 2-of-3, 3-of-5, or any N-of-M configuration Audit trails: Every transaction requires multiple approvals, creating clear accountability Risk mitigation: Protects against key compromise, insider threats, and human error Key considerations: Higher transaction costs due to multiple signature verification Longer processing time as multiple parties must sign Requires coordination between signers for each transaction More complex setup and key management procedures While the operational overhead is higher than that of single-signature wallets, the security benefits make multisig essential for any custodial operation handling significant assets or requiring regulatory compliance. ​Payment gateways For businesses operating payment gateways, exchanges, or services requiring high-volume transaction processing, Highload wallets are your best choice when handling thousands of payments and withdrawals efficiently. Highload wallets are engineered explicitly for maximum throughput and cost efficiency: Massive throughput: Process up to 8,380,415 requests with up to 254 outgoing messages (total maximum of up to 2 billion outgoing messages) per timeout period Query-based processing: Uses query id and batch id instead of seqno for better transaction submission tracking. They help discover individual transaction submissions Use for: Cryptocurrency exchanges: Handle thousands of user withdrawals and deposits Payment processors: Process merchant payments and payouts at scale Trading platforms: Execute high-frequency trading operations Key considerations: Requires technical expertise for proper implementation More complex setup compared to standard wallets Need robust monitoring and error handling systems Read more: Highload wallet implementation Was this page helpful?YesNoSuggest editsRaise issuePreviousPerformance benchmarkNext⌘IgithubxtelegramPowered by MintlifyOn this pageComparison tableUse casesRetail usersShared custodyPayment gateways",
    "category": "smart-contracts",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "dapp",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:37:37.234Z"
  },
  {
    "id": "docs-ton-org--v3-documentation-infra-bridges-toncoin",
    "title": "Bridges",
    "url": "https://docs.ton.org/v3/documentation/infra/bridges/toncoin",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationEcosystemBridgesEcosystemBridgesCopy pageCopy pageIn the TON ecosystem, bridges allow users to transfer assets and data between TON and other major blockchains like Ethereum, BNB Chain, and Polygon. In this article, we will explore cross-chain bridges on TON. ​What are Cross-Chain Bridges? Cross-chain bridges are protocols that allow users to transfer cryptocurrencies, tokens, and sometimes arbitrary data from one blockchain to another. They act as connectors between otherwise isolated blockchain networks, enabling a multi-chain ecosystem where assets can move freely across different platforms. Bridges typically work by locking assets on the source blockchain and minting equivalent wrapped tokens on the destination blockchain. When users want to move assets back, the wrapped tokens are burned on the destination chain, and the original assets are unlocked on the source chain. ​Types of Cross-Chain Bridges ​1. Trustless vs. Custodial Bridges Trustless Bridges: Use smart contracts and cryptographic proofs for validation No single point of failure Decentralized verification mechanisms Centralized Bridges: Rely on trusted entities or multi-signature wallets Single point of failure risk Generally, they are easier to implement ​2. Asset Transfer Methods Lock-and-Mint Bridges: Lock original assets on the source chain Mint wrapped tokens on the destination chain Most common bridge type Burn-and-Mint Bridges: Burn tokens on the source chain Mint new tokens on the destination chain Used for native multi-chain tokens ​Bridges on TON The TON blockchain has a bridge ecosystem that connects it to major EVM-compatible networks. There are several kinds of bridge providers on TON. ​Legacy: Official TON Bridges During the early development of TON ecosystem (2021-2023) there were a few official TON bridges, supported at the protocol level. Now, they are considered legacy and not recommended for usage since they can be deprecated at any moment. TON blockchain supports several official bridges configured at the protocol level: ​Outbound Bridges (Config parameters 71-73) These bridges wrap TON into other networks: ETH-TON Bridge (Config Parameter 71) BNB-TON Bridge (Config Parameter 72) Polygon-TON Bridge (Config Parameter 73) ​Inbound Bridges (Config parameters 79, 81-82) These bridges wrap tokens from other networks into TON: ETH-TON Bridge (Config Parameter 79) BNB-TON Bridge (Config Parameter 81) Polygon-TON Bridge (Config Parameter 82) You can read more about these bridge configuration parameters on the TON Config page. ​Third-Party Bridge Ecosystem The TON ecosystem features multiple bridge providers offering different features and supported networks. You can read more about them in TON Bridges page. You can see existing bridges statistics on TON Foundation Bridge Dashboard.Was this page helpful?YesNoSuggest editsRaise issuePreviousOverviewNext⌘IgithubxtelegramPowered by MintlifyOn this pageWhat are Cross-Chain Bridges?Types of Cross-Chain Bridges1. Trustless vs. Custodial Bridges2. Asset Transfer MethodsBridges on TONLegacy: Official TON BridgesOutbound Bridges (Config parameters 71-73)Inbound Bridges (Config parameters 79, 81-82)Third-Party Bridge Ecosystem",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:37:40.188Z"
  },
  {
    "id": "docs-ton-org--v3-documentation-network-global-config",
    "title": "Run a node with MyTonCtrl",
    "url": "https://docs.ton.org/v3/documentation/network/global-config",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeOverviewRun a node with MyTonCtrlRun a validatorIntegrate MyTonCtrl with PrometheusSetting up a local blockchain using MyLocalTonMyTonCtrl referenceStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationBlockchain nodeRun a node with MyTonCtrlEcosystemBlockchain nodeRun a node with MyTonCtrlCopy pageProvision hardware, install MyTonCtrl, and follow runbooks for validator, liteserver, or archive roles.Copy pageHandle validator keys like production secrets.Keep recovery phrases offline, restrict shell access, and rehearse new procedures on testnet before touching wallets that hold real stake. ​Plan the environment ​Supported operating systems MyTonCtrl is tested on the following distributions (choose one and keep it up to date): Ubuntu 22.04 LTS or 24.04 LTS Debian 11 or 12 Always create and use a non-root operator with sudo access—running MyTonCtrl as root leads to subtle permission failures later on. ​Hardware sizing by role RoleCPURAMStorageNetworkTrafficNotesFull/validator node16 dedicated cores (32 threads preferred)128 GB≥1 TB NVMe SSD or provisioned 64k+ IOPS≥1 Gbps up/down64 TB/month typical (peaks ~100 TB)Leave headroom for elections and snapshots.Liteserver16 cores128 GB≥1 TB NVMe SSD≥1 Gbps~16 TB/month peaksHetzner/OVH are acceptable for liteservers (not for validators).Archive liteserver16 cores128 GB≥12 TB NVMe or ZFS pool with compression≥1 Gbps≥16 TB/monthPlan for continuous growth; monitor ZFS capacity. Disk latency is the common bottleneck. Benchmark storage before going live (MyTonCtrl> benchmark). ​Network and ports Obtain a static public IPv4 address for each node. Forward a single UDP port (default 30303) from the internet to the node and leave all outbound ports open. Verify exposure with netstat -tulpn and third-party scanners. Update cloud security groups or on-prem firewalls after installation—use MyTonCtrl> about validator / about liteserver to confirm the chosen port. ​Recommended providers The TON Foundation validates the following instances for validator-class workloads: Cloud ProviderInstance TypeCPURAMStorageNetworkPublic IPTrafficGCPn2-standard-1632 vCPUs128 GB1 TB NVMe SSD16 GbpsStatic external IP64 TB/monthAlibaba Cloudecs.g6.4xlarge32 vCPUs128 GB1 TB NVMe SSDUp to 10 GbpsElastic IP64 TB/monthTencent CloudM5.4XLARGE32 vCPUs128 GB1 TB NVMe SSDUp to 10 GbpsElastic IP64 TB/monthVultrBare metal Intel E-2388G16C/32T128 GB1.92 TB NVMe SSD10 GbpsFixed64 TB/monthDigitalOceanGeneral purpose premium Intel32 vCPUs128 GB1 TB NVMe SSD10 GbpsFixed64 TB/monthLatitudec3.medium.x8616C/32T128 GB1.9 TB NVMe SSD10 GbpsFixed64 TB/monthAWSi4i.8xlarge32 vCPUs256 GB2×3.75 TB Nitro SSDUp to 25 GbpsElastic IP64 TB/month ​Prepare the operator account If you still need a dedicated operator, create and switch to it before installing MyTonCtrl: CopyAsk AIsudo adduser <USERNAME> sudo usermod -aG sudo <USERNAME> # reconnect as the new user ssh <USERNAME>@<SERVER_IP> ​Install MyTonCtrl Run the installer from the operator account with sudo so it can create system users and services: CopyAsk AIsudo apt update sudo apt install -y curl wget git ca-certificates python3-pip wget https://raw.githubusercontent.com/ton-blockchain/mytonctrl/master/scripts/install.sh sudo bash install.sh -d The interactive wizard walks through: Selecting mainnet vs. testnet (or supplying a custom global.config.json). Choosing the initial mode (validator or liteserver). Optionally downloading blockchain dumps via TON Storage (recommended for archive builds). Whether to run post-download tasks in the background (useful when pulling large dumps). Refer to the MyTonCtrl overview for installer flags and environment variables when you need unattended deployments. ​Verify services and synchronization CopyAsk AImytonctrl MyTonCtrl> status MyTonCtrl> status_fast MyTonCtrl> status_modes status shows the long-form report, including Local validator initial sync status—wait for it to read synchronized before switching roles. status_fast prints live metrics such as timeDiff and Local validator out of sync; both should trend toward zero on a healthy node. status_modes confirms which modes are currently enabled. After installation, verify ownership so MyTonCtrl and validator processes can access state and keys: CopyAsk AIsudo chown -R validator:validator /var/ton-work/db sudo chown -R <install_user>:<install_user> /var/ton-work/keys ​Baseline maintenance tasks MyTonCtrl> create_backup and restore_backup safeguard your configs and keys—run before upgrades and after major changes. MyTonCtrl> set sendTelemetry true sends telemetry to the MyTonCtrl developers so they can surface TON status alerts and diagnose emerging issues. MyTonCtrl> update followed by upgrade applies MyTonCtrl and binary updates; schedule regular maintenance windows. MyTonCtrl> settings_status reviews every setting, its owner mode, and the current value. Use tail -F /var/ton-work/log* and journalctl -u validator -f during troubleshooting; reduce verbosity again if you temporarily ran installer set_node_argument --verbosity 3. ​Validator quickstart You need: a fully synchronized node, validator mode not active elsewhere, and at least the current minimum stake (approximately 300,000 TON; check tonscan.com/validation for live numbers). ​Prepare the validator wallet (one-time) List existing wallets: MyTonCtrl> wl. The installer usually creates validator_wallet_001. If you need a dedicated wallet, create one (example): CopyAsk AIMyTonCtrl> nw 0 validator_wallet v3 1001 Fund the wallet, inspect recent activity with vas <wallet_name>, then activate it: CopyAsk AIMyTonCtrl> aw validator_wallet Tell MyTonCtrl which wallet to use for elections: CopyAsk AIMyTonCtrl> set validatorWalletName \"validator_wallet\" MyTonCtrl> get validatorWalletName Export and store the private key offline: MyTonCtrl> ew validator_wallet. Need more wallet operations? See the wallet command reference. ​Enable validator mode Disable conflicting roles (liteserver cannot run alongside validator) and switch modes: CopyAsk AIMyTonCtrl> disable_mode liteserver MyTonCtrl> enable_mode validator MyTonCtrl> status_modes MyTonCtrl> about validator Confirm that validator shows as enabled and note the advertised ADNL port for firewall rules. ​Configure staking policy Assign either a fixed stake or a percentage of wallet balance: CopyAsk AIMyTonCtrl> set stake 500000 # or MyTonCtrl> set stakePercent 99 get stake / get stakePercent display the stored values; adjust before each election window if your balance changes. ​Election routine Use the same sequence every election cycle (automate with cron if desired): CopyAsk AIMyTonCtrl> status_fast MyTonCtrl> ve MyTonCtrl> check_ef Wait until Local validator out of sync is below 20 before running ve. ve submits election messages, check_ef reports the previous and current round efficiency. MyTonCtrl automatically splits balances into two stakes when the Elector accepts your bid; withdrawals become available in the following election per protocol rules. ​Operational discipline Track network announcements via @tonstatus and enable notifications. Keep hardware aligned with the minimum system requirements; upgrade storage promptly if metrics show saturation. Leave telemetry enabled (set sendTelemetry true) so telemetry continues reaching the MyTonCtrl developers and they can warn the community about issues. Monitor RAM, disk, CPU, and bandwidth dashboards. Contact @mytonctrl_help_bot if metrics or efficiency drop below target. Re-run check_ef or consult the efficiency API when diagnosing performance. ​Liteserver quickstart You need: a synchronized full node with validator mode disabled (liteserver cannot run alongside validator on the same machine). ​Activate liteserver services CopyAsk AIMyTonCtrl> enable_mode liteserver MyTonCtrl> status_modes ​Configure endpoints and proxies CopyAsk AIMyTonCtrl> installer Installer> enable LS Installer> plsc Installer> exit enable LS deploys the liteserver daemon. plsc prints the client bundle—share it with /var/ton-work/keys/liteserver.pub so lite-clients can connect. Regenerate configs at any time with installer clcf. ​Open the liteserver port Check the port in /var/ton-work/db/config.json (within the liteservers array). Update security groups or configure ufw on bare-metal hosts: CopyAsk AIsudo apt install -y ufw sudo ufw allow ssh sudo ufw allow <port> sudo ufw enable sudo ufw status Confirm connectivity by initializing a lite-client using the generated config. ​Ongoing care Monitor netLoadAvg and CPU via status_fast; scale hardware before saturation. Export create_backup after any config change so you can rapidly rebuild liteserver hosts. Keep ports private—front them with VPNs or proxies when exposing to public users. ​Archive liteserver quickstart You need: liteserver mode enabled, ≥12 TB of fast storage, and ZFS installed for handling compressed dumps. ​Pre",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "testnet",
      "mainnet",
      "transaction",
      "deployment",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "python",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:37:45.342Z"
  },
  {
    "id": "docs-ton-org--v3-documentation-network-config-params-overview",
    "title": "Blockchain config",
    "url": "https://docs.ton.org/v3/documentation/network/config-params/overview",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationBlockchain foundationsBlockchain configBlockchain foundationsBlockchain configCopy pageCopy pageYou can view live values by using Tonviewer. This page provides a description of the configuration parameters used in the TON Blockchain. TON features a complex configuration consisting of many technical parameters, some of which are utilized by the blockchain itself, while others serve the ecosystem. However, only a limited number of individuals fully understand the significance of these parameters. This article aims to offer users a straightforward explanation of each parameter and its purpose. ​Prerequisites This material should be read alongside the parameter list. You can view the parameter values in the current configuration, and the method of writing them into cells is outlined in the block.tlb file in TL-B format. Configuration values are TL-B typed cells serialized into Bags of Cells (BoC). All parameters are in place, and you won’t get lost. For your convenience, please use the right sidebar for quick navigation. ​Param 0: config address This parameter is the address of a special smart contract that stores the blockchain’s configuration. The configuration is stored in the contract to simplify its loading and modification during validator voting. In the configuration parameter, only the hash portion of the address is recorded, as the contract always resides in the masterchain (workchain -1). Therefore, the full address of the contract will be written as -1:<value of the configuration parameter>. Parameter #0 on mainnet ​Param 1: elector address This parameter is the address of the elector smart contract, responsible for appointing validators, distributing rewards, and voting on changes to blockchain parameters. Parameter #1 on mainnet ​Param 2: TON minting address This parameter represents the address of the system, on behalf of which new Toncoin are minted and sent as rewards for validating the blockchain. If parameter 2 is missing, parameter 0 is used instead (newly minted Toncoin come from the configuration smart contract). Parameter #2 on mainnet ​Param 3: fee collector address This parameter is the address of the transaction fee collector. If this parameter is missing (for the time being), transaction fees are directed to the elector smart contract (parameter 1). Parameter #3 on mainnet ​Param 4: root DNS address This parameter is the address of the root DNS contract of the TON network. For details, see the original specification.This contract is not responsible for selling .ton domains. Parameter #4 on mainnet ​Param 6: extra currency fee This parameter is responsible for minting fees for new currencies. Parameter #6 on mainnet ​Param 7: extra currency volume This parameter stores the volume of each extra currency in circulation. The data is organized as a dictionary (also referred to as a hashmap). The structure uses the format currency_id -> amount, where the amount is represented as a VarUInteger 32, which is an integer ranging from 0 to 2^248-1. Parameter #7 on mainnet ​Param 8: network version This parameter indicates the network version and additional capabilities supported by the validators. Validators are nodes in the TON Blockchain network that are responsible for creating new blocks and verifying transactions. version: This field specifies the version. capabilities: This field is a set of flags that are used to indicate the presence or absence of certain features or capabilities. Thus, when updating the network, validators will vote to change parameter 8. This way, the TON Blockchain network can be updated without downtime. Parameter #8 on mainnet ​Param 9: mandatory params This parameter contains a list (binary tree) of mandatory parameters. It ensures that certain configuration parameters are always present and cannot be removed by a proposal to change the configuration until parameter 9 changes. Parameter #9 on mainnet ​Param 10: critical params This parameter represents a list (binary tree) of critical TON parameters whose change significantly affects the network, so more voting rounds are held. Parameter #10 on mainnet ​Param 11: config params This parameter indicates under what conditions proposals to change the TON configuration are accepted. min_tot_rounds: The minimum number of rounds before a proposal can be applied. Currently, this parameter is not used: only max_tot_round (when the proposal will be rejected) and min_wins (when the proposal will be accepted) matter. max_tot_rounds: The maximum number of rounds, upon reaching which the proposal will automatically be rejected min_wins: The required number of wins (3/4 of validators by the sum of the pledges must vote in favor) max_losses: The maximum number of losses, upon reaching which the proposal will automatically be rejected min_store_sec and max_store_sec determine the possible time interval during which the proposal will be stored bit_price and cell_price indicate the price of storing one bit or one cell of the proposal Parameter #11 on mainnet ​Param 12: Workchain config This parameter represents the configuration of a workchain in the TON Blockchain. workchains are designed as independent blockchains that can operate in parallel, allowing TON to scale and process a large number of transactions and smart contracts. ​Workchain configuration parameters enabled_since: A UNIX timestamp of the moment this workchain was enabled. actual_min_split: The minimum depth of the split (sharding) of this workchain, supported by validators. min_split: The minimum depth of the split of this workchain, set by the configuration. max_split: The maximum depth of the split of this workchain. basic: A boolean flag (1 for true, 0 for false) indicating whether this workchain is basic (handles TON coins, smart contracts based on the TON Virtual Machine). active: A boolean flag indicating whether this workchain is active at the moment. accept_msgs: A boolean flag indicating whether this workchain is accepting messages at the moment. flags: Additional flags for the workchain (reserved, currently always 0). zerostate_root_hash and zerostate_file_hash: Hashes of the first block of the workchain. version: Version of the workchain. format: The format of the workchain, which includes vm_version and vm_mode - the virtual machine used there. Parameter #12 on mainnet ​Param 13: complaint cost This parameter defines the cost of filing complaints about the incorrect operation of validators in the elector smart contract. Parameter #13 on mainnet ​Param 14: block reward This parameter indicates the reward for creating a block in the TON Blockchain. Values are in nanotons (also referred to as nanograms); therefore, the reward for block creation in the masterchain is 1.7 Toncoin, while in the basechain, it is 1.0 Toncoin. In the event of a workchain split, the block reward is also divided: if there are two shardchains within the workchain, then the reward for each shard block will be 0.5 Toncoin. Parameter #14 on mainnet ​Param 15: elections timing This parameter contains the duration of different stages of elections and validators’ work in the TON Blockchain. For each validation period, there is an election_id equal to the UNIX-format time at the start of the validation. You can get the current election_id (if elections are ongoing) or the past one by invoking the elector smart contract’s respective get-methods active_election_id and past_election_ids. ​Election and validation timing parameters validators_elected_for: The number of seconds the elected validators perform their role (one round). elections_start_before: The seconds before the end of the current round, when the election process for the next period will start. elections_end_before: The seconds before the end of the current round, the validators for the next round will be chosen. stake_held_for: The period for which a validator’s stake is held (for handling complaints) after the round expires. Each value in the arguments is determined by the uint32 data type. ​Examples In the TON Blockchain, validation periods are typically divided into even and odd rounds that alternate. Voting for the next round occurs during the previous one, so a validator must allocate their funds into two separate pools to participate in both rounds. ​Mainnet Current values: CopyAsk AIconstants = { 'validators_elected_for': 65536, # 18.2 hours 'elections_start_before': 32768, # 9.1 hours 'elections_end_before': 8192, # 2.2 hours 'stake_held_for': 32768 # 9.1 hours } Scheme: ​How to calculate periods? Let election_id = validation_start = 1600032768. Then: CopyAsk AIelection_start = election_id - constants['elections_start_before'] = 1600032768 - 32768 = 1600000000 election_end = delay_start = election_id - constants['elections_end_before'] = 1600032768 - 8192 = 1600024576 hold_st",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "testnet",
      "mainnet",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:37:47.869Z"
  },
  {
    "id": "docs-ton-org--v3-documentation-network-protocols-adnl-low-level",
    "title": "Low-level ADNL",
    "url": "https://docs.ton.org/v3/documentation/network/protocols/adnl/low-level",
    "content": "Skip to main contentDeprecated! Please, visit the new documentation at docs.ton.org Deprecated, go to new docs!On this pageLow-level ADNL Abstract Datagram Network Layer (ADNL) is the core protocol of TON, which helps network peers communicate. Peer identity​ Each peer must have at least one identity; while it's possible to use multiple identities, it is not required. Each identity consists of a keypair used for performing the Diffie-Hellman exchange between peers. An abstract network address is derived from the public key in the following way: address = SHA-256(type_id || public_key). Note that the type_id must be serialized as a little-endian uint32. Public-key cryptosystems list​ type_idcryptosystem0x4813b4c6ed255191 To perform x25519, the keypair must be generated in \"x25519\" format. However, the public key is transmitted over the network in ed25519 format, so you have to convert the public key from x25519 to ed25519, examples of such conversions can be found here for Kotlin. Client-server protocol (ADNL over TCP)​ The client connects to the server using TCP and sends an ADNL handshake packet. This packet contains a server abstract address, a client public key, and encrypted AES-CTR session parameters, which the client determines. Handshake​ First, the client must perform a key agreement protocol (for example, x25519) using their private key and server public key, taking into account the server key's type_id. As a result, the client will gain secret, which is used to encrypt session keys in future steps. Then, the client has to generate AES-CTR session parameters, a 16-byte nonce and 32-byte key, both for TX (client->server) and RX (server->client) directions and serialize it into a 160-byte buffer as follows: ParameterSizerx_key32 bytestx_key32 bytesrx_nonce16 bytestx_nonce16 bytespadding64 bytes The purpose of padding is unknown; it is not used by server implementations. It is recommended that the whole 160-byte buffer be filled with random bytes. Otherwise, an attacker may perform an active MitM attack using compromised AES-CTR session parameters. The next step is to encrypt the session parameters using the secret through the key agreement protocol outlined above. To achieve this, AES-256 needs to be initialized in CTR mode with a 128-bit big-endian counter. This will utilize a (key, nonce) pair that is computed as follows (note that aes_params is a 160-byte buffer that was created earlier): hash = SHA-256(aes_params)key = secret[0..16] || hash[16..32]nonce = hash[0..4] || secret[20..32] After encrypting aes_params, noted as E(aes_params), remove AES as it is no longer needed. We are now ready to serialize all this information into the 256-byte handshake packet and send it to the server. ParameterSizeNotesreceiver_address32 bytesServer peer identity as described in the Peer identity sectionsender_public32 bytesClient public keySHA-256(aes_params)32 bytesIntegrity proof of session parametersE(aes_params)160 bytesEncrypted session parameters The server must decrypt session parameters using a secret derived from the key agreement protocol, just as the client does. After decryption, the server must perform the following checks to ensure the security properties of the protocol: The server must possess the corresponding private key for receiver_address. Without this key, it cannot execute the key agreement protocol. The condition SHA-256(aes_params) == SHA-256(D(E(aes_params))) must hold true. If this condition is not met, it indicates that the key agreement protocol has failed and the secret values on both sides are not equal. If any of these checks fail, the server will immediately drop the connection without responding to the client. If all checks pass, the server must issue an empty datagram (see the Datagram section) to the client in order to prove that it owns the private key for the specified receiver_address. Datagram​ Both the client and server must initialize two AES-CTR instances each for both transmission (TX) and reception (RX) directions. The AES-256 must be used in CTR mode with a 128-bit big-endian counter. Each AES instance is initialized using a (key, nonce) pair, which can be taken from the aes_params during the handshake. To send a datagram, either the client or the server must construct the following structure, encrypt it, and send it to the other peer: ParameterSizeNoteslength4 bytes (LE)Length of the whole datagram, excluding length fieldnonce32 bytesRandom valuebufferlength - 64 bytesActual data to be sent to the other sidehash32 bytesSHA-256(nonce || buffer) to ensure integrity The whole structure must be encrypted using the corresponding AES instance (TX for client -> server, RX for server -> client). The receiving peer must fetch the first 4 bytes, decrypt it into the length field, and read exactly the length bytes to get the full datagram. The receiving peer may start to decrypt and process buffer earlier, but it must take into account that it may be corrupted, intentionally or occasionally. Datagram hash must be checked to ensure the integrity of the buffer. In case of failure, no new datagrams can be issued and the connection must be dropped. The first datagram in the session always goes from the server to the client after a handshake packet is successfully accepted by the server and its actual buffer is empty. The client should decrypt it and disconnect from the server in case of failure because it means that the server has not followed the protocol properly and the actual session keys differ on the server and client side. Communication details​ If you want to dive into communication details, you could check the article ADNL TCP - liteserver to see some examples. Security considerations​ Handshake padding​ It is unknown why the initial TON team decided to include this field in the handshake. aes_params integrity is protected by a SHA-256 hash, and confidentiality is protected by the key derived from the secret parameter. Probably, it was intended to migrate from AES-CTR at some point. To do this, the specification may be extended to include a special magic value in aes_params, which will signal that the peer is ready to use the updated primitives. The response to such a handshake may be decrypted twice, with new and old schemes, to clarify which scheme the other peer is actually using. Session parameters encryption key derivation process​ If an encryption key is derived only from the secret parameter, it will be static because the secret is static. To derive a new encryption key for each session, developers also use SHA-256(aes_params), which is random if aes_params is random. However, the actual key derivation algorithm with the concatenation of different subarrays is considered harmful. Datagram nonce​ The purpose of the nonce field in the datagram may not be immediately clear. Even without it, any two ciphertexts will differ due to the session-bounded keys used in AES and the encryption method in CTR mode. However, if a nonce is absent or predictable, a potential attack can occur. In CTR encryption mode, block ciphers like AES function as stream ciphers, allowing for bit-flipping attacks. If an attacker knows the plaintext corresponding to an encrypted datagram, they can create an exact key stream and XOR it with their own plaintext, effectively replacing the original message sent by a peer. Although buffer integrity is protected by a hash (referred to here as SHA-256), an attacker can still manipulate it because if they know the entire plaintext, they can also compute its hash. The nonce field is crucial for preventing such attacks, as it ensures that an attacker cannot replace the SHA-256 without also having access to the nonce. P2P protocol (ADNL over UDP)​ A detailed description can be found in the article ADNL UDP - internode. References​ The Open Network, p. 80 ADNL implementation in TON Thanks to the hacker-volodya for contributing to the community! Here a link to the original article on GitHub. Was this article useful?YesNoEdit this pageLast updated on Sep 18, 2025 by aigerimuPeer identityPublic-key cryptosystems listClient-server protocol (ADNL over TCP)HandshakeDatagramCommunication detailsSecurity considerationsP2P protocol (ADNL over UDP)ReferencesUseGet a WalletGet ToncoinStakeAccept PaymentsApps & ServicesDomainsUSDT on TONCross-Chain BridgesLearnTON ConceptDecentralized NetworkRoadmapTonStatHistory of MiningToncoinValidatorsWhite PaperBrand AssetsSustainabilityFor BuildersTON Builders PortalGetting StartedDocumentationTelegram Mini AppsDev ChatsBug BountyFind a JobFind a TalentUse CasesGameFiMemecoins & TokensCommunity ToolsTON SitesCommunityCommunitiesBlogCareers",
    "category": "general",
    "tags": [
      "ton",
      "func",
      "wallet",
      "telegram",
      "mini app",
      "builder",
      "address",
      "message",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:37:51.081Z"
  },
  {
    "id": "docs-ton-org--v3-documentation-network-protocols-adnl-tcp",
    "title": "ADNL TCP",
    "url": "https://docs.ton.org/v3/documentation/network/protocols/adnl/tcp",
    "content": "Skip to main contentDeprecated! Please, visit the new documentation at docs.ton.org Deprecated, go to new docs!On this pageADNL TCP This is the low-level protocol that supports all interactions within the TON network. While it can operate on top of any protocol, it is most commonly used in conjunction with TCP and UDP. Typically, UDP facilitates communication between nodes, whereas TCP is employed for communication with liteservers. In this section, we will analyze how ADNL operates over TCP and learn how to interact directly with liteservers. In the TCP version of ADNL, network nodes utilize public keys (ed25519) as their addresses. Connections are established using a shared key obtained through the Elliptic Curve Diffie-Hellman (ECDH) procedure. Packet structure​ Each ADNL TCP packet, except for the handshake, has the following structure: 4-byte packet size in little-endian (N) 32-byte nonce (random bytes to protect against checksum attacks) (N - 64) payload bytes 32-byte SHA-256 checksum of nonce and payload The entire packet, including its size, is encrypted using AES-CTR. After decrypting the packet, you must verify that the checksum matches the data. To do this, simply calculate the checksum yourself and compare it to the checksum provided in the packet. The handshake packet is an exception; it is transmitted partially unencrypted and is detailed in the next chapter. Establishing a connection​ To establish a connection, we need to know the server's IP, port, and public key and generate our own private and public key, ed25519. Public server data such as IP, port, and key can be obtained from the global config. The IP in the config (a decimal integer) can be converted to dotted-decimal IPv4 form using (for example) this tool. The public key in the config is in base64 format. The client generates 160 random bytes, some of which will be used by the parties as the basis for AES encryption. Two permanent AES-CTR ciphers are created, which the parties will use to encrypt/decrypt messages after the handshake. Cipher A - key 0–31 bytes, IV 64–79 bytes Cipher B - key 32–63 bytes, IV 80–95 bytes The ciphers are utilized in the following order: Cipher A is used by the server to encrypt the messages it sends. Cipher A is used by the client to decrypt messages it receives. Cipher B is used by the client to encrypt the messages it sends. Cipher B is used by the server to decrypt messages it receives. To establish a connection, the client must send a handshake packet containing: [32 bytes] Server key ID (details) [32 bytes] Our Ed25519 public key [32 bytes] SHA-256 hash of our 160 bytes [160 bytes] Our 160 bytes encrypted (details) When receiving a handshake packet, the server will do the same actions: receive an ECDH key, decrypt 160 bytes, and create 2 permanent keys. If everything works out, the server will respond with an empty ADNL packet, without payload, to decrypt which (as well as subsequent ones) we need to use one of the permanent ciphers. From this point on, the connection can be considered established. After establishing a connection, you can start receiving information. Data is serialized using TL. Learn more about TL here. Ping and pong​ It is optimal to send a ping packet once every 5 seconds. This is necessary to maintain the connection while no data is being transmitted; otherwise, the server may terminate the connection. Like all the others, the ping packet is built according to the standard schema described above and carries the request ID and ping ID as payload data. Let's find the desired schema for the ping request here and calculate the schema id as crc32_IEEE(\"tcp.ping random_id:long = tcp.Pong\"). When converted to little endian bytes, we get 9a2b084d. Therefore, our ADNL ping packet will look like this: 4-byte packet size in little-endian -> 64 + (4+8) = 76 32-byte nonce -> random 32 bytes 4-byte schema ID -> 9a2b084d 8-byte request ID -> random uint64 number 32-byte SHA-256 checksum of nonce and payload Send the packet and wait for tcp.pong, where random_id equals the one sent in the ping packet. Receiving information from a liteserver​ All requests that are aimed at obtaining information from the blockchain are wrapped in Liteserver query schema, which in turn is wrapped in ADNL query schema. LiteQuery: liteServer.query data:bytes = Object, id df068c79 ADNLQuery: adnl.message.query query_id:int256 query:bytes = adnl.Message, id 7af98bb4 LiteQuery is passed inside ADNLQuery as query:bytes, and the final query is passed inside LiteQuery as data:bytes. Learn more about encoding byte arrays in TL here. getMasterchainInfo​ Since we already know how to generate TL packets for the lite API, we can request information about the current TON MasterChain block. The MasterChain block is used in many further requests as an input parameter to indicate the state (moment) in which we need information. We are looking for the TL schema we require, calculate its ID and build the packet: 4-byte packet size in little endian -> 64 + (4+32+(1+4+(1+4+3)+3)) = 116 32-byte nonce -> random 32 bytes 4-byte ADNLQuery schema ID -> 7af98bb4 32 bytes query_id:int256 -> random 32 bytes 1 byte array size -> 12 4 bytes of ID of the LiteQuery schema -> df068c79 1 byte array size -> 4 4 bytes of ID of the getMasterchainInfo schema -> 2ee6b589 3 zero bytes of padding (alignment to 8) 3 zero bytes of padding (alignment to 16) 32-byte SHA-256 checksum of nonce and payload Packet example in hex: 74000000 -> packet size (116)5fb13e11977cb5cff0fbf7f23f674d734cb7c4bf01322c5e6b928c5d8ea09cfd -> nonce 7af98bb4 -> ADNLQuery 77c1545b96fa136b8e01cc08338bec47e8a43215492dda6d4d7e286382bb00c4 -> query_id 0c -> array size df068c79 -> LiteQuery 04 -> array size 2ee6b589 -> getMasterchainInfo 000000 -> 3 bytes of padding 000000 -> 3 bytes of paddingac2253594c86bd308ed631d57a63db4ab21279e9382e416128b58ee95897e164 -> sha256 In response, we expect to receive liteServer.masterchainInfo, consisting of last:ton.blockIdExt state_root_hash:int256 and init:tonNode.zeroStateIdExt. The received packet is deserialized using the same algorithm as the request, but in the opposite direction, except that the response is wrapped only in ADNLAnswer. After decoding the response, we get a packet of the form: 20010000 -> packet size (288)5558b3227092e39782bd4ff9ef74bee875ab2b0661cf17efdfcd4da4e53e78e6 -> nonce 1684ac0f -> ADNLAnswer 77c1545b96fa136b8e01cc08338bec47e8a43215492dda6d4d7e286382bb00c4 -> query_id (identical to request) b8 -> array size 81288385 -> liteServer.masterchainInfo last:tonNode.blockIdExt ffffffff -> workchain:int 0000000000000080 -> shard:long 27405801 -> seqno:int e585a47bd5978f6a4fb2b56aa2082ec9deac33aaae19e78241b97522e1fb43d4 -> root_hash:int256 876851b60521311853f59c002d46b0bd80054af4bce340787a00bd04e0123517 -> file_hash:int256 8b4d3b38b06bb484015faf9821c3ba1c609a25b74f30e1e585b8c8e820ef0976 -> state_root_hash:int256 init:tonNode.zeroStateIdExt ffffffff -> workchain:int 17a3a92992aabea785a7a090985a265cd31f323d849da51239737e321fb05569 -> root_hash:int256 5e994fcf4d425c0a6ce6a792594b7173205f740a39cd56f537defd28b48a0f6e -> file_hash:int256 000000 -> 3 bytes of padding520c46d1ea4daccdf27ae21750ff4982d59a30672b3ce8674195e8a23e270d21 -> sha256 runSmcMethod​ We already know how to get the MasterChain block, so now we can call any liteserver methods. Let's analyze runSmcMethod - this is a method that calls a function from a smart contract and returns a result. Here we need to understand some new data types such as TL-B, Cell and BoC. To execute the smart contract method, we need to build and send a request using the TL schema: liteServer.runSmcMethod mode:# id:tonNode.blockIdExt account:liteServer.accountId method_id:long params:bytes = liteServer.RunMethodResult And wait for a response with schema: liteServer.runMethodResult mode:# id:tonNode.blockIdExt shardblk:tonNode.blockIdExt shard_proof:mode.0?bytes proof:mode.0?bytes state_proof:mode.1?bytes init_c7:mode.3?bytes lib_extras:mode.4?bytes exit_code:int result:mode.2?bytes = liteServer.RunMethodResult; In the request, we see the following fields: mode:# - uint32 bitmask of what we want to see in the response, for example, result:mode.2?bytes will only be present in the response if the bit with index 2 is set to one. id:tonNode.blockIdExt - our master block state that we got in the previous chapter. account:liteServer.accountId - workchain and smart contract address data. method_id:long - 8 bytes, in which crc16 with the XMODEM table is written on behalf of the called method + bit 17 is set [Calculation] params:bytes - Stack serialized in BoC, containing arguments to call the method. [Implementation example] For example, we only need result:mode.2?bytes, then our mode will be equal to 0b100, that is 4. In response, we will get: mode:# -> what was sent - 4. id:tonNode.blockIdExt -> our master block against which the method was executed shardblk:tonNode.blockIdExt -> shard block where the contract account is located exit_code:int -> 4 bytes which is the exit code when executing the method. If everything is successful, then = 0, if not, it is equal to the exception code. result:mode.2?bytes -> Stack serialized in BoC, containing the values returned by the method. Let's analyze the call and get the result from the a2 method of the contract EQBL2_3lMiyywU17g-or8N7v9hDmPCpttzBPE2isF2GTzpK4: Method code in FunC: (cell, cell) a2() method_id { cell a = begin_cell().store_uint(0xAABBCC8, 32).end_cell(); cell b = begin_cell().store_uint(0xCCFFCC1, 32).end_cell(); return (a, b);} Fill out our request: mode = 4, we only need the result -> 04000000 id = result of execution getMasterchainInfo account = WorkChain 0 (4 bytes 00000000), and int256 obtained from our contract address, i.e. 32 bytes 4bdbfde5322cb2c14d7b83ea2bf0deeff610e63c2a6db7304f1368ac176193ce method_id = computed id from a2 -> 0a2e010000000000 params:bytes = Our method does not accept input parameters, so we need to pass it an empty stack (00000",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "func",
      "smart contract",
      "wallet",
      "telegram",
      "mini app",
      "tma",
      "api",
      "transaction",
      "cell",
      "builder",
      "address",
      "message",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:37:53.639Z"
  },
  {
    "id": "docs-ton-org--v3-documentation-network-protocols-adnl-udp",
    "title": "Work with UDP",
    "url": "https://docs.ton.org/v3/documentation/network/protocols/adnl/udp",
    "content": "Skip to main contentDeprecated! Please, visit the new documentation at docs.ton.org Deprecated, go to new docs!On this pageWork with UDP ADNL over UDP is a low-level protocol used by nodes and TON components to communicate with one another. It serves as the foundation for other higher-level TON protocols, such as DHT (Distributed Hash Table) and RLDP (Reliable Large Datagram Protocol). This article will explain how ADNL over UDP facilitates basic communication between nodes. Unlike ADNL over TCP, the UDP implementation involves a different form of handshake and includes an additional layer in the form of channels. However, the underlying principles remain similar: encryption keys are generated based on our private key and the peer's public key, which is either known in advance from the configuration or received from other network nodes. In the UDP version of ADNL, the connection is established simultaneously with the reception of initial data from the peer. If the initiator sends a create channel message, the channel’s key will be calculated, and the channel's creation will be confirmed. Once the channel is established, further communication continues within it. Packet structure and communication​ First packets​ Let's analyze the connection initialization with the DHT node and obtain a signed list of its addresses to understand how the protocol functions. Find a node you prefer in the global config, specifically in the dht.nodes section. For example: { \"@type\": \"dht.node\", \"id\": { \"@type\": \"pub.ed25519\", \"key\": \"fZnkoIAxrTd4xeBgVpZFRm5SvVvSx7eN3Vbe8c83YMk=\" }, \"addr_list\": { \"@type\": \"adnl.addressList\", \"addrs\": [ { \"@type\": \"adnl.address.udp\", \"ip\": 1091897261, \"port\": 15813 } ], \"version\": 0, \"reinit_date\": 0, \"priority\": 0, \"expire_at\": 0 }, \"version\": -1, \"signature\": \"cmaMrV/9wuaHOOyXYjoxBnckJktJqrQZ2i+YaY3ehIyiL3LkW81OQ91vm8zzsx1kwwadGZNzgq4hI4PCB/U5Dw==\"} Let's take the ed25519 key, fZnkoIAxrTd4xeBgVpZFRm5SvVvSx7eN3Vbe8c83YMk, and decode it from base64. Next, we will take its IP address, 1091897261, and convert it into a readable format using this service or by converting it to little-endian bytes. This will give us the IP address 65.21.7.173. Finally, we will combine this IP address with the port to obtain 65.21.7.173:15813 and establish a UDP connection. We aim to establish a communication channel with the node to obtain specific information, particularly a list of signed addresses. To achieve this, we will generate two messages. The first message will be to create the channel (see the code): adnl.message.createChannel key:int256 date:int = adnl.Message We have two parameters to consider: a key and a date. The date will be represented by the current Unix timestamp. For the key, we need to generate a new ed25519 private and public key pair specifically for the channel. This key pair will be used to initialize the public encryption key, as outlined in the link here. We will use the generated public key as the value for the key parameter in the message, while we will store the private key for future use. Next, we will serialize the populated TL structure to get the final result: bbc373e6 -- TL ID adnl.message.createChanneld59d8e3991be20b54dde8b78b3af18b379a62fa30e64af361c75452f6af019d7 -- key555c8763 -- date Next, let's proceed to our main query - retrieve a list of addresses. To execute it, we first need to serialize its TL structure: dht.getSignedAddressList = dht.Node There are no parameters to consider, so we will simply serialize it. The result will be just its ID: ed4879a9. Next, since this is a higher-level request within the DHT protocol, we must first wrap it in an adnl.message.query TL structure: adnl.message.query query_id:int256 query:bytes = adnl.Message We generate a random 32 bytes for query_id, and the query represents our main request, wrapped as an array of bytes: 7af98bb4 -- TL ID adnl.message.queryd7be82afbc80516ebca39784b8e2209886a69601251571444514b7f17fcd8875 -- query_id04 ed4879a9 000000 -- query Building the packet​ All communication is conducted using packets, which contain the following structure: TL structure: adnl.packetContents rand1:bytes -- random 7 or 15 bytes flags:# -- bit flags, used to determine the presence of fields further from:flags.0?PublicKey -- sender's public key from_short:flags.1?adnl.id.short -- sender's ID message:flags.2?adnl.Message -- message (used if there is only one message) messages:flags.3?(vector adnl.Message) -- messages (if there are > 1) address:flags.4?adnl.addressList -- list of our addresses priority_address:flags.5?adnl.addressList -- priority list of our addresses seqno:flags.6?long -- packet sequence number confirm_seqno:flags.7?long -- sequence number of the last packet received recv_addr_list_version:flags.8?int -- address version recv_priority_addr_list_version:flags.9?int -- priority address version reinit_date:flags.10?int -- connection reinitialization date (counter reset) dst_reinit_date:flags.10?int -- connection reinitialization date from the last received packet signature:flags.11?bytes -- signature rand2:bytes -- random 7 or 15 bytes = adnl.PacketContents Once we have serialized all the messages we wish to send, we can begin building the packet. Packets sent to a channel have a different content structure compared to packets sent before the channel is initialized. First, let’s examine the main packet used for initialization. During the initial data exchange, before the channel is established, the packet's serialized content structure is prefixed with the peer's public key, which is 32 bytes. Our public key is also 32 bytes, and the SHA-256 hash of the serialized TL of the packet's content structure is another 32 bytes. The content of the packet is encrypted using the shared key, which is derived from our private key and the public key of the server. Let's serialize the structure of our packet content and parse it byte by byte: 89cd42d1 -- TL ID adnl.packetContents0f 4e0e7dd6d0c5646c204573bc47e567 -- rand1, 15 (0f) random bytesd9050000 -- flags (0x05d9) -> 0b0000010111011001 -- from (present because flag's zero bit = 1)c6b41348 -- TL ID pub.ed25519 afc46336dd352049b366c7fd3fc1b143a518f0d02d9faef896cb0155488915d6 -- key:int256 -- messages (present because flag's third bit = 1)02000000 -- vector adnl.Message, size = 2 messages bbc373e6 -- TL ID adnl.message.createChannel d59d8e3991be20b54dde8b78b3af18b379a62fa30e64af361c75452f6af019d7 -- key 555c8763 -- date (date of creation) 7af98bb4 -- TL ID [adnl.message.query](/) d7be82afbc80516ebca39784b8e2209886a69601251571444514b7f17fcd8875 -- query_id 04 ed4879a9 000000 -- query (bytes size 4, padding 3) -- address (present because flag's fourth bit = 1), without TL ID since it is specified explicitly00000000 -- addrs (empty vector, because we are in client mode and do not have an address on wiretap)555c8763 -- version (usually initialization date)555c8763 -- reinit_date (usually initialization date)00000000 -- priority00000000 -- expire_at0100000000000000 -- seqno (present because flag's sixth bit = 1)0000000000000000 -- confirm_seqno (present because flag's seventh bit = 1)555c8763 -- recv_addr_list_version (present because flag's eighth bit = 1, usually initialization date)555c8763 -- reinit_date (present because flag's tenth bit = 1, usually initialization date)00000000 -- dst_reinit_date (present because flag's tenth bit = 1)0f 2b6a8c0509f85da9f3c7e11c86ba22 -- rand2, 15 (0f) random bytes After serialization, we need to sign the resulting byte array using our private client's key, specifically ed25519, which we generated and saved earlier. Once we have created the signature (which is 64 bytes in size), we must add it to the packet and serialize it again. This time, we will also set the 11th bit in the flag to indicate the presence of the signature: 89cd42d1 -- TL ID adnl.packetContents0f 4e0e7dd6d0c5646c204573bc47e567 -- rand1, 15 (0f) random bytesd90d0000 -- flags (0x0dd9) -> 0b0000110111011001 -- from (present because flag's zero bit = 1)c6b41348 -- TL ID pub.ed25519 afc46336dd352049b366c7fd3fc1b143a518f0d02d9faef896cb0155488915d6 -- key:int256 -- messages (present because flag's third bit = 1)02000000 -- vector adnl.Message, size = 2 message bbc373e6 -- TL ID adnl.message.createChannel d59d8e3991be20b54dde8b78b3af18b379a62fa30e64af361c75452f6af019d7 -- key 555c8763 -- date (date of creation) 7af98bb4 -- TL ID adnl.message.query d7be82afbc80516ebca39784b8e2209886a69601251571444514b7f17fcd8875 -- query_id 04 ed4879a9 000000 -- query (bytes size 4, padding 3) -- address (present because flag's fourth bit = 1), without TL ID since it is specified explicitly00000000 -- addrs (empty vector, because we are in client mode and do not have an address on wiretap)555c8763 -- version (usually initialization date)555c8763 -- reinit_date (usually initialization date)00000000 -- priority00000000 -- expire_at0100000000000000 -- seqno (present because flag's sixth bit = 1)0000000000000000 -- confirm_seqno (present because flag's seventh bit = 1)555c8763 -- recv_addr_list_version (present because flag's eighth bit = 1, usually initialization date)555c8763 -- reinit_date (present because flag's tenth bit = 1, usually initialization date)00000000 -- dst_reinit_date (present because flag's tenth bit = 1)40 b453fbcbd8e884586b464290fe07475ee0da9df0b8d191e41e44f8f42a63a710 -- signature (present because flag's eleventh bit = 1), (bytes size 64, padding 3) 341eefe8ffdc56de73db50a25989816dda17a4ac6c2f72f49804a97ff41df502 -- 000000 --0f 2b6a8c0509f85da9f3c7e11c86ba22 -- rand2, 15 (0f) random bytes We now have an assembled, signed, and serialized packet, which consists of an array of bytes. Next, we need to calculate the packet's SHA-256 hash, allowing the recipient to verify its integrity later. For instance, let’s say the hash is 408a2a4ed623b25a2e2ba8bbe92d01a3b5dbd22c97525092ac3203ce4044dcd2. Now, we will encrypt the contents of our packet using the AES-CTR cipher, utilizing the shared key that is derived ",
    "category": "general",
    "tags": [
      "ton",
      "func",
      "wallet",
      "telegram",
      "mini app",
      "builder",
      "address",
      "message",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:38:04.259Z"
  },
  {
    "id": "docs-ton-org--v3-documentation-network-protocols-dht-overview",
    "title": "Overview",
    "url": "https://docs.ton.org/v3/documentation/network/protocols/dht/overview",
    "content": "Skip to main contentDeprecated! Please, visit the new documentation at docs.ton.org Deprecated, go to new docs!On this pageOverview The Kademlia-like Distributed Hash Table (DHT) plays a crucial role in the networking aspect of the TON project, enabling the discovery of other nodes within the network. The keys used in the TON DHT are 256-bit integers, often derived from a SHA256 of a TL-serialized object. The values associated with these 256-bit keys are essentially arbitrary byte strings of limited length. The meaning of these byte strings is determined by the pre-image of the corresponding key; this is typically known by both the node performing the key lookup and the node storing the key. In its simplest form, the key represents an ADNL address of a node, while the value could be its IP address and port. The key-value mappings of the TON DHT are maintained on the DHT nodes. DHT nodes​ Each DHT node has a 256-bit DHT address. Unlike an ADNL address, a DHT address should not change too frequently; otherwise, other nodes will be unable to locate the keys they are searching for. The value of key K is expected to be stored on the S Kademlia-nearest nodes to K. Kademlia distance is calculated by performing a 256-bit XOR operation between the key X and the 256-bit DHT node address. This distance does not relate to geographic location. S is a small parameter, for instance, S = 7, which helps improve the reliability of the DHT. If the key were stored only on a single node (the nearest one to K) the value of that key would be lost if that node were to go offline. Kademlia routing table​ A node participating in a DHT typically maintains a Kademlia routing table. This table consists of 256 buckets, numbered from 0 to 255. The i-th bucket contains information about known nodes that lie within a Kademlia distance from 2^i to 2^(i+1) − 1 from the node’s address a. Each bucket holds a fixed number of the “best” nodes, along with some additional candidate nodes. The information stored in these buckets includes the DHT addresses, IP addresses, UDP ports, and availability details, such as the time and delay of the last ping. When a Kademlia node discovers another Kademlia node through a query, it places that node into the appropriate bucket as a candidate. If some of the “best” nodes in that bucket become unresponsive (for example, if they do not reply to ping queries for an extended period), they can be replaced by some of these candidates. This process ensures that the Kademlia routing table remains populated. Key-value pairs​ Key-value pairs can be added and updated in the TON DHT. The rules for these updates can vary. In some cases, they allow for the old value to be replaced with a new one as long as the new value is signed by the owner or creator. This signature must be retained as part of the value so that it can be verified later by any other nodes that receive this key's value. In other cases, the old value impacts the new value in some way. For example, the old value may contain a sequence number, and it can only be overwritten if the new sequence number is larger. This helps prevent replay attacks. The TON DHT is not only used to store the IP addresses of ADNL nodes; it also serves other purposes. It can store a list of addresses of nodes that are holding a specific torrent in TON Storage, a list of addresses of nodes included in an overlay subnetwork, ADNL addresses of TON services, and ADNL addresses of accounts on the TON Blockchain, among others. infoLearn more about TON DHT in Deep dive documentation, or in Chapter 3.2. of the TON Whitepaper. See also​ DHT DHT Server Was this article useful?YesNoEdit this pageLast updated on Sep 5, 2025 by Anthony TsivarevDHT nodesKademlia routing tableKey-value pairsSee alsoUseGet a WalletGet ToncoinStakeAccept PaymentsApps & ServicesDomainsUSDT on TONCross-Chain BridgesLearnTON ConceptDecentralized NetworkRoadmapTonStatHistory of MiningToncoinValidatorsWhite PaperBrand AssetsSustainabilityFor BuildersTON Builders PortalGetting StartedDocumentationTelegram Mini AppsDev ChatsBug BountyFind a JobFind a TalentUse CasesGameFiMemecoins & TokensCommunity ToolsTON SitesCommunityCommunitiesBlogCareers",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "wallet",
      "telegram",
      "mini app",
      "builder",
      "address",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:38:05.541Z"
  },
  {
    "id": "docs-ton-org--v3-documentation-network-protocols-rldp",
    "title": "RLDP",
    "url": "https://docs.ton.org/v3/documentation/network/protocols/rldp",
    "content": "Skip to main contentDeprecated! Please, visit the new documentation at docs.ton.org Deprecated, go to new docs!On this pageRLDP Please see the implementations: RLDP Part 1 RLDP Part 2 RLDP HTTP Proxy Overview​ The Reliable Large Datagram Protocol (RLDP) operates on top of the ADNL UDP protocol and is designed for transferring large data blocks. It incorporates Forward Error Correction (FEC) algorithms, which allow it to replace acknowledgment packets typically sent from the receiver back to the sender. This capability enables more efficient data transfer between network components, although it results in increased traffic consumption. RLDP plays a crucial role throughout the TON infrastructure. It is used for various purposes, such as downloading blocks from other nodes, transferring data to those nodes, and accessing TON websites and TON Storage. Protocol​ RLDP utilizes the following TL structures for communication: fec.raptorQ data_size:int symbol_size:int symbols_count:int = fec.Type;fec.roundRobin data_size:int symbol_size:int symbols_count:int = fec.Type;fec.online data_size:int symbol_size:int symbols_count:int = fec.Type;rldp.messagePart transfer_id:int256 fec_type:fec.Type part:int total_size:long seqno:int data:bytes = rldp.MessagePart;rldp.confirm transfer_id:int256 part:int seqno:int = rldp.MessagePart;rldp.complete transfer_id:int256 part:int = rldp.MessagePart;rldp.message id:int256 data:bytes = rldp.Message;rldp.query query_id:int256 max_answer_size:long timeout:int data:bytes = rldp.Message;rldp.answer query_id:int256 data:bytes = rldp.Message; The serialized structure is encapsulated in the adnl.message.custom TL schema and transmitted over ADNL UDP. RLDP transfers are utilized for sending large amounts of data. A random transfer_id is generated, and the data is then processed using the FEC algorithm. The resulting segments are wrapped in a rldp.messagePart structure and sent to the peer until the peer responds with rldp.complete or a timeout occurs. Once the receiver has gathered the necessary rldp.messagePart pieces to reconstruct the complete message, it concatenates them, decodes them using FEC, and then deserializes the resulting byte array into either an rldp.query or rldp.answer structure, depending on the type indicated by the tl prefix id. FEC​ Valid Forward Error Correction (FEC) algorithms suitable for RLDP include RoundRobin, Online, and RaptorQ. Currently, RaptorQ is used for data encoding. RaptorQ​ The core concept of RaptorQ is the division of data into symbols, which are blocks of a fixed, predetermined size. These blocks are organized into matrices, where discrete mathematical operations are performed. This process enables the creation of an almost limitless number of symbols from the same original data. All the generated symbols are combined and sent to the recipient, allowing for the recovery of lost packets without the need for additional requests to the server. This method uses fewer packets than would be required if the same pieces of data were sent repeatedly. The symbols are transmitted to the peer until they confirm that all data has been received and successfully restored (decoded) by applying the same discrete operations. [Please see implementation example of RaptorQ in Golang]. RLDP-HTTP​ To interact with TON Sites, the RLDP (Reverse Lightweight Data Protocol) is used to wrap HTTP requests. The host sets up their site on any standard HTTP web server and runs rldp-http-proxy alongside it. All incoming requests from the TON network are directed to the proxy via the RLDP protocol. The proxy then converts these requests into standard HTTP format and calls the original web server locally. On the user's side, they launch a proxy, such as Tonutils Proxy, to access the .ton sites. All traffic is wrapped in the reverse order: requests are sent to the local HTTP proxy, which then forwards them via RLDP to the remote TON site. HTTP communication within RLDP is structured using TL formats: http.header name:string value:string = http.Header;http.payloadPart data:bytes trailer:(vector http.header) last:Bool = http.PayloadPart;http.response http_version:string status_code:int reason:string headers:(vector http.header) no_payload:Bool = http.Response;http.request id:int256 method:string url:string http_version:string headers:(vector http.header) = http.Response;http.getNextPayloadPart id:int256 seqno:int max_chunk_size:int = http.PayloadPart; This is not pure HTTP in text form; everything is wrapped in a binary TL and unwrapped before being sent to the web server or browser by the proxy itself. The scheme of work is as follows: Client sends http.request The server checks the Content-Length header when receiving a request If not 0, sends a http.getNextPayloadPart request to the client When receiving a request, the client sends http.payloadPart - the requested body piece depending on seqno and max_chunk_size. The server repeats requests, incrementing seqno, until it receives all the chunks from the client, i.e. until the last:Bool field of the last chunk received is true. After processing the request, the server sends http.response, the client checks the Content-Length header If it is not 0, then sends a http.getNextPayloadPart request to the server, and the operations are repeated, as in the case of the client but vice-versa. Request the TON site​ To understand how RLDP works, let's look at an example of getting data from the TON site foundation.ton. Assuming say we have already got its ADNL address by calling the Get method of the NFT-DNS contract, determined the address and port of the RLDP service using DHT, and connected to it over ADNL UDP. Send a GET request to foundation.ton​ To accomplish this, please complete the following structure: http.request id:int256 method:string url:string http_version:string headers:(vector http.header) = http.Response; Serialize http.request by filling in the fields: e191b161 -- TL ID http.request 116505dac8a9a3cdb464f9b5dd9af78594f23f1c295099a9b50c8245de471194 -- id = {random}03 474554 -- method = string `GET`16 687474703a2f2f666f756e646174696f6e2e746f6e2f 00 -- url = string `http://foundation.ton/`08 485454502f312e31 000000 -- http_version = string `HTTP/1.1`01000000 -- headers (1) 04 486f7374 000000 -- name = Host 0e 666f756e646174696f6e2e746f6e 00 -- value = foundation.ton Now let's wrap our serialized http.request into rldp.query and serialize it too: 694d798a -- TL ID rldp.query184c01cb1a1e4dc9322e5cabe8aa2d2a0a4dd82011edaf59eb66f3d4d15b1c5c -- query_id = {random}0004040000000000 -- max_answer_size = 257 KB, can be any sufficient size that we accept as headers258f9063 -- timeout (unix) = 167041821334 e191b161116505dac8a9a3cdb464f9b5dd9af78594f23f1c295099a9b50c8245 -- data (http.request) de4711940347455416687474703a2f2f666f756e646174696f6e2e746f6e2f00 08485454502f312e310000000100000004486f73740000000e666f756e646174 696f6e2e746f6e00 000000 Encoding and sending packets​ We now need to apply the FEC RaptorQ algorithm to our data. First, we will create an encoder, which requires us to convert the resulting byte array into symbols of a fixed size. In this case, the symbol size is 768 bytes. To achieve this, we'll divide the array into segments of 768 bytes each. If the last segment is smaller than 768 bytes, we will pad it with zero bytes to reach the required size. Our current array is 156 bytes long, which means it will consist of only one segment. To make it 768 bytes, we need to add 612 zero bytes for padding. Additionally, the constants chosen for the encoder depend on the data size and the symbol size. For more detailed information, you can refer to the RaptorQ documentation. However, to simplify the process and avoid complex mathematical calculations, we recommend using a pre-existing library that implements this encoding. Please see the examples: [Example of creating an encoder] [Symbol encoding example] Symbols are encoded and transmitted in a round-robin manner. We start with an initial sequence number, seqno, set to 0, and increment it by 1 for each subsequent encoded packet. For instance, if we have two symbols, we first encode and send the first symbol, then increase seqno by 1. Next, we encode and send the second symbol and again increase seqno by 1. After that, we return to the first symbol and increment seqno (which is now 2) by another 1. This process continues until we receive a message indicating that the peer has accepted the data. Having created the encoder, we are now ready to send data. To do this, we will fill in the TL schema: fec.raptorQ data_size:int symbol_size:int symbols_count:int = fec.Type;rldp.messagePart transfer_id:int256 fec_type:fec.Type part:int total_size:long seqno:int data:bytes = rldp.MessagePart; transfer_id - random int256, the same for all messageParts within the same data transfer. fec_type is fec.raptorQ. data_size = 156 symbol_size = 768 symbols_count = 1 part in our case always 0, can be used for transfers that hit the size limit. total_size = 156. The size of our transfer data. seqno - for the first packet will be equal to 0, and for each subsequent packet it will increase by 1, will be used as parameter to decode and encode symbol. data - our encoded symbol, 768 bytes in size. After serializing rldp.messagePart, wrap it in adnl.message.custom and send it over ADNL UDP. We will send packets in a continuous loop, incrementing the seqno each time, until we either receive the rldp.complete message from the peer or reach a timeout. Once we have sent a number of packets equal to the number of our symbols, we can slow down the transmission and send additional packets, for example, once every 10 milliseconds or even less frequently. These extra packets are intended for recovery in case of data loss, as UDP is a fast but unreliable protocol. [Please see implementation example]. Processing the response from foundation.ton​ During the sending process, we can expect a response from the server. In our case, we",
    "category": "general",
    "tags": [
      "ton",
      "func",
      "wallet",
      "nft",
      "telegram",
      "mini app",
      "builder",
      "address",
      "message",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:38:08.218Z"
  },
  {
    "id": "docs-ton-org--v3-documentation-network-protocols-overlay",
    "title": "Custom overlays",
    "url": "https://docs.ton.org/v3/documentation/network/protocols/overlay",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeOverviewRun a node with MyTonCtrlRun a validatorIntegrate MyTonCtrl with PrometheusSetting up a local blockchain using MyLocalTonMyTonCtrl referenceOverviewCoreInstallerWalletValidatorCollatorNominator poolsLiquid stakingCustom overlaysUtilitiesTelegram alertingBackupBTC TeleportStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationMyTonCtrl referenceCustom overlaysEcosystemBlockchain nodeMyTonCtrl referenceCustom overlaysCopy pageSets up a custom overlay to speed up synchronization for a group of nodes.Copy page​Operational notes Overlays require MyTonCtrl to run in validator mode with an accessible validator console; the commands rely on console RPCs (addcustomoverlay, showcustomoverlays, delcustomoverlay). Keep ADNL IDs in the configuration consistent with the node’s current validator keys. The helper refuses to deploy static overlays when the node lacks the necessary IDs. Dynamic overlays are re-evaluated each election. MyTonCtrl automatically removes stale overlays tied to old election IDs and creates new ones as rounds roll over. ​add_custom_overlay Purpose: Register a custom overlay configuration and deploy it to the validator console. Syntax CopyAsk AIadd_custom_overlay <overlay-name> <path-to-config> Behavior <overlay-name> is an arbitrary label used inside MyTonCtrl and as the validator-console overlay name. <path-to-config> must point to a JSON file describing overlay nodes. Each key is an ADNL address (hex) and each value specifies whether the node is a block_sender or msg_sender (msg_sender entries may include a msg_sender_priority). Configuration files can include an @validators key to denote dynamic overlays. In that case, MyTonCtrl stores the config and schedules validator-console updates for the current and next election rounds. Static overlays are converted immediately via addcustomoverlay and require that your node owns the listed ADNL IDs; otherwise, the command prints an error. MyTonCtrl caches the config in its database, so overlays persist across restarts. Example CopyAsk AIadd_custom_overlay telemetry-overlay /etc/mytonctrl/overlays/telemetry.json ​Sample config structure CopyAsk AI{ \"3b53...d1\": { \"block_sender\": true }, \"@validators\": [\"0a1f...bc\", \"292e...7a\"], \"7c9d...4e\": { \"msg_sender\": true, \"msg_sender_priority\": 5 } } Keys other than @validators must be ADNL IDs in hex form. For msg_sender entries, set msg_sender to true and optionally include msg_sender_priority (higher numbers mean higher priority). Include @validators only when you want the overlay to track the current validator set automatically. ​list_custom_overlays Purpose: Inspect every overlay definition stored by MyTonCtrl. Syntax CopyAsk AIlist_custom_overlays Behavior Prints each overlay name and the JSON configuration saved in the local database. Highlights whether an overlay is dynamic (@validators present) or static. Helpful for auditing definitions before deploying them on another node. ​delete_custom_overlay Purpose: Remove a stored overlay and, when possible, detach it from the validator console. Syntax CopyAsk AIdelete_custom_overlay <overlay-name> Behavior Deletes <overlay-name> from the MyTonCtrl database. If the overlay was dynamic (tracked via @validators), the validator console updates within ~1 minute to remove it automatically. For static overlays, MyTonCtrl issues delcustomoverlay <overlay-name> so the validator console stops broadcasting it immediately. If the console rejects the operation, the command reports an error so you can intervene manually. Example CopyAsk AIdelete_custom_overlay telemetry-overlay Was this page helpful?YesNoSuggest editsRaise issuePreviousUtilitiesUtility commands provide quick inspection and helper tools for accounts, bookmarks, governance artifacts, and validator data.Next⌘IgithubxtelegramPowered by MintlifyOn this pageOperational notesadd_custom_overlaySample config structurelist_custom_overlaysdelete_custom_overlay",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:38:10.494Z"
  },
  {
    "id": "docs-ton-org--v3-documentation-faq",
    "title": "Get support",
    "url": "https://docs.ton.org/v3/documentation/faq",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationGet supportGet supportCopy pageCopy page​Chats, forums, and Telegram bots https://t.me/tondev_eng - the official TON Developers chat. https://t.me/tondev - the Russian-speaking TON Developers chat. https://t.me/ton_help_bot - support for TON Core products for users (bridge, vesting, multisig, etc). Zendesk + Telegram Bot. https://t.me/toncenter_help_bot - public Ton Center API support, Zendesk + Telegram Bot. https://t.me/validators_help_bot - public support for validators, Zendesk + Telegram Bot. https://t.me/ton_node_help - public chat group for blockchain node administrators. ​Builders portal https://builders.ton.org - main entry point for projects. ​TON Hubs https://builders.ton.org/opportunities/hubs - regional communities of builders. ​Security audit firms, agencies, and freelancers https://ton.org/en/talents - open database aims to connect teams willing to build products on TON with skilled professionals and agencies. https://ton.org/en/talents?Auditors - security auditors for smart contracts and TON-based applications. ​Bug bounty programs https://github.com/ton-blockchain/bug-bounty - TON Blockchain bug bounty program. https://t.me/ton_bugs_bot - security bug bounty, Telegram Bot. https://hackenproof.com/programs/ton-society - Websites, web apps, and mini apps operated by TON Society. Was this page helpful?YesNoSuggest editsRaise issuePreviousComing from EthereumNext⌘IgithubxtelegramPowered by MintlifyOn this pageChats, forums, and Telegram botsBuilders portalTON HubsSecurity audit firms, agencies, and freelancersBug bounty programs",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:38:13.487Z"
  },
  {
    "id": "docs-ton-org--v3-documentation-network-config-params-extra-currency",
    "title": "Extra currency minting",
    "url": "https://docs.ton.org/v3/documentation/network/config-params/extra-currency",
    "content": "Skip to main contentDeprecated! Please, visit the new documentation at docs.ton.org Deprecated, go to new docs!On this pageExtra currency minting Extracurrency​ According to TON Blockchain Whitepaper 3.1.6, the TON Blockchain allows users to create arbitrary cryptocurrencies or tokens, in addition to the Toncoin, provided certain conditions are met. These additional cryptocurrencies are identified by 32-bit currency_ids. The list of these defined cryptocurrencies is a part of the blockchain configuration stored in the MasterChain. Each internal message and account balance includes a special field for ExtraCurrencyCollection, which is a set of extracurrencies attached to a message or maintained in a balance: extra_currencies$_ dict:(HashmapE 32 (VarUInteger 32)) = ExtraCurrencyCollection;currencies$_ grams:Grams other:ExtraCurrencyCollection = CurrencyCollection; Extracurrency config​ A dictionary, specifically ExtraCurrencyCollection, containing all currencies to be minted is stored in ConfigParam7: _ to_mint:ExtraCurrencyCollection = ConfigParam 7; ConfigParam 6 contains data related to the minting: _ mint_new_price:Grams mint_add_price:Grams = ConfigParam 6; ConfigParam2 contains the address of minter. Low-level minting flow​ In each block, the collator compares the old global balance (the global balance of all currencies at the end of the previous block) with ConfigParam7. If any amount for any currency in ConfigParam7 is less than it is in the global balance, the config is invalid. If any amount of any currency in ConfigParam7 is higher than it is in the global balance, a minting message will be created. This minting message has source -1:0000000000000000000000000000000000000000000000000000000000000000 and minter from ConfigParam2 as destination and contains excesses of extracurrencies in ConfigParam7 over the old global balance. The problem here is that the minting message includes only additional currencies and no Toncoins. As a result, even if the Minter is designated as a fundamental smart contract (as indicated in ConfigParam31), a minting message will lead to an aborted transaction with the error: compute_ph:(tr_phase_compute_skipped reason:cskip_no_gas). High-level minting flow​ One possible high-level minting flow, which is implemented here (check *.tolk files) is as follows: There is ExtraCurrencyAuthorizationConfig: the config contains information on which contracts (addresses) have authorization to request minter to mint new extracurrencies. This config has the following scheme: _ (Hashmap 32 std_addr) = ExtraCurrencyAuthorizationConfig; where key - currency_id and std_addr is admin of this currency (can be in any WorkChain). Minter accepts mint requests from admins, forwards requests for mint to config, config updates ConfigParam 7, and responds to minter. Since extracurrencies would be minted to minter only on the next MasterChain block, withdrawing extra currencies to admin should be delayed. It is done via echo smart-contract, not in MasterChain. When a response from echo comes to minter, it sends extracurrencies to admin. So the scheme is as follows: Admin -> Minter -> Config -> Minter -> Echo (in other workchain to wait until the next masterchain block) -> Minter -> Admin An example of this flow is as follows: minting 2'000'000'000 units of currency_id=100 dangerEach minting of new extracurrency or an increase in the supply of existing currency necessitates a change to ConfigParam7, which in turn alters the configuration and creation of keyblocks. Frequent keyblock generation can slow down shard performance since each key block causes a rotation of validator groups and affects the synchronization of liteclients. Therefore, contracts like swap.tolk should not be utilized in production environments. Instead, it is advisable to use schemes that involve reserves to minimize minting events. infoSending of extracurrency to blackhole has the following effect: extracurrency amount is burnt, but since ConfigParam7 is not changed, on the next block, minter will receive the burnt amount on its balance. How to mint your own extracurrency​ Ensure that your network has the minter contract and that ConfigParam2 and ConfigParam6 are set correctly. Create a currency admin contract that will control how the extra currency is minted. Submit a proposal to the validators to add your currency admin contract address to the ExtraCurrencyAuthorizationConfig for a specific currency_id and obtain their approval. Send a mint request from the currency admin contract to the minter. Wait for the minter to return the extra currency. Was this article useful?YesNoEdit this pageLast updated on Sep 5, 2025 by Anthony TsivarevExtracurrencyExtracurrency configLow-level minting flowHigh-level minting flowHow to mint your own extracurrencyUseGet a WalletGet ToncoinStakeAccept PaymentsApps & ServicesDomainsUSDT on TONCross-Chain BridgesLearnTON ConceptDecentralized NetworkRoadmapTonStatHistory of MiningToncoinValidatorsWhite PaperBrand AssetsSustainabilityFor BuildersTON Builders PortalGetting StartedDocumentationTelegram Mini AppsDev ChatsBug BountyFind a JobFind a TalentUse CasesGameFiMemecoins & TokensCommunity ToolsTON SitesCommunityCommunitiesBlogCareers",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "smart contract",
      "wallet",
      "telegram",
      "mini app",
      "transaction",
      "builder",
      "address",
      "message",
      "gas",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:38:18.222Z"
  },
  {
    "id": "docs-ton-org--v3-contribute-",
    "title": "How to contribute",
    "url": "https://docs.ton.org/v3/contribute/",
    "content": "Skip to main contentDeprecated! Please, visit the new documentation at docs.ton.org Deprecated, go to new docs!On this pageHow to contribute infoLearn how to submit content to TON Documentation here. Contribution guidelines​ Documentation maintainer community​ TON Documentation is entirely open source. Community enthusiasts and early TON contributors have played a key role in creating this open source TON documentation by turning their notes into detailed pages. It was initially written by TON contributors and supported by TON Studio. We aim to educate users about TON through explicit, easily searchable content that appeals to technical experts and casual readers. How to contribute​ Clone the current version from the ton-docs GitHub repository. Choose an area to contribute according to the Style guide and open a related issue. Familiarize yourself with Content standardization and Typography. Before submitting your pull request, complete and verify each milestone in the description checklist. Open a pull request against the main branch with a clear description and concise updates according to the template. Pull request template​ ## DescriptionBrief description of the changes introduced in this pull request. Include any relevant issue numbers or links.Closes [link to issue].## Checklist- [ ] I have created an issue.- [ ] I am working on content that aligns with the [Style guide](https://docs.ton.org/v3/contribute/style-guide/).- [ ] I have reviewed and formatted the content according to [Content standardization](https://docs.ton.org/v3/contribute/content-standardization/).- [ ] I have reviewed and formatted the text in the article according to [Typography](https://docs.ton.org/v3/contribute/typography/). infoTo avoid excessive rework, read the contribution guidelines in the Style guide, Content standardization, and Typography before contributing. Don't worry about minor issues; maintainers will help you fix them during the review process. Development​ Learn the documentation development flow from the ton-docs/README.md document. Best practices for pull requests​ Keep your pull request small. Minor pull requests (~300 lines of diff) are easier to review and more likely to get merged. Make sure the pull request does only one thing; otherwise, please split it. Use descriptive titles. It would be best to follow the commit message style. Build locally and ensure it succeeds without crashes. Use soft wrap: Don't wrap lines at 80 characters; configure your editor to soft wrap. Communicate with other developers​ Get familiar with frequently asked questions in the TON Developers chat. Ask questions related to TON documentation in the TON Docs Club chat in Telegram. Create an issue with your ideas for improvements. Find and take available bounties for the documentation. See ton-docs on GitHub. See also​ Style guide Typography Edit this pageLast updated on Sep 5, 2025 by AlexGContribution guidelinesDocumentation maintainer communityHow to contributeDevelopmentCommunicate with other developersSee alsoUseGet a WalletGet ToncoinStakeAccept PaymentsApps & ServicesDomainsUSDT on TONCross-Chain BridgesLearnTON ConceptDecentralized NetworkRoadmapTonStatHistory of MiningToncoinValidatorsWhite PaperBrand AssetsSustainabilityFor BuildersTON Builders PortalGetting StartedDocumentationTelegram Mini AppsDev ChatsBug BountyFind a JobFind a TalentUse CasesGameFiMemecoins & TokensCommunity ToolsTON SitesCommunityCommunitiesBlogCareers",
    "category": "general",
    "tags": [
      "ton",
      "wallet",
      "telegram",
      "mini app",
      "guide",
      "builder",
      "message",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:38:19.253Z"
  },
  {
    "id": "docs-ton-org--v3-contribute-style-guide",
    "title": "Documentation style guide",
    "url": "https://docs.ton.org/v3/contribute/style-guide",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationContributeDocumentation style guideContributeDocumentation style guideCopy pageCopy pageThis guide covers the basics: how to structure pages, write examples, and keep docs consistent and safe. ​Write for the reader Default audience: experienced software developers new to blockchain. Explain TON-specific concepts. Do not re-teach general programming. This keeps pages focused. Be answer‑first. Start with what the reader will achieve, what they need, and the steps. This shortens the time to success. Lead with a working example. Show a copy‑pasteable snippet early and the expected output. This shows it works. Use a neutral, precise tone. Write in the present tense, active voice, and second person (“Run the node”). This makes actions clear. Avoid marketing or hype (“blazingly fast”, “seamless”, “revolutionary”) and vague praise. Prefer measurable facts or omit the claim. Keep it scannable. Use short sections and paragraphs, clear headings, lists, and tables. Most readers skim to find the next action. Aim for one main idea per sentence. Split long, multi‑clause sentences or turn them into lists. Use bold only for a few scan‑worthy words in a paragraph, not full sentences or tokens. If a skimming reader loses nothing when the bold is removed, drop it. Use italics for new or defined terms and subtle emphasis; use bold for words a skimming reader should find quickly. Draft in plain text first. During editing, add minimal emphasis and remove any styling that does not change meaning. ​Page types Step-by-step guides — for beginners; handhold from zero to first success on one happy path; explain from scratch, define terms, and link out for depth. How-tos — a focused recipe for a specific outcome; assume concepts known and show only what’s needed. Explanation — concepts, architecture, and trade‑offs; clarify why and when, with minimal examples. Reference — exact, complete facts (APIs, CLI, types, errors); stable anchors and minimal prose. Don’t mix types on the same page. ​Where pages go Keep the flow linear; follow the docs.json sidebar. In each topic group, order pages: Explanation → How‑to → Reference. Canonical specs — reference/. Link to it; don’t duplicate tables or parameters. ​Structure pages for success Start with Objective and Prerequisites so readers know they’re in the right place. Use Prerequisites for things the reader must have or have done; use an Audience note for skills or knowledge. Make each step a single action; use sub‑bullets for options. Include Verify and Troubleshoot so readers can confirm success and fix common errors. End with Next steps / See also only if essential (1–3 links). Prefer a linear path that needs no extra navigation. ​Examples that run Make commands copy‑pasteable. Do not include shell prompts like $ or >. Prompts break commands when pasted. Separate command and output. Use two fenced blocks. Mixing them causes copy errors. Use <ANGLE_CASE> placeholders in commands and prose and define each on first use (for example, <RPC_URL>). In code, use UPPER_SNAKE if < > clashes with syntax. One clear convention prevents hard‑coded values from slipping in. Tag code fences with a language (bash, json, rust, and so on). This enables correct highlighting and tooling. Prefer end‑to‑end examples on testnet by default. Safe defaults encourage trying the steps. Label partial snippets as Not runnable and link to a complete example. Do not hard‑wrap long commands. Use soft wrap in the UI or safe continuation if the shell supports it. Hard wraps break execution. For UI buttons, menu items, and key names, wrap the label in <kbd>…</kbd> instead of quotes or bold. This keeps controls easy to spot and consistent with the main style guide. Good CopyAsk AIton-node start --ledger <LEDGER_DIR> --network testnet Expected output CopyAsk AINode started. Workchain: 0 Shard: -1 Status: running Define placeholders <LEDGER_DIR> — local ledger directory. <RPC_URL> — HTTPS endpoint of your TON RPC provider. ​Safety warnings Add a Caution or Warning when a step moves funds, changes fees or withdrawals, exposes or stores private keys or mnemonics, modifies validator or network settings, or performs chain‑affecting operations such as resharding, pruning, halting, or replay. These actions can cause irreversible loss or outages. On long guides with many risky commands, combine a clear page‑level warning at the top (covering risk, scope, rollback where feasible, and environment) with short local notes next to each critical step. Local notes can be brief if they point back to the main warning. Pattern Warning — funds at risk Running the next command on mainnet transfers funds irreversibly. Safer first (testnet): CopyAsk AIjetton transfer --to <ADDR> --amount <AMOUNT> --network testnet If you must use mainnet: no rollback; on‑chain transfers are final. Default to testnet in task pages. Make destructive flags opt‑in and document mitigations. ​Necessary disclaimers Add a Caution or Warning when a page or step: Moves funds or changes fee/withdrawal behavior. Exposes, stores, or transmits private keys or mnemonics. Modifies validator configuration, networking, or other consensus‑affecting parameters. Performs chain‑affecting operations (for example, resharding, pruning, halting, replay). Uses destructive flags or commands that delete, rewrite, or lock state (for example, --purge, --force). Runs on mainnet, where actions are irreversible; label the environment and give the safer testnet first. Make sure the guide as a whole clearly covers the risk, scope, rollback or mitigation (where feasible), and the environment label (testnet vs mainnet). For a single hazardous step, put these points directly in its callout. On long risky guides, put a big safety callout at the top and keep step‑level notes short, pointing back to that summary. ​Titles and headings Use sentence case. Keep headings concise and unique. Use imperatives for tasks (“Deploy a validator”); nouns for concepts (“Validator architecture”). Titles should signal action vs. explanation. Don’t style headings, except when an identifier needs code font. Use clear section labels such as Verify, Troubleshoot, and See also. ​Link to details, don’t duplicate On first useful mention, link flags, parameters, error codes, and data types to their reference anchors. Do not paste reference tables into guides. Link instead. Duplicated tables go stale. Use descriptive link text that names the destination, not generic labels like “click here”, “here”, or “this page”, and avoid mechanics-focused link labels like “click” or “go to”. Link core TON terms to the Glossary on first useful mention unless you define them on the page. Internal links MUST be root‑absolute (start with /). Deep‑link to the exact section or anchor that contains the needed fact (not the page top). MUST NOT use relative segments like ./ or ../ in any Markdown/MDX link. (Why: content moves frequently; root‑absolute links survive reorganizations.) ​Images Use the <Image> component for all images. Markdown image syntax ![...](...) and raw <img ...> are not allowed. Store images under resources/images/ and reference them with root‑absolute paths, for example <Image src=\"/resources/images/<GROUP>/<FILE>.png\" />. MUST NOT use relative src such as ./ or ../. Provide meaningful, non‑empty alt text (never alt=\"\"); add darkSrc when the dark theme needs different contrast. Keep sizes/aspect ratios consistent across a page. SVGs: if you omit darkSrc, colors are auto‑inverted in dark mode; add darkSrc if inversion isn’t correct. ​Terminology and names Use the project term bank for canonical spellings, casing, and preferred terms. One vocabulary prevents drift. Examples: TON, jetton, smart contract, BoC (bag of cells), accountchain, shardchain, workchain, masterchain, basechain. Prefer allowlist and denylist over whitelist and blacklist. These are clearer and inclusive. Use mainnet and testnet as common nouns. Use TON Mainnet and TON Testnet for the proper names. This distinguishes the generic type from the named network. ​Files, front matter, labels Filenames use kebab-case.md or kebab-case.mdx (for example, validator-setup.mdx). This is readable and consistent across platforms. Optional front matter can declare doc_type, audience, and status (experimental or deprecated). If deprecated, add an Important callout with the replacement and timeline. Keep sidebar labels short (2–4 words) and mirror in‑page headings. ​Accessibility Use plain English; avoid idioms and culture-specific references. Use American English spelling (e.g., color, analyze). Write descriptive headings and link text. Tables should have headers and units (for example, “Latency (ms)”) and keep cells brief. Provide text alternatives for complex figures when possible. Avoid emojis. Only use them where they follow a common",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "testnet",
      "mainnet",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:38:21.589Z"
  },
  {
    "id": "docs-ton-org--v3-contribute-maintainers",
    "title": "Maintainers",
    "url": "https://docs.ton.org/v3/contribute/maintainers",
    "content": "Skip to main contentDeprecated! Please, visit the new documentation at docs.ton.org Deprecated, go to new docs!On this pageMaintainers Active team​ Below the current members of the TON documentation team. Alex Golev​ Onboarding Lead at TON Studio Telegram: @alexgton GitHub: Reveloper Aigerim Gilmanova​ Technical Writer at TON Studio GitHub: aigerimu Favour Kelvin​ Technical Writer at TON Studio GitHub: fakela Social​ TON Documentation channel Acknowledgements​ TON documentation was created by tolya-yanot and EmelyanenkoK. Over time, TON documentation has benefitted from the intellect and dedication of numerous external contributors. We extend our heartfelt gratitude to each of them. However, we would like to acknowledge the substantial contributions made by the following individuals especially. Their respective contributions have greatly enriched the quality and depth of our documentation: akifoq: early contributions amnch1: fixes aSpite: content awesome-doge: early contributions coalus: content delovoyhomie: content Gusarich: content krau5: improvements LevZed: content ProgramCrafter: content siandreev: content SpyCheese: early contributions SwiftAdviser: content, user-friendly docs inventor Tal Kol: early contributions TrueCarry: content xssnick: content We sincerely appreciate each contributor who has helped make TON documentation a rich and reliable resource. See also​ How to contribute Content standardization Typography Was this article useful?YesNoEdit this pageLast updated on Sep 5, 2025 by AlexGActive teamAlex GolevAigerim GilmanovaFavour KelvinSocialAcknowledgementsSee alsoUseGet a WalletGet ToncoinStakeAccept PaymentsApps & ServicesDomainsUSDT on TONCross-Chain BridgesLearnTON ConceptDecentralized NetworkRoadmapTonStatHistory of MiningToncoinValidatorsWhite PaperBrand AssetsSustainabilityFor BuildersTON Builders PortalGetting StartedDocumentationTelegram Mini AppsDev ChatsBug BountyFind a JobFind a TalentUse CasesGameFiMemecoins & TokensCommunity ToolsTON SitesCommunityCommunitiesBlogCareers",
    "category": "general",
    "tags": [
      "ton",
      "wallet",
      "telegram",
      "mini app",
      "builder",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:38:25.427Z"
  },
  {
    "id": "docs-ton-org--v3-contribute-maintainers-",
    "title": "Maintainers",
    "url": "https://docs.ton.org/v3/contribute/maintainers/",
    "content": "Skip to main contentDeprecated! Please, visit the new documentation at docs.ton.org Deprecated, go to new docs!On this pageMaintainers Active team​ Below the current members of the TON documentation team. Alex Golev​ Onboarding Lead at TON Studio Telegram: @alexgton GitHub: Reveloper Aigerim Gilmanova​ Technical Writer at TON Studio GitHub: aigerimu Favour Kelvin​ Technical Writer at TON Studio GitHub: fakela Social​ TON Documentation channel Acknowledgements​ TON documentation was created by tolya-yanot and EmelyanenkoK. Over time, TON documentation has benefitted from the intellect and dedication of numerous external contributors. We extend our heartfelt gratitude to each of them. However, we would like to acknowledge the substantial contributions made by the following individuals especially. Their respective contributions have greatly enriched the quality and depth of our documentation: akifoq: early contributions amnch1: fixes aSpite: content awesome-doge: early contributions coalus: content delovoyhomie: content Gusarich: content krau5: improvements LevZed: content ProgramCrafter: content siandreev: content SpyCheese: early contributions SwiftAdviser: content, user-friendly docs inventor Tal Kol: early contributions TrueCarry: content xssnick: content We sincerely appreciate each contributor who has helped make TON documentation a rich and reliable resource. See also​ How to contribute Content standardization Typography Was this article useful?YesNoEdit this pageLast updated on Sep 5, 2025 by AlexGActive teamAlex GolevAigerim GilmanovaFavour KelvinSocialAcknowledgementsSee alsoUseGet a WalletGet ToncoinStakeAccept PaymentsApps & ServicesDomainsUSDT on TONCross-Chain BridgesLearnTON ConceptDecentralized NetworkRoadmapTonStatHistory of MiningToncoinValidatorsWhite PaperBrand AssetsSustainabilityFor BuildersTON Builders PortalGetting StartedDocumentationTelegram Mini AppsDev ChatsBug BountyFind a JobFind a TalentUse CasesGameFiMemecoins & TokensCommunity ToolsTON SitesCommunityCommunitiesBlogCareers",
    "category": "general",
    "tags": [
      "ton",
      "wallet",
      "telegram",
      "mini app",
      "builder",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:38:26.382Z"
  },
  {
    "id": "docs-ton-org--v3-contribute-content-standardization-",
    "title": "Content standardization",
    "url": "https://docs.ton.org/v3/contribute/content-standardization/",
    "content": "Skip to main contentDeprecated! Please, visit the new documentation at docs.ton.org Deprecated, go to new docs!On this pageContent standardization Introduction​ This guideline aims to maintain a consistent documentation style and help contributors standardize their content so that it seamlessly integrates into the documentation. Text preferences​ Use American English​ For words that have multiple spellings, use American English over British English. Examples: \"decentralized\" over \"decentralised\" \"color\" over \"colour\" \"analyze\" over \"analyse\" Use present tense​ Use present tense to describe general behavior, current functionality, and step-by-step instructions. This makes documentation clear and easy to follow. Examples: This guideline provides an overview of the contribution process. The system checks the file format and shows an error if it is invalid. Avoid future or past tense for immediate or typical actions. Avoid: The system will check the file format. The user clicked the button. When to use the future or past tenses​ Present tense is standard, but future and past tenses are allowed in specific cases. Future tense: for actions that happen later, after a condition or delay. Examples: After setup, the system will send a confirmation email. If payment fails, the user will get a notification. Avoid the future tense for immediate behavior or unreleased features. Also, avoid \"would\". Avoid: The system will check the file format. The API would return an error. Past tense: for describing past events like changelogs or logs. Examples: Version 2.1 fixed a validation issue. The user submitted the form at 2 pm and got a 500 error. Avoid past tense in general documentation — it can imply outdated info. Avoid: The system checked the user’s location. The user clicked the button. Use active voice​ Sentences using active voice are more concise and efficient, making your writing more engaging and easier to comprehend. Active voice sentence: An actor acts on a target \"The smart contract processed a message.\" Passive voice sentence: A target acts on an actor \"The message was processed by the smart contract.\" Read more on active voice This isn't an easy one, especially for non-native English speakers. If you aren't sure, don't worry. We'll help with any of these. Grammar​ This documentation uses cspell to check spelling during development. cspell will check the spelling and automatically suggest corrections in case of mistakes before creating a new commit. Feel free to add specific words to the cspell.json config and include them in the verification dictionary. Date format​ Use the \"Mon D, YYYY\" format. This approach is standard for American readers, spells out the month (or uses a three-letter abbreviation), and minimizes confusion with day–month ordering. Preferred format:​ Nov 2, 2023 Feb 11, 2023 Incorrect format:​ 2-Nov-2023 11/2/2023 2/11/2023 Adhering to these guidelines creates a unified approach to presenting dates, fostering clarity and comprehension throughout the TON documentation. Use of emojis and icons​ In the Documentation section:​ Avoid using emojis and decorative icons. Technical documentation should be clear, professional, and distraction-free. Use only standard formatting elements like headings, lists, and code blocks. In the Guidelines section:​ Emojis and icons are allowed to make content more engaging and friendly. Use them purposefully and consistently, preferring functional icons such as ✅ Success, ⚠️ Warning, ❌ Error. Always use icons with supporting text — don’t rely on icons alone to convey meaning. Avoid overly decorative or emotional emojis that don’t add meaning. When in doubt, skip the icon. Clarity, consistency, and neutrality come first. Link preferences​ Linking to internal pages​ Use a site-relative path (rooted at “/”) instead of a full URL when linking to another page in the TON documentation. Correct link:​ Read more about [smart contracts](/v3/documentation/smart-contracts/overview/) Incorrect link:​ Read more about [smart contracts](https://docs.ton.org/v3/documentation/smart-contracts/overview) Don't hard-code the language path (for example, /zh-CN/) in any links. This maintains consistent capability across different language versions of the site. Correct link:​ Read more about [smart contracts](/v3/documentation/smart-contracts/overview/) Incorrect link:​ Read more about [smart contracts](/zh-CN/v3/documentation/smart-contracts/overview) Set a trailing slash on internal documentation links to avoid redirects, which hurt site performance. Correct link:​ Read more about [smart contracts](/v3/documentation/smart-contracts/overview/) Incorrect link:​ Read more about [smart contracts](/v3/documentation/smart-contracts/overview) Article authors​ When citing articles by a specific author or organization, use the article's name as a link, followed by an em dash and the author's name italicized. Correct description:​ - [How to shard your TON smart contract and why](https://blog.ton.org/how-to-shard-your-ton-smart-contract-and-why-studying-the-anatomy-of-tons-jettons) — _Tal Kol_- [TON Teleport BTC Whitepaper](https://tgbtc.gitbook.io/docs/whitepaper/abstract) — _RSquad Blockchain Lab_ Incorrect description:​ - [How to shard your TON smart contract and why](https://blog.ton.org/how-to-shard-your-ton-smart-contract-and-why-studying-the-anatomy-of-tons-jettons)- [TON Teleport BTC Whitepaper](https://tgbtc.gitbook.io/docs/whitepaper/abstract) by RSquad Blockchain Lab See also links section​ Include related resources on your page in an H2 section titled ## See also. This section guides readers to additional materials and supports a cohesive developer journey. Example:​ ## See also- [Style guide](/v3/contribute/style-guide/)- [Typography](/v3/contribute/typography/) Image preferences​ Linking to images​ When adding an image to a page, download and set an image in the TON documentation static/img folder. Correct linking:​ ![jetton_transfer](/img/docs/asset-processing/jetton_transfer.png) Incorrect linking:​ ![tact_logo](https://docs.tact-lang.org/_astro/logomark-dark.BSmgZYWc_ZKRrUl.svg) This is helpful to ensure the image will be available. Light and dark theme modes​ TON documentation supports theme-specific images. Follow these steps to add themed pictures to the page. Themed mode is available only for .mdx files. Import the ThemedImage module in the header. import ThemedImage from \"@theme/ThemedImage\"; Set the links for both images according to the example: <br /><ThemedImage alt=\"Message delivery diagram\" sources={{ light: '/img/docs/message-delivery/message_delivery_2.svg?raw=true', dark: '/img/docs/message-delivery/message_delivery_2_dark.svg?raw=true', }}/><br /> Annotation specification​ To depict message processing, use a graphical representation that resembles a smart contract graph, including labels for transactions and messages. If the transaction order isn't essential, omit their labels. This approach simplifies the diagram, making it easier to read and understand the message and contract details. Annotation primitives​ Avoid using a large variety of bright colors. Modify figures by applying techniques such as a dashed border. To emphasize specific details, display transactions using distinct line styles (e.g., solid and dashed). Message processing schemes​ On the TON blockchain, providing clear explanations of actor behavior and message processing for various smart contracts and fundamental scenarios is essential. The message processing schemes offer additional context for readers seeking a clear understanding of actor behavior. These schemes should be unified throughout the TON documentation to ensure maximum clarity. Example​ Sequence diagram​ Use a sequence diagram for complex and repetitive communication schemes between 2–3 actors. For messages, use the notation of a typical synchronous message arrow. Example​ Scheme formats and colors​ Format:​ Use PNG format for the diagrams in the documentation to ensure readability on various devices. Fonts:​ Use the Inter font family for all text within diagrams. Maintain a consistent text size. Avoid overusing bold and italic formatting for optimal readability. Themed colors for light mode:​ Pencil Hand Drawn, default Visio theme. Themed colors for dark mode:​ Font #e3e3e3. Background #232328. Light Highlight, arrows and scheme borders #058dd2. Dark Highlight, arrows and scheme borders #0088cc. InnerBackGround, for nested blocks #333337. Version control policy:​ Store the original files under /static/schemes-visio to facilitate future modifications. Learn Visio references directly from Visio sources. Math equations​ To include mathematical expressions in documentation, use the react-katex library. It supports both inline and block-level math using LaTeX syntax. Import the required components at the top of your .mdx file: import { BlockMath, InlineMath } from 'react-katex';import 'katex/dist/katex.min.css'; These imports allow you to render LaTeX math expressions: BlockMath is used for centered, standalone formulas. InlineMath is used for short expressions inside the regular text. The css import applies the necessary styling for proper rendering. Contributors can use the following examples to format various types of math expressions in the documentation: Systems of equations​ For systems of equations, use LaTeX formatting for clarity: <BlockMath math={`\\begin{cases}x + y = 10 \\\\2x - y = 4\\end{cases}`} /> This renders the system of equations as: \begin{cases} x + y = 10 \\ 2x - y = 4 end{cases} Exponential functions​ For exponential functions, you can use the following format: <InlineMath math=\"e^{x} = \\\\lim\\\\limits_{n\\\\to \\\\infty} \\\\left( 1 + \\\\frac{x}{n} \\\\right)^n\" /> This renders the equation: ex=limlimitsntoinftyleft(1+fracxnright)ne^{x} = \\\\lim\\\\limits_{n\\\\to \\\\infty} \\\\left( 1 + \\\\frac{x}{n} \\\\right)^nex=limlimitsntoinfty​left(1+fracxnright)n Fractions​ To represent fractions, use \\frac{numerator}{denominator}: <InlineMath math=\"\\\\fra",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "ton connect",
      "api",
      "testnet",
      "mainnet",
      "transaction",
      "guide",
      "cell",
      "builder",
      "message",
      "react",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:40:05.950Z"
  },
  {
    "id": "docs-ton-org--standard-wallets-highload-v3-send-single-transfer",
    "title": "How to send a single transfer",
    "url": "https://docs.ton.org/standard/wallets/highload/v3/send-single-transfer",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsHow they workMnemonicsComparisonPerformance benchmarkHow to interactHistoryV4V5Highload WalletsOverviewHighload Wallet v3How to create Highload Wallet v3How to send a single transferHow to send a batch of transfersHow to verify message is processedSpecificationHighload Wallet v2Lockup walletPreprocessed Wallet V2Restricted walletTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationHighload Wallet v3How to send a single transferStandard contractsWalletsHighload WalletsHighload Wallet v3How to send a single transferCopy pageCopy pageFunds at risk: This guide sends real TON. Test on testnet first. Double-check recipient addresses — blockchain transactions cannot be reversed. This guide shows how to send a single transfer from your Highload Wallet v3. ​Objective By the end of this guide, you will: Send a single TON transfer from your Highload Wallet v3 Understand how query_id, created_at, and send modes work ​Prerequisites Completed wallet creation with funded balance and saved configuration in .wallet.json ​Step 1: Load wallet configuration Load the wallet data and create the wallet instance: CopyAsk AIimport { TonClient, internal, toNano } from '@ton/ton'; import { mnemonicToPrivateKey } from '@ton/crypto'; import { Cell, SendMode } from '@ton/core'; import { HighloadWalletV3 } from './wrappers/HighloadWalletV3'; import { HighloadQueryId } from './wrappers/HighloadQueryId'; import * as fs from 'fs'; // Load wallet data const walletData = JSON.parse(fs.readFileSync('.wallet.json', 'utf-8')); const mnemonic = walletData.mnemonic.split(' '); const keyPair = await mnemonicToPrivateKey(mnemonic); const CODE = Cell.fromBoc(Buffer.from('b5ee9c7241021001000228000114ff00f4a413f4bcf2c80b01020120020d02014803040078d020d74bc00101c060b0915be101d0d3030171b0915be0fa4030f828c705b39130e0d31f018210ae42e5a4ba9d8040d721d74cf82a01ed55fb04e030020120050a02027306070011adce76a2686b85ffc00201200809001aabb6ed44d0810122d721d70b3f0018aa3bed44d08307d721d70b1f0201200b0c001bb9a6eed44d0810162d721d70b15800e5b8bf2eda2edfb21ab09028409b0ed44d0810120d721f404f404d33fd315d1058e1bf82325a15210b99f326df82305aa0015a112b992306dde923033e2923033e25230800df40f6fa19ed021d721d70a00955f037fdb31e09130e259800df40f6fa19cd001d721d70a00937fdb31e0915be270801f6f2d48308d718d121f900ed44d0d3ffd31ff404f404d33fd315d1f82321a15220b98e12336df82324aa00a112b9926d32de58f82301de541675f910f2a106d0d31fd4d307d30cd309d33fd315d15168baf2a2515abaf2a6f8232aa15250bcf2a304f823bbf2a35304800df40f6fa199d024d721d70a00f2649130e20e01fe5309800df40f6fa18e13d05004d718d20001f264c858cf16cf8301cf168e1030c824cf40cf8384095005a1a514cf40e2f800c94039800df41704c8cbff13cb1ff40012f40012cb3f12cb15c9ed54f80f21d0d30001f265d3020171b0925f03e0fa4001d70b01c000f2a5fa4031fa0031f401fa0031fa00318060d721d300010f0020f265d2000193d431d19130e272b1fb00b585bf03', 'hex'))[0]; const client = new TonClient({ endpoint: 'https://testnet.toncenter.com/api/v2/jsonRPC', // This is TESTNET endpoint // apiKey: 'your-api-key' // Optional: get from @tonapibot or @tontestnetapibot }); const wallet = client.open( HighloadWalletV3.createFromConfig( { publicKey: keyPair.publicKey, subwalletId: walletData.subwalletId, timeout: walletData.timeout, }, CODE ) ); ​Step 2: Prepare the transfer message Create an internal message with the transfer details: CopyAsk AIconst internalMessage = internal({ to: 'EQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM9c', // Zero address (for testing) value: toNano('0.01'), bounce: false, }); This example uses the zero address for testing. Replace it with your actual destination address. No state-init support: Highload Wallet v3 cannot send messages containing StateInit using this method.If you need to deploy a contract (send a message with StateInit), use batch transfers with an action list instead. See Limitations and constraints in the specification for details. ​Step 3: Send the transfer Send the transfer using the sendExternalMessage method: CopyAsk AIconst createdAt = Math.floor(Date.now() / 1000) - 30; // 30 seconds ago const queryId = new HighloadQueryId(); // Represents query_id as a seqno await wallet.sendExternalMessage(keyPair.secretKey, { message: internalMessage, mode: SendMode.PAY_GAS_SEPARATELY, query_id: queryId, createdAt: createdAt, subwalletId: walletData.subwalletId, timeout: walletData.timeout, }); console.log('Transfer sent'); Automatic deployment: If your wallet is in uninit status (has a balance but no code), it will automatically deploy when processing this external message. The wallet transitions to active status, and the transfer is executed in the same transaction. ​Parameter explanation query_id — Unique identifier for replay protection: Each query_id can only be processed once within the protection window HighloadQueryId is a wrapper class that represents the composite query_id as a sequential counter Provides getNext() method to increment to the next unique ID Total range: 8,380,416 unique IDs See Query ID structure for details createdAt — Message timestamp for expiration: Set to 30 seconds before current time: Math.floor(Date.now() / 1000) - 30 Compensates for blockchain time lag (lite-servers use last block time, not current time) See Timestamp validation for why this is necessary ​Next steps Your wallet is fully operational. You can send multiple transfers in parallel or batch multiple messages in one transaction. To verify that your message, see How to verify message is processed.Was this page helpful?YesNoSuggest editsRaise issuePreviousHow to send a batch of transfersNext⌘IgithubxtelegramPowered by MintlifyOn this pageObjectivePrerequisitesStep 1: Load wallet configurationStep 2: Prepare the transfer messageStep 3: Send the transferParameter explanationNext steps",
    "category": "wallets",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "testnet",
      "transaction",
      "deployment",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:40:18.803Z"
  },
  {
    "id": "docs-ton-org--standard-wallets-highload-v3-send-batch-transfers",
    "title": "How to send a batch of transfers",
    "url": "https://docs.ton.org/standard/wallets/highload/v3/send-batch-transfers",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsHow they workMnemonicsComparisonPerformance benchmarkHow to interactHistoryV4V5Highload WalletsOverviewHighload Wallet v3How to create Highload Wallet v3How to send a single transferHow to send a batch of transfersHow to verify message is processedSpecificationHighload Wallet v2Lockup walletPreprocessed Wallet V2Restricted walletTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationHighload Wallet v3How to send a batch of transfersStandard contractsWalletsHighload WalletsHighload Wallet v3How to send a batch of transfersCopy pageCopy pageFunds at risk: This guide sends real TON. Test on testnet first. Double-check recipient addresses — blockchain transactions cannot be reversed. This guide shows how to send multiple transfers in a single transaction using Highload Wallet v3. This is the main feature of the wallet, enabling up to 254 messages per transaction. ​Objective By the end of this guide, you will: Send multiple transfers (up to 254) in a single transaction Understand the two-transaction flow for batch transfers Know how to calculate the compute fees for the internal transaction ​Prerequisites Completed wallet creation with funded balance and saved configuration in .wallet.json ​Step 1: Load wallet configuration Load the wallet data and create the wallet instance: CopyAsk AIimport { TonClient, internal, toNano, comment } from '@ton/ton'; import { mnemonicToPrivateKey } from '@ton/crypto'; import { Cell, SendMode } from '@ton/core'; import { HighloadWalletV3 } from './wrappers/HighloadWalletV3'; import { HighloadQueryId } from './wrappers/HighloadQueryId'; import * as fs from 'fs'; // Load wallet data const walletData = JSON.parse(fs.readFileSync('.wallet.json', 'utf-8')); const mnemonic = walletData.mnemonic.split(' '); const keyPair = await mnemonicToPrivateKey(mnemonic); const CODE = Cell.fromBoc(Buffer.from('b5ee9c7241021001000228000114ff00f4a413f4bcf2c80b01020120020d02014803040078d020d74bc00101c060b0915be101d0d3030171b0915be0fa4030f828c705b39130e0d31f018210ae42e5a4ba9d8040d721d74cf82a01ed55fb04e030020120050a02027306070011adce76a2686b85ffc00201200809001aabb6ed44d0810122d721d70b3f0018aa3bed44d08307d721d70b1f0201200b0c001bb9a6eed44d0810162d721d70b15800e5b8bf2eda2edfb21ab09028409b0ed44d0810120d721f404f404d33fd315d1058e1bf82325a15210b99f326df82305aa0015a112b992306dde923033e2923033e25230800df40f6fa19ed021d721d70a00955f037fdb31e09130e259800df40f6fa19cd001d721d70a00937fdb31e0915be270801f6f2d48308d718d121f900ed44d0d3ffd31ff404f404d33fd315d1f82321a15220b98e12336df82324aa00a112b9926d32de58f82301de541675f910f2a106d0d31fd4d307d30cd309d33fd315d15168baf2a2515abaf2a6f8232aa15250bcf2a304f823bbf2a35304800df40f6fa199d024d721d70a00f2649130e20e01fe5309800df40f6fa18e13d05004d718d20001f264c858cf16cf8301cf168e1030c824cf40cf8384095005a1a514cf40e2f800c94039800df41704c8cbff13cb1ff40012f40012cb3f12cb15c9ed54f80f21d0d30001f265d3020171b0925f03e0fa4001d70b01c000f2a5fa4031fa0031f401fa0031fa00318060d721d300010f0020f265d2000193d431d19130e272b1fb00b585bf03', 'hex'))[0]; const client = new TonClient({ endpoint: 'https://testnet.toncenter.com/api/v2/jsonRPC', // This is TESTNET endpoint // apiKey: 'your-api-key' // Optional: get from @tonapibot or @tontestnetapibot }); const wallet = client.open( HighloadWalletV3.createFromConfig( { publicKey: keyPair.publicKey, subwalletId: walletData.subwalletId, timeout: walletData.timeout, }, CODE ) ); ​Step 2: Prepare the message batch Create an array of messages to send: CopyAsk AIconst messages = []; for (let i = 1; i <= 10; i++) { messages.push({ type: 'sendMsg' as const, mode: SendMode.PAY_GAS_SEPARATELY, outMsg: internal({ to: 'EQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM9c', // Zero address (for testing) value: toNano('0.001'), body: comment(`#${i}`), bounce: false, }), }); } Each message in the batch: type: 'sendMsg' — specifies that this is an outgoing message action mode — send mode for each individual message outMsg — the internal message to send Batch limit: You can send up to 254 messages per transaction. This limit exists because one action slot is reserved for set_code protection. ​Step 3: Send the batch Send the batch using the sendBatch method: CopyAsk AIconst queryId = HighloadQueryId.fromSeqno(17n); // Use a specific seqno const createdAt = Math.floor(Date.now() / 1000) - 30; // 30 seconds ago const value = toNano('0.0007024'); // Compute fee for internal receiver await wallet.sendBatch( keyPair.secretKey, messages, walletData.subwalletId, queryId, walletData.timeout, createdAt, value ); console.log('Batch sent: 10 transfers'); console.log(`Query ID: ${queryId.toSeqno()}`); console.log(`Created At: ${createdAt}`); Automatic deployment: If your wallet is in uninit status (has a balance but no code), it will automatically deploy when processing this external message. The wallet transitions to active status, and the batch transfer is executed in the same transaction. ​Parameter explanation queryId — Unique identifier for replay protection: Each query_id can only be processed once within the protection window HighloadQueryId is a wrapper class that represents the composite query_id as a sequential counter Use HighloadQueryId.fromSeqno(n) to create a specific query ID Provides getNext() method to increment to the next unique ID Total range: 8,380,416 unique IDs See Query ID structure for details createdAt — Message timestamp for expiration: Set to 30 seconds before current time: Math.floor(Date.now() / 1000) - 30 Compensates for blockchain time lag (lite-servers use last block time, not current time) See Timestamp validation for why this is necessary value — Compute fee for the internal transaction: The internal receiver (Transaction 2) consumes a fixed 1,756 gas to process the action list At current gas prices, this equals ~0.0007024 TON This fee is sent to the wallet itself to cover internal message processing If insufficient, the internal transaction may fail (but replay protection remains intact) Compute fee requirement: The value parameter covers gas for the internal transaction that processes the action list. This is in addition to the gas costs of the external message itself. ​How it works Batch transfers use a two-transaction pattern: the external message marks the query_id as processed and sends an internal message to itself with the action list, then the internal transaction processes the actions and sends all outgoing messages. See Message sending flow for the complete validation sequence. ​Next steps You can send multiple batches in parallel, each with a unique query_id. To verify that your batch was fully processed, see How to verify message is processed.Was this page helpful?YesNoSuggest editsRaise issuePreviousHow to verify message is processedNext⌘IgithubxtelegramPowered by MintlifyOn this pageObjectivePrerequisitesStep 1: Load wallet configurationStep 2: Prepare the message batchStep 3: Send the batchParameter explanationHow it worksNext steps",
    "category": "wallets",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "testnet",
      "transaction",
      "deployment",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:40:21.159Z"
  },
  {
    "id": "docs-ton-org--standard-wallets-highload-v3-verify-is-processed",
    "title": "How to verify message is processed",
    "url": "https://docs.ton.org/standard/wallets/highload/v3/verify-is-processed",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsHow they workMnemonicsComparisonPerformance benchmarkHow to interactHistoryV4V5Highload WalletsOverviewHighload Wallet v3How to create Highload Wallet v3How to send a single transferHow to send a batch of transfersHow to verify message is processedSpecificationHighload Wallet v2Lockup walletPreprocessed Wallet V2Restricted walletTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationHighload Wallet v3How to verify message is processedStandard contractsWalletsHighload WalletsHighload Wallet v3How to verify message is processedCopy pageCopy pageThis guide shows how to verify that a transfer (single or batch) was fully processed across both transactions. ​Objective By the end of this guide, you will: Verify that both transactions (external and internal) succeeded Calculate how many messages were successfully sent Detect partial failures in batch transfers ​Prerequisites Completed wallet creation with funded balance Sent at least one transfer (single or batch) Know the query_id and created_at values used in the transfer ​Verification overview Highload Wallet v3 uses a two-transaction pattern. To verify full processing, you need to check both transactions: External transaction (Transaction 1): Validates the message and marks query_id as processed Internal transaction (Transaction 2): Processes the action list and sends outgoing messages Even if processed? returns true, the internal transaction may have failed. Full verification requires checking both transactions. See Message sending flow for the complete two-transaction pattern. ​Helper functions Create helper functions for transaction search and parsing: CopyAsk AIimport { TonClient } from '@ton/ton'; import { Cell, Transaction, Address } from '@ton/core'; // Retry helper for network requests async function retry<T>(fn: () => Promise<T>, options: { retries: number; delay: number }): Promise<T> { let lastError: Error | undefined; for (let i = 0; i < options.retries; i++) { try { return await fn(); } catch (e) { if (e instanceof Error) lastError = e; await new Promise((resolve) => setTimeout(resolve, options.delay)); } } throw lastError; } // Parse external message to extract query_id and created_at function parseExternalMessageBody(body: Cell) { try { const inner = body.refs[0]!.beginParse(); inner.skip(32 + 8); // Skip subwalletId and mode const queryId = inner.loadUintBig(23); const createdAt = inner.loadUint(64); return { queryId, createdAt }; } catch (e) { return null; } } // Generic transaction finder with pagination async function findTransaction( client: TonClient, address: Address, predicate: (tx: Transaction) => boolean ): Promise<Transaction | null> { let lt: string | undefined = undefined; let hash: string | undefined = undefined; while (true) { const transactions = await retry( () => client.getTransactions(address, { hash, lt, limit: 20, archival: true, }), { delay: 1000, retries: 3 } ); if (transactions.length === 0) return null; const found = transactions.find(predicate); if (found) return found; const last = transactions.at(-1)!; lt = last.lt.toString(); hash = last.hash().toString('base64'); } } ​Step 1: Set up and check if processed Load wallet configuration and check if the query_id was marked as processed: CopyAsk AIimport { mnemonicToPrivateKey } from '@ton/crypto'; import { HighloadWalletV3 } from './wrappers/HighloadWalletV3'; import { HighloadQueryId } from './wrappers/HighloadQueryId'; import * as fs from 'fs'; // Load wallet data const walletData = JSON.parse(fs.readFileSync('.wallet.json', 'utf-8')); const keyPair = await mnemonicToPrivateKey(walletData.mnemonic.split(' ')); const CODE = Cell.fromBoc(Buffer.from('b5ee9c7241021001000228000114ff00f4a413f4bcf2c80b01020120020d02014803040078d020d74bc00101c060b0915be101d0d3030171b0915be0fa4030f828c705b39130e0d31f018210ae42e5a4ba9d8040d721d74cf82a01ed55fb04e030020120050a02027306070011adce76a2686b85ffc00201200809001aabb6ed44d0810122d721d70b3f0018aa3bed44d08307d721d70b1f0201200b0c001bb9a6eed44d0810162d721d70b15800e5b8bf2eda2edfb21ab09028409b0ed44d0810120d721f404f404d33fd315d1058e1bf82325a15210b99f326df82305aa0015a112b992306dde923033e2923033e25230800df40f6fa19ed021d721d70a00955f037fdb31e09130e259800df40f6fa19cd001d721d70a00937fdb31e0915be270801f6f2d48308d718d121f900ed44d0d3ffd31ff404f404d33fd315d1f82321a15220b98e12336df82324aa00a112b9926d32de58f82301de541675f910f2a106d0d31fd4d307d30cd309d33fd315d15168baf2a2515abaf2a6f8232aa15250bcf2a304f823bbf2a35304800df40f6fa199d024d721d70a00f2649130e20e01fe5309800df40f6fa18e13d05004d718d20001f264c858cf16cf8301cf168e1030c824cf40cf8384095005a1a514cf40e2f800c94039800df41704c8cbff13cb1ff40012f40012cb3f12cb15c9ed54f80f21d0d30001f265d3020171b0925f03e0fa4001d70b01c000f2a5fa4031fa0031f401fa0031fa00318060d721d300010f0020f265d2000193d431d19130e272b1fb00b585bf03', 'hex'))[0]; const client = new TonClient({ endpoint: 'https://testnet.toncenter.com/api/v2/jsonRPC', // This is TESTNET endpoint // apiKey: 'your-api-key' // Optional: get from @tonapibot or @tontestnetapibot }); const highloadWallet = HighloadWalletV3.createFromConfig( { publicKey: keyPair.publicKey, subwalletId: walletData.subwalletId, timeout: walletData.timeout, }, CODE ); const wallet = client.open(highloadWallet); // The query_id and created_at from your transfer const queryId = HighloadQueryId.fromSeqno(17n); const createdAt = 1759878156; // Your actual created_at timestamp // Check if processed const isProcessed = await wallet.getProcessed(queryId); if (!isProcessed) { console.log('❌ Query not processed'); return; } console.log('✓ Query marked as processed'); What processed? tells you: This GET method only confirms that the query_id was marked as processed in the wallet’s storage. It does not confirm that the internal transaction succeeded or that messages were sent.See processed? method in the specification for details. ​Step 2: Find and verify external transaction Search transaction history to find the external transaction by query_id and created_at: CopyAsk AI// Find external transaction by query_id + created_at async function findHighloadExternalTransaction( client: TonClient, walletAddress: Address, queryId: HighloadQueryId, createdAt: number ): Promise<Transaction | null> { const targetQueryId = queryId.getQueryId(); return findTransaction(client, walletAddress, (tx) => { if (tx.inMessage?.info.type !== 'external-in') return false; if (!tx.inMessage.body) return false; const parsed = parseExternalMessageBody(tx.inMessage.body); if (!parsed) return false; return parsed.queryId === targetQueryId && parsed.createdAt === createdAt; }); } const externalTx = await findHighloadExternalTransaction( client, highloadWallet.address, queryId, createdAt ); if (!externalTx) { console.log('❌ External transaction not found'); return; } // Verify external transaction compute phase if (externalTx.description.type !== 'generic') { console.log('❌ Invalid transaction'); return; } const externalCompute = externalTx.description.computePhase; if (!externalCompute.success || externalCompute.exitCode !== 0) { console.log(`❌ External transaction failed: exit code ${externalCompute.exitCode}`); return; } console.log('✓ External transaction succeeded'); If the external transaction failed, see Exit codes for troubleshooting. ​Step 3: Find and verify internal transaction Follow the transaction chain to find and verify Transaction 2: CopyAsk AI// Find internal transaction by prevTransactionLt async function findHighloadInternalTransaction( client: TonClient, walletAddress: Address, externalLt: string ): Promise<Transaction | null> { return findTransaction(client, walletAddress, (tx) => tx.prevTransactionLt.toString() === externalLt ); } // Check for outgoing messages if (externalTx.outMessagesCount === 0) { console.log('❌ No outgoing messages from external transaction'); return; } // Find the internal transaction const internalTx = await findHighloadInternalTransaction( client, highloadWallet.address, externalTx.lt.toString() ); if (!internalTx || internalTx.description.type !== 'generic') { console.log('❌ Internal transaction not found'); return; } // Verify compute phase if (internalTx.description.computePhase.type !== 'vm') { console.log('❌ Compute phase skipped'); return; } const internalCompute = internalTx.description.computePhase; if (!internalCompute.success || internalCompute.exitCode !== 0) { console.log(`❌ Internal transaction failed: exit code ${internalCompute.exitCode}`); return; } // Verify action phase if (!internalTx.description.actionPhase) { console.log('❌ No action phase in internal transaction'); return; } const action = internalTx.description.actionPhase; if (!action.success) { console.log(`❌ Action phase failed: result code ${action.resultCode}`); return; } console.log('✓ Internal transaction succeeded'); Transaction linking: The external transaction creates an outgoing message with outMsg.createdLt. The inter",
    "category": "wallets",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "testnet",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "react",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:40:22.724Z"
  },
  {
    "id": "docs-ton-org--ecosystem-ton-connect-walletkit",
    "title": "WalletKit: TON Connect for custodial and non-custodial wallets",
    "url": "https://docs.ton.org/ecosystem/ton-connect/walletkit",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectOverviewIntegrate a dAppIntegrate a walletManifestsMessage lookupWalletKitOverviewWebiOSAndroidIntegration QA guideNative and web walletsBrowser extensions and in-wallet browsersTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationWalletKitWalletKit: TON Connect for custodial and non-custodial walletsEcosystemTON ConnectWalletKitWalletKit: TON Connect for custodial and non-custodial walletsCopy pageCopy pageTON Connect WalletKit is an open-source SDK that helps integrate your custodial or non-custodial wallet with TON in a secure and streamlined fashion. It’s designed for institutions, non-custodians, and custodians that need full control over key management, signing, and access without compromising UX or compliance. ​Features Awaits a partial or full release of the WalletKit ​Use cases Awaits a partial or full release of the WalletKit ​Quick start First, follow this step-by-step guide: How to integrate a wallet with TON. Then, follow relevant usage recipes: WebInitialize the kitManage TON walletsHandle connectionsHandle other events ​See also Read more about the TON Connect itself: TON Connect overview. Skim the reference pages with more in-depth information: TON Connect manifests @tonconnect/protocol, external API reference Was this page helpful?YesNoSuggest editsRaise issuePreviousInitialize the kitNext⌘IgithubxtelegramPowered by MintlifyOn this pageFeaturesUse casesQuick startSee also",
    "category": "integration",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "dapp",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:40:30.272Z"
  },
  {
    "id": "docs-ton-org--ecosystem-ton-connect-walletkit-ios-installation",
    "title": "How to install the TON Connect's WalletKit on the iOS platform",
    "url": "https://docs.ton.org/ecosystem/ton-connect/walletkit/ios/installation",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectOverviewIntegrate a dAppIntegrate a walletManifestsMessage lookupWalletKitOverviewWebiOSInstall the kitInit the kitManage TON walletsReceiving informationTransactionsHandle eventsWebView injectionAndroidIntegration QA guideNative and web walletsBrowser extensions and in-wallet browsersTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationiOSHow to install the TON Connect's WalletKit on the iOS platformEcosystemTON ConnectWalletKitiOSHow to install the TON Connect's WalletKit on the iOS platformCopy pageCopy page​Requirements iOS 13.0+ Swift 5.9+ ​Adding WalletKit to XCode project Open the project in XCode Go to File → Add Package Dependencies Search for WalletKit package by URL: https://github.com/ton-connect/kit-ios.git Tap the Add Package button ​Adding WalletKit to Swift package Open the package’s Package.swift manifest file Add a dependency: CopyAsk AIdependencies: [ .package(url: \"https://github.com/ton-connect/kit-ios.git\", .upToNextMajor(from: \"0.0.2\")) ] Add a product to the target: CopyAsk AI.product(name: \"TONWalletKit\", package: \"TONWalletKit\") Alternatively, explore the complete demo wallet with WalletKit integration: Demo wallet, GitHubWas this page helpful?YesNoSuggest editsRaise issuePreviousInit the kitNext⌘IgithubxtelegramPowered by MintlifyOn this pageRequirementsAdding WalletKit to XCode projectAdding WalletKit to Swift package",
    "category": "integration",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "dapp",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:40:32.481Z"
  },
  {
    "id": "docs-ton-org--ecosystem-ton-connect-walletkit-android-installation",
    "title": "How to install the TON Connect's WalletKit on the Android platform",
    "url": "https://docs.ton.org/ecosystem/ton-connect/walletkit/android/installation",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectOverviewIntegrate a dAppIntegrate a walletManifestsMessage lookupWalletKitOverviewWebiOSAndroidInstall the kitInit the kitManage TON walletsReceiving informationHandle eventsTransactionsWebView injectionIntegration QA guideNative and web walletsBrowser extensions and in-wallet browsersTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationAndroidHow to install the TON Connect's WalletKit on the Android platformEcosystemTON ConnectWalletKitAndroidHow to install the TON Connect's WalletKit on the Android platformCopy pageCopy page​Requirements Android SDK 26+ Java 17+ Gradle 7.0+ Up-to-date Android System WebView (tested with 138.0.7204.179+) ​Adding WalletKit to project Add the dependency to the app’s build.gradle.kts file: CopyAsk AIdependencies { implementation(\"io.ton:walletkit:0.1.0\") } Ensure Maven Central is included in the repository list: CopyAsk AIrepositories { google() mavenCentral() } ​Permissions Add the required permission to the AndroidManifest.xml: CopyAsk AI<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"> <uses-permission android:name=\"android.permission.INTERNET\" /> </manifest> Alternatively, explore the complete demo wallet with WalletKit integration: Demo wallet, GitHubWas this page helpful?YesNoSuggest editsRaise issuePreviousInit the kitNext⌘IgithubxtelegramPowered by MintlifyOn this pageRequirementsAdding WalletKit to projectPermissions",
    "category": "integration",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "dapp",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:40:34.521Z"
  },
  {
    "id": "docs-ton-org--ecosystem-ton-connect-walletkit-android-init",
    "title": "How to initialize the TON Connect's WalletKit on the Android platform",
    "url": "https://docs.ton.org/ecosystem/ton-connect/walletkit/android/init",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectOverviewIntegrate a dAppIntegrate a walletManifestsMessage lookupWalletKitOverviewWebiOSAndroidInstall the kitInit the kitManage TON walletsReceiving informationHandle eventsTransactionsWebView injectionIntegration QA guideNative and web walletsBrowser extensions and in-wallet browsersTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationAndroidHow to initialize the TON Connect's WalletKit on the Android platformEcosystemTON ConnectWalletKitAndroidHow to initialize the TON Connect's WalletKit on the Android platformCopy pageCopy page​Creating configuration The basic kit initialization consists of creating a corresponding object by passing it a minimal set of necessary arguments. Pick a TON network to operate on, a wallet manifest, and feature configurations. Here is an example of a minimal configuration: CopyAsk AIimport io.ton.walletkit.ITONWalletKit import io.ton.walletkit.config.TONWalletKitConfiguration import io.ton.walletkit.config.SignDataType import io.ton.walletkit.model.TONNetwork // URL of the wallet's implementation of the HTTP bridge: // https://github.com/ton-connect/docs/blob/main/bridge.md#http-bridge // // Can be different, e.g., https://bridge.tonapi.io/bridge val bridgeURL = \"https://connect.ton.org/bridge\" val features = listOf( // Wallet can send transactions. TONWalletKitConfiguration.SendTransactionFeature( // Max number of messages that can be sent in a single transaction. // Depends on the TON wallet used, because different kinds can handle // different number of messages. maxMessages = 1, // Are messages sending extra-currencies supported? extraCurrencySupported = false ), TONWalletKitConfiguration.SignDataFeature( types = listOf( // Types of data to sign. SignDataType.TEXT, SignDataType.BINARY, SignDataType.CELL ) ) ) val configuration = TONWalletKitConfiguration( network = TONNetwork.MAINNET, /* or TONNetwork.TESTNET */ walletManifest = TONWalletKitConfiguration.Manifest( name = \"Name of your wallet service\", appName = \"your_wallet_service_id\", /* e.g. best_ton_wallet_service */ imageUrl = \"https://<YOUR_WALLET_SERVICE_URL>/image.png\", aboutUrl = \"https://<YOUR_WALLET_SERVICE_URL>/about\", universalLink = \"https://<YOUR_WALLET_SERVICE_URL>/universal-link\", bridgeUrl = bridgeURL ), bridge = TONWalletKitConfiguration.Bridge( bridgeUrl = bridgeURL ), features = features ) ​Storage configuration By default, WalletKit uses persistent storage. To set a different behavior, use the storage parameter when creating a new configuration: CopyAsk AIval configuration = TONWalletKitConfiguration( // ...other fields... storage = TONWalletKitConfiguration.Storage( persistent = true // or false for memory-only storage ) ) ​Creating WalletKit instance Once you have a configuration, create an instance of the kit: CopyAsk AIimport io.ton.walletkit.ITONWalletKit // Instance val walletKit = ITONWalletKit.initialize( context = context, config = configuration ) Was this page helpful?YesNoSuggest editsRaise issuePreviousManage TON walletsNext⌘IgithubxtelegramPowered by MintlifyOn this pageCreating configurationStorage configurationCreating WalletKit instance",
    "category": "integration",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "dapp",
      "api",
      "sdk",
      "testnet",
      "mainnet",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:40:36.409Z"
  },
  {
    "id": "docs-ton-org--ecosystem-ton-connect-walletkit-android-wallets",
    "title": "How to manage TON wallets with WalletKit on the Android platform",
    "url": "https://docs.ton.org/ecosystem/ton-connect/walletkit/android/wallets",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectOverviewIntegrate a dAppIntegrate a walletManifestsMessage lookupWalletKitOverviewWebiOSAndroidInstall the kitInit the kitManage TON walletsReceiving informationHandle eventsTransactionsWebView injectionIntegration QA guideNative and web walletsBrowser extensions and in-wallet browsersTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationAndroidHow to manage TON wallets with WalletKit on the Android platformEcosystemTON ConnectWalletKitAndroidHow to manage TON wallets with WalletKit on the Android platformCopy pageCopy pageInitialize the WalletKit before managing wallets. See the initialization guide for details. The SDK provides a comprehensive API for creating, retrieving, and managing wallets. All wallet operations follow a three-step pattern. ​Creation pattern The SDK uses a three-step pattern for creating wallets, providing fine-grained control over key management and wallet configuration: Create a signer: generate or import cryptographic keys Create an adapter: configure wallet version and network settings Add the wallet: register the wallet with the SDK ​Creating wallets from mnemonic Import an existing wallet from a mnemonic: CopyAsk AIval mnemonic = listOf(\"word1\", \"word2\", /* ... 24 words ... */) val signer = walletKit.createSignerFromMnemonic(mnemonic) val adapter = walletKit.createV5R1Adapter( signer = signer, network = TONNetwork.MAINNET ) val wallet = walletKit.addWallet(adapter.adapterId) Always store mnemonic phrases securely using platform-specific encrypted storage. Never store them in plain text or as part of the code. ​Creating wallets from secret key For externally managed keys: CopyAsk AIval secretKey = /* 32-byte secret key as ByteArray */ val signer = walletKit.createSignerFromSecretKey(secretKey) val adapter = walletKit.createV5R1Adapter( signer = signer, network = TONNetwork.MAINNET ) val wallet = walletKit.addWallet(adapter.adapterId) ​Wallet versions The SDK supports multiple wallet contract versions: V5R1 and V4R2. ​V5R1 (Recommended) The latest wallet version with improved features and gas optimization: CopyAsk AIval adapter = walletKit.createV5R1Adapter( signer = signer, network = TONNetwork.MAINNET ) ​V4R2 (Compatible) Widely supported legacy version: CopyAsk AIval adapter = walletKit.createV4R2Adapter( signer = signer, network = TONNetwork.MAINNET ) ​Retrieving wallets Get all wallets managed by the SDK: CopyAsk AIval wallets = walletKit.getWallets() Get a specific wallet by an address: CopyAsk AIval wallet = walletKit.getWallet(\"<TON_WALLET_ADDRESS>\") ​Removing wallets Remove a single wallet: CopyAsk AIwalletKit.removeWallet(\"<TON_WALLET_ADDRESS>\") ​Next steps Handle eventsLearn how to handle dApp connections and other eventsRetrieve wallet dataGet balances, Jettons, and NFTsWas this page helpful?YesNoSuggest editsRaise issuePreviousReceiving informationNext⌘IgithubxtelegramPowered by MintlifyOn this pageCreation patternCreating wallets from mnemonicCreating wallets from secret keyWallet versionsV5R1 (Recommended)V4R2 (Compatible)Retrieving walletsRemoving walletsNext steps",
    "category": "integration",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "dapp",
      "api",
      "sdk",
      "mainnet",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:40:38.787Z"
  },
  {
    "id": "docs-ton-org--ecosystem-ton-connect-walletkit-android-data",
    "title": "How to retrieve wallet information, jettons, and NFTs with WalletKit on the Android platform",
    "url": "https://docs.ton.org/ecosystem/ton-connect/walletkit/android/data",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectOverviewIntegrate a dAppIntegrate a walletManifestsMessage lookupWalletKitOverviewWebiOSAndroidInstall the kitInit the kitManage TON walletsReceiving informationHandle eventsTransactionsWebView injectionIntegration QA guideNative and web walletsBrowser extensions and in-wallet browsersTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationAndroidHow to retrieve wallet information, jettons, and NFTs with WalletKit on the Android platformEcosystemTON ConnectWalletKitAndroidHow to retrieve wallet information, jettons, and NFTs with WalletKit on the Android platformCopy pageCopy pageAll methods require an existing wallet instance. Create or retrieve a wallet before accessing data. Retrieve wallet information, Jettons, and NFTs using WalletKit. ​Wallet information ​Balance CopyAsk AI// Returns balance in nanoToncoin val balance = wallet.getBalance() ​Address CopyAsk AIval address = wallet.address ​Jettons ​Get all Jettons CopyAsk AIval jettons = wallet.getJettons(limit = 10, offset = 0) ​Get specific Jetton balance CopyAsk AI// Address of a Jetton minter contract // E.g., EQCxE6mUtQJKFnGfaROTKOt1lZbDiiX1kCixRv7Nw2Id_sDs for USDT val jettonAddress = \"<JETTON_ADDRESS>\" // Returns balance in nanoToncoin with decimals count according to Jetton specification val balance = wallet.getJettonBalance(jettonAddress) ​Get Jetton wallet address CopyAsk AI// Address of a Jetton minter contract // E.g., EQCxE6mUtQJKFnGfaROTKOt1lZbDiiX1kCixRv7Nw2Id_sDs for USDT val jettonAddress = \"<JETTON_ADDRESS>\" val walletAddress = wallet.getJettonWalletAddress(jettonAddress) ​NFTs ​Get all NFTs CopyAsk AIval nfts = wallet.getNFTItems(limit = 10, offset = 0) ​Get specific NFT CopyAsk AI// Address of an NFT item contract // E.g., EQDkT3BSIU3CTwnZG9ZIdyWYmcnuaAEwGr_dsS1RFYqBTanY val nftAddress = \"<NFT_ADDRESS>\" val nft = wallet.getNFT(nftAddress) ​Next steps TransactionsTransfer Toncoin, Jettons and NFTsManage walletsCreate and manage TON walletsWas this page helpful?YesNoSuggest editsRaise issuePreviousHandle eventsNext⌘IgithubxtelegramPowered by MintlifyOn this pageWallet informationBalanceAddressJettonsGet all JettonsGet specific Jetton balanceGet Jetton wallet addressNFTsGet all NFTsGet specific NFTNext steps",
    "category": "integration",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "dapp",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:40:40.367Z"
  },
  {
    "id": "docs-ton-org--ecosystem-ton-connect-walletkit-android-events",
    "title": "How to connect to dApp and handle wallet events on the Android platform",
    "url": "https://docs.ton.org/ecosystem/ton-connect/walletkit/android/events",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectOverviewIntegrate a dAppIntegrate a walletManifestsMessage lookupWalletKitOverviewWebiOSAndroidInstall the kitInit the kitManage TON walletsReceiving informationHandle eventsTransactionsWebView injectionIntegration QA guideNative and web walletsBrowser extensions and in-wallet browsersTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationAndroidHow to connect to dApp and handle wallet events on the Android platformEcosystemTON ConnectWalletKitAndroidHow to connect to dApp and handle wallet events on the Android platformCopy pageCopy pageInitialize WalletKit before adding an events handler. See the initialization guide for details. ​Connection Before receiving and handling wallet events, set up an events handler and establish a connection with a dApp. ​Setting up events handler Create your own implementation of an events handler and add it to the WalletKit instance: CopyAsk AIimport io.ton.walletkit.ITONWalletKit import io.ton.walletkit.listener.TONBridgeEventsHandler import io.ton.walletkit.event.TONWalletKitEvent class YourCustomWalletEventsHandler : TONBridgeEventsHandler { override fun handle(event: TONWalletKitEvent) { // Process the event or throw an error } } val eventsHandler = YourCustomWalletEventsHandler() walletKit.addEventsHandler(eventsHandler) If a handler is not needed anymore or needs to be replaced by some other handler, remove it: CopyAsk AIwalletKit.removeEventsHandler(eventsHandler) ​Establishing connection with dApp To establish a connection with a dApp, one needs a connection request URL from any source: copy/paste, QR code, deep link, etc. Send it to the WalletKit to initiate a connection request. CopyAsk AIwallet.connect(/* connection url */) Once the connection request is fired, the corresponding event will be sent to your event handler. The connection event contains an object you can use to display request information to your app’s users and to approve (or reject) the request to complete connection establishment. CopyAsk AIclass YourCustomWalletEventsHandler : TONBridgeEventsHandler { override fun handle(event: TONWalletKitEvent) { when (event) { is TONWalletKitEvent.ConnectRequest -> { // Send request object to appropriate screen // to display request information to app user } else -> {} } } } // Call an appropriate method corresponding to the user's response // To approve request.approve(walletAddress = /* TON wallet address */) // To reject request.reject(reason = /* rejection reason */) After approval, the connection will be established, and the wallet service will be able to receive and handle other events associated with the corresponding TON wallet. ​Handling events All event handling is made through a custom event handler. Received events carry a lot of useful information that can be displayed to the user to allow them to approve or reject the request based on their action. The only exception is a disconnection request. Even though it contains information you can show to a user, there is no need to approve or reject it on their end. ​Transaction event handling CopyAsk AIclass YourCustomWalletEventsHandler : TONBridgeEventsHandler { override fun handle(event: TONWalletKitEvent) { when (event) { is TONWalletKitEvent.TransactionRequest -> { // Send request object to appropriate screen // to display request information to app user } else -> {} } } } // Call an appropriate method corresponding to the user's response // To approve request.approve() // To reject request.reject(reason = /* rejection reason */) ​Sign data event handling CopyAsk AIclass YourCustomWalletEventsHandler : TONBridgeEventsHandler { override fun handle(event: TONWalletKitEvent) { when (event) { is TONWalletKitEvent.SignDataRequest -> { // Send request object to appropriate screen // to display request information to app user } else -> {} } } } // Call an appropriate method corresponding to the user's response // To approve request.approve() // To reject request.reject(reason = /* rejection reason */) ​Disconnection event handling CopyAsk AIclass YourCustomWalletEventsHandler : TONBridgeEventsHandler { override fun handle(event: TONWalletKitEvent) { when (event) { is TONWalletKitEvent.Disconnect -> { // Send info object to appropriate screen // to display request information to app user } else -> {} } } } Alternatively, explore the complete demo wallet with WalletKit integration: Demo wallet, GitHubWas this page helpful?YesNoSuggest editsRaise issuePreviousTransactionsNext⌘IgithubxtelegramPowered by MintlifyOn this pageConnectionSetting up events handlerEstablishing connection with dAppHandling eventsTransaction event handlingSign data event handlingDisconnection event handling",
    "category": "integration",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "dapp",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:40:42.446Z"
  },
  {
    "id": "docs-ton-org--ecosystem-ton-connect-walletkit-android-transactions",
    "title": "How to transfer Toncoin, Jettons and NFTs with WalletKit on the Android platform",
    "url": "https://docs.ton.org/ecosystem/ton-connect/walletkit/android/transactions",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectOverviewIntegrate a dAppIntegrate a walletManifestsMessage lookupWalletKitOverviewWebiOSAndroidInstall the kitInit the kitManage TON walletsReceiving informationHandle eventsTransactionsWebView injectionIntegration QA guideNative and web walletsBrowser extensions and in-wallet browsersTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationAndroidHow to transfer Toncoin, Jettons and NFTs with WalletKit on the Android platformEcosystemTON ConnectWalletKitAndroidHow to transfer Toncoin, Jettons and NFTs with WalletKit on the Android platformCopy pageCopy pageAll methods require an existing wallet instance. Create or retrieve a wallet before accessing data. Create transactions to send Toncoin, Jettons, and NFTs, or generate previews for users. ​Creating a transaction Before sending any transaction to the blockchain, initialize it for the appropriate asset: Toncoin, Jetton, or NFT. ​Toncoin CopyAsk AIval message = TONTransferParams( // TON wallet address toAddress = \"<TON_WALLET_ADDRESS>\", // 1 Toncoin in nanoToncoin format amount = \"1000000000\" ) val transaction = wallet.createTransferTonTransaction(message) ​Jettons CopyAsk AIval parameters = TONJettonTransferParams( // TON wallet address toAddress = \"<TON_WALLET_ADDRESS>\", // Address of a Jetton minter contract // E.g., EQCxE6mUtQJKFnGfaROTKOt1lZbDiiX1kCixRv7Nw2Id_sDs for USDT jettonAddress = \"<JETTON_ADDRESS>\", // 1 token in Jetton units amount = \"1000000\" ) val transaction = wallet.createTransferJettonTransaction(parameters) ​NFTs CopyAsk AIval parameters = TONNFTTransferParamsHuman( // TON wallet address toAddress = \"<TON_WALLET_ADDRESS>\", // Address of an NFT item contract // E.g., EQDkT3BSIU3CTwnZG9ZIdyWYmcnuaAEwGr_dsS1RFYqBTanY nftAddress = \"<NFT_ADDRESS>\", ) val transaction = wallet.createTransferNFTTransaction(parameters) ​Transaction Preview Once a transaction object is created, present a preview to the user before sending it. CopyAsk AIval preview = wallet.getTransactionPreview(transaction) ​Sending a transaction CopyAsk AIwallet.sendTransaction(transaction) ​Next steps Receiving informationGet wallet information, Jettons, and NFTsManage walletsCreate and manage TON walletsWas this page helpful?YesNoSuggest editsRaise issuePreviousWebView injectionNext⌘IgithubxtelegramPowered by MintlifyOn this pageCreating a transactionToncoinJettonsNFTsTransaction PreviewSending a transactionNext steps",
    "category": "integration",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "dapp",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:40:43.727Z"
  },
  {
    "id": "docs-ton-org--ecosystem-tma-telegram-ui-overview",
    "title": "Overview",
    "url": "https://docs.ton.org/ecosystem/tma/telegram-ui/overview",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsOverviewTMA create CLITelegram UIOverviewGetting startedAppRoot componentReferenceMateAnalyticsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationTelegram UIOverviewEcosystemTMA: Telegram Mini AppsTelegram UIOverviewCopy pageCopy pageTelegram UI kit equips you with a variety of pre-designed components and tools to help you quickly develop high-quality Telegram applications. Whether you’re aiming to create custom client apps, integrate Telegram functionality, or develop unique bots, this toolkit is your go-to resource. ​Installation CopyAsk AInpm i @telegram-apps/telegram-ui ​Usage CopyAsk AIimport '@telegram-apps/telegram-ui/dist/styles.css'; import { AppRoot, Placeholder } from '@telegram-apps/telegram-ui'; const App = () => ( <AppRoot> <Placeholder header=\"Title\" description=\"Description\" > <img alt=\"Telegram sticker\" src=\"https://xelene.me/telegram.gif\" style={{ display: 'block', width: '144px', height: '144px' }} /> </Placeholder> </AppRoot> ); export default App; ​Features Cross-Platform Design Consistency: Use built-in support for iOS’s Human Interface Guidelines and Android’s Material Design to maintain a uniform look and functionality across both platforms. Pre-designed UI Components: Access a variety of ready-to-use UI components inspired by Telegram’s interface, designed for easy integration and customization. Responsive Design: Create apps that look and work great on any device, using flexible layouts and media queries to ensure optimal display and functionality. Telegram Color Scheme Support: Apply Telegram’s native color schemes to your apps for consistent branding and a familiar user experience. ​Environment support Modern browsers Server-side Rendering All known Telegram clients ​Resources Example Mini App: GitHub. Playground and Storybook: Experiment with components and visualize changes in real-time at Playground and Storybook. Figma Resources: Design and prototype with ease using our comprehensive Figma files available at Figma. ​Contribute Contributions are welcome! To contribute, fork the repository, make your changes, and submit a pull request. We look forward to your innovative ideas and improvements. ​License This Telegram UI Kit is available under the MIT License. Use it freely in both personal and commercial projects. The library was skillfully crafted by @mainsmirnov and @heyqbnk, with the generous sponsorship of TON Foundation.Was this page helpful?YesNoSuggest editsRaise issuePreviousGetting startedNext⌘IgithubxtelegramPowered by MintlifyOn this pageInstallationUsageFeaturesEnvironment supportResourcesContributeLicense",
    "category": "tma",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "dapp",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:40:45.281Z"
  },
  {
    "id": "docs-ton-org--ecosystem-tma-mate-telegram-apps-mate",
    "title": "@telegram-apps/mate",
    "url": "https://docs.ton.org/ecosystem/tma/mate/telegram-apps-mate",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsOverviewTMA create CLITelegram UIMate@telegram-apps/mateGetting startedHostingAnalyticsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationMate@telegram-apps/mateEcosystemTMA: Telegram Mini AppsMate@telegram-apps/mateCopy pageCopy pageMate is a multifunctional tool for developers at the Telegram Mini Apps platform, that solves a wide range of problems. ​Installing To start using Mate, it is required to install the @telegram-apps/mate package. The developer can do it both locally and globally: locallyCopyAsk AInpm i -D @telegram-apps/mate globallyCopyAsk AInpm i -g @telegram-apps/mate Once installed, the package will be accessible via the mate CLI tool: CopyAsk AImate --help It is highly recommended to install the package locally to avoid confusion over package versions and to ensure a consistent usage experience within the development team. ​Install-free Usage Not to install the package, you can also use the package using pnpm or npx: CopyAsk AInpx @telegram-apps/mate@latest --help Was this page helpful?YesNoSuggest editsRaise issuePreviousGetting startedNext⌘IgithubxtelegramPowered by MintlifyOn this pageInstallingInstall-free Usage",
    "category": "tma",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:40:47.035Z"
  },
  {
    "id": "docs-ton-org--languages-tolk-syntax-operators",
    "title": "Operators",
    "url": "https://docs.ton.org/languages/tolk/syntax/operators",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedOverviewBasic syntaxIdioms and conventionsType systemSyntax detailsVariablesConditions and loopsExceptionsFunctions and methodsStructures and fieldsPattern matchingMutabilityOperatorsImportsLanguage featuresMigrating from FunCChangelogTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationSyntax detailsOperatorsLanguagesTolkSyntax detailsOperatorsCopy pageCopy pageTolk provides standard operators for integers and booleans. ​Operator priority From highest to lowest. ​Parenthesis ( ) Groups expressions: (1 + 2) * 3; or creates tensors: pair = (1, 2). ​Square brackets [ ] Creates typed tuples: [1, 2]. ​Operator lazy With lazy loading the compiler loads only the accessed fields and skips the rest. ​Non-null assertion operator ! Skips the nullability check: someVar!. ​Unary operators ! ~ - + Logical negation !x, bitwise not ~x, unary -x and +x. ​Operators as is !is Unsafe as cast and checks for union types: someVar is int. ​Multiplicative * / % ^/ ~/ Integer multiplication, division, modulo, ceiling-division, and rounding-division. All integers have 257-bit precision. ​Additive + - Standard integer addition and subtraction. ​Shifts << >> ^>> ~>> Bitwise shifts, extended by ceiling-right and rounding-right. ​Comparison == < > <= >= != <=> Comparison operators. <=> is known as the spaceship or sign operator. Operators == and != also work for several non-numeric types. For example, addresses. ​Bitwise & | ^ Standard bitwise operators, applicable to both integers and booleans. ​Logical && || Short-circuit: the right operand is evaluated only when necessary. ​Assignment = += -= and other Assignment and augmented assignments. ​Ternary ... ? ... : ... Ternary expressions are available in conditions. ​Missing operators Tolk does not support i++ and i--. Use i += 1 and i -= 1 instead. ​Warnings on unexpected precedence A common pitfall: CopyAsk AIif (flags & 0xFF != 0) { // ... } This does not check the lowest byte. It is parsed as flags & (0xFF != 0), because != has higher precedence, as in C++. To prevent such cases, the compiler reports an error: CopyAsk AIerror: & has lower precedence than !=, probably this code won't work as you expected. Use parenthesis: either (... & ...) to evaluate it first, or (... != ...) to suppress this error. 2 | if (flags & 0xFF != 0) { | ^^^^^^^^^^^^^^^^^ Was this page helpful?YesNoSuggest editsRaise issuePreviousImportsNext⌘IgithubxtelegramPowered by MintlifyOn this pageOperator priorityParenthesis ( )Square brackets [ ]Operator lazyNon-null assertion operator !Unary operators ! ~ - +Operators as is !isMultiplicative * / % ^/ ~/Additive + -Shifts << >> ^>> ~>>Comparison == < > <= >= != <=>Bitwise & | ^Logical && ||Assignment = += -= and otherTernary ... ? ... : ...Missing operatorsWarnings on unexpected precedence",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:40:49.134Z"
  },
  {
    "id": "docs-ton-org--v3-concepts-dive-into-ton-go-from-ethereum-blockchain-comparison",
    "title": "Coming from Ethereum",
    "url": "https://docs.ton.org/v3/concepts/dive-into-ton/go-from-ethereum/blockchain-comparison",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationComing from EthereumComing from EthereumCopy pageCopy pageLearn how to develop and build on TON coming from the Ethereum (EVM) ecosystem. ​Execution model ​Asynchronous blockchain A fundamental aspect of TON development is the asynchronous execution model. Messages sent by one contract take time to arrive at another, so the resulting transactions for processing incoming messages occur after the current transaction terminates. Compared to Ethereum, where multiple messages and state changes on different contracts can be processed within the same atomic transaction, a TON transaction represents a state change only for one account and only for a processing of a single message. Even though in both blockchains a signed included-in-block unit is called a “transaction”, one transaction on Ethereum usually corresponds to several transactions on TON, that are processed over a span of several blocks. Action descriptionEthereumTONSingle message processing with state change on one contractMessage call or “internal transaction”TransactionNumber of state changes and messages on different accounts produced from initial contract callTransactionChain of transactions or “trace” Consider a practical example: liquidity withdrawal on a DEX. On Ethereum, it appears as a single atomic transaction with multiple contract calls inside it. This transaction has a single hash and is included in one block. The same operation on TON consists of a sequence of more than 10 transactions. Each arrow on this image represents a distinct finalized transaction, with its own hash, inclusion block, and all the other properties: Executing a large transaction on Ethereum or any other EVM-based blockchain comes with certain limitations: call depth of 1,024 nested calls and the block gas limit. With TON’s asynchronous execution model, a trace — a chain of transactions — can have any length, as long as there are enough fees to continue it. For example, the trace resulting from this message consisted of more than 1.5 million transactions, lasting more than 4,000 blocks until completion. ​On-chain get methods Another difference is in the get methods. Both Ethereum and TON support them, allowing data to be retrieved from contracts without paying fees. However, in TON, get methods cannot be called on-chain: a contract cannot synchronously retrieve data from another contract during a transaction. This is a consequence of TON’s asynchronous model: by the moment transaction that called a get method would start its execution, data might already change. ​Account model In Ethereum, there are two types of accounts: externally owned accounts (EOA), and contract accounts. EOAs are human-controlled entities, each represented by a private-public key pair. They sign transactions and each has its own balance; the community often refers to them as “wallets”. In TON, there is no such separation. Every valid address represents an on-chain account, each with its own state and balance, that could be changed through transactions. This means that “wallets” in TON are smart contracts that operate under the same rules as any other contract on the blockchain. The TON wallet smart contract works as a proxy: handles an external message, checks message is sent by the wallet’s owner using regular public-key cryptography, and sends an internal message somewhere further in the network. ​Limited contract storage In Ethereum, it’s possible to store any amount of data in a single contract. Unbounded maps and arrays are considered standard practice. TON sets a limit to the amount of data a contract can store. This means that ERC-20-like fungible tokens cannot be implemented in the same way as in an EVM chain, using a single map within a single contract. The limit for contract storage is 65,536 unique cells contract storage, where a cell stores up to 1,023 bits. Messages are constrained by two size limits: 8,192 cells or 221 bits among them, whichever is smaller. Every map that is expected to grow beyond 1,000 values is dangerous. In the TVM map, key access is asymptotically logarithmic, meaning that gas consumption continuously increases to find keys as the map grows. Instead, sharding should be used. ​Ecosystem ​Tooling The recommended programming language for smart contract development in TON is Tolk. Other established languages are also used in the ecosystem; more information about them is available here. For off-chain software, Typescript is the most adopted language in TON. Most of the tooling, bindings and SDKs are implemented in Typescript. Use caseEthereum toolTON counterpartBlockchain interactionEthers, Web3.js, Viem@ton/ton, Asset-sdkWallet connection protocolWalletconnect, WagmiTonConnectDev environment framework / scriptingHardhat, TruffleBlueprintSimulation engineRevm & RethSandbox For low-level manipulation of TON-specific data structures, there is @ton/core. Another library with wrappers for most important contracts and HTTP APIs is @ton/ton. ​Services Web3 developers often rely on specific products and services for on-chain development. The following table showcases some use cases that existing TON services support. Use caseEthereum serviceTON serviceUser-friendly explorerEtherscanTonviewer, TonscanOpen-source dev explorerBlockscoutTON ExplorerDebuggerRemix DebuggerTxTracerIDERemix IDEWeb IDEAsm playground and compilation explorerEVM.CodesTxTracer ​Standards The table maps Ethereum standards and proposals, including ERC and EIP, to their TON counterparts, referred to as TEP. Due to significant differences in execution models, most of the standards in TON differ significantly in semantics and general approach compared to their Ethereum analogs. DescriptionEthereum standardTON Standard (TEP)Fungible token standardERC-20Jettons (TEP-0074)Non-fungible token standardERC-721NFT standard (TEP-0062)Token metadataERC-4955 (Not exactly, but close match)Token Data Standard (TEP-0064)NFT royalty standardEIP-2981NFT Royalty Standard (TEP-0066)DNS-like registryENS (EIP-137)DNS Standard (TEP-0081)Soulbound / account-bound token conceptEIP-4973SBT Standard (TEP-0085)Wallet connection protocolWalletConnect / EIP-1193TonConnect (TEP-0115)Was this page helpful?YesNoSuggest editsRaise issuePreviousOther resourcesNext⌘IgithubxtelegramPowered by MintlifyOn this pageExecution modelAsynchronous blockchainOn-chain get methodsAccount modelLimited contract storageEcosystemToolingServicesStandards",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "typescript",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:40:53.873Z"
  },
  {
    "id": "docs-ton-org--v3-documentation-data-formats-cells-overview",
    "title": "Cells",
    "url": "https://docs.ton.org/v3/documentation/data-formats/cells/overview",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationCellsLibrary referencesMerkle proofsMerkle updatesPruned branchesBag of cellsAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationSerializationCellsBlockchain foundationsSerializationCellsCopy pageCopy page​Basic structure The TON Virtual Machine (TVM) memory, persistent storage, and smart contract code consist of cells. In turn, each cell consists of up to 1023 bits; up to 4 references to other cells. Circular references are forbidden and cannot be created, because computing cryptographic hash function of data that contains the same hash is impossible. In this way, all cells are kept in TVM memory and persistent storage constitute a directed acyclic graph (DAG). From the perspective of low-level cell operations, these data bits and cell references are not intermixed. In other words, a cell essentially is a couple consisting of a list of up to 1023 bits and a list of up to four cell references, without prescribing an order in which the references and the data bits should be deserialized, even though TL-B schemes appear to suggest such an order. ​Kinds of cells There are two kinds of cells: ordinary and exotic. The former are the simplest and most commonly used flavor of cells, which can only contain data and references, while the latter are used for special purposes only. They sometimes appear in actual representations of blocks and other data structures on TON Blockchain. Their memory layouts and purposes differ significantly from ordinary cells. From the low-level perspective, ordinary and exotic cells can be distinguished by a special 1-bit flag stored outside the main 1,023 bits and read by TVM at runtime. Users cannot read this flag directly. TVM can support up to 256 different types of exotic cells, each identified by a special 8-bit type identifier stored in the first byte of the cell data. TVM supports four types of exotic cells: Type IDDescription0x01Pruned branch0x02Library reference0x03Merkle proof0x04Merkle update ​Level of a cell Every cell c has an attribute Lvl(c)Lvl(c)Lvl(c) called its level, which takes integer values in the range 0…3. A cell’s level affects the number of higher hashes it has. The level of an ordinary cell ccc is equal to the maximum of the levels of all its children cic_ici​: Lvl(c)=max⁡iLvl(ci).Lvl(c) = \\max_i Lvl(c_i).Lvl(c)=imax​Lvl(ci​). For instance, each cell in a tree of cells that does not contain any exotic cell has level 0. Exotic cells may have different rules for setting their level. ​Standard cell representation and its hash Before a cell can be transferred over the network or stored on disk, it must be serialized. A common way to do this is to use the so-called standard cell representation, CellRepr(c). The standard representation of a cell c is a byte sequence that is constructed as follows: Two descriptor bytes d1d_1d1​ and d2d_2d2​ are serialized first. Byte d1d_1d1​ equals r+8s+32l, where 0 ≤ r ≤ 4 is the quantity of cell references contained in the cell, 0 ≤ l ≤ 3 is the level of the cell, and 0 ≤ s ≤ 1 is 1 for exotic cells and 0 for ordinary cells. Byte d2d_2d2​ equals ⌊b8⌋+⌈b8⌉\\lfloor\\frac{b}{8}\\rfloor + \\lceil\\frac{b}{8}\\rceil⌊8b​⌋+⌈8b​⌉, where 0 ≤ b ≤ 1023 is the quantity of data bits in c. Then the data bits are serialized as ⌈b8⌉\\lceil\\frac{b}{8}\\rceil⌈8b​⌉ bytes. If b is not a multiple of eight, a binary 1 and up to six binary 0s are appended to the data bits. After that, the data is split into ⌈b8⌉\\lceil\\frac{b}{8}\\rceil⌈8b​⌉ 8-bit groups, and each group is interpreted as an unsigned big-endian integer 0 … 255 and stored into a byte. Next, for every referenced cell, 2 bytes in big-endian format store the depth of the refs, i.e. the number of cells between the root of the cell tree (the current cell) and the deepest reference, including it. For example, a cell containing only one reference and no further references would have a depth of 1, while the referenced cell would have a depth of 0. Finally, for every referenced cell, the SHA-256 hash of its standard representation is stored, occupying 32 bytes per referenced cell, recursively repeating the said algorithm. Note that cyclic cell references are not allowed, so this algorithm always terminates. If there are no referenced cells, neither depths nor hashes are stored. In this way, 2+⌈b8⌉+2r+32r2 + \\lceil\\frac{b}{8}\\rceil + 2r + 32r2+⌈8b​⌉+2r+32r bytes of CellRepr(c) are obtained. Thus, we got the serialization of c. However, the serialization of graphs formed by cells is arranged differently; see bag of cells for details. ​Cell manipulation Cells are read-only and immutable, but there are two major sets of ordinary cell manipulation instructions in TVM: Cell creation (or serialization) instructions, which are used to construct new cells from previously stored values and cells. Cell parsing (or deserialization) instructions, which are used to extract or load data previously stored into cells via serialization instructions. All cell manipulation instructions require transforming values of Cell type into either builder or slice types before such cells can be modified or inspected. Libraries like @ton/core and @ton-community/assets-sdk provide efficient cell handling. Below are examples of sequential cell creation, populating it with data, and then parsing. ​Create a cell and store data To build a cell, you use the beginCell() function. While the cell is open, you can store various data types with store...() functions. When you’re done, you close the cell with the endCell() function. CopyAsk AIimport { Address, beginCell } from \"@ton/core\"; const cell = beginCell() .storeUint(99, 64) // Stores uint 99 in 64 bits .storeAddress(Address.parse(\"EQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM9c\")) // Stores an address .storeCoins(123) // Stores 123 as coins .endCell(); // Closes the cell Each cell has a 1023-bit limit. If you exceed this, an error occurs: CopyAsk AI// This will fail due to overflow const cell = beginCell() .storeUint(1, 256) .storeUint(2, 256) .storeUint(3, 256) .storeUint(4, 256) // Exceeds 1023-bit limit (256 + 256 + 256 + 256 = 1024) .endCell(); To store more data, cells can reference up to four other cells. You can use the storeRef() function to create nested cells: CopyAsk AIconst cell = beginCell() .storeUint(1, 256) .storeUint(2, 256) .storeRef(beginCell().storeUint(3, 256).storeUint(4, 256).endCell()) .endCell(); You can store optional (nullable) values in cells by using the storeMaybe...() helpers: CopyAsk AIconst cell = beginCell() .storeMaybeInt(null, 64) // Optionally stores an int .storeMaybeInt(1, 64) .storeMaybeRef(null) // Optionally stores a reference .storeMaybeRef(beginCell().storeCoins(123).endCell()) .endCell(); ​Load data from a cell To read data from a cell, you first convert it into a slice using the beginParse() function. Then, you can extract various data types with load...() functions. You read data in the same order it was stored. CopyAsk AIconst slice = cell.beginParse(); const uint = slice.loadUint(64); const address = slice.loadAddress(); const coins = slice.loadCoins(); To load a referenced (nested) cell, use loadRef(): CopyAsk AIconst slice = cell.beginParse(); const uint1 = slice.loadUint(256); const uint2 = slice.loadUint(256); const innerSlice = slice.loadRef().beginParse(); // Load and parse nested cell const uint3 = innerSlice.loadUint(256); const uint4 = innerSlice.loadUint(256); You can parse optional values using the corresponding loadMaybe...() functions. Returned values are nullable, so do not forget to check them for null. CopyAsk AIconst slice = cell.beginParse(); const maybeInt = slice.loadMaybeInt(64); const maybeInt1 = slice.loadMaybeInt(64); const maybeRef = slice.loadMaybeRef(); const maybeRef1 = slice.loadMaybeRef(); if (maybeRef1) { const coins = maybeRef1.beginParse().loadCoins(); } ​References Parse and view TON smart contract cells in a human-readable format. Was this page helpful?YesNoSuggest editsRaise issuePreviousLibrary referencesNext⌘IgithubxtelegramPowered by MintlifyOn this pageBasic structureKinds of cellsLevel of a cellStandard cell representation and its hashCell manipulationCreate a cell and store dataLoad data from a cellReferences",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:41:07.224Z"
  },
  {
    "id": "docs-ton-org--v3-documentation-data-formats-tlb-types",
    "title": "Syntax and Semantics",
    "url": "https://docs.ton.org/v3/documentation/data-formats/tlb/types",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BOverviewSyntax and SemanticsSimple examplesComplex and non-trivial examplesTEP examplesToolingFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationTL-BSyntax and SemanticsLanguagesTL-BSyntax and SemanticsCopy pageCopy page​Syntax Each line of a TL-B file is either a TL-B scheme (i.e., type declaration), a comment, or a blank line. ​TL-B Scheme The TL-B scheme describes how to serialize a certain algebraic data structure into a binary format. Here are some examples: In general, each TL-B scheme has the following structure: Constructor that consists of optional constructor name; tag: empty, $ or #; prefix code or _. CopyAsk AIbool_true$1; transfer#5fcc3d14; some#_; _#_. Fields definitions, each of which consists of optional field name (ident); type expression (type-expr). CopyAsk AIval:(## 32); src:MsgAddressInt; Constraints: optional expressions that restrict values which are instances of the Nat type. CopyAsk AI{ n <= 100 }; { ~b = a + 10 }; { anycast = 0 }; { b >= c }. Parameters declarations: declare fields of types # (natural numbers) or Type (types of types) that may be used as parameters for parameterized types. Always framed by curly {} brackets. CopyAsk AI_ {x:#} my_val:(## x) = A x; _ {X:Type} my_val:(## 32) next_val:X = A X; Combinator name: the right side of the TL-B scheme that represents the name of the defined combinator. Could be parameterized. CopyAsk AI... = MsgAddrSmpl; // parameterized combinators ... = Maybe X; ... = Hashmap n X. ​Comments The comments follow the same conventions as in C++. CopyAsk AI/* This is a comment */ // This is a single-line comment ​Semantics From a high-level perspective, the right-hand side of each scheme is a type, either simple (such as Bit or True) or parametrized (such as Hashmap n X) and the left-hand side describes a way to define, or even to serialize, a value of the type indicated in the right-hand side. Below, we gradually describe each component of TL-B schemes. ​Constructors Constructors define a combinator’s type, including its state during serialization. Each constructor begins with the (possibly empty _) string name, such as a message or bool_true, immediately followed by an optional constructor tag, such as #_ or $10, which describes the bitstring used to encode (serialize) the constructor in question. Tags may be given in either binary (after a dollar sign) or hexadecimal notation (after a hash sign). If a tag is not explicitly provided, the TL-B parser must compute a default 32-bit constructor tag by hashing with the CRC32 algorithm the text of the scheme with | 0x80000000 defining this constructor in a certain fashion. Therefore, empty tags must be explicitly provided by #_ or $_. All constructor names must be distinct, and constructor tags for the same combinator must constitute a prefix code (otherwise the deserialization would not be unique), i.e., no tag can be a prefix of any other. Also, there are size limitations: maximum number of constructors per type: 64; maximum number of bits for a tag: 63. For example, each address in TON could be either an internal message or an external, see general info page. Addresses are serialized according to the following TL-B schemes: CopyAsk AIaddr_none$00 = MsgAddressExt; addr_extern$01 ... = MsgAddressExt; addr_std$10 ... = MsgAddressInt; addr_var$11 ... = MsgAddressInt; ... _ _:MsgAddressInt = MsgAddress; _ _:MsgAddressExt = MsgAddress; When parsing the binary string 10... that should be an instance of MsgAddress combinator, the parser extracts the initial two bits that determine the tag. It then understands that this address is further serialized as add_std and continues to parse our string relative to the fields defined in this constructor. All main variations of constructors are presented in the following table: ConstructorSerializationsome#3f5476caA 32-bit uint is serialized from a hex value.some#5feA 12-bit uint is serialized from a hex value.some$0101 or _$0101Serialize the 0101 raw bits.some or some#Serialize crc32(equation) | 0x80000000.some#_ or some$_ or _Serialize nothing. In addition to the standard hex tag definition, a hexadecimal number may be followed by an underscore _ character. This indicates that the tag should be interpreted as the hexadecimal value with the least significant bit (LSB) removed. For example, consider the following schema, which represents a stack integer value: CopyAsk AIvm_stk_int#0201_ ... = VmStackValue; In this case, the tag is not equal to 0x0201. To compute the actual tag, remove the LSB from the binary representation of 0x0201: CopyAsk AI0000001000000001 -> 000000100000000 The resulting tag is the 15-bit binary number 0b000000100000000. ​Field definitions Field definitions follow each constructor and its optional tag. A field definition has the format ident:type-expr, where: ident is the field’s name. If you don’t want to assign a specific name to the field, just leave it as _. type-expr is the field’s type. It can be a simple type, a parameterized type with appropriate arguments, or a more complex expression. Note: the total size of all fields in a type must not exceed the limits of a single cell: 1023 bits and 4 references. TL-B schemes define types. At the same time, the previously defined types can be used in other schemes in fields. Therefore, in order to properly understand what types can be assigned to fields, we need to simultaneously figure out how to define the types themselves. ​Types ​Simple Fields that are simple types are just examples of some previously defined or built-in types. They do not contain parameterization or any conditions. For example, Tick and Tock transactions are designated for special system smart contracts that must be automatically invoked in every block. Tick transactions are executed at the start of each masterchain block, while Tock transactions are initiated at the end. Here is how they are represented in TL-B: CopyAsk AItrans_tick_tock$001 is_tock:Bool storage_ph:TrStoragePhase compute_ph:TrComputePhase action:(Maybe ^TrActionPhase) aborted:Bool destroyed:Bool = TransactionDescr; So, is_tock, storage_ph, compute_ph, aborted, and destroyed are fields with simple types. Below are all the built-in types that can be used in defining fields: #: 32-bit unsigned integer; ## x: unsigned integer with x bits; #< x: unsigned integer less than x bits, stored as lenBits(x - 1) bits up to 31 bits; #<= x: unsigned integer less than or equal to x bits, stored as lenBits(x) bits up to 32 bits; Any or Cell: remaining bits and references; uint1: uint256 - 1 - 256 bits; int1: int257 - 1 - 257 bits; bits1: bits1023 - 1 - 1023 bits. ​Contained complex expressions Multiplicative expression for tuple creation. The expression x * T creates a tuple of the natural length x, where each element is of type T. CopyAsk AIa$_ a:(## 32) = A; b$_ b:(2 * A) = PairOf32-bits-uints; Serialization in the ref cell: ^[ ... ] means that the fields inside the brackets are serialized in a separate cell, which is referenced from the current cell. CopyAsk AI_ a:(## 32) ^[ b:(## 32) c:(## 32) d:(## 32)] = A; Chains of references are also allowed. In the following example, each variable (a, b, c) is stored in a separate cell, resulting in a chain of three referenced cells: CopyAsk AI_ ^[ a:(## 32) ^[ b:(## 32) ^[ c:(## 32) ] ] ] = A; Other complex type expressions are related to the Nat type only. The Nat type is a built-in type that represents natural numbers. The types #, ## x, #< x, and #<= x together constitute the Nat type. In TL-B schemes, the + and * operations can be performed on Nat. Constraints: Nat = Nat | Nat <= Nat | Nat < Nat | Nat >= Nat | Nat > Nat. Each constraint must be enclosed in curly braces {}, and the variables used inside must be defined earlier. CopyAsk AI_ flag1:(## 10) flag2:# { flag1 + flag2 <= 100 } = Flag; This constraint means that the sum of the flags fields must be less than or equal to 100. Condition operator: Nat?Type means that if the natural number is positive, then the field has the type T. Otherwise, the field is omitted. CopyAsk AI_ a:(## 1) b:a?(## 32) = Example; In the Example type, the field b is serialized only if the a field is equal to 1. Bit selector: The expression E . B means to take bit B from the Nat value E. CopyAsk AI_ a:(## 2) b:(a . 1)?(## 32) = CondExample; Similarly, in the CondExample type, the variable b is serialized only if the second bit of a is 1. For the real-world example, one may consider the following McStateExtra combinator that describes data stored in each masterchain block. CopyAsk AImasterchain_state_extra#cc26 shard_hashes:ShardHashes config:ConfigParams ^[ flags:(## 16) { flags <= 1 } validator_info:ValidatorInfo prev_blocks:OldMcBlocksInfo after_key_block:Bool last_key_block:(Maybe ExtBlkRef) block_create_stats:(flags . 0)?BlockCreateStats ] global_balance:CurrencyCollection = McStateExtra; ​Parame",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:41:12.386Z"
  },
  {
    "id": "docs-ton-org--v3-documentation-data-formats-tl",
    "title": "TL Language",
    "url": "https://docs.ton.org/v3/documentation/data-formats/tl",
    "content": "TL Language TL (Type Language) serves to describe the used system of types, constructors, and existing functions. In fact, the combinator description format presented in Binary Data Serialization is used. See also: Polymorphism in TL Advanced topics: Dependent types in TL Formal description of TL Formal description of TL combinators Type serialization TL schema for serialization of TL schemas Optional combinator parameters and their values Binary serialization and abstract TL types Formal description of templates in TL Overview A TL program usually consists of two sections separated by keyword ---functions---. The first section consists of declarations of built-in types and aggregate types (i.e. their constructors). The second section consists of the declared functions, i.e. functional combinators. Actually, both the first and second sections consist of combinator declarations, each of which ends with a semicolon. However, the first section contains only constructors, while the second section only involves functions. Each combinator is declared using a “combinator declaration” in the format explained above. However, the combinator number and field names may be explicitly assigned. If additional type declarations are required after functions have been declared, the keyword (section divider) ---types--- is used. Furthermore, a functional combinator may be declared in the type section if its result type begins with an exclamation point (in fact, when the function section is interpreted, this exclamation point is added automatically). To explicitly define 32-bit names of combinators, a hash mark (#) is added immediately after the combinator's name, followed by 8 hexadecimal digits. Namespaces Composite constructions like <namespace_identifier>.<constructor_identifier> and <namespace_identifier>.<Type_identifier> can be used as constructor- or type identifiers. The portion of the identifier to the left of the period is called the namespace. Moreover, the rule about a first uppercase letter in type identifiers and lowercase letter in constructor identifiers applies to the part of the construction after the period. For example, auth.Message would be a type, while auth.std_message would be a constructor. Namespaces do not require a special declaration. Comments Comments are the same as in C++. Example // built-in types int#a8509bda ? = Int; long ? = Long; double ? = Double; string ? = String; null = Null; vector {t:Type} # [ t ] = Vector t; coupleInt {alpha:Type} int alpha = CoupleInt<alpha>; coupleStr {gamma:Type} string gamma = CoupleStr gamma; /* The name of the type variable is irrelevant: \"gamma\" could be replaced with \"alpha\"; However, the combinator number will depend on the specific choice. */ intHash {alpha:Type} vector<coupleInt<alpha>> = IntHash<alpha>; strHash {alpha:Type} (vector (coupleStr alpha)) = StrHash alpha; intSortedHash {alpha:Type} intHash<alpha> = IntSortedHash<alpha>; strSortedHash {alpha:Type} (strHash alpha) = StrSortedHash alpha; // custom types pair x:Object y:Object = Pair; triple x:Object y:Object z:Object = Triple; user#d23c81a3 id:int first_name:string last_name:string = User; no_user#c67599d1 id:int = User; group id:int title:string last_name:string = Group; no_group = Group; ---functions--- // Maybe some built-in arithmetic functions; inverse quotes make \"identifiers\" out of arbitrary non-alphanumeric strings `+` Int Int = Int; `-` Int Int = Int; `+` Double Double = Double; // ... // API functions (aka RPC functions) getUser#b0f732d5 int = User; getUsers#2d84d5f5 (Vector int) = Vector User; In this case, the user constructor has been explicitly assigned a number (0xd23c81a3); In fact, this was not necessary, since this value is the CRC32 of the string \"user id:int first_name:string last_name:string = User\", which would have been used by default. Special constructors are not required for Vector int, Vector User, Vector Object, etc. -- the same universal constructor can be used everywhere: vector#1cb5c415 {t:Type} # [ t ] = Vector t; Note that when the getUsers (Vector int) = Vector User; constructor number is calculated, the CRC32 of the string \"getUsers Vector int = Vector User” is computed (from which all parentheses have been removed). Notation T0<T1,T2,...,Tn> is syntactic sugar for (T0 (T1) (T2) ... (Tn)). For example, Vector<User> and (Vector User) are entirely interchangeable. Example of an RPC query Suppose we want to call getUsers([2,3,4]). This query will be serialized into a sequence of 32-bit integers as follows: 0x2d84d5f5 0x1cb5c415 0x3 0x2 0x3 0x4 Please note that TL serialization yields sequences of 32-bit integers. When it has to be embedded into a byte stream, for example a network packet, each 32-bit integer is represented by four bytes in little-endian order. In this way the above query corresponds to the following byte stream: F5 D5 84 2D 15 C4 B5 1C 03 00 00 00 02 00 00 00 03 00 00 00 04 00 00 00 The response might look something like this: 0x1cb5c415 0x3 0xd23c81a3 0x2 0x74655005 0x00007265 0x72615006 0x72656b 0xc67599d1 0x3 0xd23c81a3 0x4 0x686f4a04 0x6e 0x656f4403 This roughly corresponds to [{\"id\":2,\"first_name\":\"Peter\", \"last_name\":\"Parker\"},{},{\"id\":4,\"first_name\":\"John\",\"last_name\":\"Doe\"}] Note that in both cases the same universal constructor vector#1cb5c415 is used: in the request to serialize the value of type Vector int, and in the serialization of the value of type Vector User in the response. There is no ambiguity because in both cases the type of the value being (de)serialized is known before its (de)serialization begins. For example, after receiving the query, the server sees that the first part is 0x2d84d5f5, which corresponds to the combinator getUsers#2d84d5f5 (Vector int) = Vector User. Thus, it is understood that what follows will be a value of type Vector int. After receiving the response to this query, the client knows that it must receive a value of type Vector User and it deserializes the response accordingly. Telegram Telegram is a cloud-based mobile and desktop messaging app with a focus on security and speed. About FAQ Privacy Press Mobile Apps iPhone/iPad Android Mobile Web Desktop Apps PC/Mac/Linux macOS Web-browser Platform API Translations Instant View About Blog Press Moderation",
    "category": "general",
    "tags": [
      "tact",
      "func",
      "telegram",
      "api",
      "message",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:41:13.466Z"
  },
  {
    "id": "docs-ton-org--v3-documentation-network-protocols-dht-deep-dive",
    "title": "Deep dive",
    "url": "https://docs.ton.org/v3/documentation/network/protocols/dht/deep-dive",
    "content": "Skip to main contentDeprecated! Please, visit the new documentation at docs.ton.org Deprecated, go to new docs!On this pageDeep dive DHT stands for Distributed Hash Table, which is a type of distributed key-value database. In this system, each member of the network can store information, such as details about themselves. The implementation of DHT in TON is similar to the Kademlia protocol, which is also used in IPFS. Any network participant can operate a DHT node, generate keys, and store data. To do this, they need to create a random ID and inform other nodes about their presence. An algorithm determines the \"distance\" between the node and the key, which helps identify which node should store the data. The algorithm is straightforward: it takes the node's ID and the key's ID and performs the XOR operation. A smaller resulting value indicates a closer proximity between the node and the key. The goal is to store the key on nodes that are as close as possible to the key so that other network participants can, using the same algorithm, easily locate a node that can provide data associated with that key. Finding a value by key​ Let's examine an example involving a search for a key: connect to any DHT node and establish a connection via ADNL UDP. Suppose we want to find the address and public key needed to connect to the node hosting the foundation.ton site. Assuming we have already obtained this site's ADNL address by executing the \"get method\" of the DNS contract, the ADNL address in hexadecimal format is 516618cf6cbe9004f6883e742c9a2e3ca53ed02e3e36f4cef62a98ee1e449174. Our objective is to determine the IP address, port number, and public key of the node associated with this address. To achieve this, we first need to get the ID of the DHT key. We will begin by populating the DHT key schema: dht.key id:int256 name:bytes idx:int = dht.Key The term name refers to the type of key. For ADNL addresses, the term address is used. For instance, when searching for shard nodes, the term nodes is used. However, the key type can vary and may consist of any array of bytes, depending on the specific value you are seeking. By applying this schema, we get: 8fde67f6 -- TL ID dht.key516618cf6cbe9004f6883e742c9a2e3ca53ed02e3e36f4cef62a98ee1e449174 -- the ADNL address being searched07 61646472657373 -- key type, the word \"address\" as a TL array of bytes00000000 -- index 0 because there is only 1 key Next, retrieve the key ID and the SHA-256 hash from the bytes serialized above. It will be b30af0538916421b46df4ce580bf3a29316831e0c3323a7f156df0236c5b2f75. Now we can begin our search. To do this, we need to execute a query that uses the following schema: dht.findValue key:int256 k:int = dht.ValueResult The key represents the ID of our DHT key, while k indicates the \"width\" of the search. A smaller value for k results in a more accurate search but limits the number of potential nodes to query. In TON, the specific value of k depends on the implementation. Now, let's populate this structure, serialize it, and send the request using the adnl.message.query schema. For more details, please refer to the documentation here. In response, we can get: dht.valueNotFound - if the value is not found. dht.valueFound - if the value is found on this node. dht.valueNotFound​ If we receive dht.valueNotFound, the response will include a list of nodes that are known to the node we queried and as close as possible to the key we requested. In this situation, we need to connect to these received nodes and add them to our list of known nodes. Afterwards, we will select the closest, accessible nodes that have not yet been queried from our entire list of known nodes and send the same request to one of them. We will continue this process until we have tried all the nodes within our chosen range or until we stop receiving new nodes. Let’s analyze the response fields and the schemas used in more detail: adnl.address.udp ip:int port:int = adnl.Address;adnl.addressList addrs:(vector adnl.Address) version:int reinit_date:int priority:int expire_at:int = adnl.AddressList;dht.node id:PublicKey addr_list:adnl.addressList version:int signature:bytes = dht.Node;dht.nodes nodes:(vector dht.node) = dht.Nodes;dht.valueNotFound nodes:dht.nodes = dht.ValueResult; dht.nodes -> nodes - list of DHT nodes (array). Each node has an id, which serves as its public key, typically represented as pub.ed25519. This key is used to connect to the node via ADNL. Additionally, each node contains a list of addresses, addr_list:adnl.addressList, along with its version and signature. We need to verify the signature of each node. To do this, we first read the value of the signature field and then set it to zero, effectively making it an empty byte array. Next, we serialize the TL structure dht.node using this empty signature and check the signature field that we emptied earlier. We validate the serialized bytes using the public key from the id field. [Please see implementation example]. From the list addrs:(vector adnl.Address), we select an address and attempt to establish an ADNL UDP connection, using id (the public key) as the server key. To determine the \"distance\" to this node, we retrieve the key ID from the id field and calculate the distance using the XOR operation between the node's key ID and the desired key. If the distance is small enough, we can make the same request to this node. This process continues until we find a value or run out of new nodes. dht.valueFound​ The response will include the value itself, complete key information, and optionally a signature, depending on the value type. Let's analyze the response fields in more detail, the schemas used: adnl.address.udp ip:int port:int = adnl.Address;adnl.addressList addrs:(vector adnl.Address) version:int reinit_date:int priority:int expire_at:int = adnl.AddressList;dht.key id:int256 name:bytes idx:int = dht.Key;dht.updateRule.signature = dht.UpdateRule;dht.updateRule.anybody = dht.UpdateRule;dht.updateRule.overlayNodes = dht.UpdateRule;dht.keyDescription key:dht.key id:PublicKey update_rule:dht.UpdateRule signature:bytes = dht.KeyDescription;dht.value key:dht.keyDescription value:bytes ttl:int signature:bytes = dht.Value;dht.valueFound value:dht.Value = dht.ValueResult; Let's determine key:dht.keyDescription. This provides a complete description of the key, including the key itself and information about who can update its value and how. key:dht.key - the key must match the one from which we took the key ID for the search. id:PublicKey - the public key of the record owner. update_rule:dht.UpdateRule - record update rule. dht.updateRule.signature - only the owner of the private key can update the record, the signature of both the key and the value must be valid dht.updateRule.anybody - everyone can update the record, signature is empty and not checked dht.updateRule.overlayNodes - nodes from the same overlay can update the key, used to find nodes of the same overlay and add yourself dht.updateRule.signature​ After reviewing the key's description, we proceed based on the updateRule. In the ADNL address lookup, the type is always dht.updateRule.signature. We verify the key signature in the same manner as before. First, we set the signature to an empty byte array, serialize it, and perform the necessary checks. Next, we repeat this process for the entire dht.value object while ensuring that the key signature is restored to its original state. [Please see implementation example]. dht.updateRule.overlayNodes​ Used for keys that contain information about other nodes, shards of the WorkChain in the network, the value always follows the TL structure overlay.nodes. The signature field must be empty. overlay.node id:PublicKey overlay:int256 version:int signature:bytes = overlay.Node;overlay.nodes nodes:(vector overlay.node) = overlay.Nodes; To check for validity, we must check all nodes and for each check signature against its id by serializing the TL structure: overlay.node.toSign id:adnl.id.short overlay:int256 version:int = overlay.node.ToSign; We should replace the id with adnl.id.short, which is the key identifier (hash) from the original structure's id field. After serialization, we will verify the signature against the data. As a result, we obtain a valid list of nodes that can provide information about the required WorkChain shard. dht.updateRule.anybody​ There are no signatures required; anyone can make updates. Using a value​ Once everything has been verified and the ttl:int value has not expired, we can begin working with the value itself, specifically value:bytes. For an ADNL address, this will include an adnl.addressList structure. This structure will contain the IP addresses and ports of the servers corresponding to the requested ADNL address. In our case, we will have an RLDP-HTTP address associated with the foundation.ton service. We will use the public key, id:PublicKey, from the DHT key information as the server key. After establishing the connection, we can request the site's pages using the RLDP protocol. At this stage, the task from the DHT perspective is complete. Search for nodes that store the state of the blockchain​ DHT is also used to locate information about the nodes storing the data of WorkChains and their shards. The process for retrieving this information is similar to searching for any key; however, the key serialization and response validation differ. We will examine these aspects in this section. To retrieve data, such as that of the MasterChain and its shards, we need to complete the TL structure: tonNode.shardPublicOverlayId workchain:int shard:long zero_state_file_hash:int256 = tonNode.ShardPublicOverlayId; In the context of a MasterChain, the workchain value will be set to -1. The corresponding shard will be represented as -9223372036854775808 (0x8000000000000000). Additionally, the zero_state_file_hash refers to the hash of the chain’s zero state (file_hash). Like other data, this can be obtained fro",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "wallet",
      "telegram",
      "mini app",
      "builder",
      "address",
      "message",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:41:16.821Z"
  },
  {
    "id": "docs-ton-org--v3-documentation-network-config-params-update",
    "title": "System contracts",
    "url": "https://docs.ton.org/v3/documentation/network/config-params/update",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationBlockchain foundationsSystem contractsBlockchain foundationsSystem contractsCopy pageCopy pageThese are low-level TON Blockchain internals. You typically do not need to write or deploy these contracts. System contracts are smart contracts and have on‑chain addresses. See config parameters 1–4. The Config account stores the Config contract address. To track changes, review proposals to the Config contract. In TON, a set of special smart contracts controls consensus parameters for node operation — including TVM, catchain, fees, and chain topology — and how these parameters are stored and updated. Unlike older blockchains that hardcode these parameters, TON enables transparent on‑chain governance. The current governance contracts include the Elector and Config contracts, with expansion plans (for example, the extra‑currency Minter). ​Elector The Elector smart contract manages validator elections, validation rounds, and reward distribution. To become a validator and interact with the Elector, follow the validator instructions. ​Data storage The Elector stores: Non-withdrawn Toncoin in the credits hashmap. New validator applications in the elect hashmap. Past election data in the past_elections hashmap (including complaints and frozen stakes held for stake_held_for periods, defined in ConfigParam 15). ​Key functions Process validator applications Conduct elections Handle validator misbehavior reports Distribute validation rewards ​Processing applications To apply, a validator must: Send a message to the Elector with their Abstract Datagram Network Layer (ADNL) address, public key, max_factor, and stake (TON amount). The Elector validates the parameters and either registers the application or refunds the stake. Note: Only masterchain addresses can apply. ​Conducting elections The Elector is a special smart contract triggered by Tick and Tock transactions (forced executions at the start and end of each block). It checks whether it’s time to conduct a new election during each block. Process details: Take applications with stake ≥ min_stake (ConfigParam 17). Arrange candidates by stake in descending order. If applicants exceed max_validators (ConfigParam 16), discard the lowest-staked candidates. For each subset size i (from 1 to remaining candidates): Assume the i-th candidate (lowest in the subset) defines the baseline. Calculate effective stake (true_stake) for each j-th candidate (j < i) as: not runnableCopyAsk AImin(stake[i] * max_factor[j], stake[j]) Track the subset with the highest total effective stake (TES). Submit the winning validator set to the Config contract. Return unused stakes and excess amounts (e.g., stake[j] - min(stake[i] * max_factor[j], stake[j])) to credits. Example breakdown: Case 1: 9 candidates stake 100,000 TON (max_factor=2.7), 1 candidate stakes 10,000. Without the 10,000-stake candidate: TES = 900,000. With the 10,000-stake candidate: TES = 9 * 27,000 + 10,000 = 253,000. Result: 10,000-stake candidate are excluded. Case 2: 1 candidate stakes 100,000-stake (max_factor=2.7), 9 stake 10,000. Effective stake for the 100,000-stake candidate: 10,000 * 2.7 = 27,000. Excess: 100,000 - 27,000 = 73,000 → sent to credits. Result: All 10 participate. Election constraints: min_validators ≤ participants ≤ max_validators (ConfigParam 16). Stakes must satisfy: min_stake ≤ stake ≤ max_stake min_total_stake ≤ total stake ≤ max_total_stake Stake ratios ≤ max_stake_factor (ConfigParam 17). If conditions aren’t met, elections are postponed. ​Report validator misbehavior Each validator is periodically assigned the duty to create new blocks, with the frequency of assignments determined by their weight. After a validation round, anyone can audit the blocks to check whether the actual number of blocks produced by a validator significantly deviates from the expected number (based on their weight). A statistically significant underperformance (e.g., fewer blocks created than expected) constitutes misbehavior. To report misbehavior, a user must: Generate a Merkle proof demonstrating the validator’s failure to produce the expected blocks. Propose a fine proportional to the severity of the offense. Submit the proof and fine proposal to the Elector contract, covering the associated storage costs. The Elector registers the complaint in the past_elections hashmap. Current round validators then verify the complaint. If the proof is valid and the proposed fine aligns with the severity of the misbehavior, validators vote on the complaint. Approval requires agreement from over two-thirds of the total validator weight (not just a majority of participants). The fine is deducted from the validator’s frozen stake in the relevant past_elections record if approved. These funds stay locked for the period defined by ConfigParam 15 (stake_held_for). ​Distributing rewards The Elector releases frozen stakes and rewards (gas fees plus block rewards) proportionally to past validators. Funds move to credits, and the election record clears from past_elections. ​Config The Config contract manages TON’s configuration parameters, validator set updates, and proposal voting. ​Validator set updates The Elector notifies Config of a new validator set. Config stores it in ConfigParam 36 (next validators). At the scheduled time (utime_since), Config: Moves the old set to ConfigParam 32 (previous validators). Promotes ConfigParam 36 to ConfigParam 34 (current validators). ​Proposal/voting mechanism Submit a proposal: Pay storage fees to propose parameter changes. Vote: Validators (from ConfigParam 34) sign approval messages. Outcome: Approved: After min_wins rounds (ConfigParam 11) with ≥3/4 weighted votes. Rejected: After max_losses rounds. Critical parameters (ConfigParam 10) require more rounds. ​Emergency updates Reserved indexes (-999, -1000, -1001) allow urgent updates to Config/Elector code. A temporary emergency key (assigned to the TON Foundation in 2021) accelerated fixes but couldn’t alter contracts. Key retired on Nov 22, 2023 (block 34312810), replaced with zeros. Later patched to a fixed byte sequence (sha256(\"Not a valid curve point\")) to prevent exploits. Historical uses: Apr 2022: Increased gas limits (blocks 19880281/19880300) to unblock elections. Mar 2023: Raised special_gas_limit to 25M (block 27747086) for election throughput. Was this page helpful?YesNoSuggest editsRaise issuePreviousPrecompiled contractsNext⌘IgithubxtelegramPowered by MintlifyOn this pageElectorData storageKey functionsProcessing applicationsConducting electionsReport validator misbehaviorDistributing rewardsConfigValidator set updatesProposal/voting mechanismEmergency updates",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:41:21.263Z"
  },
  {
    "id": "docs-ton-org--v3-contribute-localization-program-translation-style-guide",
    "title": "Translation style guide",
    "url": "https://docs.ton.org/v3/contribute/localization-program/translation-style-guide",
    "content": "Skip to main contentDeprecated! Please, visit the new documentation at docs.ton.org Deprecated, go to new docs!On this pageTranslation style guide This translation style guide contains essential guidelines, instructions, and tips for translators, helping us localize the website. This document serves as a general guide and is not specific to any language. Capturing the essence of the message​ When translating TON Docs content, avoid literal translations. The translations must capture the essence of the message. This approach means rephrasing specific phrases or using descriptive translations instead of translating the content word for word. Different languages have different grammar rules, conventions, and word order. When translating, please be mindful of structuring sentences in the target language, and avoid word-for-word translation of the English source, as this can lead to poor sentence structure and readability. Instead of translating the source text word for word, you should read the entire sentence and adapt it to fit the conventions of the target language. Formal vs. informal​ We use the formal form of address, which is always polite and appropriate for all visitors. Using the formal address allows us to avoid sounding unofficial or offensive and works regardless of the reader’s age and gender. Most Indo-European and Afro-Asiatic languages use gender-specific second-person personal pronouns, distinguishing between males and females. When addressing the user or using possessive pronouns, we can avoid assuming the reader’s gender, as the formal address is generally applicable and consistent, regardless of how they identify. Straightforward vocabulary and meaning​ Our goal is to make content on the website understandable to as many people as possible. In most cases, contributors can achieve this result by using short and simple words that are easily understandable. If multiple possible translations exist for a word in your language with the same meaning, the best option is often the shortest word reflecting the meaning. Writing system​ Translate using your language’s writing system, except for standard acronyms, brand names, ISO codes, and proper names defined in the Glossary. Do not translate proper names defined in the Glossary. Translating page metadata​ Some pages contain metadata, such as title, lang, description, sidebar, etc. When uploading new pages to Crowdin, we hide content that translators should never translate. This feature makes only the text that should be translated visible to translators in Crowdin. Please be especially careful when translating strings where the source text is 'en'. This represents the language page, which is available and should be translated to the ISO language code for your language. These strings should always be entered using Latin characters, not the writing system native to the target language. Some examples of language codes for the most widely spoken languages: English - en Simplified Chinese - zh-CN Russian - ru Korean - ko Polish - pl Ukrainian - uk Titles of external articles​ Some strings contain titles of external articles. Most of our developer documentation pages contain links to external articles for further reading. The strings containing article titles need to be translated, regardless of the article's language, to ensure a more consistent user experience for visitors viewing the page in their language. Crowdin warnings​ Crowdin has a built-in feature that warns translators when they are about to make a mistake. Crowdin will automatically alert you before saving your translation if you forget to include a tag from the source, translate elements that should not be translated, add several consecutive spaces, forget the end punctuation, etc. If you see a warning like this, please double-check the suggested translation. warningNever ignore these warnings, as they usually mean something is wrong or the translation lacks a key part of the source text. Short vs. complete forms and abbreviations​ The website uses many abbreviations, such as apps, DApps, NFT, DAO, DeFi, etc. These abbreviations are standard in English, and most visitors are familiar with them. Since they usually don’t have established translations in other languages, the best approach to these and similar terms is to provide a descriptive translation of the entire form and add the English abbreviation in brackets. Do not translate English abbreviations into localized versions, since they would not make much sense to most visitors. Example of how to translate DApps: Decentralized applications (DApps) → Translated in complete form (English abbreviation in brackets) Terms without established translations​ Some terms might not have established translations in other languages but are widely known by their original English names. Such terms include newer concepts, like proof-of-work, proof-of-stake, Beacon Chain, staking, etc. While translating these terms can sound unnatural, since the English version serves as the basis for other languages, it is highly recommended that they be translated. Feel free to get creative, use descriptive translations, or translate them literally. Most terms should be translated instead of leaving some in English, as this new terminology will become more widespread as more people start using TON and related technologies. To onboard more people to TON, we must provide understandable terminology in as many languages as possible, even if we need to create it ourselves. Buttons & CTAs​ Translate the website’s UI text, including buttons. You may identify button text by viewing the context screenshots connected with most strings or by checking the context in the editor, which includes the phrase button. Button translations should be as short as possible to prevent formatting mismatches. Additionally, button translations, i.e., presenting a command or request, should be imperative. Translating for inclusivity​ TON Docs visitors come from all over the world and from different backgrounds. Therefore, the language on the website should be neutral, welcoming to everyone, and not exclusive. Gender neutrality is an essential aspect of this. Use the formal address form and avoid gender-specific words in the translations. Another form of inclusivity is trying to translate for a global audience, not specific to any country, race, or region. Finally, the language should be suitable for all audiences and ages. Language-specific translations​ When translating, it is crucial to follow the grammar rules, conventions, and formatting used in your language instead of copying from the source. The source text follows English grammar rules and conventions, which do not apply to many other languages. You should be aware of the rules for your language and translate accordingly. If you need help, contact us; we will help you with resources on translating elements for your language. Some examples of what to be particularly mindful of: Punctuation and formatting​ Capitalization​ There are vast differences in capitalization in different languages. In English, it is common to capitalize all words in titles and names, months and days, language names, holidays, etc. In many other languages, this is grammatically incorrect, as they have different capitalization rules. Some languages also have rules about capitalizing personal pronouns, nouns, and adjectives that you shouldn't capitalize in English. Spacing​ Spacing before units, degree signs, certain punctuation (such as ellipses), and around slashes varies by language. Translators should follow their language’s orthographic rules. Lists​ Every language has a diverse and complex set of rules for writing lists. These can be significantly different from English. In some languages, the first word of each new line needs to be capitalized, while in others, new lines should start with lowercase letters. Many languages also have different rules about capitalization in lists, depending on the length of each line. The same applies to the punctuation of line items. The end punctuation in lists can be a period (.), comma (,), or semicolon (;), depending on the language. Quotation marks​ Languages use many different quotation marks. Simply copying the English quotation marks from the source is often incorrect. Some of the most common types of quotation marks include: „example text“ ‚example text’ »example text« “example text” ‘example text’ «example text» Hyphens and dashes​ In English, use an en dash (–) for ranges and an em dash (—) for pauses. Example: Use an em dash—like this—to indicate a pause. Many languages have different rules for using hyphens and dashes that should be observed. Formats​ Numbers​ The main difference in writing numbers in different languages is the separator for decimals and thousands. For thousands, this can be a period, comma, or space. Similarly, some languages use a decimal point, while others use a decimal comma. Example: English – 1,000.50 Spanish – 1.000,50 French – 1 000,50 The percent sign is another critical consideration when translating numbers. Write numbers in the typical format for the corresponding language. Example: 100%, 100 %, or %100. Finally, negative numbers can be displayed differently, depending on the language. Example: -100, 100-, (100), or [100]. Dates​ When translating dates, there are several considerations and differences based on the language. These include the date format, separator, capitalization, and leading zeros. There are also differences between full-length and numerical dates. Some examples of different date formats: English UK (dd/mm/yyyy) – 1 January 2022 English US (mm/dd/yyyy) – January 1, 2022 Chinese (yyyy-mm-dd) – 2022 年 1 月 1 日 French (dd/mm/yyyy) – 1er janvier 2022 Italian (dd/mm/yyyy) – 1º gennaio 2022 German (dd/mm/yyyy) – 1. Januar 2022 Currencies​ The main differences in writing currencies in different languages include symbol placement, decimal commas vs. decimal points, spacing, and abbre",
    "category": "general",
    "tags": [
      "ton",
      "tact",
      "wallet",
      "nft",
      "telegram",
      "mini app",
      "dapp",
      "api",
      "guide",
      "builder",
      "address",
      "message",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:41:24.557Z"
  },
  {
    "id": "docs-ton-org--v3-contribute-content-standardization",
    "title": "Content standardization",
    "url": "https://docs.ton.org/v3/contribute/content-standardization",
    "content": "Skip to main contentDeprecated! Please, visit the new documentation at docs.ton.org Deprecated, go to new docs!On this pageContent standardization Introduction​ This guideline aims to maintain a consistent documentation style and help contributors standardize their content so that it seamlessly integrates into the documentation. Text preferences​ Use American English​ For words that have multiple spellings, use American English over British English. Examples: \"decentralized\" over \"decentralised\" \"color\" over \"colour\" \"analyze\" over \"analyse\" Use present tense​ Use present tense to describe general behavior, current functionality, and step-by-step instructions. This makes documentation clear and easy to follow. Examples: This guideline provides an overview of the contribution process. The system checks the file format and shows an error if it is invalid. Avoid future or past tense for immediate or typical actions. Avoid: The system will check the file format. The user clicked the button. When to use the future or past tenses​ Present tense is standard, but future and past tenses are allowed in specific cases. Future tense: for actions that happen later, after a condition or delay. Examples: After setup, the system will send a confirmation email. If payment fails, the user will get a notification. Avoid the future tense for immediate behavior or unreleased features. Also, avoid \"would\". Avoid: The system will check the file format. The API would return an error. Past tense: for describing past events like changelogs or logs. Examples: Version 2.1 fixed a validation issue. The user submitted the form at 2 pm and got a 500 error. Avoid past tense in general documentation — it can imply outdated info. Avoid: The system checked the user’s location. The user clicked the button. Use active voice​ Sentences using active voice are more concise and efficient, making your writing more engaging and easier to comprehend. Active voice sentence: An actor acts on a target \"The smart contract processed a message.\" Passive voice sentence: A target acts on an actor \"The message was processed by the smart contract.\" Read more on active voice This isn't an easy one, especially for non-native English speakers. If you aren't sure, don't worry. We'll help with any of these. Grammar​ This documentation uses cspell to check spelling during development. cspell will check the spelling and automatically suggest corrections in case of mistakes before creating a new commit. Feel free to add specific words to the cspell.json config and include them in the verification dictionary. Date format​ Use the \"Mon D, YYYY\" format. This approach is standard for American readers, spells out the month (or uses a three-letter abbreviation), and minimizes confusion with day–month ordering. Preferred format:​ Nov 2, 2023 Feb 11, 2023 Incorrect format:​ 2-Nov-2023 11/2/2023 2/11/2023 Adhering to these guidelines creates a unified approach to presenting dates, fostering clarity and comprehension throughout the TON documentation. Use of emojis and icons​ In the Documentation section:​ Avoid using emojis and decorative icons. Technical documentation should be clear, professional, and distraction-free. Use only standard formatting elements like headings, lists, and code blocks. In the Guidelines section:​ Emojis and icons are allowed to make content more engaging and friendly. Use them purposefully and consistently, preferring functional icons such as ✅ Success, ⚠️ Warning, ❌ Error. Always use icons with supporting text — don’t rely on icons alone to convey meaning. Avoid overly decorative or emotional emojis that don’t add meaning. When in doubt, skip the icon. Clarity, consistency, and neutrality come first. Link preferences​ Linking to internal pages​ Use a site-relative path (rooted at “/”) instead of a full URL when linking to another page in the TON documentation. Correct link:​ Read more about [smart contracts](/v3/documentation/smart-contracts/overview/) Incorrect link:​ Read more about [smart contracts](https://docs.ton.org/v3/documentation/smart-contracts/overview) Don't hard-code the language path (for example, /zh-CN/) in any links. This maintains consistent capability across different language versions of the site. Correct link:​ Read more about [smart contracts](/v3/documentation/smart-contracts/overview/) Incorrect link:​ Read more about [smart contracts](/zh-CN/v3/documentation/smart-contracts/overview) Set a trailing slash on internal documentation links to avoid redirects, which hurt site performance. Correct link:​ Read more about [smart contracts](/v3/documentation/smart-contracts/overview/) Incorrect link:​ Read more about [smart contracts](/v3/documentation/smart-contracts/overview) Article authors​ When citing articles by a specific author or organization, use the article's name as a link, followed by an em dash and the author's name italicized. Correct description:​ - [How to shard your TON smart contract and why](https://blog.ton.org/how-to-shard-your-ton-smart-contract-and-why-studying-the-anatomy-of-tons-jettons) — _Tal Kol_- [TON Teleport BTC Whitepaper](https://tgbtc.gitbook.io/docs/whitepaper/abstract) — _RSquad Blockchain Lab_ Incorrect description:​ - [How to shard your TON smart contract and why](https://blog.ton.org/how-to-shard-your-ton-smart-contract-and-why-studying-the-anatomy-of-tons-jettons)- [TON Teleport BTC Whitepaper](https://tgbtc.gitbook.io/docs/whitepaper/abstract) by RSquad Blockchain Lab See also links section​ Include related resources on your page in an H2 section titled ## See also. This section guides readers to additional materials and supports a cohesive developer journey. Example:​ ## See also- [Style guide](/v3/contribute/style-guide/)- [Typography](/v3/contribute/typography/) Image preferences​ Linking to images​ When adding an image to a page, download and set an image in the TON documentation static/img folder. Correct linking:​ ![jetton_transfer](/img/docs/asset-processing/jetton_transfer.png) Incorrect linking:​ ![tact_logo](https://docs.tact-lang.org/_astro/logomark-dark.BSmgZYWc_ZKRrUl.svg) This is helpful to ensure the image will be available. Light and dark theme modes​ TON documentation supports theme-specific images. Follow these steps to add themed pictures to the page. Themed mode is available only for .mdx files. Import the ThemedImage module in the header. import ThemedImage from \"@theme/ThemedImage\"; Set the links for both images according to the example: <br /><ThemedImage alt=\"Message delivery diagram\" sources={{ light: '/img/docs/message-delivery/message_delivery_2.svg?raw=true', dark: '/img/docs/message-delivery/message_delivery_2_dark.svg?raw=true', }}/><br /> Annotation specification​ To depict message processing, use a graphical representation that resembles a smart contract graph, including labels for transactions and messages. If the transaction order isn't essential, omit their labels. This approach simplifies the diagram, making it easier to read and understand the message and contract details. Annotation primitives​ Avoid using a large variety of bright colors. Modify figures by applying techniques such as a dashed border. To emphasize specific details, display transactions using distinct line styles (e.g., solid and dashed). Message processing schemes​ On the TON blockchain, providing clear explanations of actor behavior and message processing for various smart contracts and fundamental scenarios is essential. The message processing schemes offer additional context for readers seeking a clear understanding of actor behavior. These schemes should be unified throughout the TON documentation to ensure maximum clarity. Example​ Sequence diagram​ Use a sequence diagram for complex and repetitive communication schemes between 2–3 actors. For messages, use the notation of a typical synchronous message arrow. Example​ Scheme formats and colors​ Format:​ Use PNG format for the diagrams in the documentation to ensure readability on various devices. Fonts:​ Use the Inter font family for all text within diagrams. Maintain a consistent text size. Avoid overusing bold and italic formatting for optimal readability. Themed colors for light mode:​ Pencil Hand Drawn, default Visio theme. Themed colors for dark mode:​ Font #e3e3e3. Background #232328. Light Highlight, arrows and scheme borders #058dd2. Dark Highlight, arrows and scheme borders #0088cc. InnerBackGround, for nested blocks #333337. Version control policy:​ Store the original files under /static/schemes-visio to facilitate future modifications. Learn Visio references directly from Visio sources. Math equations​ To include mathematical expressions in documentation, use the react-katex library. It supports both inline and block-level math using LaTeX syntax. Import the required components at the top of your .mdx file: import { BlockMath, InlineMath } from 'react-katex';import 'katex/dist/katex.min.css'; These imports allow you to render LaTeX math expressions: BlockMath is used for centered, standalone formulas. InlineMath is used for short expressions inside the regular text. The css import applies the necessary styling for proper rendering. Contributors can use the following examples to format various types of math expressions in the documentation: Systems of equations​ For systems of equations, use LaTeX formatting for clarity: <BlockMath math={`\\begin{cases}x + y = 10 \\\\2x - y = 4\\end{cases}`} /> This renders the system of equations as: \begin{cases} x + y = 10 \\ 2x - y = 4 end{cases} Exponential functions​ For exponential functions, you can use the following format: <InlineMath math=\"e^{x} = \\\\lim\\\\limits_{n\\\\to \\\\infty} \\\\left( 1 + \\\\frac{x}{n} \\\\right)^n\" /> This renders the equation: ex=limlimitsntoinftyleft(1+fracxnright)ne^{x} = \\\\lim\\\\limits_{n\\\\to \\\\infty} \\\\left( 1 + \\\\frac{x}{n} \\\\right)^nex=limlimitsntoinfty​left(1+fracxnright)n Fractions​ To represent fractions, use \\frac{numerator}{denominator}: <InlineMath math=\"\\\\fra",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "ton connect",
      "api",
      "testnet",
      "mainnet",
      "transaction",
      "guide",
      "cell",
      "builder",
      "message",
      "react",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:41:29.489Z"
  },
  {
    "id": "docs-ton-org--v3-contribute-typography",
    "title": "Typography",
    "url": "https://docs.ton.org/v3/contribute/typography",
    "content": "Skip to main contentDeprecated! Please, visit the new documentation at docs.ton.org Deprecated, go to new docs!On this pageTypography Introduction​ This standard ensures a consistent and professional style across TON documentation. By following these guidelines, you help maintain clarity, enhance readability, and support easy navigation in the documentation site and any associated menus. File names​ Naming convention: Use kebab-case - all lowercase, words separated by hyphens. Example: kebab-case-file-name.md Purpose: Kebab-case is SEO-friendly, easy to read, and helps avoid naming conflicts or issues in case-sensitive file systems. Document typography​ General text style​ Write concise, clear sentences. Use simple, direct language suitable for both new and experienced users. Avoid overly complex structures; aim for clarity and brevity. Avoid excessive use of bold or italic styles. All graphic elements containing text should use the Inter or a similarly compatible font. Acronyms​ When introducing an unfamiliar acronym, spell the entire term and put the abbreviation in parentheses. Put both the full term and acronym in bold. Example: The Open Network (TON) is a decentralized and open internet platform... Headers​ Header hierarchy:​ H1 (#) – Document title H2 (##) – Major sections H3 (###) – Subsections under H2 H4 (####) and below – Use sparingly for finer detail Header capitalization style:​ H1, H2, H3 and H4: Sentence case Example: # This sentence is in sentence case Example: ## This sentence is in sentence case Example: ### This sentence is in sentence case Example: #### This sentence is in sentence case Headers use sentence case. Capitalize only proper nouns and defined terms. Example: ## Use American English Example: # Run the TON Center service Header consistency:​ Avoid repeating the exact words in consecutive headers. Header formatting:​ Use plain text for all headers. Avoid using any formatting styles in headings: No code formatting using backticks (`) No bold text No italics text No quotation marks (“ ” or \" \") No ALL CAPS (unless it's an acronym) Keep headers clean and consistent. Use formatting only in body text. Correct: Run the TON Center service How the smart contract works Incorrect: Run the TON Center service How the smart contract works “Run the TON Center service” HOW THE SMART CONTRACT WORKS Capitalized terms in headers​ Some terms are defined as proper nouns and should be capitalized according to American English rules. Example: ## Use American English Example: ### Date format Avoid quotation marks​ Do not use \"quotation marks\" to highlight terms, variables, or functions. Instead, apply bold for terms and code formatting for code references. Correct usage: Use smart contract when introducing a term. Use get_wallet_address when referencing a code variable or function. Incorrect usage: Do not use \"get_wallet_address\" for a term, code variable, or function. Navigation menu headings​ The navigation menus should remain minimalistic in both the left sidebar and the navbar. For consistency and clarity, all menu headings must use sentence case. Left sidebar menu:​ Avoid lengthy descriptions. Use short, clear labels of two or three words. infoSpecify the left sidebar with sidebars configuration files. Navbar​ Set only high-level hierarchy pages in this menu. Use broad, descriptive terms to categorize content, ensuring users can quickly identify the main section they need. infoSpecify the navbar with the navbar.js configuration file. Consistency between menu and in-page headers​ Match the header text used in the left sidebar or table of contents with the header text in the article, ensuring readers know they're on the correct page or section. Putting it all together​ Create your new documentation file using the kebab-case naming convention Example: getting-started-guide.md. Open the file and set an H1 heading in sentence case Example: # Getting started guide. Organize content with H2 headings for main topics Example: ## Installation steps, also in sentence case. Use H3 headings for more detailed subtopics in sentence case Example: ### Installing on Linux. Maintain consistency in any side menus or tables of contents by matching the header text from within the document. Example structure​ getting-started-with-ton.md# Getting started with TON## Prerequisites### What is TON**The Open Network (TON)** is a decentralized and open internet platform...The content goes here.### Checking your environmentThe content goes here.## Installation steps### Installing on LinuxThe content goes here.### Installing on macOSThe content goes here.## Basic usage### Running your first commandThe content goes here.## See also- [How to contribute](/v3/contribute/) See also​ How to contribute Content standardization Typography Was this article useful?YesNoEdit this pageLast updated on Sep 8, 2025 by Daniil SedovIntroductionFile namesDocument typographyGeneral text styleAcronymsHeadersAvoid quotation marksNavigation menu headingsPutting it all togetherExample structureSee alsoUseGet a WalletGet ToncoinStakeAccept PaymentsApps & ServicesDomainsUSDT on TONCross-Chain BridgesLearnTON ConceptDecentralized NetworkRoadmapTonStatHistory of MiningToncoinValidatorsWhite PaperBrand AssetsSustainabilityFor BuildersTON Builders PortalGetting StartedDocumentationTelegram Mini AppsDev ChatsBug BountyFind a JobFind a TalentUse CasesGameFiMemecoins & TokensCommunity ToolsTON SitesCommunityCommunitiesBlogCareers",
    "category": "general",
    "tags": [
      "ton",
      "func",
      "smart contract",
      "wallet",
      "telegram",
      "mini app",
      "api",
      "guide",
      "builder",
      "address",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:41:31.405Z"
  },
  {
    "id": "docs-ton-org--ecosystem-ton-connect-walletkit-ios-init",
    "title": "How to initialize the TON Connect's WalletKit on the iOS platform",
    "url": "https://docs.ton.org/ecosystem/ton-connect/walletkit/ios/init",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectOverviewIntegrate a dAppIntegrate a walletManifestsMessage lookupWalletKitOverviewWebiOSInstall the kitInit the kitManage TON walletsReceiving informationTransactionsHandle eventsWebView injectionAndroidIntegration QA guideNative and web walletsBrowser extensions and in-wallet browsersTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationiOSHow to initialize the TON Connect's WalletKit on the iOS platformEcosystemTON ConnectWalletKitiOSHow to initialize the TON Connect's WalletKit on the iOS platformCopy pageCopy page​Creating configuration The basic kit initialization consists of creating a corresponding object by passing it a minimal set of necessary arguments. Pick a TON network to operate on, a wallet manifest, and feature configurations. Here is an example of a minimal configuration: CopyAsk AIimport TONWalletKit // URL of the wallet's implementation of the HTTP bridge: // https://github.com/ton-connect/docs/blob/main/bridge.md#http-bridge // // Can be different, e.g., https://bridge.tonapi.io/bridge let bridgeURL = \"https://connect.ton.org/bridge\" let features: [TONWalletKitConfiguration.Feature] = [ // Wallet can send transactions. TONWalletKitConfiguration.SendTransactionFeature( // Max number of messages that can be sent in a single transaction. // Depends on the TON wallet used, because different kinds can handle // different number of messages. maxMessages: 1, // Are messages sending extra-currencies supported? extraCurrencySupported: false ), TONWalletKitConfiguration.SignDataFeature(types: [ // Types of data to sign. .text, .binary, .cell ]), ] let configuration = TONWalletKitConfiguration( network: .mainnet, /* or .testnet */ walletManifest: TONWalletKitConfiguration.Manifest( name: \"Name of your wallet service\", appName: \"your_wallet_service_id\", /* e.g. best_ton_wallet_service */ imageUrl: \"https://<YOUR_WALLET_SERVICE_URL>/image.png\", aboutUrl: \"https://<YOUR_WALLET_SERVICE_URL>/about\", universalLink: \"https://<YOUR_WALLET_SERVICE_URL>/universal-link\", bridgeUrl: bridgeURL ), features: features ) ​Creating WalletKit instance Once you have a configuration, create an instance of the kit: CopyAsk AIimport TONWalletKit // Instructs how to store intermediate events and other data from the WalletKit. let storage: TONWalletKitStorageType = .memory // .keychain or .custom(/* custom storage */) // Instance let walletKit = try await TONWalletKit.initialize( configuration: configuration, storage: storage ) ​Creating custom storage One can implement a custom storage and provide it during initialization: CopyAsk AIimport TONWalletKit class YourCustomStorage: TONWalletKitStorage { func save(key: String, value: String) throws { ... } func get(key: String) throws -> String? { ... } func remove(key: String) throws { ... } func clear() throws { ... } } let walletKit = try await TONWalletKit.initialize( configuration: configuration, storage: .custom(YourCustomStorage()) ) Was this page helpful?YesNoSuggest editsRaise issuePreviousManage TON walletsNext⌘IgithubxtelegramPowered by MintlifyOn this pageCreating configurationCreating WalletKit instanceCreating custom storage",
    "category": "integration",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "dapp",
      "api",
      "sdk",
      "testnet",
      "mainnet",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:41:32.953Z"
  },
  {
    "id": "docs-ton-org--ecosystem-ton-connect-walletkit-ios-wallets",
    "title": "How to manage TON wallets with WalletKit on the iOS platform",
    "url": "https://docs.ton.org/ecosystem/ton-connect/walletkit/ios/wallets",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectOverviewIntegrate a dAppIntegrate a walletManifestsMessage lookupWalletKitOverviewWebiOSInstall the kitInit the kitManage TON walletsReceiving informationTransactionsHandle eventsWebView injectionAndroidIntegration QA guideNative and web walletsBrowser extensions and in-wallet browsersTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationiOSHow to manage TON wallets with WalletKit on the iOS platformEcosystemTON ConnectWalletKitiOSHow to manage TON wallets with WalletKit on the iOS platformCopy pageCopy pageInitialize the WalletKit before managing wallets. See the initialization guide for details. The SDK provides a comprehensive API for creating, retrieving, and managing wallets. All wallet operations follow a three-step pattern. ​Creation pattern The SDK uses a three-step pattern for creating wallets, providing fine-grained control over key management and wallet configuration: Create a signer: generate or import cryptographic keys Create an adapter: configure wallet version and network settings Add the wallet: register the wallet with the SDK ​Creating wallets from mnemonic Import an existing wallet from a mnemonic: CopyAsk AIlet mnemonic = TONMnemonic(value: [\"word1\", \"word2\", /* ... 24 words ... */]) let signer = try await walletKit.signer(mnemonic: mnemonic) let adapter = try await walletKit.walletV5R1Adapter( signer: signer, parameters: .init(network: .mainnet) ) let wallet = try await walletKit.add(walletAdapter: adapter) Always store mnemonic phrases securely using platform-specific encrypted storage. Never store them in plain text or as part of the code. ​Creating wallets from secret key For externally managed keys: CopyAsk AIlet privateKey = /* 32-byte private key as Data */ let signer = try await walletKit.signer(privateKey: privateKey) let adapter = try await walletKit.walletV5R1Adapter( signer: signer, parameters: .init(network: .mainnet) ) let wallet = try await walletKit.add(walletAdapter: adapter) ​Wallet versions The SDK supports multiple wallet contract versions: V5R1 and V4R2. ​V5R1 (Recommended) The latest wallet version with improved features and gas optimization: CopyAsk AIlet adapter = try await walletKit.walletV5R1Adapter( signer: signer, parameters: .init(network: .mainnet) ) ​V4R2 (Compatible) Widely supported legacy version: CopyAsk AIlet adapter = try await walletKit.walletV4R2Adapter( signer: signer, parameters: .init(network: .mainnet) ) ​Retrieving wallets Get all wallets managed by the SDK: CopyAsk AIlet wallets = try await walletKit.wallets() Get a specific wallet by an address: CopyAsk AIlet wallet = try walletKit.wallet(address: \"<TON_WALLET_ADDRESS>\") ​Removing wallets Remove a single wallet: CopyAsk AItry await walletKit.remove(walletAddress: \"<TON_WALLET_ADDRESS>\") ​Next steps Handle eventsLearn how to handle dApp connections and other eventsRetrieve wallet dataGet balances, Jettons, and NFTsWas this page helpful?YesNoSuggest editsRaise issuePreviousReceiving informationNext⌘IgithubxtelegramPowered by MintlifyOn this pageCreation patternCreating wallets from mnemonicCreating wallets from secret keyWallet versionsV5R1 (Recommended)V4R2 (Compatible)Retrieving walletsRemoving walletsNext steps",
    "category": "integration",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "dapp",
      "api",
      "sdk",
      "mainnet",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:41:35.372Z"
  },
  {
    "id": "docs-ton-org--ecosystem-ton-connect-walletkit-ios-data",
    "title": "How to retrieve wallet information, jettons, and NFTs with WalletKit on the iOS platform",
    "url": "https://docs.ton.org/ecosystem/ton-connect/walletkit/ios/data",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectOverviewIntegrate a dAppIntegrate a walletManifestsMessage lookupWalletKitOverviewWebiOSInstall the kitInit the kitManage TON walletsReceiving informationTransactionsHandle eventsWebView injectionAndroidIntegration QA guideNative and web walletsBrowser extensions and in-wallet browsersTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationiOSHow to retrieve wallet information, jettons, and NFTs with WalletKit on the iOS platformEcosystemTON ConnectWalletKitiOSHow to retrieve wallet information, jettons, and NFTs with WalletKit on the iOS platformCopy pageCopy pageAll methods require an existing wallet instance. Create or retrieve a wallet before accessing data. Retrieve wallet information, Jettons, and NFTs using WalletKit. ​Wallet information ​Balance CopyAsk AI// Returns balance in nanoToncoin let balance = try await wallet.balance() ​Address CopyAsk AIlet address = wallet.address ​Jettons ​Get all Jettons CopyAsk AIlet jettons = try await wallet.jettons(limit: TONLimitRequest(limit: 10, offset: 0)) ​Get specific Jetton balance CopyAsk AI// Address of a Jetton minter contract // E.g., EQCxE6mUtQJKFnGfaROTKOt1lZbDiiX1kCixRv7Nw2Id_sDs for USDT let jettonAddress = \"<JETTON_ADDRESS>\" // Returns balance in nano with decimals count according to Jetton specification let balance = try await wallet.jettonBalance(jettonAddress: jettonAddress) ​Get Jetton wallet address CopyAsk AI// Address of a Jetton minter contract // E.g., EQCxE6mUtQJKFnGfaROTKOt1lZbDiiX1kCixRv7Nw2Id_sDs for USDT let jettonAddress = \"<JETTON_ADDRESS>\" let walletAddress = try await wallet.jettonWalletAddress(jettonAddress: jettonAddress) ​NFTs ​Get all NFTs CopyAsk AIlet nfts = try await wallet.nfts(limit: TONLimitRequest(limit: 10, offset: 0)) ​Get specific NFT CopyAsk AI// Address of an NFT // E.g., EQDkT3BSIU3CTwnZG9ZIdyWYmcnuaAEwGr_dsS1RFYqBTanY let nftAddress = \"<NFT_ADDRESS>\" let nft = wallet.nft(address: nftAddress) ​Next steps TransactionsTransfer Toncoin, Jettons and NFTsManage walletsCreate and manage TON walletsWas this page helpful?YesNoSuggest editsRaise issuePreviousTransactionsNext⌘IgithubxtelegramPowered by MintlifyOn this pageWallet informationBalanceAddressJettonsGet all JettonsGet specific Jetton balanceGet Jetton wallet addressNFTsGet all NFTsGet specific NFTNext steps",
    "category": "integration",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "dapp",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:41:37.452Z"
  },
  {
    "id": "docs-ton-org--ecosystem-ton-connect-walletkit-ios-transactions",
    "title": "How to transfer Toncoin, Jettons and NFTs with WalletKit on the iOS platform",
    "url": "https://docs.ton.org/ecosystem/ton-connect/walletkit/ios/transactions",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectOverviewIntegrate a dAppIntegrate a walletManifestsMessage lookupWalletKitOverviewWebiOSInstall the kitInit the kitManage TON walletsReceiving informationTransactionsHandle eventsWebView injectionAndroidIntegration QA guideNative and web walletsBrowser extensions and in-wallet browsersTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationiOSHow to transfer Toncoin, Jettons and NFTs with WalletKit on the iOS platformEcosystemTON ConnectWalletKitiOSHow to transfer Toncoin, Jettons and NFTs with WalletKit on the iOS platformCopy pageCopy pageAll methods require an existing wallet instance. Create or retrieve a wallet before accessing data. Create transactions to send Toncoin, Jettons, and NFTs, or generate previews for users. ​Creating a transaction Before sending any transaction to the blockchain, initialize it for the appropriate asset: Toncoin, Jetton, or NFT. ​Toncoin CopyAsk AI// Transaction for 1 Toncoin let amountFormatter = TONTokenAmountFormatter() // Provide the user's input here guard let amount = amountFormatter.amount(from: \"1\") else { return } let message = TONTransferMessage( // TON wallet address toAddress: address, amount: amount, ) let transaction = try await wallet.transferTONTransaction(message: message) ​Jettons CopyAsk AI// Transaction for 1 Jetton of some kind (e.g., USDT) let amountFormatter = TONTokenAmountFormatter() amountFormatter.nanoUnitDecimalsNumber = 6 // Provide the user's input here guard let amount = amountFormatter.amount(from: \"1\") else { return } let parameters = TONJettonTransferParams( // TON wallet address toAddress: address, // Address of a Jetton minter contract jettonAddress: jettonAddress, amount: amount, ) let transaction = try await wallet.transferJettonTransaction(parameters: parameters) ​NFTs CopyAsk AIlet parameters = TONNFTTransferParamsHuman( // TON wallet address toAddress: address, // Address of an NFT item contract nftAddress: nft.address, ) let transaction = try await wallet.transferNFTTransaction(parameters: parameters) ​Transaction Preview Once a transaction object is created, present a preview to the user before sending it. CopyAsk AIlet preview = try await wallet.preview(transaction: transaction) ​Sending a transaction CopyAsk AItry await wallet.send(transaction: transaction) ​Next steps Receiving informationGet wallet information, Jettons, and NFTsManage walletsCreate and manage TON walletsWas this page helpful?YesNoSuggest editsRaise issuePreviousHandle eventsNext⌘IgithubxtelegramPowered by MintlifyOn this pageCreating a transactionToncoinJettonsNFTsTransaction PreviewSending a transactionNext steps",
    "category": "integration",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "nft",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "dapp",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:41:39.322Z"
  },
  {
    "id": "docs-ton-org--ecosystem-ton-connect-walletkit-ios-events",
    "title": "How to connect to dApp and handle wallet events on the iOS platform",
    "url": "https://docs.ton.org/ecosystem/ton-connect/walletkit/ios/events",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectOverviewIntegrate a dAppIntegrate a walletManifestsMessage lookupWalletKitOverviewWebiOSInstall the kitInit the kitManage TON walletsReceiving informationTransactionsHandle eventsWebView injectionAndroidIntegration QA guideNative and web walletsBrowser extensions and in-wallet browsersTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationiOSHow to connect to dApp and handle wallet events on the iOS platformEcosystemTON ConnectWalletKitiOSHow to connect to dApp and handle wallet events on the iOS platformCopy pageCopy pageInitialize WalletKit before adding an events handler. See the initialization guide for details. ​Connection Before receiving and handling wallet events, set up an events handler and establish a connection with a dApp. ​Setting up events handler Create your own implementation of an events handler and add it to the WalletKit instance: CopyAsk AIimport TONWalletKit class YourCustomWalletEventsHandler: TONBridgeEventsHandler { func handle(event: TONWalletKitEvent) throws { // Process the event or throw an error } } let eventsHandler = YourCustomWalletEventsHandler() try await walletKit.add(eventsHandler: eventsHandler) If a handler is not needed anymore or needs to be replaced by some other handler, remove it: CopyAsk AItry await walletKit.remove(eventsHandler: eventsHandler) ​Establishing connection with dApp To establish a connection with a dApp, one needs a connection request URL from any source: copy/paste, QR code, deep link, etc. Send it to the WalletKit to initiate a connection request. CopyAsk AItry await walletKit.connect(url: /* connection url */) Once the connection request is fired, the corresponding event will be sent to your event handler. The connection event contains an object you can use to display request information to your app’s users and to approve (or reject) the request to complete connection establishment. CopyAsk AIclass YourCustomWalletEventsHandler: TONBridgeEventsHandler { func handle(event: TONWalletKitEvent) throws { switch event { case .connectRequest(let request): // Send request object to appropriate screen // to display request information to app user break default: () } } } // Call an appropriate method corresponding to the user's response // To approve try await request.approve(walletAddress: /* TON wallet address */) // To reject try await request.reject(reason: /* rejection reason */) After approval, the connection will be established, and the wallet service will be able to receive and handle other events associated with the corresponding TON wallet. ​Handling events All event handling is made through a custom event handler. Received events carry a lot of useful information that can be displayed to the user to allow them to approve or reject the request based on their action. The only exception is a disconnection request. Even though it contains information you can show to a user, there is no need to approve or reject it on their end. ​Transaction event handling CopyAsk AIclass YourCustomWalletEventsHandler: TONBridgeEventsHandler { func handle(event: TONWalletKitEvent) throws { switch event { case .transactionRequest(let request): // Send request object to appropriate screen // to display request information to app user break default: () } } } // Call an appropriate method corresponding to the user's response // To approve try await request.approve() // To reject try await request.reject(reason: /* rejection reason */) ​Sign data event handling CopyAsk AIclass YourCustomWalletEventsHandler: TONBridgeEventsHandler { func handle(event: TONWalletKitEvent) throws { switch event { case .signDataRequest(let request): // Send request object to appropriate screen // to display request information to app user break default: () } } } // Call an appropriate method corresponding to the user's response // To approve try await request.approve() // To reject try await request.reject(reason: /* rejection reason */) ​Disconnection event handling CopyAsk AIclass YourCustomWalletEventsHandler: TONBridgeEventsHandler { func handle(event: TONWalletKitEvent) throws { switch event { case .disconnect(let info): // Send info object to appropriate screen // to display request information to app user break default: () } } } Alternatively, explore the complete demo wallet with WalletKit integration: Demo wallet, GitHubWas this page helpful?YesNoSuggest editsRaise issuePreviousWebView injectionNext⌘IgithubxtelegramPowered by MintlifyOn this pageConnectionSetting up events handlerEstablishing connection with dAppHandling eventsTransaction event handlingSign data event handlingDisconnection event handling",
    "category": "integration",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "dapp",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:41:40.391Z"
  },
  {
    "id": "docs-ton-org--ecosystem-ton-connect-walletkit-ios-webview",
    "title": "How to inject TON's WalletKit into WebView on iOS platform",
    "url": "https://docs.ton.org/ecosystem/ton-connect/walletkit/ios/webview",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectOverviewIntegrate a dAppIntegrate a walletManifestsMessage lookupWalletKitOverviewWebiOSInstall the kitInit the kitManage TON walletsReceiving informationTransactionsHandle eventsWebView injectionAndroidIntegration QA guideNative and web walletsBrowser extensions and in-wallet browsersTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationiOSHow to inject TON's WalletKit into WebView on iOS platformEcosystemTON ConnectWalletKitiOSHow to inject TON's WalletKit into WebView on iOS platformCopy pageCopy pageInitialize the WalletKit before injecting it into WebView. See the initialization guide for details. Injecting WalletKit into WebView allows integrating the wallet service with a dApp running in a native WebView and handling its events. To do so, obtain the dApp injection bridge key — it is the name under which the dApp injects itself in the window object. CopyAsk AIimport TONWalletKit import WebKit let webView = WKWebView() try webView.inject(walletKit: walletKit, key: /* dApp bridge key */) webView.load(URLRequest(url: /* dApp URL */)) After the injection is complete, handle dApp events from a custom events handler.Was this page helpful?YesNoSuggest editsRaise issuePreviousInstall the kitNext⌘IgithubxtelegramPowered by Mintlify",
    "category": "integration",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "dapp",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:41:43.011Z"
  },
  {
    "id": "docs-ton-org--ecosystem-tma-telegram-ui-getting-started",
    "title": "Getting started",
    "url": "https://docs.ton.org/ecosystem/tma/telegram-ui/getting-started",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsOverviewTMA create CLITelegram UIOverviewGetting startedAppRoot componentReferenceMateAnalyticsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationTelegram UIGetting startedEcosystemTMA: Telegram Mini AppsTelegram UIGetting startedCopy pageCopy pageDive into our sleek design on Figma to get a glimpse of what awaits you. ​Easy installation Getting started is a breeze with npm or yarn. Simply run: CopyAsk AInpm install @telegram-apps/telegram-ui ​Import styles Before diving into the development, ensure to import the necessary styles: CopyAsk AIimport '@telegram-apps/telegram-ui/dist/styles.css'; ​Wrap your App Wrap your application with AppRoot to leverage this platform’s features: CopyAsk AIimport { AppRoot } from '@telegram-apps/telegram-ui'; ReactDOM.render( <AppRoot> <App /> </AppRoot>, document.getElementById('root') ); ​Usage example CopyAsk AI// Import the necessary styles globally import '@telegram-apps/telegram-ui/dist/styles.css'; // Import components from the library import { AppRoot, Cell, List, Section } from '@telegram-apps/telegram-ui'; // Example data for rendering list cells const cellsTexts = ['Chat Settings', 'Data and Storage', 'Devices']; export const App = () => ( <AppRoot> {/* List component to display a collection of items */} <List> {/* Section component to group items within the list */} <Section header=\"Header for the section\" footer=\"Footer for the section\"> {/* Mapping through the cells data to render Cell components */} {cellsTexts.map((cellText, index) => ( <Cell key={index}> {cellText} </Cell> ))} </Section> </List> </AppRoot> ); With these steps, you’re all set to explore the potential of this library. ​More UI components Find more demo components here.Was this page helpful?YesNoSuggest editsRaise issuePreviousAppRoot componentNext⌘IgithubxtelegramPowered by MintlifyOn this pageEasy installationImport stylesWrap your AppUsage exampleMore UI components",
    "category": "tma",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "dapp",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "cell",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "react",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:41:44.296Z"
  },
  {
    "id": "docs-ton-org--ecosystem-tma-telegram-ui-platform-and-palette",
    "title": "AppRoot component",
    "url": "https://docs.ton.org/ecosystem/tma/telegram-ui/platform-and-palette",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsOverviewTMA create CLITelegram UIOverviewGetting startedAppRoot componentReferenceMateAnalyticsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationTelegram UIAppRoot componentEcosystemTMA: Telegram Mini AppsTelegram UIAppRoot componentCopy pageCopy pageThe AppRoot component is pivotal in implementing a dynamic theming system within your application. It employs a sophisticated approach to CSS variables and React context to seamlessly adapt to various themes and platforms. This section delves into the inner workings of this system, explaining how themes are managed and applied internally. ​CSS variables: the backbone of theming At the heart of the AppRoot theming system lie CSS variables, which are utilized to create a flexible and adaptable styling framework. These variables are divided into two main categories: Basic Variables and Custom Variables. Both play a crucial role in tailoring the application’s appearance to match both Telegram’s theme and any additional stylistic preferences. ​Basic variables Basic Variables are designed to inherit styles directly from Telegram or fall back on predefined styles within the library. This ensures that the application remains consistent with the user’s current Telegram theme settings. Telegram Style Inheritance: When available, Basic Variables dynamically adopt values from Telegram’s theme, aligning the application’s appearance with the platform’s chosen theme. Library Defaults: In scenarios where Telegram theme data isn’t available or not supported in the current version, these variables revert to a set of default styles specified within the library, maintaining a coherent and user-friendly interface. ​Custom variables Custom Variables offer an extension to the theming capabilities, allowing for more nuanced and specific styling adjustments that go beyond the scope of Telegram’s native themes. Enhanced Styling Flexibility: These variables enable the definition of unique stylistic elements like accent colors, providing opportunities for brand alignment and distinct visual design. Brand Identity Support: By leveraging Custom Variables, developers can ensure that the application not only adheres to Telegram’s theming but also reflects the brand’s identity through consistent use of colors, typography, and other design elements. ​Internal mechanism for theme and platform adaptation AppRoot intelligently leverages React context and CSS variables to dynamically adjust the application’s styling based on the current theme (light, dark, or Telegram custom themes) and platform (iOS, Android, web). Here’s an overview of how this process unfolds internally: Theme Detection and Application: Upon initialization, AppRoot detects the current theme settings (from Telegram or manually set preferences) and updates the CSS variables accordingly. This process ensures that the theme is consistently applied across the application. Platform-Specific Styling: In addition to theme management, AppRoot also detects the user’s platform and applies platform-specific styles to optimize the user experience. This might include adjustments to typography, element sizing, and interaction feedback, aligning with platform conventions. Contextual Theme and Platform Information: Through the use of React context, AppRoot provides nested components with access to current theme and platform information. This allows for conditional rendering or styling adjustments deep within the component tree, based on the overall application context. ​Summary The AppRoot theming system is a sophisticated framework designed to ensure visual consistency and adaptability across different themes and platforms. By combining CSS variables with React context, it offers a robust solution for managing theme and platform-specific styling, all while keeping the application aligned with Telegram’s theming capabilities and the brand’s visual identity. Through this internal mechanism, AppRoot abstracts away the complexities of dynamic theming, allowing developers to focus on building feature-rich and visually appealing applications that provide a seamless user experience across all platforms and themes.Was this page helpful?YesNoSuggest editsRaise issuePreviousAvatarNext⌘IgithubxtelegramPowered by MintlifyOn this pageCSS variables: the backbone of themingBasic variablesCustom variablesInternal mechanism for theme and platform adaptationSummary",
    "category": "tma",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "dapp",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "react",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:41:46.553Z"
  },
  {
    "id": "docs-ton-org--ecosystem-tma-mate-getting-started",
    "title": "Getting started",
    "url": "https://docs.ton.org/ecosystem/tma/mate/getting-started",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsOverviewTMA create CLITelegram UIMate@telegram-apps/mateGetting startedHostingAnalyticsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationMateGetting startedEcosystemTMA: Telegram Mini AppsMateGetting startedCopy pageCopy pageYour companion for managing Telegram Mini Apps. This project simplifies the manipulation of your mini app distribution files. To start using the project, you need to obtain your deploy token, which is unique to each project. To get your token, go to @tma_mate_bot and press the Start button. Next, press the Create a Project button and enter the name of your project, following the specified rules. After this step, the bot will provide you with a Deploy Token, which you will use later to deploy the project. ​Installing @telegram-apps/mate To deploy your project, you need to install the @telegram-apps/mate CLI package. CopyAsk AInpm i -D @telegram-apps/mate Alternatively, you can install it globally: CopyAsk AInpm i -g @telegram-apps/mate Once installed, the package will be accessible via the mate CLI tool: CopyAsk AImate --help Not to install the package, you can also use the package using pnpm or npx: CopyAsk AInpx @telegram-apps/mate@latest --help ​Retrieving project deployment info Before deploying the project, you might want to know the base URL. The base URL is the absolute URL that the project bundler will use to create links to all project assets. To retrieve the project deployment information, including the base URL, use the following command: CopyAsk AI# TOKEN refers to the deploy token received from the bot. # PROJECT is a project identifier. Example: 48 mate deploy info --token {TOKEN} --project {PROJECT} You will see an output similar to this: CopyAsk AI✔ Fetched deploy information for paper-planes (id 48) project Project Title: paper-planes Short title of the project -------- Base Path (using tag \"test\"): https://35f105bd6b.tapps.global/latest This path will be used as a base path for the uploaded assets associated with this project. Consider using this value as a base path in your bundler. You can also use different tags using the --tag option -------- Allowed file extensions: html, css, js, cjs, mjs, png, jpg, jpeg, webp, ttf, woff, woff2, eot, json, ico Files extensions which are allowed to be uploaded -------- Maximum size: 10485760 bytes Maximum upload size -------- Maximum files count: 100 Maximum files count a single upload can contain The value https://35f105bd6b.tapps.global/latest is the base URL that you should use in your bundler. ​Deploying Before deploying the project assets, ensure that you have built your project and are not deploying source files. You should only deploy files that can be successfully opened by the user’s browser. Let’s assume you have a project with ID 48. Also, you have a dist directory with all the built files. To deploy this directory to the CDN, use the following command: CopyAsk AI# TOKEN refers to the deploy token received from the bot. mate deploy upload --dir dist --token {SPECIFY TOKEN HERE} --project 48 As a result, you will see a message like this in your console: CopyAsk AI✔ Fetched deploy information for paper-planes (id 48) project i Assets base path (using tag \"latest\"): https://35f105bd6b.tapps.global/latest i Allowed file extensions: html, css, js, cjs, mjs, png, jpg, jpeg, webp, ttf, woff, woff2, eot, json, ico i Maximum upload size: 10485760 bytes i Maximum files count: 100 ✔ Directory compressed successfully from 24185 to 7168 bytes ✔ Archive uploaded successfully 📁 dist ╰ 📄 index.js (https://35f105bd6b.tapps.global/latest/index.js) Important Note that your directory must include only the usual files and directories. All other types of files (symlinks, for example) are forbidden; the CLI tool will let you know about it. ​Tagging Mate allows you to use multiple tags in your project. A tag is simply a marker for your deployment version. Each tag corresponds to its own subdirectory, which is reflected in the final asset URL. By default, Mate uses the latest tag. To override this, use the --tag option: CopyAsk AImate deploy upload --dir dist --token {TOKEN} --project {PROJECT} --tag test ​Using Config To enhance your experience, you can create a mate.yml file in your project root directory and include the following content: CopyAsk AIdeploy: projectId: {PROJECT} directory: dist token: {TOKEN} Then, you can use the mate commands: CopyAsk AImate deploy info mate deploy upload Was this page helpful?YesNoSuggest editsRaise issuePreviousHostingNext⌘IgithubxtelegramPowered by MintlifyOn this pageInstalling @telegram-apps/mateRetrieving project deployment infoDeployingTaggingUsing Config",
    "category": "tma",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "deployment",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:41:48.277Z"
  },
  {
    "id": "docs-ton-org--ecosystem-tma-mate-hosting",
    "title": "Hosting",
    "url": "https://docs.ton.org/ecosystem/tma/mate/hosting",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsOverviewTMA create CLITelegram UIMate@telegram-apps/mateGetting startedHostingAnalyticsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationMateHostingEcosystemTMA: Telegram Mini AppsMateHostingCopy pageCopy pageWith Mate’s fast and reliable hosting, developers can effectively manage static assets for their mini applications. Delivering static files efficiently and securely is vital for optimal performance. By utilizing a Content Delivery Network (CDN), Mate’s hosting boosts reliability and accelerates file loading for users across various regions, surpassing the performance of single-server solutions. The hosting service is free, though there are some limitations on data transfer. If you’re currently using a single server for both static file hosting and server-side operations, transitioning to Mate’s hosting may require code adjustments. If your app already distinguishes between static and dynamic requests, integration will be much simpler. ​Important recommendation When deploying an SPA on a static hosting platform (like Mate’s hosting), it’s crucial to choose routing methods that do not depend on server-side configurations. Hash-based routing (using the # symbol in URLs) is a simple and effective way to manage routes without needing server support. Many frameworks offer built-in solutions or plugins to implement this type of routing. For instance, if you are using React, use HashRouter instead of BrowserRouter: CopyAsk AIimport { HashRouter as Router, Route, Switch } from 'react-router-dom'; function App() { return ( <Router> <Switch> <Route exact path=\"/\" component={Home} /> {/* Other routes */} </Switch> </Router> ); } export default App; ​Features ​Lightning Speed The crucial feature of Mate’s hosting is its well-configured Content Delivery Network spread across the world, in countries where mini applications are commonly used. This feature allows developers to focus on building their applications rather than worrying about how to deliver static assets as quickly as possible. ​Version Management System Another notable hosting feature is the version management system. Mate allows the creation of up to five deployment tags, enabling developers to deploy the project with a specific tag without affecting previously deployed assets. ​Usage Example A common use case here is when the project has two versions: latest and staging. The developer can use the latest version for production and staging for the Quality Assurance team. After deploying the staging assets, the QA team checks if this staging state is acceptable. Then, the same assets can be deployed with the latest tag for production. ​About Base URL When deploying static assets, Mate uses the following base URL pattern: CopyAsk AIhttps://{storage_key}.tapps.global/{tag} Here’s some information on these parameters for clarification: storage_key: a unique key for the deployed project. This value is non-configurable and is assigned to the project upon creation. tag: a deployment tag. This value is set during the deployment process by the developer. Examples include staging, latest, dev, etc. ​Getting started ​Register a project To start using the hosting functionality, you must register the project and obtain its deployment token. To get the token, go to @tma_mate_bot and press the Start button to begin the conversation with the bot. Next, press the Create a Project button and enter the title of the project to be created, following the specified rules. After this step, the bot will return the created project information, including the deployment token. ​Update the static assets base URL Before deploying the project, ensure that all static assets have a valid base URL. You can learn more about how Mate generates the static assets base URL here. To retrieve the project deployment information using a specific tag, use the following command: CopyAsk AImate deploy info \\ --token {DEPLOYMENT_TOKEN} \\ --project {PROJECT_ID} \\ --tag {TAG} Here, the DEPLOYMENT_TOKEN and PROJECT_ID values refer to the deployment token and project identifier received from the previous step. TAG is a deployment version tag name. Output example: CopyAsk AI✔ Fetched deploy information for paper-planes (id 48) project Project Title: paper-planes Short title of the project -------- Base Path (using tag \"staging\"): https://35f105bd6b.tapps.global/staging This path will be used as a base path for the uploaded assets associated with this project. Consider using this value as a base path in your bundler. You can also use different tags using the --tag option. -------- Allowed file extensions: html, css, js, cjs, mjs, png, jpg, jpeg, webp, ttf, woff, woff2, eot, json, ico Files extensions that are allowed to be uploaded. -------- Maximum size: 10485760 bytes Maximum upload size. -------- Maximum files count: 100 Maximum number of files a single upload can contain. The value https://35f105bd6b.tapps.global/staging is the base URL that should be used in the project bundler. Here’s how it can be applied using Vite. CopyAsk AIimport { defineConfig } from 'vite'; export default defineConfig({ base: 'https://35f105bd6b.tapps.global/staging' }); ​Deploy the project To deploy the project, Mate requires specifying a folder to be uploaded to the hosting service. The folder must only contain files that can be opened by the user’s browser, so no source files or files for different purposes should be present in the directory. Let’s assume the following conditions: A project with ID 48 and token aabbccdd was created. A folder named dist contains all the mini application built static assets. It is required to deploy the static assets with the tag latest. To deploy the project under these conditions, run the following command: CopyAsk AImate deploy upload \\ --dir dist \\ --token TOKEN \\ --project 48 \\ --tag latest Here’s the possible output: CopyAsk AI✔ Fetched deploy information for paper-planes (id 48) project i Assets base path (using tag \"latest\"): https://35f105bd6b.tapps.global/latest i Allowed file extensions: html, css, js, cjs, mjs, png, jpg, jpeg, webp, ttf, woff, woff2, eot, json, ico i Maximum upload size: 10485760 bytes i Maximum files count: 100 ✔ Directory compressed successfully from 24185 to 7168 bytes ✔ Archive uploaded successfully 📁 dist ╰ 📄 index.js (https://35f105bd6b.tapps.global/latest/index.js) [!WARNING] The deployed directory must include only standard files and directories, excluding private ones (starting with the . symbol). All other types of files (such as symlinks) are forbidden. If found during the deployment process, the CLI tool will throw a corresponding error. ​Verify deployment and configure TMA After deploying, it’s recommended to verify that your application is working correctly by accessing it via the direct link: CopyAsk AIhttps://{storage_key}.tapps.global/{tag}/index.html If everything functions properly, use this link as the web app URL when creating your Telegram mini-app. Example: If your storage_key is 35f105bd6b and your tag is latest, the link will look like this: CopyAsk AIhttps://35f105bd6b.tapps.global/latest/index.html Ensure that when you navigate to this link, your application loads and operates without errors. This guarantees that your Telegram mini-app will work correctly with your hosting setup. ​Using config To avoid repeatedly specifying parameters, Mate allows creating a special configuration with all the parameters included. To start using the Mate config along with the optional commands’ options, create the mate.yml or mate.json file in the project root directory with the following example content: CopyAsk AIdeploy: projectId: 48 directory: dist token: TOKEN tag: latest CopyAsk AI{ \"deploy\": { \"projectId\": 48, \"directory\": \"dist\", \"token\": \"TOKEN\", \"tag\": \"latest\" } } Then, the info and upload commands will retrieve the values from the configuration. CopyAsk AI# Both of these commands will use # the options from the Mate config prior: # --project = 48 # --dir \"dist\" # --token \"TOKEN\" # --tag \"latest\" mate deploy info mate deploy upload If any parameter override is required, it should be specified in the command. For example, to override the tag option with the staging value, use the following command: CopyAsk AImate deploy info --tag staging Was this page helpful?YesNoSuggest editsRaise issuePreviousTelegram analyticsNext⌘IgithubxtelegramPowered by MintlifyOn this pageImportant recommendationFeaturesLightning SpeedVersion Management SystemUsage ExampleAbout Base URLGetting startedRegister a projectUpdate the static assets base URLDeploy the projectVerify deployment and configure TMAUsing config",
    "category": "tma",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "deployment",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "react",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:41:49.912Z"
  },
  {
    "id": "docs-ton-org--ecosystem-tma-telegram-ui-reference-avatar",
    "title": "Avatar",
    "url": "https://docs.ton.org/ecosystem/tma/telegram-ui/reference/avatar",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsOverviewTMA create CLITelegram UIOverviewGetting startedAppRoot componentReferenceAvatarMateAnalyticsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationReferenceAvatarEcosystemTMA: Telegram Mini AppsTelegram UIReferenceAvatarCopy pageCopy pageRenders an image with specific styles for an avatar presentation, including optional acronym display and badge support. Utilizes the Image component for core functionality, enhancing it with avatar-specific features like acronyms and badges. External avatar documentation Was this page helpful?YesNoSuggest editsRaise issuePrevious@telegram-apps/mateNext⌘IgithubxtelegramPowered by Mintlify",
    "category": "tma",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "dapp",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "reference",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:41:51.291Z"
  },
  {
    "id": "docs-ton-org--api",
    "title": "Page not found",
    "url": "https://docs.ton.org/api",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationPage Not Found404Page not foundMaybe you were looking for one of these pages below?API EndpointsAPIGlossary⌘I",
    "category": "api",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:42:00.369Z"
  },
  {
    "id": "docs-ton-org--schema",
    "title": "Page not found",
    "url": "https://docs.ton.org/schema",
    "content": "Skip to main contentTON Docs home pageSearch...⌘KStart hereGet supportComing from EthereumOther resourcesOld documentationEcosystemWallet appsExplorersSDKsAPIsNetwork statusOraclesBridgesTON ConnectTMA: Telegram Mini AppsBlockchain nodeStakingAnalyticsPayment processingOverviewToncoinJettonsStandard contractsWalletsTokensVestingContract developmentYour first smart contractIDEs and editor pluginsDevelopment environmentTestingDebugging smart contractsSigning messagesContract shardingSecurity best practicesEstimate gas usage in TON contractsJetton processingUsing on-chain librariesRandom numbersUpgrading contractsUse a vanity contractZero-knowledge proofsLanguagesTolkrecommendedTL-BFiftFunCTactTVM: TON Virtual MachineOverviewToolsInstructionsBuilders and SlicesContinuationsRegistersGasInitializationExit codesGet methodsBlockchain foundationsSerializationAddressesMessages & TransactionsActionsConsensusAccount statusExecution phasesTransaction feesTracesBlockchain shardingLimitsConfigWeb3 servicesMerkle proofsSystem contractsPrecompiled contractsWhitepapersGlossaryContributeStyle guideComponents and snippetsTON Docs home pageSearch...⌘KAsk AISearch...NavigationPage Not Found404Page not foundMaybe you were looking for one of these pages below?Preprocessed Wallet V2 — specificationHighload Wallet v2 — specificationHighload Wallet v3 — specification⌘I",
    "category": "general",
    "tags": [
      "ton",
      "blockchain",
      "tact",
      "func",
      "tvm",
      "smart contract",
      "wallet",
      "jetton",
      "telegram",
      "mini app",
      "tma",
      "ton connect",
      "api",
      "sdk",
      "transaction",
      "testing",
      "guide",
      "slice",
      "builder",
      "address",
      "message",
      "gas",
      "fees",
      "official",
      "docs.ton.org"
    ],
    "lastUpdated": "2025-12-22T19:42:04.071Z"
  }
]